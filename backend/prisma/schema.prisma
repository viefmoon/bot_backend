// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum OrderType {
  delivery
  pickup
}

enum OrderStatus {
  created
  accepted
  in_preparation
  prepared
  in_delivery
  finished
  canceled
}

enum PaymentStatus {
  pending
  paid
}

enum PizzaHalf {
  left
  right
  full
}

enum IngredientAction {
  add
  remove
}

// Models
model Category {
  id           String        @id
  name         String        @unique
  isActive     Boolean       @default(true)
  subcategories Subcategory[]
}

model Customer {
  customerId          String               @id @unique // WhatsApp phone number
  localId             String?              @unique @db.Uuid // UUID from local backend
  firstName           String?              @db.VarChar(100)
  lastName            String?              @db.VarChar(100)
  email               String?              @db.VarChar(255)
  birthDate           DateTime?            @db.Date
  fullChatHistory     Json?
  relevantChatHistory Json?
  stripeCustomerId    String?              @unique
  lastInteraction     DateTime?
  totalOrders         Int                  @default(0)
  totalSpent          Decimal              @default(0) @db.Decimal(10, 2)
  isActive            Boolean              @default(true)
  isBanned            Boolean              @default(false)
  bannedAt            DateTime?
  banReason           String?              @db.Text
  deletedAt           DateTime?            // Soft delete
  lastSyncAt          DateTime?            // Last sync timestamp
  syncVersion         Int                  @default(0) // For optimistic locking
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  addresses           Address[]            // One-to-Many relationship
  
  @@index([localId])
  @@index([email])
  @@index([lastSyncAt])
}

// Customer addresses (1:N relationship)
// A customer can have multiple delivery addresses
model Address {
  id                Int      @id @default(autoincrement())
  localId           String?  @unique @db.Uuid // UUID from local backend (maps to 'id' in local)
  customerId        String   @map("customer_id")
  street            String   @db.VarChar(200)
  number            String   @db.VarChar(50)
  interiorNumber    String?  @db.VarChar(50)
  neighborhood      String?  @db.VarChar(150)
  city              String?  @db.VarChar(100)
  state             String?  @db.VarChar(100)
  zipCode           String?  @db.VarChar(10)
  country           String?  @db.VarChar(100)
  references        String?  @db.Text
  latitude          Decimal? @db.Decimal(10, 8)
  longitude         Decimal? @db.Decimal(11, 8)
  geocodedAddress   String?  @db.Text
  isDefault         Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  deletedAt         DateTime? // Soft delete
  customer          Customer @relation(fields: [customerId], references: [customerId], onDelete: Cascade)
  
  @@index([customerId])
  @@index([localId])
  @@index([zipCode])
}

model MessageLog {
  id        Int     @id @default(autoincrement())
  messageId String  @unique
  processed Boolean @default(false)
}

model MessageRateLimit {
  id              Int      @id @default(autoincrement())
  customerId      String   @unique
  messageCount    Int      @default(0)
  lastMessageTime DateTime
}

model Modifier {
  id               String             @id
  name             String
  price            Float
  modifierTypeId   String
  shortName        String?
  isActive         Boolean            @default(true)
  modifierType     ModifierType       @relation(fields: [modifierTypeId], references: [id])
  selectedModifiers SelectedModifier[]
}

model ModifierType {
  id              String     @id
  name            String
  acceptsMultiple Boolean    @default(false)
  required        Boolean    @default(false)
  productId       String
  product         Product    @relation(fields: [productId], references: [id])
  modifiers       Modifier[]
}

model Order {
  id                   Int               @id @default(autoincrement())
  dailyOrderNumber     Int
  orderType            OrderType
  status               OrderStatus       @default(created)
  paymentStatus        PaymentStatus?
  totalCost            Float
  customerId           String
  estimatedTime        Int               @default(0)
  scheduledDeliveryTime DateTime?
  messageId            String?
  stripeSessionId      String?
  finishedAt           DateTime?
  syncedWithLocal      Boolean           @default(false)
  localId              Int?
  createdAt            DateTime
  updatedAt            DateTime
  orderItems           OrderItem[]
  deliveryInfo         OrderDeliveryInfo?
}

// Order's delivery address (snapshot at order time)
// This is a copy of the customer's address at the time of order creation
// Preserves historical data even if customer changes their address later
model OrderDeliveryInfo {
  id                Int       @id @default(autoincrement())
  street            String?   @db.VarChar(200)
  number            String?   @db.VarChar(50)
  interiorNumber    String?   @db.VarChar(50)
  neighborhood      String?   @db.VarChar(150)
  city              String?   @db.VarChar(100)
  state             String?   @db.VarChar(100)
  zipCode           String?   @db.VarChar(10)  // Changed from postalCode
  country           String?   @db.VarChar(100)
  references        String?   @db.Text // Changed from additionalDetails
  latitude          Decimal?  @db.Decimal(10, 8) // Changed to Decimal for precision
  longitude         Decimal?  @db.Decimal(11, 8) // Changed to Decimal for precision
  geocodedAddress   String?   @db.Text
  pickupName        String?   // For pickup orders
  preOrderId        Int?
  orderId           Int?      @unique
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  order             Order?    @relation(fields: [orderId], references: [id])
  preOrder          PreOrder? @relation(fields: [preOrderId], references: [id])
}

model OrderItem {
  id                    Int                        @id @default(autoincrement())
  quantity              Int                        @default(1)
  price                 Float
  comments              String?
  orderId               Int
  productId             String
  productVariantId      String?
  createdAt             DateTime
  updatedAt             DateTime
  order                 Order                      @relation(fields: [orderId], references: [id])
  product               Product                    @relation(fields: [productId], references: [id])
  productVariant        ProductVariant?            @relation(fields: [productVariantId], references: [id])
  selectedModifiers     SelectedModifier[]
  selectedPizzaIngredients SelectedPizzaIngredient[]
}

model PizzaIngredient {
  id                    String                    @id
  name                  String
  ingredientValue       Int                       @default(1)
  productId             String
  ingredients           String?
  isActive              Boolean                   @default(true)
  product               Product                   @relation(fields: [productId], references: [id])
  selectedPizzaIngredients SelectedPizzaIngredient[]
}

model PreOrder {
  id                    Int                @id @default(autoincrement())
  orderItems            Json
  orderType             OrderType
  scheduledDeliveryTime DateTime?
  customerId            String
  messageId             String?
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  deliveryInfo          OrderDeliveryInfo[]
}

model Product {
  id              String           @id
  name            String
  shortName       String?
  price           Float?
  ingredients     String?
  isActive        Boolean          @default(true)
  subcategoryId   String
  subcategory     Subcategory      @relation(fields: [subcategoryId], references: [id])
  variants        ProductVariant[]
  modifierTypes   ModifierType[]
  pizzaIngredients PizzaIngredient[]
  orderItems      OrderItem[]
}

model ProductVariant {
  id          String      @id
  name        String
  shortName   String?
  price       Float
  productId   String
  ingredients String?
  isActive    Boolean     @default(true)
  product     Product     @relation(fields: [productId], references: [id])
  orderItems  OrderItem[]
}

model RestaurantConfig {
  id                    Int                @id @default(autoincrement())
  // Información básica del restaurante
  restaurantName        String             @default("La Leña") // Nombre del restaurante
  phoneMain             String?            // Teléfono principal
  phoneSecondary        String?            // Teléfono secundario/móvil
  address               String?            // Dirección completa
  city                  String?            // Ciudad
  state                 String?            // Estado
  postalCode            String?            // Código postal
  
  // Configuración de operación
  acceptingOrders       Boolean            @default(true)
  estimatedPickupTime   Int                @default(20) // Tiempo estimado de recolección en minutos
  estimatedDeliveryTime Int                @default(40) // Tiempo estimado de entrega a domicilio en minutos
  openingGracePeriod    Int                @default(30) // Minutos después de abrir antes de aceptar pedidos
  closingGracePeriod    Int                @default(30) // Minutos antes de cerrar para dejar de aceptar pedidos
  timeZone              String             @default("America/Mexico_City") // Zona horaria del restaurante
  businessHours         BusinessHours[]
  
  // Configuración de delivery
  deliveryCoverageArea  Json?              // Polígono de cobertura - Array de objetos {lat: number, lng: number}
  centerLatitude        Float?             // Centro del área de servicio (para mostrar en mapas)
  centerLongitude       Float?
}

model BusinessHours {
  id                 Int              @id @default(autoincrement())
  dayOfWeek          Int              // 0 = Domingo, 1 = Lunes, ... 6 = Sábado
  openingTime        String?          // Hora de apertura en formato HH:mm (null = cerrado)
  closingTime        String?          // Hora de cierre en formato HH:mm (null = cerrado)
  isClosed           Boolean          @default(false) // true si el restaurante está cerrado ese día
  restaurantConfigId Int
  restaurantConfig   RestaurantConfig @relation(fields: [restaurantConfigId], references: [id])
  
  @@unique([restaurantConfigId, dayOfWeek]) // Un solo horario por día
}

model SeederControl {
  id      String   @id
  lastRun DateTime
}

model SelectedModifier {
  id          Int       @id @default(autoincrement())
  orderItemId Int
  modifierId  String
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id])
  modifier    Modifier  @relation(fields: [modifierId], references: [id])
}

model SelectedPizzaIngredient {
  id               Int              @id @default(autoincrement())
  half             PizzaHalf        @default(full)
  pizzaIngredientId String
  orderItemId      Int
  action           IngredientAction @default(add)
  orderItem        OrderItem        @relation(fields: [orderItemId], references: [id])
  pizzaIngredient  PizzaIngredient  @relation(fields: [pizzaIngredientId], references: [id])
}

model Subcategory {
  id         String    @id
  name       String    @unique
  categoryId String
  isActive   Boolean   @default(true)
  category   Category  @relation(fields: [categoryId], references: [id])
  products   Product[]
}

// Sync tracking between local and cloud backends
model SyncLog {
  id            Int       @id @default(autoincrement())
  entityType    String    // 'customer', 'order', etc.
  entityId      String    // WhatsApp backend ID (phone number for customers)
  localId       String?   @db.Uuid // Local backend UUID
  action        String    // 'create', 'update', 'delete'
  syncDirection String    // 'local_to_cloud' or 'cloud_to_local'
  syncStatus    String    // 'pending', 'success', 'failed'
  errorMessage  String?   @db.Text
  createdAt     DateTime  @default(now())
  completedAt   DateTime?
  
  @@index([entityType, entityId])
  @@index([syncStatus])
}