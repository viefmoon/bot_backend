This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: backend
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
backend/.claude/settings.local.json
backend/.env.example
backend/.gitignore
backend/ecosystem.config.js
backend/ERROR_HANDLING_GUIDE.md
backend/package.json
backend/prisma/migrations/20250718185619_initial_migration/migration.sql
backend/prisma/migrations/migration_lock.toml
backend/prisma/schema.prisma
backend/README.md
backend/scripts/generate-embeddings.js
backend/scripts/production-pgvector-setup.sql
backend/scripts/README_PGVECTOR.md
backend/scripts/reset-db.sh
backend/scripts/setup-local-pgvector.sh
backend/src/api/audio/audioHealth.controller.ts
backend/src/api/audio/audioOrder.controller.ts
backend/src/api/audio/audioOrder.routes.ts
backend/src/common/config/envValidator.ts
backend/src/common/config/predefinedMessages.ts
backend/src/common/constants/interactiveActions.ts
backend/src/common/middlewares/apiKeyAuth.middleware.ts
backend/src/common/middlewares/errorHandler.ts
backend/src/common/middlewares/otp.middleware.ts
backend/src/common/middlewares/validation.middleware.ts
backend/src/common/services/errors/CustomErrors.ts
backend/src/common/services/errors/errorMessages.ts
backend/src/common/services/errors/index.ts
backend/src/common/services/errors/types.ts
backend/src/common/types/index.ts
backend/src/common/types/menu.ts
backend/src/common/types/order-item.types.ts
backend/src/common/types/order.types.ts
backend/src/common/types/preorder.types.ts
backend/src/common/types/restaurant.ts
backend/src/common/types/services.types.ts
backend/src/common/types/whatsapp-messages.types.ts
backend/src/common/utils/addressFormatter.ts
backend/src/common/utils/logger.ts
backend/src/common/utils/messageSplitter.ts
backend/src/common/utils/timeUtils.ts
backend/src/common/utils/whatsappErrorHandler.ts
backend/src/dto/address/address.dto.ts
backend/src/dto/address/create-address.dto.ts
backend/src/dto/address/delete-address.dto.ts
backend/src/dto/address/get-addresses-query.dto.ts
backend/src/dto/address/index.ts
backend/src/dto/address/send-address-selection.dto.ts
backend/src/dto/address/set-default-address.dto.ts
backend/src/dto/address/update-address-selection.dto.ts
backend/src/dto/address/update-address.dto.ts
backend/src/dto/auth/index.ts
backend/src/dto/auth/invalidate-otp.dto.ts
backend/src/dto/auth/verify-otp.dto.ts
backend/src/dto/customer/index.ts
backend/src/dto/customer/update-customer-name.dto.ts
backend/src/dto/index.ts
backend/src/dto/order/create-order.dto.ts
backend/src/dto/order/index.ts
backend/src/dto/order/process-audio-order.dto.ts
backend/src/dto/whatsapp/index.ts
backend/src/dto/whatsapp/send-message.dto.ts
backend/src/lib/prisma.ts
backend/src/queues/messageQueue.ts
backend/src/queues/types.ts
backend/src/routes/address-registration.ts
backend/src/routes/address-selection.ts
backend/src/routes/sync.ts
backend/src/routes/webhook.ts
backend/src/run-workers.ts
backend/src/server.ts
backend/src/services/ai/AgentService.ts
backend/src/services/ai/GeminiService.ts
backend/src/services/ai/index.ts
backend/src/services/ai/MenuSearchService.ts
backend/src/services/ai/prompts/generalAgent.prompt.ts
backend/src/services/ai/prompts/index.ts
backend/src/services/ai/prompts/orderAgent.prompt.ts
backend/src/services/ai/tools/generalAgent.tools.ts
backend/src/services/ai/tools/handlers/generateAddressUpdateLinkHandler.ts
backend/src/services/ai/tools/handlers/getBusinessHoursHandler.ts
backend/src/services/ai/tools/handlers/getWaitTimesHandler.ts
backend/src/services/ai/tools/handlers/mapOrderItemsHandler.ts
backend/src/services/ai/tools/handlers/prepareOrderContextHandler.ts
backend/src/services/ai/tools/handlers/resetConversationHandler.ts
backend/src/services/ai/tools/handlers/sendBotInstructionsHandler.ts
backend/src/services/ai/tools/handlers/sendMenuHandler.ts
backend/src/services/ai/tools/index.ts
backend/src/services/ai/tools/orderAgent.tools.ts
backend/src/services/ai/tools/toolHandlers.ts
backend/src/services/ai/tools/types.ts
backend/src/services/audio/AudioOrderService.ts
backend/src/services/config/ConfigService.ts
backend/src/services/messaging/index.ts
backend/src/services/messaging/MessageContext.ts
backend/src/services/messaging/MessageProcessor.ts
backend/src/services/messaging/middlewares/AddressRequiredMiddleware.ts
backend/src/services/messaging/middlewares/CustomerValidationMiddleware.ts
backend/src/services/messaging/middlewares/MessageProcessingMiddleware.ts
backend/src/services/messaging/middlewares/MessageTypeMiddleware.ts
backend/src/services/messaging/middlewares/RateLimitMiddleware.ts
backend/src/services/messaging/middlewares/RestaurantHoursMiddleware.ts
backend/src/services/messaging/pipeline/MessagePipeline.ts
backend/src/services/messaging/README.md
backend/src/services/messaging/strategies/AudioMessageStrategy.ts
backend/src/services/messaging/strategies/InteractiveMessageStrategy.ts
backend/src/services/messaging/strategies/MessageStrategy.ts
backend/src/services/messaging/strategies/TextMessageStrategy.ts
backend/src/services/messaging/TextProcessingService.ts
backend/src/services/messaging/types.ts
backend/src/services/messaging/types/responses.ts
backend/src/services/orders/OrderService.ts
backend/src/services/orders/PreOrderService.ts
backend/src/services/orders/preOrderWorkflowService.ts
backend/src/services/orders/services/DeliveryInfoService.ts
backend/src/services/orders/services/OrderFormattingService.ts
backend/src/services/orders/services/OrderManagementService.ts
backend/src/services/orders/services/ProductCalculationService.ts
backend/src/services/orders/services/SchedulingService.ts
backend/src/services/payment/StripeService.ts
backend/src/services/products/ProductService.ts
backend/src/services/redis/RedisService.ts
backend/src/services/restaurant/RestaurantService.ts
backend/src/services/security/OTPService.ts
backend/src/services/sync/EmbeddingManager.ts
backend/src/services/sync/EmbeddingService.ts
backend/src/services/sync/SyncMetadataService.ts
backend/src/services/sync/SyncNotificationService.ts
backend/src/services/sync/UnifiedSyncService.ts
backend/src/services/whatsapp/index.ts
backend/src/services/whatsapp/WhatsAppService.ts
backend/src/startup/embeddingInitializer.ts
backend/src/whatsapp/handlers/interactiveMessageHandler.ts
backend/src/whatsapp/handlers/orders/index.ts
backend/src/whatsapp/handlers/orders/orderFormatters.ts
backend/src/workers/messageWorker.ts
backend/tsconfig.json

================================================================
Files
================================================================

================
File: backend/.gitignore
================
# Dependencies
node_modules/

# Build output
dist

# Environment files
.env
.env.local
.env.production

# IDE
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Testing
coverage/
.nyc_output/

# Temporary files
*.tmp
*.temp
.cache/

# repomix
.repomix/

/generated/prisma

================
File: backend/prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

================
File: backend/README.md
================
# Backend - WhatsApp Restaurant Bot

Backend service for a WhatsApp restaurant bot using Express, Prisma, and PostgreSQL.

## Quick Start

See the main README.md in the parent directory for setup instructions.

## Environment Variables

Required environment variables:

```bash
# Database
DATABASE_URL=postgresql://postgres:postgres@localhost:5433/bot_db

# Google AI
GOOGLE_AI_API_KEY=your_api_key  # Get from https://makersuite.google.com/app/apikey
GEMINI_MODEL=gemini-2.5-pro

# WhatsApp Business API
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=your_phone_id
WHATSAPP_ACCESS_TOKEN=your_access_token
WHATSAPP_VERIFY_TOKEN=your_verify_token

# Application
FRONTEND_BASE_URL=http://localhost:3000
NODE_ENV=development
PORT=5000

# Rate Limiting
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5

# Optional - Stripe Payments
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=
```

## Database Schema

The database uses Prisma ORM with the following main tables:
- Customer: WhatsApp customer information
- Product: Restaurant menu items
- Order: Customer orders
- PreOrder: Temporary cart items
- Address: Customer addresses

## API Endpoints

- `GET /backend` - Health check
- `POST /backend/webhook` - WhatsApp webhook
- `POST /backend/otp/verify` - Verify OTP
- `POST /backend/customer-delivery-info` - Create delivery info
- `PUT /backend/customer-delivery-info/:customerId` - Update delivery info
- `GET /backend/customer-delivery-info/:customerId` - Get delivery info
- `POST /backend/pre-orders/select-products` - Add products to cart

## Development

```bash
npm run dev         # Start development server
npm run build       # Build for production
npm run studio      # Open Prisma Studio
npm run migrate:dev # Run migrations
npm run seed        # Seed database
```

================
File: backend/src/common/middlewares/errorHandler.ts
================
import { Request, Response, NextFunction } from 'express';
import { 
  BaseError, 
  ErrorType,
  ValidationError,
  BusinessLogicError,
  NotFoundError,
  RateLimitError,
  TechnicalError,
  ExternalServiceError
} from '../services/errors';
import logger from '../utils/logger';

interface ErrorResponse {
  error: {
    code: string;
    message: string;
    type: string;
    timestamp: string;
    requestId?: string;
    details?: any;
  };
}

/**
 * Maps custom error types to HTTP status codes
 */
function mapErrorTypeToStatusCode(error: BaseError): number {
  if (error instanceof ValidationError) return 400;
  if (error instanceof NotFoundError) return 404;
  if (error instanceof BusinessLogicError) return 409;
  if (error instanceof RateLimitError) return 429;
  if (error instanceof ExternalServiceError) return 502;
  if (error instanceof TechnicalError) return 500;
  
  // Fallback based on error type enum
  switch (error.type) {
    case ErrorType.VALIDATION:
      return 400;
    case ErrorType.NOT_FOUND:
      return 404;
    case ErrorType.BUSINESS_LOGIC:
      return 409;
    case ErrorType.RATE_LIMIT:
      return 429;
    case ErrorType.EXTERNAL_SERVICE:
      return 502;
    case ErrorType.TECHNICAL:
    default:
      return 500;
  }
}

/**
 * Global error handling middleware for Express
 * Provides consistent error responses and proper logging
 */
export function globalErrorHandler(
  err: Error, 
  req: Request, 
  res: Response, 
  next: NextFunction
): void {
  // Generate request ID for tracking
  const requestId = req.headers['x-request-id'] as string || generateRequestId();
  
  // Handle custom errors
  if (err instanceof BaseError) {
    const statusCode = mapErrorTypeToStatusCode(err);
    
    // Log based on severity
    if (statusCode >= 500) {
      logger.error('Server Error:', {
        error: err.message,
        code: err.code,
        type: err.type,
        context: err.context,
        stack: err.stack,
        requestId,
        path: req.path,
        method: req.method
      });
    } else {
      logger.warn('Client Error:', {
        error: err.message,
        code: err.code,
        type: err.type,
        context: err.context,
        requestId,
        path: req.path,
        method: req.method
      });
    }
    
    const errorResponse: ErrorResponse = {
      error: {
        code: err.code,
        message: err.message,
        type: err.type,
        timestamp: new Date().toISOString(),
        requestId
      }
    };
    
    // Include additional details in development
    if (process.env.NODE_ENV === 'development' && err.context) {
      errorResponse.error.details = err.context;
    }
    
    res.status(statusCode).json(errorResponse);
    return;
  }
  
  // Handle Prisma errors
  if (err.name === 'PrismaClientKnownRequestError') {
    const prismaError = err as any;
    let statusCode = 400;
    let message = 'Database operation failed';
    
    switch (prismaError.code) {
      case 'P2002':
        message = 'A unique constraint would be violated';
        break;
      case 'P2025':
        statusCode = 404;
        message = 'Record not found';
        break;
      case 'P2003':
        message = 'Foreign key constraint failed';
        break;
    }
    
    logger.error('Prisma Error:', {
      error: message,
      code: prismaError.code,
      meta: prismaError.meta,
      requestId,
      path: req.path,
      method: req.method
    });
    
    const errorResponse: ErrorResponse = {
      error: {
        code: `PRISMA_${prismaError.code}`,
        message,
        type: ErrorType.TECHNICAL,
        timestamp: new Date().toISOString(),
        requestId
      }
    };
    
    res.status(statusCode).json(errorResponse);
    return;
  }
  
  // Handle unexpected errors
  logger.error('Unhandled Internal Server Error:', {
    error: err.message,
    stack: err.stack,
    requestId,
    path: req.path,
    method: req.method,
    body: req.body,
    query: req.query
  });
  
  const errorResponse: ErrorResponse = {
    error: {
      code: 'INTERNAL_SERVER_ERROR',
      message: process.env.NODE_ENV === 'production' 
        ? 'An unexpected error occurred. Please try again later.' 
        : err.message,
      type: ErrorType.TECHNICAL,
      timestamp: new Date().toISOString(),
      requestId
    }
  };
  
  res.status(500).json(errorResponse);
}

/**
 * Async error handler wrapper for route handlers
 * Catches async errors and passes them to the error middleware
 */
export function asyncHandler(fn: Function) {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

/**
 * Generate a simple request ID
 */
function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

================
File: backend/src/common/middlewares/validation.middleware.ts
================
import { plainToInstance } from 'class-transformer';
import { validate, ValidationError as ClassValidationError } from 'class-validator';
import { RequestHandler } from 'express';
import { ValidationError, ErrorCode } from '../services/errors';

/**
 * Middleware para validar automáticamente DTOs usando class-validator
 * @param type La clase DTO a validar
 * @param skipMissingProperties Si se deben omitir propiedades faltantes (default: false)
 * @returns Express middleware
 */
export function validationMiddleware(
  type: any,
  skipMissingProperties = false
): RequestHandler {
  return async (req, _res, next) => {
    try {
      // Transformar el body a la instancia del DTO
      const dto = plainToInstance(type, req.body);
      
      // Validar el DTO
      const errors: ClassValidationError[] = await validate(dto as object, {
        skipMissingProperties,
        whitelist: true, // Remover propiedades no definidas en el DTO
        forbidNonWhitelisted: true, // Lanzar error si hay propiedades no definidas
      });

      if (errors.length > 0) {
        // Formatear mensajes de error
        const messages = errors.map((error: ClassValidationError) => {
          const constraints = error.constraints || {};
          return `${error.property}: ${Object.values(constraints).join(', ')}`;
        });
        
        next(new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          `Validation failed: ${messages.join('; ')}`
        ));
      } else {
        // Reemplazar req.body con el DTO validado y transformado
        req.body = dto;
        next();
      }
    } catch (error) {
      next(error);
    }
  };
}

/**
 * Middleware para validar query parameters
 */
export function queryValidationMiddleware(
  type: any,
  skipMissingProperties = false
): RequestHandler {
  return async (req, _res, next) => {
    try {
      const dto = plainToInstance(type, req.query);
      const errors: ClassValidationError[] = await validate(dto as object, {
        skipMissingProperties,
        whitelist: true,
        forbidNonWhitelisted: true,
      });

      if (errors.length > 0) {
        const messages = errors.map((error: ClassValidationError) => {
          const constraints = error.constraints || {};
          return `${error.property}: ${Object.values(constraints).join(', ')}`;
        });
        
        next(new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          `Query validation failed: ${messages.join('; ')}`
        ));
      } else {
        req.query = dto as any;
        next();
      }
    } catch (error) {
      next(error);
    }
  };
}

================
File: backend/src/common/services/errors/CustomErrors.ts
================
import { ErrorCode, ErrorType, ErrorContext } from './types';

export class BaseError extends Error {
  constructor(
    public code: ErrorCode,
    public type: ErrorType,
    message: string,
    public context?: ErrorContext
  ) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
}

export class BusinessLogicError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.BUSINESS_LOGIC, message, context);
    this.name = 'BusinessLogicError';
  }
}

export class ValidationError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.VALIDATION, message, context);
    this.name = 'ValidationError';
  }
}

export class TechnicalError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.TECHNICAL, message, context);
    this.name = 'TechnicalError';
  }
}

export class ExternalServiceError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.EXTERNAL_SERVICE, message, context);
    this.name = 'ExternalServiceError';
  }
}

export class NotFoundError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.BUSINESS_LOGIC, message, context);
    this.name = 'NotFoundError';
  }
}

export class RateLimitError extends BaseError {
  constructor(message: string, context?: ErrorContext) {
    super(ErrorCode.RATE_LIMIT_EXCEEDED, ErrorType.RATE_LIMIT, message, context);
    this.name = 'RateLimitError';
  }
}

================
File: backend/src/common/types/restaurant.ts
================
/**
 * Tipo para la información del restaurante
 * Usado en predefinedMessages.ts
 */
export interface RestaurantInfo {
  restaurantName: string;
  phoneMain: string;
  phoneSecondary: string;
  address: string;
  city: string;
  state: string;
  postalCode: string;
}

================
File: backend/src/common/types/whatsapp-messages.types.ts
================
/**
 * Tipos consolidados para mensajes de WhatsApp
 * Este archivo unifica todas las definiciones de tipos relacionadas con WhatsApp
 */

// Tipos de mensajes entrantes
export interface IncomingMessage {
  id: string;
  from: string;
  type: 'text' | 'interactive' | 'audio' | 'image' | 'document' | 'location';
  timestamp: string;
  text?: {
    body: string;
  };
  interactive?: {
    type: 'button_reply' | 'list_reply';
    button_reply?: {
      id: string;
      title: string;
    };
    list_reply?: {
      id: string;
      title: string;
      description?: string;
    };
  };
  audio?: {
    id: string;
    mime_type: string;
  };
}

// Estructura del webhook de WhatsApp
export interface WebhookEntry {
  changes: Array<{
    value: {
      messages?: IncomingMessage[];
      messaging_product?: string;
      metadata?: {
        display_phone_number: string;
        phone_number_id: string;
      };
    };
  }>;
}

export interface WebhookBody {
  object: string;
  entry: WebhookEntry[];
}

// Tipos de mensajes salientes
export interface OutgoingTextMessage {
  messaging_product: 'whatsapp';
  to: string;
  type: 'text';
  text: { body: string };
}

export interface InteractiveButton {
  type: 'reply';
  reply: {
    id: string;
    title: string;
  };
}

export interface InteractiveSection {
  title?: string;
  rows: Array<{
    id: string;
    title: string;
    description?: string;
  }>;
}

export interface InteractiveContent {
  header?: {
    type: 'text' | 'image';
    text?: string;
    image?: {
      link: string;
    };
  };
  body: {
    text: string;
  };
  footer?: {
    text: string;
  };
  action: {
    button?: string;
    buttons?: InteractiveButton[];
    sections?: InteractiveSection[];
  };
}

export interface OutgoingInteractiveMessage {
  messaging_product: 'whatsapp';
  recipient_type: 'individual';
  to: string;
  type: 'interactive';
  interactive: InteractiveContent;
}

// Union type para cualquier mensaje saliente
export type OutgoingMessage = OutgoingTextMessage | OutgoingInteractiveMessage;

// Respuesta de la API de WhatsApp
export interface WhatsAppApiResponse {
  messages: [{
    id: string;
  }];
}

================
File: backend/src/dto/address/get-addresses-query.dto.ts
================
import { IsOptional, IsBoolean } from 'class-validator';
import { Transform } from 'class-transformer';

export class GetAddressesQueryDto {
  @IsOptional()
  @Transform(({ value }: { value: any }) => value === 'true')
  @IsBoolean()
  includeInactive?: boolean;
}

================
File: backend/src/dto/whatsapp/send-message.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class SendMessageDto {
  @IsNotEmpty({ message: 'to is required' })
  @IsString({ message: 'to must be a string' })
  to!: string;

  @IsNotEmpty({ message: 'message is required' })
  @IsString({ message: 'message must be a string' })
  message!: string;
}

================
File: backend/src/services/messaging/index.ts
================
export * from './types';
export { MessageContext } from './MessageContext';
export * from './pipeline/MessagePipeline';
export * from './MessageProcessor';

// Export middlewares
export * from './middlewares/RateLimitMiddleware';
export * from './middlewares/CustomerValidationMiddleware';
export * from './middlewares/MessageTypeMiddleware';

================
File: backend/src/services/messaging/MessageContext.ts
================
import { IncomingMessage, MessageResponse } from './types';
import { Customer } from '../../common/types';

export class MessageContext {
  public message: IncomingMessage;
  public customer?: Customer;
  public chatHistory: any[] = [];
  public responses: MessageResponse[] = [];
  public metadata: Map<string, any> = new Map();
  public shouldStop: boolean = false;
  public error?: Error;

  constructor(message: IncomingMessage) {
    this.message = message;
  }

  addResponse(response: MessageResponse) {
    this.responses.push(response);
  }

  setCustomer(customer: Customer) {
    this.customer = customer;
  }

  setChatHistory(history: any[]) {
    this.chatHistory = history;
  }

  stop() {
    this.shouldStop = true;
  }

  setError(error: Error) {
    this.error = error;
    this.stop();
  }

  get(key: string): any {
    return this.metadata.get(key);
  }

  set(key: string, value: any): void {
    this.metadata.set(key, value);
  }
}

================
File: backend/src/services/messaging/MessageProcessor.ts
================
import { MessagePipeline } from './pipeline/MessagePipeline';
import { IncomingMessage } from './types';
import logger from '../../common/utils/logger';

// Esta clase proporciona una interfaz simple para procesar mensajes de WhatsApp
// a través de nuestro pipeline de procesamiento de mensajes

export class MessageProcessor {
  private static pipeline: MessagePipeline | null = null;
  
  static getPipeline(): MessagePipeline {
    if (!this.pipeline) {
      this.pipeline = new MessagePipeline();
    }
    return this.pipeline;
  }
  
  // Este método procesa los mensajes entrantes a través del pipeline
  static async processWithPipeline(message: any): Promise<void> {
    try {
      // Convertir el formato del mensaje al formato del pipeline
      const incomingMessage: IncomingMessage = {
        id: message.id,
        from: message.from,
        type: message.type,
        timestamp: message.timestamp,
        text: message.text,
        interactive: message.interactive,
        audio: message.audio
      };
      
      // Procesar con el pipeline
      await this.getPipeline().process(incomingMessage);
    } catch (error) {
      logger.error('Error in MessageProcessor:', error);
      throw error; // Dejar que el llamador maneje el error
    }
  }
}

================
File: backend/src/services/messaging/middlewares/MessageProcessingMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { MessageStrategy } from '../strategies/MessageStrategy';
import { TextMessageStrategy } from '../strategies/TextMessageStrategy';
import { InteractiveMessageStrategy } from '../strategies/InteractiveMessageStrategy';
import { AudioMessageStrategy } from '../strategies/AudioMessageStrategy';
import logger from '../../../common/utils/logger';

export class MessageProcessingMiddleware implements MessageMiddleware {
  name = 'MessageProcessingMiddleware';
  
  private strategies: MessageStrategy[] = [
    new AudioMessageStrategy(),      // Audio primero para convertir a texto
    new InteractiveMessageStrategy(), // Mensajes interactivos
    new TextMessageStrategy(),        // Mensajes de texto
  ];
  
  async process(context: MessageContext): Promise<MessageContext> {
    try {
      // Encontrar la estrategia apropiada
      for (const strategy of this.strategies) {
        if (strategy.canHandle(context)) {
          await strategy.execute(context);
          
          // Si el audio se convirtió a texto, continuar procesando
          if (strategy.name === 'AudioMessageStrategy' && context.message.type === 'text') {
            continue;
          }
          
          break;
        }
      }
      
      return context;
    } catch (error) {
      logger.error('Error in MessageProcessingMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/README.md
================
# Pipeline de Procesamiento de Mensajes

Este sistema de pipeline permite un procesamiento de mensajes modular y mantenible para el bot de WhatsApp.

## Arquitectura

### Pipeline Principal
- `MessagePipeline`: Orquesta el flujo de procesamiento de mensajes
- `MessageContext`: Contiene toda la información del mensaje y su procesamiento
- `MessageProcessor`: Interfaz principal para procesar mensajes de WhatsApp

### Middlewares
Los middlewares se ejecutan en orden y cada uno puede:
- Modificar el contexto
- Detener el procesamiento (`context.stop()`)
- Agregar respuestas
- Manejar errores

#### Middlewares Actuales:
1. **RateLimitMiddleware**: Controla el límite de mensajes por usuario
2. **CustomerValidationMiddleware**: Valida y carga información del cliente
3. **MessageTypeMiddleware**: Maneja diferentes tipos de mensajes y mensajes de bienvenida

## Uso

### Flujo de Procesamiento

1. **Webhook de WhatsApp** → `messageProcessor.ts`
2. **MessageProcessor** convierte el mensaje al formato del pipeline
3. **Pipeline** ejecuta los middlewares en orden:
   - Crea un `MessageContext`
   - Ejecuta cada middleware
   - Procesa el mensaje según su tipo
   - Envía respuestas
   - Actualiza el historial del chat

### Agregar Nuevos Middlewares

```typescript
// Crear el middleware
export class MyMiddleware implements MessageMiddleware {
  name = 'MyMiddleware';
  
  async process(context: MessageContext): Promise<MessageContext> {
    // Tu lógica aquí
    return context;
  }
}

// Agregarlo al pipeline
pipeline.addMiddleware(new MyMiddleware());
```

## Estructura de Estrategias

### Estrategias de Procesamiento
- **TextMessageStrategy**: Procesa mensajes de texto con AI
- **InteractiveMessageStrategy**: Maneja botones y listas interactivas
- **AudioMessageStrategy**: Transcribe audio a texto usando Gemini

### Extensibilidad
Para agregar soporte a nuevos tipos de mensajes, simplemente crea una nueva estrategia que extienda `MessageStrategy`.

## Ventajas del Sistema

1. **Modularidad**: Cada responsabilidad en su propio middleware
2. **Testabilidad**: Fácil testear cada componente por separado
3. **Mantenibilidad**: Código más limpio y organizado
4. **Extensibilidad**: Fácil agregar nuevas funcionalidades
5. **Escalabilidad**: Diseñado para crecer con nuevos requerimientos

## Debugging

El pipeline incluye logs detallados:
```
DEBUG: Running middleware: RateLimitMiddleware
DEBUG: Running middleware: CustomerValidationMiddleware
DEBUG: Pipeline stopped by middleware: RateLimitMiddleware
```

Esto facilita identificar dónde ocurren problemas.

================
File: backend/src/services/messaging/strategies/InteractiveMessageStrategy.ts
================
import { MessageStrategy } from './MessageStrategy';
import { MessageContext } from '../MessageContext';
import { handleInteractiveMessage } from '../../../whatsapp/handlers/interactiveMessageHandler';
import logger from '../../../common/utils/logger';

export class InteractiveMessageStrategy extends MessageStrategy {
  name = 'InteractiveMessageStrategy';
  
  canHandle(context: MessageContext): boolean {
    return context.message.type === 'interactive';
  }
  
  async execute(context: MessageContext): Promise<void> {
    try {
      // Delegar al manejador de mensajes interactivos existente
      await handleInteractiveMessage(context.message.from, context.message);
      
      // Detener procesamiento adicional ya que los mensajes interactivos se manejan completamente
      context.stop();
    } catch (error) {
      logger.error('Error handling interactive message:', error);
      // El manejo de errores ya se hace en handleInteractiveMessage
      context.stop();
    }
  }
}

================
File: backend/src/services/messaging/strategies/MessageStrategy.ts
================
import { MessageContext } from '../MessageContext';
import { MessageResponse } from '../types';

export abstract class MessageStrategy {
  abstract name: string;
  
  abstract canHandle(context: MessageContext): boolean;
  
  abstract execute(context: MessageContext): Promise<void>;
  
  protected addResponse(context: MessageContext, response: MessageResponse): void {
    context.addResponse(response);
  }
}

================
File: backend/src/services/messaging/types.ts
================
import { Customer } from '@prisma/client';

export * from './types/responses';

// Re-exportar tipos de WhatsApp desde la ubicación centralizada
export { IncomingMessage } from '../../common/types/whatsapp-messages.types';

export interface MessageContext {
  message: IncomingMessage;
  customer?: Customer;
  chatHistory?: any[];
  response?: MessageResponse;
  metadata: Map<string, any>;
  shouldStop: boolean;
  error?: Error;
}

export interface MessageResponse {
  text?: string;
  interactiveMessage?: any;
  sendToWhatsApp: boolean;
  isRelevant: boolean;
  preOrderId?: number;
  confirmationMessage?: string;
  historyMarker?: string; // Texto alternativo para guardar en el historial
}

export interface MessageMiddleware {
  name: string;
  process(context: MessageContext): Promise<MessageContext>;
}

export interface MessageStrategy {
  execute(message: IncomingMessage, customer: Customer): Promise<MessageResponse[]>;
}

================
File: backend/src/services/orders/preOrderWorkflowService.ts
================
import { randomUUID } from 'crypto';
import { prisma } from '../../lib/prisma';
import { redisService } from '../redis/RedisService';
import { PreOrderService } from './PreOrderService';
import { OrderManagementService } from './services/OrderManagementService';
import { sendWhatsAppMessage, WhatsAppService } from '../whatsapp';
import { generateOrderSummary } from '../../whatsapp/handlers/orders/orderFormatters';
import { BusinessLogicError, ErrorCode, ValidationError } from '../../common/services/errors';
import logger from '../../common/utils/logger';
import { SyncMetadataService } from '../sync/SyncMetadataService';
import {
  ProcessedOrderData,
  PreOrderWorkflowResult,
  PreOrderActionParams,
  TokenValidationResult
} from '../../common/types/preorder.types';

export class PreOrderWorkflowService {
  private static readonly TOKEN_PREFIX = 'preorder:token:';
  private static readonly TOKEN_TTL_SECONDS = 600; // 10 minutes
  private static readonly PREORDER_EXPIRY_MINUTES = 10; // Same as token TTL
  
  static async createAndNotify(params: {
    orderData: ProcessedOrderData;
    customerId: string;
    whatsappNumber: string;
  }): Promise<PreOrderWorkflowResult> {
    try {
      logger.info('Creating preorder with workflow', { 
        customerId: params.customerId,
        orderType: params.orderData.orderType 
      });
      
        if (!params.orderData.orderItems || params.orderData.orderItems.length === 0) {
        throw new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          'No se puede crear una orden sin productos',
          {
            metadata: {
              validationFailure: 'EMPTY_ORDER',
              message: 'Debes agregar al menos un producto a tu pedido'
            }
          }
        );
      }
      
      await this.cleanupExpiredPreOrders();
      
      await this.discardActivePreOrders(params.whatsappNumber);
      
      const preOrderService = new PreOrderService();
      const preOrderResult = await preOrderService.createPreOrder({
        orderItems: params.orderData.orderItems,
        orderType: params.orderData.orderType,
        scheduledAt: params.orderData.scheduledAt || undefined,
        whatsappPhoneNumber: params.whatsappNumber,
        deliveryInfo: params.orderData.deliveryInfo,
      });
      
      const actionToken = await this.generateActionToken(preOrderResult.preOrderId);
      const expiresAt = new Date(Date.now() + this.TOKEN_TTL_SECONDS * 1000);
      
      await this.sendOrderSummaryWithButtons(
        params.whatsappNumber, 
        preOrderResult,
        actionToken
      );
      
      await this.updateChatHistoryWithPreOrder(params.whatsappNumber, preOrderResult);
      
      logger.info('PreOrder workflow completed', { 
        preOrderId: preOrderResult.preOrderId,
        token: actionToken.substring(0, 8) + '...' 
      });
      
      return { 
        preOrderId: preOrderResult.preOrderId, 
        actionToken,
        expiresAt 
      };
    } catch (error) {
      logger.error('Error in preorder workflow', error);
      throw error;
    }
  }
  
  static async processAction(params: PreOrderActionParams): Promise<void> {
    logger.info('Processing preorder action', { 
      action: params.action,
      token: params.token.substring(0, 8) + '...' 
    });
    
    const validation = await this.validateActionToken(params.token);
    if (!validation.isValid || !validation.preOrderId) {
      // Don't send messages here - let the error handler do it
      // The error will be caught and handled by the WhatsApp handler
      throw new BusinessLogicError(
        ErrorCode.INVALID_TOKEN,
        validation.error || 'Token inválido o expirado'
      );
    }
    
    if (params.action === 'confirm') {
      await this.confirmPreOrder(validation.preOrderId, params.whatsappNumber);
    } else {
      await this.discardPreOrder(validation.preOrderId, params.whatsappNumber);
    }
    
    await this.deleteActionToken(params.token);
  }
  
  private static async generateActionToken(preOrderId: number): Promise<string> {
    const token = randomUUID();
    const key = `${this.TOKEN_PREFIX}${token}`;
    
    await redisService.set(key, preOrderId.toString(), this.TOKEN_TTL_SECONDS);
    
    logger.debug('Generated action token', { 
      preOrderId, 
      token: token.substring(0, 8) + '...' 
    });
    
    return token;
  }
  
  private static async validateActionToken(token: string): Promise<TokenValidationResult> {
    const key = `${this.TOKEN_PREFIX}${token}`;
    
    try {
      const preOrderIdStr = await redisService.get(key);
      
      if (!preOrderIdStr) {
        return { 
          isValid: false, 
          error: 'Token no encontrado o expirado' 
        };
      }
      
      const preOrderId = parseInt(preOrderIdStr, 10);
      
      const preOrder = await prisma.preOrder.findUnique({
        where: { id: preOrderId }
      });
      
      if (!preOrder) {
        return { 
          isValid: false, 
          error: 'Esta preorden ya no está disponible. Por favor, realiza un nuevo pedido.' 
        };
      }
      
      return { 
        isValid: true, 
        preOrderId 
      };
      
    } catch (error) {
      logger.error('Error validating token', error);
      return { 
        isValid: false, 
        error: 'Error al validar token' 
      };
    }
  }
  
  private static async deleteActionToken(token: string): Promise<void> {
    const key = `${this.TOKEN_PREFIX}${token}`;
    await redisService.del(key);
  }
  
  static async sendOrderSummaryWithButtons(
    whatsappNumber: string, 
    preOrderResult: any,
    token: string
  ): Promise<void> {
    let orderSummary = generateOrderSummary(preOrderResult);
    
    // WhatsApp button messages have a 1024 character limit for the body
    const MAX_BODY_LENGTH = 1000; // Leave some margin
    if (orderSummary.length > MAX_BODY_LENGTH) {
      // Truncate and add indication that the message was truncated
      orderSummary = orderSummary.substring(0, MAX_BODY_LENGTH - 20) + '\n\n[...]';
      logger.warn(`Order summary truncated from ${orderSummary.length} to ${MAX_BODY_LENGTH} characters`);
    }
    
    // Build buttons array
    const buttons = [
      {
        type: "reply",
        reply: {
          id: `preorder_confirm:${token}`,
          title: "✅ Confirmar"
        }
      }
    ];
    
    // Add change address button only for delivery orders
    if (preOrderResult.orderType === 'DELIVERY') {
      buttons.push({
        type: "reply",
        reply: {
          id: `preorder_change_address:${token}`,
          title: "📍 Cambiar dirección"
        }
      });
    }
    
    buttons.push({
      type: "reply",
      reply: {
        id: `preorder_discard:${token}`,
        title: "❌ Cancelar"
      }
    });
    
    const message = {
      type: "button",
      body: {
        text: orderSummary
      },
      action: {
        buttons: buttons
      }
    };
    
    await WhatsAppService.sendInteractiveMessage(
      whatsappNumber, 
      message
    );
  }
  
  /**
   * Creates a sanitized version of the order summary for chat history
   * Removes sensitive information like prices
   */
  private static createHistoryMarker(preOrderResult: any): string {
    const orderType = preOrderResult.orderType === 'DELIVERY' ? 'entrega a domicilio' : 'recolección';
    
    let historyMessage = `📋 Resumen de pedido (${orderType}):\n`;
    
    // Agregar lista de productos sin precios
    if (preOrderResult.items && preOrderResult.items.length > 0) {
      historyMessage += 'Productos ordenados:\n';
      preOrderResult.items.forEach((item: any) => {
        const productName = item.product?.name || 'Producto';
        const variantName = item.productVariant?.name || '';
        const displayName = variantName || productName;
        const quantity = item.quantity || 1;
        
        historyMessage += `• ${quantity}x ${displayName}`;
        
        // Agregar modificadores sin precios
        if (item.modifiers && item.modifiers.length > 0) {
          const modifierNames = item.modifiers.map((mod: any) => mod.name).join(', ');
          historyMessage += ` (${modifierNames})`;
        }
        
        // Agregar personalizaciones de pizza
        if (item.pizzaCustomizations && item.pizzaCustomizations.length > 0) {
          const customNames = item.pizzaCustomizations
            .filter((cust: any) => cust.action === 'ADD')
            .map((cust: any) => cust.name)
            .join(', ');
          if (customNames) {
            historyMessage += ` - ${customNames}`;
          }
        }
        
        historyMessage += '\n';
      });
    }
    
    return historyMessage.trim();
  }
  
  /**
   * Updates chat history with preorder information
   */
  private static async updateChatHistoryWithPreOrder(
    whatsappNumber: string, 
    preOrderResult: any
  ): Promise<void> {
    try {
      const customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber: whatsappNumber }
      });
      
      if (!customer) {
        logger.warn('Customer not found for chat history update');
        return;
      }
      
      // Obtener historial actual - manejar tanto string como array
      let fullChatHistory = [];
      let relevantChatHistory = [];
      
      try {
        if (customer.fullChatHistory) {
          fullChatHistory = typeof customer.fullChatHistory === 'string' 
            ? JSON.parse(customer.fullChatHistory) 
            : customer.fullChatHistory;
        }
        if (customer.relevantChatHistory) {
          relevantChatHistory = typeof customer.relevantChatHistory === 'string'
            ? JSON.parse(customer.relevantChatHistory)
            : customer.relevantChatHistory;
        }
      } catch (parseError) {
        logger.warn('Error parsing chat history, using empty arrays', parseError);
        fullChatHistory = [];
        relevantChatHistory = [];
      }
      
      const historyMarker = this.createHistoryMarker(preOrderResult);
      
      const fullMessage = generateOrderSummary(preOrderResult);
      fullChatHistory.push({
        role: 'assistant',
        content: fullMessage,
        timestamp: new Date()
      });
      
      relevantChatHistory.push({
        role: 'assistant',
        content: historyMarker,
        timestamp: new Date()
      });
      
      // Limitar historial relevante a 20 mensajes
      const limitedRelevantHistory = relevantChatHistory.slice(-20);
      
      await prisma.customer.update({
        where: { id: customer.id },
        data: {
          fullChatHistory: JSON.stringify(fullChatHistory),
          relevantChatHistory: JSON.stringify(limitedRelevantHistory),
          lastInteraction: new Date()
        }
      });
      
      await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
      
      logger.info('Chat history updated with preorder information');
    } catch (error) {
      logger.error('Error updating chat history with preorder:', error);
      // No lanzar error para no interrumpir el flujo de preorden
    }
  }
  
  private static async confirmPreOrder(
    preOrderId: number, 
    whatsappNumber: string
  ): Promise<void> {
    logger.info('Confirming preorder', { preOrderId });
    
    const orderManagementService = new OrderManagementService();
    
    const order = await orderManagementService.confirmPreOrder(preOrderId);
    
    logger.info('Order created successfully', { 
      orderId: order.id,
      shiftOrderNumber: order.shiftOrderNumber 
    });
    
    // Clear relevant chat history after confirming order
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: whatsappNumber }
    });
    
    if (customer) {
      await prisma.customer.update({
        where: { id: customer.id },
        data: {
          relevantChatHistory: [],
          updatedAt: new Date()
        }
      });
      logger.info(`Cleared relevant chat history for customer ${customer.id} after order confirmation`);
      
      // Mark for sync
      await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
    }
    
    await orderManagementService.sendOrderConfirmation(whatsappNumber, order.id, 'confirmed');
  }
  
  private static async discardPreOrder(
    preOrderId: number, 
    whatsappNumber: string
  ): Promise<void> {
    logger.info('Discarding preorder and clearing history', { preOrderId });
    
    const orderManagementService = new OrderManagementService();
    
    await orderManagementService.discardPreOrder(preOrderId);
    
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: whatsappNumber }
    });
    
    if (customer) {
      await prisma.customer.update({
        where: { id: customer.id },
        data: {
          relevantChatHistory: [],
          updatedAt: new Date()
        }
      });
      logger.info(`Cleared relevant chat history for customer ${customer.id}`);
    }
    
    await sendWhatsAppMessage(
      whatsappNumber,
      "❌ Tu pedido ha sido descartado y tu historial de conversación ha sido reiniciado.\n\n" +
      "🍕 Puedes comenzar un nuevo pedido desde cero cuando gustes.\n\n" +
      "💡 *Tip:* Para hacer un pedido, simplemente escribe lo que deseas ordenar e indica si es para entrega a domicilio o recolección en el restaurante."
    );
  }
  
  private static async discardActivePreOrders(whatsappNumber: string): Promise<void> {
    try {
      const activePreOrders = await prisma.preOrder.findMany({
        where: { whatsappPhoneNumber: whatsappNumber }
      });
      
      if (activePreOrders.length === 0) {
        return;
      }
      
      logger.info(`Found ${activePreOrders.length} active preorders for ${whatsappNumber}. Discarding them.`);
      
      const tokenKeys = await redisService.keys(`${this.TOKEN_PREFIX}*`);
      for (const key of tokenKeys) {
        const preOrderIdStr = await redisService.get(key);
        if (preOrderIdStr) {
          const preOrderId = parseInt(preOrderIdStr, 10);
          if (activePreOrders.some(po => po.id === preOrderId)) {
            await redisService.del(key);
            logger.debug(`Deleted token for preorder ${preOrderId}`);
          }
        }
      }
      
      await prisma.preOrder.deleteMany({
        where: { whatsappPhoneNumber: whatsappNumber }
      });
      
      logger.info(`Discarded ${activePreOrders.length} preorders for ${whatsappNumber}`);
    } catch (error) {
      logger.error('Error discarding active preorders', error);
      // Don't throw - this shouldn't prevent creating a new preorder
    }
  }
  
  static async cleanupExpiredPreOrders(): Promise<void> {
    try {
      const expiryDate = new Date();
      expiryDate.setMinutes(expiryDate.getMinutes() - this.PREORDER_EXPIRY_MINUTES);
      
      const expiredPreOrders = await prisma.preOrder.findMany({
        where: {
          createdAt: {
            lt: expiryDate
          }
        }
      });
      
      if (expiredPreOrders.length === 0) {
        return;
      }
      
      logger.info(`Found ${expiredPreOrders.length} expired preorders to clean up`);
      
      const tokenKeys = await redisService.keys(`${this.TOKEN_PREFIX}*`);
      for (const key of tokenKeys) {
        const preOrderIdStr = await redisService.get(key);
        if (preOrderIdStr) {
          const preOrderId = parseInt(preOrderIdStr, 10);
          if (expiredPreOrders.some(po => po.id === preOrderId)) {
            await redisService.del(key);
            logger.debug(`Deleted expired token for preorder ${preOrderId}`);
          }
        }
      }
      
      const result = await prisma.preOrder.deleteMany({
        where: {
          createdAt: {
            lt: expiryDate
          }
        }
      });
      
      logger.info(`Cleaned up ${result.count} expired preorders`);
    } catch (error) {
      logger.error('Error cleaning up expired preorders', error);
    }
  }
  
  /**
   * Recreate preOrder with new address
   * This is used when customer changes address during preorder flow
   */
  static async recreatePreOrderWithNewAddress(params: {
    oldPreOrderId: number;
    newAddressId: string;
    whatsappNumber: string;
  }): Promise<PreOrderWorkflowResult> {
    try {
      // Get the old preOrder with all details
      const oldPreOrder = await prisma.preOrder.findUnique({
        where: { id: params.oldPreOrderId },
        include: {
          orderItems: {
            include: {
              product: true,
              productVariant: true,
              productModifiers: true,
              selectedPizzaCustomizations: {
                include: {
                  pizzaCustomization: true
                }
              }
            }
          }
        }
      });
      
      if (!oldPreOrder) {
        throw new BusinessLogicError(
          ErrorCode.ORDER_NOT_FOUND,
          'PreOrder not found',
          { metadata: { preOrderId: params.oldPreOrderId } }
        );
      }
      
      // Get the new address
      const newAddress = await prisma.address.findUnique({
        where: { id: params.newAddressId },
        include: { customer: true }
      });
      
      if (!newAddress) {
        throw new BusinessLogicError(
          ErrorCode.ADDRESS_NOT_FOUND,
          'Address not found',
          { metadata: { addressId: params.newAddressId } }
        );
      }
      
      // Prepare order data from old preOrder
      const orderData: ProcessedOrderData = {
        orderItems: oldPreOrder.orderItems.map(item => ({
          productId: item.productId,
          productVariantId: item.productVariantId || undefined,
          quantity: 1,
          selectedModifiers: item.productModifiers.map(m => m.id),
          selectedPizzaCustomizations: item.selectedPizzaCustomizations.map(pc => ({
            pizzaCustomizationId: pc.pizzaCustomizationId,
            half: pc.half,
            action: pc.action
          }))
        })),
        orderType: oldPreOrder.orderType as 'DELIVERY' | 'TAKE_AWAY',
        scheduledAt: oldPreOrder.scheduledAt || undefined,
        deliveryInfo: {
          name: newAddress.name,
          street: newAddress.street,
          number: newAddress.number,
          interiorNumber: newAddress.interiorNumber,
          neighborhood: newAddress.neighborhood,
          city: newAddress.city,
          state: newAddress.state,
          zipCode: newAddress.zipCode,
          country: newAddress.country,
          deliveryInstructions: newAddress.deliveryInstructions,
          latitude: newAddress.latitude?.toNumber() || null,
          longitude: newAddress.longitude?.toNumber() || null
        }
      };
      
      // Mark that we're updating a preOrder to prevent welcome message
      const updateKey = `preorder:updating:${params.whatsappNumber}`;
      await redisService.set(updateKey, 'true', 60); // 60 seconds TTL
      
      // Discard the old preOrder
      const orderManagementService = new OrderManagementService();
      await orderManagementService.discardPreOrder(params.oldPreOrderId);
      
      // Delete old token
      const tokenKeys = await redisService.keys(`${this.TOKEN_PREFIX}*`);
      for (const key of tokenKeys) {
        const storedPreOrderId = await redisService.get(key);
        if (storedPreOrderId === params.oldPreOrderId.toString()) {
          await redisService.del(key);
          break;
        }
      }
      
      // Create new preOrder with new address
      const result = await this.createAndNotify({
        orderData,
        customerId: newAddress.customerId,
        whatsappNumber: params.whatsappNumber
      });
      
      // Clean up the update flag
      await redisService.del(updateKey);
      
      return result;
    } catch (error) {
      logger.error('Error recreating preOrder with new address', error);
      throw error;
    }
  }
}

================
File: backend/src/services/security/OTPService.ts
================
import logger from '../../common/utils/logger';
import crypto from 'crypto';
import { redisService } from '../redis/RedisService';

/**
 * Service for managing One-Time Passwords (OTP)
 */
export class OTPService {
  // Fallback to memory if Redis is not available
  private static memoryStore = new Map<string, { code: string; expires: Date }>();
  private static cleanupInterval: NodeJS.Timeout | null = null;
  private static readonly OTP_EXPIRY_MINUTES = 10;
  private static readonly REDIS_KEY_PREFIX = 'otp:';

  /**
   * Get Redis key for OTP
   */
  private static getRedisKey(whatsappPhoneNumber: string): string {
    return `${this.REDIS_KEY_PREFIX}${whatsappPhoneNumber}`;
  }

  /**
   * Generate a new OTP code
   */
  static generateOTP(): string {
    return crypto.randomInt(100000, 999999).toString();
  }

  /**
   * Store an OTP for a WhatsApp phone number
   */
  static async storeOTP(whatsappPhoneNumber: string, otp: string, isAddressRegistration: boolean = false): Promise<void> {
    const expires = new Date(Date.now() + this.OTP_EXPIRY_MINUTES * 60 * 1000);
    const expiresInSeconds = this.OTP_EXPIRY_MINUTES * 60;
    
    // Try Redis first
    if (redisService.isAvailable()) {
      const key = this.getRedisKey(whatsappPhoneNumber);
      const data = { code: otp, expires: expires.toISOString() };
      const stored = await redisService.setJSON(key, data, expiresInSeconds);
      
      if (stored) {
        logger.info(`OTP stored in Redis for phone ${whatsappPhoneNumber} (expires at ${expires.toISOString()})`);
        return;
      }
    }
    
    // Fallback to memory
    this.memoryStore.set(whatsappPhoneNumber, { code: otp, expires });
    logger.info(`OTP stored in memory for phone ${whatsappPhoneNumber} (expires at ${expires.toISOString()})`);
  }

  /**
   * Generate and store OTP for a WhatsApp phone number
   */
  static async generateAndSendOTP(whatsappPhoneNumber: string): Promise<boolean> {
    try {
      const otp = this.generateOTP();
      await this.storeOTP(whatsappPhoneNumber, otp);

      // In production, send via SMS/WhatsApp
      // For development, just log it
      logger.info(`OTP for phone ${whatsappPhoneNumber}: ${otp}`);

      return true;
    } catch (error) {
      logger.error('Error generating OTP:', error);
      return false;
    }
  }

  /**
   * Verify an OTP
   */
  static async verifyOTP(whatsappPhoneNumber: string, code: string): Promise<boolean> {
    try {
      logger.info(`Verifying OTP for phone ${whatsappPhoneNumber}, code: ${code}`);
      
      let storedOTP: { code: string; expires: Date | string } | null = null;
      
      // Try Redis first
      if (redisService.isAvailable()) {
        const key = this.getRedisKey(whatsappPhoneNumber);
        const redisData = await redisService.getJSON<{ code: string; expires: string }>(key);
        
        if (redisData) {
          storedOTP = { code: redisData.code, expires: new Date(redisData.expires) };
          logger.debug(`OTP found in Redis for phone ${whatsappPhoneNumber}`);
        }
      }
      
      // Fallback to memory if not found in Redis
      if (!storedOTP) {
        const memoryData = this.memoryStore.get(whatsappPhoneNumber);
        if (memoryData) {
          storedOTP = memoryData;
          logger.debug(`OTP found in memory for phone ${whatsappPhoneNumber}`);
        }
      }
      
      if (!storedOTP) {
        logger.warn(`No OTP found for phone ${whatsappPhoneNumber}`);
        return false;
      }

      // Check if expired
      const expiryDate = storedOTP.expires instanceof Date ? storedOTP.expires : new Date(storedOTP.expires);
      if (new Date() > expiryDate) {
        await this.invalidateOTP(whatsappPhoneNumber);
        logger.warn(`OTP expired for phone ${whatsappPhoneNumber} - Expired at: ${expiryDate.toISOString()}, Current time: ${new Date().toISOString()}`);
        return false;
      }

      // Verify code
      if (storedOTP.code === code) {
        // Don't delete immediately for address registration - allow multiple verifications
        logger.info(`OTP verified successfully for phone ${whatsappPhoneNumber}`);
        return true;
      }

      logger.warn(`Invalid OTP attempt for phone ${whatsappPhoneNumber} - Expected: ${storedOTP.code}, Received: ${code}`);
      return false;
    } catch (error) {
      logger.error('Error verifying OTP:', error);
      return false;
    }
  }

  /**
   * Invalidate an OTP
   */
  static async invalidateOTP(whatsappPhoneNumber: string): Promise<void> {
    // Try Redis first
    if (redisService.isAvailable()) {
      const key = this.getRedisKey(whatsappPhoneNumber);
      await redisService.del(key);
    }
    
    // Also remove from memory
    this.memoryStore.delete(whatsappPhoneNumber);
    logger.info(`OTP invalidated for phone ${whatsappPhoneNumber}`);
  }


  /**
   * Clean up expired OTPs from memory store
   */
  private static cleanupExpiredOTPs(): void {
    const now = new Date();
    let cleanedCount = 0;
    
    for (const [whatsappPhoneNumber, otp] of this.memoryStore.entries()) {
      if (now > otp.expires) {
        this.memoryStore.delete(whatsappPhoneNumber);
        cleanedCount++;
      }
    }
    
    if (cleanedCount > 0) {
      logger.debug(`Cleaned up ${cleanedCount} expired OTPs from memory`);
    }
    
    // Note: Redis handles expiration automatically, no need to clean up there
  }

  /**
   * Start periodic cleanup of expired OTPs
   */
  static startOTPCleanup(): void {
    if (this.cleanupInterval) return; // Already running
    
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredOTPs();
    }, 60000); // Run every minute
    
    logger.info('OTP cleanup interval started');
  }

  /**
   * Stop periodic cleanup
   */
  static stopOTPCleanup(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
      logger.info('OTP cleanup interval stopped');
    }
  }

  /**
   * Get OTP statistics (for monitoring)
   */
  static async getStats(): Promise<{ total: number; expired: number; source: 'redis' | 'memory' | 'both' }> {
    const now = new Date();
    let expired = 0;
    let total = 0;
    let source: 'redis' | 'memory' | 'both' = 'memory';
    
    // Check Redis if available
    if (redisService.isAvailable()) {
      const keys = await redisService.keys(`${this.REDIS_KEY_PREFIX}*`);
      total = keys.length;
      
      // For expired count in Redis, we'd need to check each key
      // which is expensive, so we'll skip it for Redis
      source = 'redis';
    } else {
      // Use memory store
      total = this.memoryStore.size;
      for (const [, otp] of this.memoryStore.entries()) {
        if (now > otp.expires) {
          expired++;
        }
      }
    }

    return {
      total,
      expired,
      source
    };
  }
}

================
File: backend/src/services/whatsapp/index.ts
================
/**
 * Central export file for WhatsApp functionality
 * Re-exports commonly used functions for easier imports
 */

// Re-export from WhatsAppService
export { 
  WhatsAppService,
  WhatsAppService as default 
} from './WhatsAppService';

// Re-export specific WhatsApp functions
import { WhatsAppService } from './WhatsAppService';

export const sendWhatsAppMessage = WhatsAppService.sendWhatsAppMessage.bind(WhatsAppService);
export const sendWhatsAppInteractiveMessage = WhatsAppService.sendInteractiveMessage.bind(WhatsAppService);
export const sendMessageWithUrlButton = WhatsAppService.sendMessageWithUrlButton.bind(WhatsAppService);
export const getWhatsAppMediaUrl = WhatsAppService.getMediaUrl.bind(WhatsAppService);
export const downloadWhatsAppMedia = WhatsAppService.downloadMedia.bind(WhatsAppService);
export const verifyWhatsAppWebhook = WhatsAppService.verifyWebhook.bind(WhatsAppService);
export const handleWhatsAppWebhook = WhatsAppService.handleWebhook.bind(WhatsAppService);

================
File: backend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": ".",
    "strict": true,
    "strictPropertyInitialization": false,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "types": ["node"],
    "allowJs": true,
    "noEmit": false,
    "incremental": true,
    "sourceMap": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*", "prisma/seed.ts"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "transpileOnly": true,
    "files": true,
    "compilerOptions": {
      "module": "commonjs"
    }
  }
}

================
File: backend/.claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(npx prisma migrate dev:*)",
      "Bash(DATABASE_URL=\"postgresql://postgres:postgres@localhost:5433/bot_db\" npx prisma migrate dev --name remove_message_rate_limit_table --create-only)",
      "Bash(powershell:*)",
      "Bash(mkdir:*)",
      "Bash(Remove-Item -Path \"C:\\Users\\Leonel\\Desktop\\bot_backend\\backend\\prisma\\migrations\" -Recurse -Force)"
    ],
    "deny": []
  }
}

================
File: backend/prisma/migrations/20250718185619_initial_migration/migration.sql
================
-- CreateExtension
CREATE EXTENSION IF NOT EXISTS "vector";

-- CreateEnum
CREATE TYPE "OrderType" AS ENUM ('DINE_IN', 'TAKE_AWAY', 'DELIVERY');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'IN_PREPARATION', 'READY', 'IN_DELIVERY', 'DELIVERED', 'COMPLETED', 'CANCELLED');

-- CreateEnum
CREATE TYPE "PaymentStatus" AS ENUM ('PENDING', 'PAID', 'FAILED', 'REFUNDED', 'CANCELLED');

-- CreateEnum
CREATE TYPE "PaymentMethod" AS ENUM ('CASH', 'CREDIT_CARD', 'DEBIT_CARD', 'TRANSFER', 'STRIPE', 'PAYPAL', 'OTHER');

-- CreateEnum
CREATE TYPE "PizzaHalf" AS ENUM ('FULL', 'HALF_1', 'HALF_2');

-- CreateEnum
CREATE TYPE "CustomizationAction" AS ENUM ('ADD', 'REMOVE');

-- CreateEnum
CREATE TYPE "CustomizationType" AS ENUM ('FLAVOR', 'INGREDIENT');

-- CreateEnum
CREATE TYPE "PreparationStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'READY', 'DELIVERED', 'CANCELLED');

-- CreateTable
CREATE TABLE "Category" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "photoId" TEXT,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Category_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Customer" (
    "id" UUID NOT NULL,
    "whatsappPhoneNumber" TEXT NOT NULL,
    "firstName" VARCHAR(100),
    "lastName" VARCHAR(100),
    "email" VARCHAR(255),
    "birthDate" DATE,
    "fullChatHistory" JSONB,
    "relevantChatHistory" JSONB,
    "stripeCustomerId" TEXT,
    "lastInteraction" TIMESTAMP(3),
    "totalOrders" INTEGER NOT NULL DEFAULT 0,
    "totalSpent" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "isBanned" BOOLEAN NOT NULL DEFAULT false,
    "bannedAt" TIMESTAMP(3),
    "banReason" TEXT,
    "deletedAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Customer_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Address" (
    "id" UUID NOT NULL,
    "customerId" UUID NOT NULL,
    "name" VARCHAR(100) NOT NULL,
    "street" VARCHAR(200) NOT NULL,
    "number" VARCHAR(50) NOT NULL,
    "interiorNumber" VARCHAR(50),
    "neighborhood" VARCHAR(150),
    "city" VARCHAR(100),
    "state" VARCHAR(100),
    "zipCode" VARCHAR(10),
    "country" VARCHAR(100),
    "deliveryInstructions" TEXT,
    "latitude" DECIMAL(10,8),
    "longitude" DECIMAL(11,8),
    "isDefault" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Address_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "MessageLog" (
    "id" SERIAL NOT NULL,
    "messageId" TEXT NOT NULL,
    "processed" BOOLEAN NOT NULL DEFAULT false,

    CONSTRAINT "MessageLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductModifier" (
    "id" TEXT NOT NULL,
    "modifierGroupId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "price" DOUBLE PRECISION,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "isDefault" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "ProductModifier_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ModifierGroup" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "minSelections" INTEGER NOT NULL DEFAULT 0,
    "maxSelections" INTEGER NOT NULL DEFAULT 1,
    "isRequired" BOOLEAN NOT NULL DEFAULT false,
    "allowMultipleSelections" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "ModifierGroup_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Order" (
    "id" UUID NOT NULL,
    "shiftOrderNumber" INTEGER,
    "orderType" "OrderType" NOT NULL,
    "orderStatus" "OrderStatus" NOT NULL DEFAULT 'PENDING',
    "subtotal" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "total" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "customerId" UUID NOT NULL,
    "estimatedDeliveryTime" TIMESTAMP(3),
    "scheduledAt" TIMESTAMP(3),
    "notes" TEXT,
    "isFromWhatsApp" BOOLEAN NOT NULL DEFAULT true,
    "finalizedAt" TIMESTAMP(3),
    "shiftId" UUID,
    "userId" UUID,
    "tableId" UUID,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Order_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "DeliveryInfo" (
    "id" UUID NOT NULL,
    "orderId" UUID,
    "preOrderId" INTEGER,
    "name" VARCHAR(100),
    "fullAddress" TEXT,
    "street" VARCHAR(200),
    "number" VARCHAR(50),
    "interiorNumber" VARCHAR(50),
    "neighborhood" VARCHAR(150),
    "city" VARCHAR(100),
    "state" VARCHAR(100),
    "zipCode" VARCHAR(10),
    "country" VARCHAR(100),
    "recipientName" VARCHAR(255),
    "recipientPhone" VARCHAR(50),
    "deliveryInstructions" TEXT,
    "latitude" DECIMAL(10,8),
    "longitude" DECIMAL(11,8),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "DeliveryInfo_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "OrderItem" (
    "id" UUID NOT NULL,
    "orderId" UUID,
    "preOrderId" INTEGER,
    "productId" TEXT NOT NULL,
    "productVariantId" TEXT,
    "basePrice" DOUBLE PRECISION NOT NULL,
    "finalPrice" DOUBLE PRECISION NOT NULL,
    "preparationStatus" "PreparationStatus" NOT NULL DEFAULT 'PENDING',
    "statusChangedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "preparationNotes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "OrderItem_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PizzaCustomization" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "type" "CustomizationType" NOT NULL,
    "ingredients" TEXT,
    "toppingValue" INTEGER NOT NULL DEFAULT 1,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "PizzaCustomization_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PizzaConfiguration" (
    "id" UUID NOT NULL,
    "productId" TEXT NOT NULL,
    "includedToppings" INTEGER NOT NULL DEFAULT 4,
    "extraToppingCost" DOUBLE PRECISION NOT NULL DEFAULT 20,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "PizzaConfiguration_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PreOrder" (
    "id" SERIAL NOT NULL,
    "orderType" "OrderType" NOT NULL,
    "estimatedDeliveryTime" INTEGER NOT NULL DEFAULT 0,
    "scheduledAt" TIMESTAMP(3),
    "notes" TEXT,
    "subtotal" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "total" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "whatsappPhoneNumber" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "PreOrder_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Product" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "price" DOUBLE PRECISION,
    "hasVariants" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "isPizza" BOOLEAN NOT NULL DEFAULT false,
    "subcategoryId" TEXT NOT NULL,
    "preparationScreenId" TEXT,
    "photoId" TEXT,
    "estimatedPrepTime" INTEGER NOT NULL DEFAULT 0,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "embedding" vector(768),

    CONSTRAINT "Product_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductVariant" (
    "id" TEXT NOT NULL,
    "productId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price" DOUBLE PRECISION NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "ProductVariant_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "RestaurantConfig" (
    "id" SERIAL NOT NULL,
    "restaurantName" TEXT NOT NULL DEFAULT 'La Leña',
    "phoneMain" TEXT,
    "phoneSecondary" TEXT,
    "address" TEXT,
    "city" TEXT,
    "state" TEXT,
    "postalCode" TEXT,
    "country" TEXT,
    "acceptingOrders" BOOLEAN NOT NULL DEFAULT true,
    "estimatedPickupTime" INTEGER NOT NULL DEFAULT 20,
    "estimatedDeliveryTime" INTEGER NOT NULL DEFAULT 40,
    "openingGracePeriod" INTEGER NOT NULL DEFAULT 30,
    "closingGracePeriod" INTEGER NOT NULL DEFAULT 30,
    "timeZone" TEXT NOT NULL DEFAULT 'America/Mexico_City',
    "deliveryCoverageArea" JSONB,

    CONSTRAINT "RestaurantConfig_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "BusinessHours" (
    "id" SERIAL NOT NULL,
    "dayOfWeek" INTEGER NOT NULL,
    "openingTime" TEXT,
    "closingTime" TEXT,
    "isClosed" BOOLEAN NOT NULL DEFAULT false,
    "restaurantConfigId" INTEGER NOT NULL,

    CONSTRAINT "BusinessHours_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SelectedPizzaCustomization" (
    "id" UUID NOT NULL,
    "orderItemId" UUID NOT NULL,
    "pizzaCustomizationId" TEXT NOT NULL,
    "half" "PizzaHalf" NOT NULL DEFAULT 'FULL',
    "action" "CustomizationAction" NOT NULL DEFAULT 'ADD',

    CONSTRAINT "SelectedPizzaCustomization_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Subcategory" (
    "id" TEXT NOT NULL,
    "categoryId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "photoId" TEXT,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Subcategory_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SyncLog" (
    "id" TEXT NOT NULL,
    "syncType" TEXT NOT NULL,
    "recordsAffected" INTEGER NOT NULL DEFAULT 0,
    "status" TEXT NOT NULL,
    "error" TEXT,
    "startedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "SyncLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Payment" (
    "id" UUID NOT NULL,
    "orderId" UUID NOT NULL,
    "paymentMethod" "PaymentMethod" NOT NULL DEFAULT 'CASH',
    "amount" DECIMAL(10,2) NOT NULL,
    "status" "PaymentStatus" NOT NULL DEFAULT 'PENDING',
    "stripePaymentId" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Payment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Shift" (
    "id" UUID NOT NULL,
    "shiftDate" DATE NOT NULL,
    "shiftNumber" INTEGER NOT NULL DEFAULT 1,
    "startTime" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "endTime" TIMESTAMP(3),
    "orderCounter" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Shift_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Table" (
    "id" UUID NOT NULL,
    "tableNumber" TEXT NOT NULL,
    "capacity" INTEGER NOT NULL DEFAULT 4,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Table_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" UUID NOT NULL,
    "username" TEXT NOT NULL,
    "email" TEXT,
    "firstName" TEXT,
    "lastName" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "TicketImpression" (
    "id" UUID NOT NULL,
    "orderId" UUID NOT NULL,
    "printedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "printerName" TEXT,

    CONSTRAINT "TicketImpression_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Adjustment" (
    "id" UUID NOT NULL,
    "orderId" UUID,
    "preOrderId" INTEGER,
    "orderItemId" UUID,
    "type" TEXT NOT NULL,
    "amount" DECIMAL(10,2) NOT NULL,
    "reason" TEXT,
    "appliedBy" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Adjustment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SyncMetadata" (
    "id" TEXT NOT NULL,
    "entityType" TEXT NOT NULL,
    "entityId" TEXT NOT NULL,
    "lastModifiedAt" TIMESTAMP(3) NOT NULL,
    "modifiedBy" TEXT NOT NULL DEFAULT 'REMOTE',
    "syncPending" BOOLEAN NOT NULL DEFAULT false,
    "syncVersion" INTEGER NOT NULL DEFAULT 1,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "SyncMetadata_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_ProductModifierGroups" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_ProductModifierGroups_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateTable
CREATE TABLE "_OrderItemProductModifiers" (
    "A" UUID NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_OrderItemProductModifiers_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateTable
CREATE TABLE "_ProductPizzaCustomizations" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_ProductPizzaCustomizations_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE UNIQUE INDEX "Category_name_key" ON "Category"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Customer_whatsappPhoneNumber_key" ON "Customer"("whatsappPhoneNumber");

-- CreateIndex
CREATE UNIQUE INDEX "Customer_stripeCustomerId_key" ON "Customer"("stripeCustomerId");

-- CreateIndex
CREATE INDEX "Customer_whatsappPhoneNumber_idx" ON "Customer"("whatsappPhoneNumber");

-- CreateIndex
CREATE INDEX "Customer_email_idx" ON "Customer"("email");

-- CreateIndex
CREATE INDEX "Address_customerId_idx" ON "Address"("customerId");

-- CreateIndex
CREATE INDEX "Address_zipCode_idx" ON "Address"("zipCode");

-- CreateIndex
CREATE UNIQUE INDEX "MessageLog_messageId_key" ON "MessageLog"("messageId");

-- CreateIndex
CREATE INDEX "Order_shiftId_idx" ON "Order"("shiftId");

-- CreateIndex
CREATE INDEX "Order_tableId_idx" ON "Order"("tableId");

-- CreateIndex
CREATE INDEX "Order_userId_idx" ON "Order"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "DeliveryInfo_orderId_key" ON "DeliveryInfo"("orderId");

-- CreateIndex
CREATE UNIQUE INDEX "DeliveryInfo_preOrderId_key" ON "DeliveryInfo"("preOrderId");

-- CreateIndex
CREATE INDEX "OrderItem_orderId_idx" ON "OrderItem"("orderId");

-- CreateIndex
CREATE INDEX "OrderItem_preOrderId_idx" ON "OrderItem"("preOrderId");

-- CreateIndex
CREATE UNIQUE INDEX "PizzaConfiguration_productId_key" ON "PizzaConfiguration"("productId");

-- CreateIndex
CREATE INDEX "PreOrder_whatsappPhoneNumber_idx" ON "PreOrder"("whatsappPhoneNumber");

-- CreateIndex
CREATE UNIQUE INDEX "BusinessHours_restaurantConfigId_dayOfWeek_key" ON "BusinessHours"("restaurantConfigId", "dayOfWeek");

-- CreateIndex
CREATE UNIQUE INDEX "SelectedPizzaCustomization_orderItemId_pizzaCustomizationId_key" ON "SelectedPizzaCustomization"("orderItemId", "pizzaCustomizationId", "half", "action");

-- CreateIndex
CREATE UNIQUE INDEX "Subcategory_name_key" ON "Subcategory"("name");

-- CreateIndex
CREATE INDEX "SyncLog_syncType_idx" ON "SyncLog"("syncType");

-- CreateIndex
CREATE INDEX "SyncLog_status_idx" ON "SyncLog"("status");

-- CreateIndex
CREATE INDEX "Payment_orderId_idx" ON "Payment"("orderId");

-- CreateIndex
CREATE INDEX "Payment_status_idx" ON "Payment"("status");

-- CreateIndex
CREATE INDEX "Shift_shiftDate_idx" ON "Shift"("shiftDate");

-- CreateIndex
CREATE INDEX "Shift_startTime_idx" ON "Shift"("startTime");

-- CreateIndex
CREATE UNIQUE INDEX "Shift_shiftDate_shiftNumber_key" ON "Shift"("shiftDate", "shiftNumber");

-- CreateIndex
CREATE UNIQUE INDEX "Table_tableNumber_key" ON "Table"("tableNumber");

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE INDEX "TicketImpression_orderId_idx" ON "TicketImpression"("orderId");

-- CreateIndex
CREATE INDEX "Adjustment_orderId_idx" ON "Adjustment"("orderId");

-- CreateIndex
CREATE INDEX "Adjustment_preOrderId_idx" ON "Adjustment"("preOrderId");

-- CreateIndex
CREATE INDEX "Adjustment_orderItemId_idx" ON "Adjustment"("orderItemId");

-- CreateIndex
CREATE INDEX "SyncMetadata_syncPending_entityType_idx" ON "SyncMetadata"("syncPending", "entityType");

-- CreateIndex
CREATE INDEX "SyncMetadata_lastModifiedAt_idx" ON "SyncMetadata"("lastModifiedAt");

-- CreateIndex
CREATE INDEX "SyncMetadata_entityId_idx" ON "SyncMetadata"("entityId");

-- CreateIndex
CREATE UNIQUE INDEX "SyncMetadata_entityType_entityId_key" ON "SyncMetadata"("entityType", "entityId");

-- CreateIndex
CREATE INDEX "_ProductModifierGroups_B_index" ON "_ProductModifierGroups"("B");

-- CreateIndex
CREATE INDEX "_OrderItemProductModifiers_B_index" ON "_OrderItemProductModifiers"("B");

-- CreateIndex
CREATE INDEX "_ProductPizzaCustomizations_B_index" ON "_ProductPizzaCustomizations"("B");

-- AddForeignKey
ALTER TABLE "Address" ADD CONSTRAINT "Address_customerId_fkey" FOREIGN KEY ("customerId") REFERENCES "Customer"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductModifier" ADD CONSTRAINT "ProductModifier_modifierGroupId_fkey" FOREIGN KEY ("modifierGroupId") REFERENCES "ModifierGroup"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_customerId_fkey" FOREIGN KEY ("customerId") REFERENCES "Customer"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_shiftId_fkey" FOREIGN KEY ("shiftId") REFERENCES "Shift"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_tableId_fkey" FOREIGN KEY ("tableId") REFERENCES "Table"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DeliveryInfo" ADD CONSTRAINT "DeliveryInfo_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DeliveryInfo" ADD CONSTRAINT "DeliveryInfo_preOrderId_fkey" FOREIGN KEY ("preOrderId") REFERENCES "PreOrder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_preOrderId_fkey" FOREIGN KEY ("preOrderId") REFERENCES "PreOrder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_productVariantId_fkey" FOREIGN KEY ("productVariantId") REFERENCES "ProductVariant"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "PizzaConfiguration" ADD CONSTRAINT "PizzaConfiguration_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_subcategoryId_fkey" FOREIGN KEY ("subcategoryId") REFERENCES "Subcategory"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductVariant" ADD CONSTRAINT "ProductVariant_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BusinessHours" ADD CONSTRAINT "BusinessHours_restaurantConfigId_fkey" FOREIGN KEY ("restaurantConfigId") REFERENCES "RestaurantConfig"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SelectedPizzaCustomization" ADD CONSTRAINT "SelectedPizzaCustomization_orderItemId_fkey" FOREIGN KEY ("orderItemId") REFERENCES "OrderItem"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SelectedPizzaCustomization" ADD CONSTRAINT "SelectedPizzaCustomization_pizzaCustomizationId_fkey" FOREIGN KEY ("pizzaCustomizationId") REFERENCES "PizzaCustomization"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Subcategory" ADD CONSTRAINT "Subcategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Payment" ADD CONSTRAINT "Payment_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "TicketImpression" ADD CONSTRAINT "TicketImpression_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Adjustment" ADD CONSTRAINT "Adjustment_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Adjustment" ADD CONSTRAINT "Adjustment_preOrderId_fkey" FOREIGN KEY ("preOrderId") REFERENCES "PreOrder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Adjustment" ADD CONSTRAINT "Adjustment_orderItemId_fkey" FOREIGN KEY ("orderItemId") REFERENCES "OrderItem"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductModifierGroups" ADD CONSTRAINT "_ProductModifierGroups_A_fkey" FOREIGN KEY ("A") REFERENCES "ModifierGroup"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductModifierGroups" ADD CONSTRAINT "_ProductModifierGroups_B_fkey" FOREIGN KEY ("B") REFERENCES "Product"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_OrderItemProductModifiers" ADD CONSTRAINT "_OrderItemProductModifiers_A_fkey" FOREIGN KEY ("A") REFERENCES "OrderItem"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_OrderItemProductModifiers" ADD CONSTRAINT "_OrderItemProductModifiers_B_fkey" FOREIGN KEY ("B") REFERENCES "ProductModifier"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductPizzaCustomizations" ADD CONSTRAINT "_ProductPizzaCustomizations_A_fkey" FOREIGN KEY ("A") REFERENCES "PizzaCustomization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductPizzaCustomizations" ADD CONSTRAINT "_ProductPizzaCustomizations_B_fkey" FOREIGN KEY ("B") REFERENCES "Product"("id") ON DELETE CASCADE ON UPDATE CASCADE;

================
File: backend/scripts/generate-embeddings.js
================
#!/usr/bin/env node

/**
 * Script to manually generate embeddings for all products
 * Can be run with: npm run seed:embeddings
 */

const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function main() {
  try {
    console.log('🚀 Starting embedding generation...\n');
    
    // Check if products exist
    const productCount = await prisma.product.count({
      where: { isActive: true }
    });
    
    if (productCount === 0) {
      console.log('❌ No active products found in database');
      console.log('💡 Embeddings will be generated automatically after menu sync');
      return;
    }
    
    console.log(`Found ${productCount} active products\n`);
    
    // Import and use EmbeddingManager
    const { EmbeddingManager } = require('../dist/services/sync/EmbeddingManager');
    
    // Check current status
    const status = await EmbeddingManager.getEmbeddingStatus();
    console.log('📊 Current status:');
    console.log(`   Total products: ${status.totalProducts}`);
    console.log(`   With embeddings: ${status.productsWithEmbeddings}`);
    console.log(`   Need embeddings: ${status.productsNeedingEmbeddings}\n`);
    
    if (status.productsNeedingEmbeddings === 0) {
      console.log('✅ All products already have embeddings!');
      return;
    }
    
    // Generate embeddings
    console.log('⏳ Generating embeddings...\n');
    const updatedCount = await EmbeddingManager.generateEmbeddingsAfterSync();
    
    // Check final status
    const finalStatus = await EmbeddingManager.getEmbeddingStatus();
    console.log('\n✅ Embedding generation completed!');
    console.log(`   Generated: ${updatedCount} embeddings`);
    console.log(`   Total with embeddings: ${finalStatus.productsWithEmbeddings}/${finalStatus.totalProducts}`);
    
  } catch (error) {
    console.error('❌ Error generating embeddings:', error.message);
    if (error.message.includes('Cannot find module')) {
      console.error('\n💡 Make sure to build the project first: npm run build');
    }
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Check for required environment variable
if (!process.env.GOOGLE_AI_API_KEY) {
  console.error('❌ GOOGLE_AI_API_KEY environment variable is not set');
  console.error('💡 Add it to your .env file to enable embedding generation');
  process.exit(1);
}

main().catch(console.error);

================
File: backend/scripts/README_PGVECTOR.md
================
# pgvector Setup Documentation

## Overview
This project uses pgvector for semantic search capabilities. pgvector is a PostgreSQL extension that enables vector similarity search, which powers our AI-based menu search functionality.

## Automatic Setup
When you run `start-local.sh`, everything is configured automatically:
1. Docker Compose uses the `pgvector/pgvector:pg15` image
2. Database migrations create the vector extension and embedding column
3. Product embeddings are generated automatically when the server starts
4. Embeddings update automatically when products change

## Production Setup
For production environments (e.g., Railway), you need to enable pgvector:

1. Execute `production-pgvector-setup.sql` in your production database:
```sql
-- Enable pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- Create index for efficient similarity search
CREATE INDEX IF NOT EXISTS product_embedding_idx ON "Product" 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

2. Deploy your application - embeddings will be generated automatically on first startup

## How It Works

### Embedding Generation
- Each product gets a 768-dimensional vector embedding
- Embeddings include: name, category, subcategory, description, ingredients, variants, and modifiers
- Generated using Google's text-embedding-004 model

### Automatic Updates
- On server startup: Checks for products without embeddings
- Every hour: Checks for product changes and updates embeddings
- All embedding generation is automatic - no manual steps required

### Search Process
1. User query is converted to embedding
2. pgvector finds the 15 most similar products using cosine similarity
3. Results are returned sorted by relevance

## Troubleshooting

### "type vector does not exist" error
- Ensure you're using `pgvector/pgvector:pg15` Docker image
- Restart Docker: `docker-compose down && docker-compose up -d`
- The migration should create the extension automatically

### Embeddings not generating
- Check `GOOGLE_AI_API_KEY` is set in `.env`
- Verify pgvector is installed: `SELECT * FROM pg_extension WHERE extname = 'vector';`
- Check server logs for rate limiting errors from Google AI API

### Search returning empty results
- Verify embeddings exist: `SELECT COUNT(*) FROM "Product" WHERE embedding IS NOT NULL;`
- Restart the server - embeddings generate automatically on startup
- Check server logs for errors during embedding generation

## Performance Notes
- HNSW index provides fast similarity searches
- Initial embedding generation takes ~300ms per product (rate limited)
- Search queries typically complete in <100ms
- Index parameters: m=16, ef_construction=64 (balanced for accuracy/speed)

================
File: backend/scripts/setup-local-pgvector.sh
================
#!/bin/bash

echo "Configurando pgvector en base de datos local..."

# Verificar si pgvector está disponible
docker compose exec -T postgres psql -U postgres -d bot_db -c "CREATE EXTENSION IF NOT EXISTS vector;" 2>/dev/null

if [ $? -eq 0 ]; then
    echo "✅ pgvector configurado exitosamente"
    exit 0
else
    echo "⚠️  No se pudo configurar pgvector (la extensión podría no estar disponible)"
    exit 1
fi

================
File: backend/src/common/middlewares/apiKeyAuth.middleware.ts
================
import { Request, Response, NextFunction } from 'express';
import { TechnicalError, ErrorCode } from '../services/errors';
import logger from '../utils/logger';

export interface ApiKeyAuthRequest extends Request {
  apiKey?: string;
}

export async function apiKeyAuthMiddleware(
  req: ApiKeyAuthRequest,
  _res: Response,
  next: NextFunction
): Promise<void> {
  try {
    // Get API key from header
    const apiKey = req.headers['x-api-key'] as string;
    
    if (!apiKey) {
      throw new TechnicalError(
        ErrorCode.AUTHENTICATION_REQUIRED,
        'API key required for this operation'
      );
    }
    
    // Validate API key against environment variable
    const validApiKey = process.env.CLOUD_API_KEY;
    
    if (!validApiKey) {
      logger.error('CLOUD_API_KEY not configured in environment');
      throw new TechnicalError(
        ErrorCode.DATABASE_ERROR,
        'API key not configured'
      );
    }
    
    if (apiKey !== validApiKey) {
      throw new TechnicalError(
        ErrorCode.INVALID_CREDENTIALS,
        'Invalid API key'
      );
    }
    
    // Store API key in request for logging/tracking
    req.apiKey = apiKey;
    
    next();
  } catch (error) {
    next(error);
  }
}

================
File: backend/src/common/middlewares/otp.middleware.ts
================
import { Request, Response, NextFunction } from 'express';
import { OTPService } from '../../services/security/OTPService';
import { prisma } from '../../lib/prisma';
import { ValidationError, NotFoundError, ErrorCode } from '../services/errors';
import { asyncHandler } from './errorHandler';

/**
 * Extended Request interface with authenticated customer
 */
export interface AuthenticatedRequest extends Request {
  customer: {
    id: string;
    whatsappPhoneNumber: string;
    firstName?: string | null;
    lastName?: string | null;
  };
}

/**
 * Middleware for OTP authentication
 * Verifies OTP and attaches customer information to the request
 * 
 * Looks for whatsappPhoneNumber and otp in:
 * 1. Request body (for POST/PUT/DELETE)
 * 2. Query parameters (for GET)
 */
export const otpAuthMiddleware = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {
  // Extract whatsappPhoneNumber and otp from body or query
  let whatsappPhoneNumber: string | undefined;
  let otp: string | undefined;

  if (req.method === 'GET') {
    // For GET requests, check query parameters
    whatsappPhoneNumber = req.query.whatsappPhoneNumber as string;
    otp = req.query.otp as string;
  } else {
    // For other methods, check body
    whatsappPhoneNumber = req.body.whatsappPhoneNumber;
    otp = req.body.otp;
  }

  // Special case: if route has :customerId param that's actually a phone number
  if (!whatsappPhoneNumber && req.params.customerId && req.params.customerId.startsWith('+')) {
    whatsappPhoneNumber = req.params.customerId;
  }

  // Validate required fields
  if (!whatsappPhoneNumber || !otp) {
    throw new ValidationError(
      ErrorCode.MISSING_REQUIRED_FIELD,
      'whatsappPhoneNumber and otp are required'
    );
  }

  // Verify OTP
  const isValid = await OTPService.verifyOTP(whatsappPhoneNumber, otp);
  if (!isValid) {
    throw new ValidationError(
      ErrorCode.INVALID_OTP,
      'Invalid or expired OTP'
    );
  }

  // Get customer record
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber },
    select: {
      id: true,
      whatsappPhoneNumber: true,
      firstName: true,
      lastName: true
    }
  });

  if (!customer) {
    throw new NotFoundError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found',
      { whatsappPhoneNumber }
    );
  }

  // Attach customer to request
  (req as AuthenticatedRequest).customer = customer;
  
  next();
});

================
File: backend/src/common/services/errors/index.ts
================
export * from './types';
export * from './CustomErrors';
export * from './errorMessages';

================
File: backend/src/common/types/menu.ts
================
export interface ProductoInfo {
  productId: string;
  name: string;
  productVariants?: Array<{
    productVariantId: string;
    name: string;
  }>;
  modifierGroups?: Array<{
    modifierGroupId: string;
    name: string;
    minSelections: number;
    maxSelections: number;
    isRequired: boolean;
    allowMultipleSelections: boolean;
    productModifiers?: Array<{
      productModifierId: string;
      name: string;
    }>;
  }>;
  pizzaCustomizations?: Array<{
    pizzaCustomizationId: string;
    name: string;
    type: 'FLAVOR' | 'INGREDIENT';
    ingredients?: string;
  }>;
}

================
File: backend/src/common/types/order-item.types.ts
================
/**
 * Unified types for order items throughout the system
 * This file serves as the single source of truth for order item structures
 */

/**
 * Base structure for pizza customizations
 */
export interface PizzaCustomizationData {
  pizzaCustomizationId: string;
  half: 'FULL' | 'HALF_1' | 'HALF_2';
  action: 'ADD' | 'REMOVE';
}

/**
 * Base order item structure used throughout the system
 * This is the canonical format - no field name variations allowed
 */
export interface BaseOrderItem {
  productId: string;
  productVariantId?: string | null;
  quantity: number;
  comments?: string | null;
  selectedModifiers?: string[];
  selectedPizzaCustomizations?: PizzaCustomizationData[];
}

/**
 * Order item as it comes from the AI agent
 * We'll transform this immediately to BaseOrderItem format
 */
export interface AIOrderItem {
  productId: string;
  variantId?: string | null;  // AI uses 'variantId' instead of 'productVariantId'
  quantity: number;
  modifiers?: string[];  // AI uses 'modifiers' instead of 'selectedModifiers'
  pizzaCustomizations?: Array<{
    customizationId: string;  // AI uses 'customizationId' instead of 'pizzaCustomizationId'
    half: string;
    action: string;
  }>;
}

/**
 * Order item with calculated pricing information
 * This is what we store in the PreOrder JSON field
 */
export interface CalculatedOrderItem extends BaseOrderItem {
  basePrice: number;  // Price before modifiers
  modifiersPrice: number;  // Total price of modifiers
  unitPrice: number;  // basePrice + modifiersPrice
  totalPrice: number;  // unitPrice * quantity
  productName: string;  // For display purposes
  variantName?: string | null;  // For display purposes
  // Optional enriched data for display
  modifierNames?: string[];  // Names of selected modifiers
  pizzaCustomizationDetails?: Array<{
    pizzaCustomizationId: string;
    name: string;
    type: 'FLAVOR' | 'INGREDIENT';
    half: 'FULL' | 'HALF_1' | 'HALF_2';
    action: 'ADD' | 'REMOVE';
  }>;
}

/**
 * Order item data for creating an actual Order
 * This matches what OrderService expects
 */
export type CreateOrderItem = BaseOrderItem;

/**
 * Transform AI order item to base format
 */
export function transformAIOrderItem(aiItem: AIOrderItem): BaseOrderItem {
  return {
    productId: aiItem.productId,
    productVariantId: aiItem.variantId || null,
    quantity: aiItem.quantity || 1,
    selectedModifiers: aiItem.modifiers || [],
    selectedPizzaCustomizations: aiItem.pizzaCustomizations?.map(pc => ({
      pizzaCustomizationId: pc.customizationId,
      half: (pc.half || 'FULL') as 'FULL' | 'HALF_1' | 'HALF_2',
      action: (pc.action || 'ADD') as 'ADD' | 'REMOVE'
    })) || []
  };
}

/**
 * Transform calculated item back to base format for order creation
 */
export function extractBaseOrderItem(calculated: CalculatedOrderItem): CreateOrderItem {
  return {
    productId: calculated.productId,
    productVariantId: calculated.productVariantId,
    quantity: calculated.quantity,
    comments: calculated.comments,
    selectedModifiers: calculated.selectedModifiers,
    selectedPizzaCustomizations: calculated.selectedPizzaCustomizations
  };
}

================
File: backend/src/common/utils/addressFormatter.ts
================
/**
 * Utility functions for formatting addresses consistently across the application
 */

export function formatAddressFull(address: any): string {
  const parts = [];
  
  if (address.name) {
    parts.push(`*${address.name}*`);
  }
  
  if (address.street && address.number) {
    let streetLine = `${address.street} ${address.number}`;
    if (address.interiorNumber) {
      streetLine += ` Int. ${address.interiorNumber}`;
    }
    parts.push(streetLine);
  }
  
  if (address.neighborhood) parts.push(address.neighborhood);
  
  if (address.city && address.state) {
    parts.push(`${address.city}, ${address.state}`);
  }
  
  if (address.deliveryInstructions) {
    parts.push(`Referencias: ${address.deliveryInstructions}`);
  }
  
  return parts.join('\n');
}

export function formatAddressShort(address: any): string {
  const parts = [];
  if (address.name) parts.push(`*${address.name}*`);
  parts.push(`${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}`);
  if (address.neighborhood) parts.push(address.neighborhood);
  parts.push(`${address.city}, ${address.state}`);
  return parts.join('\n');
}

export function formatAddressDescription(address: any): string {
  const parts = [];
  if (address.street && address.number) {
    parts.push(`${address.street} ${address.number}`);
  }
  if (address.neighborhood) parts.push(address.neighborhood);
  if (address.city) parts.push(address.city);
  if (address.isDefault) parts.push('(Principal)');
  return parts.join(', ');
}

================
File: backend/src/common/utils/logger.ts
================
import * as winston from 'winston';

// Helper function to format JSON for better readability
const formatJSON = (obj: any, indent = 2): string => {
  try {
    if (typeof obj === 'string') {
      // Try to parse if it's a JSON string
      try {
        const parsed = JSON.parse(obj);
        return JSON.stringify(parsed, null, indent);
      } catch {
        return obj;
      }
    }
    return JSON.stringify(obj, null, indent);
  } catch (error) {
    return String(obj);
  }
};

const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message, ...meta }) => {
      // Helper function to safely stringify objects with circular references
      const safeStringify = (obj: any, indent = 0): string => {
        const seen = new WeakSet();
        return JSON.stringify(obj, (key, value) => {
          if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
              return '[Circular Reference]';
            }
            seen.add(value);
          }
          return value;
        }, indent);
      };
      
      // Si el mensaje es un objeto, convertirlo a string
      const formattedMessage = typeof message === 'object' 
        ? safeStringify(message, 2)
        : String(message);
      
      // Si hay metadata adicional, incluirla en el log
      const metadata = Object.keys(meta).length ? `\n${safeStringify(meta, 2)}` : '';
      
      return `${timestamp} [${level}]: ${formattedMessage}${metadata}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
});

// Add helper methods for JSON logging
(logger as any).json = function(message: string, data: any) {
  this.debug(`${message}\n${formatJSON(data)}`);
};

(logger as any).jsonInfo = function(message: string, data: any) {
  this.info(`${message}\n${formatJSON(data)}`);
};

export default logger;

================
File: backend/src/common/utils/whatsappErrorHandler.ts
================
import { sendWhatsAppMessage } from '../../services/whatsapp';
import logger from './logger';
import { BaseError } from '../services/errors/CustomErrors';
import { ERROR_MESSAGES } from '../services/errors/errorMessages';

/**
 * Handles errors in WhatsApp message processing by:
 * 1. Logging the error with context
 * 2. Sending an appropriate error message to the user
 * 
 * This is specifically for WhatsApp handlers where we can't use HTTP responses
 */
export async function handleWhatsAppError(
  error: unknown,
  whatsappNumber: string,
  context: {
    userId?: string;
    operation: string;
    metadata?: any;
  }
): Promise<void> {
  // Log the error with full context
  logger.error('WhatsApp handler error:', {
    error: error instanceof Error ? {
      name: error.name,
      message: error.message,
      stack: error.stack
    } : error,
    whatsappNumber,
    context,
    timestamp: new Date().toISOString()
  });

  // Determine user message
  let userMessage: string;
  
  if (error instanceof BaseError) {
    // Use the specific error message for known errors
    const errorConfig = ERROR_MESSAGES[error.code];
    userMessage = errorConfig?.user || '😔 Lo siento, ocurrió un error. Por favor intenta de nuevo.';
  } else if (error instanceof Error) {
    // For unexpected errors, use a generic message
    userMessage = '😔 Lo siento, ocurrió un error inesperado. Por favor intenta de nuevo más tarde.';
  } else {
    userMessage = '😔 Lo siento, algo salió mal. Por favor intenta de nuevo.';
  }

  // Send error message to user
  try {
    await sendWhatsAppMessage(whatsappNumber, userMessage);
  } catch (sendError) {
    logger.error('Failed to send error message to WhatsApp user:', {
      whatsappNumber,
      originalError: error,
      sendError,
      context
    });
  }
}

/**
 * Wraps a WhatsApp handler function to automatically handle errors
 * Usage: wrapWhatsAppHandler(async (from, message) => { ... })
 */
export function wrapWhatsAppHandler<T extends any[], R>(
  handler: (...args: T) => Promise<R>,
  operation: string
): (...args: T) => Promise<R | void> {
  return async (...args: T): Promise<R | void> => {
    try {
      return await handler(...args);
    } catch (error) {
      // Assume first argument is the WhatsApp number (from)
      const whatsappNumber = args[0] as string;
      await handleWhatsAppError(error, whatsappNumber, {
        operation,
        userId: whatsappNumber
      });
    }
  };
}

================
File: backend/src/dto/address/address.dto.ts
================
import { IsNotEmpty, IsString, IsNumber, IsOptional, IsBoolean } from 'class-validator';

export class AddressDto {
  @IsNotEmpty({ message: 'El nombre de la dirección es requerido' })
  @IsString()
  name!: string;

  @IsNotEmpty({ message: 'La calle es requerida' })
  @IsString()
  street!: string;

  @IsNotEmpty({ message: 'El número es requerido' })
  @IsString()
  number!: string;

  @IsOptional()
  @IsString()
  interiorNumber?: string;

  @IsOptional()
  @IsString()
  neighborhood?: string;

  @IsNotEmpty({ message: 'La ciudad es requerida' })
  @IsString()
  city!: string;

  @IsNotEmpty({ message: 'El estado es requerido' })
  @IsString()
  state!: string;

  @IsOptional()
  @IsString()
  zipCode?: string;

  @IsNotEmpty({ message: 'El país es requerido' })
  @IsString()
  country!: string;

  @IsNotEmpty({ message: 'La latitud es requerida' })
  @IsNumber()
  latitude!: number;

  @IsNotEmpty({ message: 'La longitud es requerida' })
  @IsNumber()
  longitude!: number;

  @IsOptional()
  @IsString()
  deliveryInstructions?: string;

  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;
}

================
File: backend/src/dto/address/delete-address.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class DeleteAddressDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;

  @IsNotEmpty({ message: 'otp is required' })
  @IsString({ message: 'otp must be a string' })
  otp!: string;
}

================
File: backend/src/dto/address/index.ts
================
// Address DTOs
export * from './address.dto';
export * from './create-address.dto';
export * from './update-address.dto';
export * from './delete-address.dto';
export * from './get-addresses-query.dto';
export * from './set-default-address.dto';
export * from './send-address-selection.dto';
export * from './update-address-selection.dto';

================
File: backend/src/dto/address/send-address-selection.dto.ts
================
import { IsNotEmpty, IsString, IsOptional } from 'class-validator';

export class SendAddressSelectionDto {
  @IsNotEmpty({ message: 'customerId is required' })
  @IsString({ message: 'customerId must be a string' })
  customerId!: string;

  @IsOptional()
  @IsString({ message: 'preOrderId must be a string' })
  preOrderId?: string;
}

================
File: backend/src/dto/address/set-default-address.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class SetDefaultAddressDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;

  @IsNotEmpty({ message: 'otp is required' })
  @IsString({ message: 'otp must be a string' })
  otp!: string;
}

================
File: backend/src/dto/address/update-address-selection.dto.ts
================
import { IsNotEmpty, IsString, IsInt } from 'class-validator';
import { Type } from 'class-transformer';

export class UpdateAddressSelectionDto {
  @IsNotEmpty({ message: 'preOrderId is required' })
  @Type(() => Number)
  @IsInt({ message: 'preOrderId must be an integer' })
  preOrderId!: number;

  @IsNotEmpty({ message: 'addressId is required' })
  @IsString({ message: 'addressId must be a string' })
  addressId!: string;

  @IsNotEmpty({ message: 'customerId is required' })
  @IsString({ message: 'customerId must be a string' })
  customerId!: string;
}

================
File: backend/src/dto/address/update-address.dto.ts
================
import { IsOptional, IsString, IsNumber, IsBoolean } from 'class-validator';

export class UpdateAddressDto {
  @IsOptional()
  @IsString({ message: 'name must be a string' })
  name?: string;

  @IsOptional()
  @IsString({ message: 'street must be a string' })
  street?: string;

  @IsOptional()
  @IsString({ message: 'number must be a string' })
  number?: string;

  @IsOptional()
  @IsString({ message: 'interiorNumber must be a string' })
  interiorNumber?: string;

  @IsOptional()
  @IsString({ message: 'neighborhood must be a string' })
  neighborhood?: string;

  @IsOptional()
  @IsString({ message: 'city must be a string' })
  city?: string;

  @IsOptional()
  @IsString({ message: 'state must be a string' })
  state?: string;

  @IsOptional()
  @IsString({ message: 'zipCode must be a string' })
  zipCode?: string;

  @IsOptional()
  @IsString({ message: 'country must be a string' })
  country?: string;

  @IsOptional()
  @IsNumber({}, { message: 'latitude must be a number' })
  latitude?: number;

  @IsOptional()
  @IsNumber({}, { message: 'longitude must be a number' })
  longitude?: number;

  @IsOptional()
  @IsString({ message: 'deliveryInstructions must be a string' })
  deliveryInstructions?: string;

  @IsOptional()
  @IsBoolean({ message: 'isDefault must be a boolean' })
  isDefault?: boolean;
}

================
File: backend/src/dto/auth/index.ts
================
// Auth/OTP DTOs
export * from './verify-otp.dto';
export * from './invalidate-otp.dto';

================
File: backend/src/dto/auth/invalidate-otp.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class InvalidateOtpDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;
}

================
File: backend/src/dto/auth/verify-otp.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class VerifyOtpDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;

  @IsNotEmpty({ message: 'otp is required' })
  @IsString({ message: 'otp must be a string' })
  otp!: string;
}

================
File: backend/src/dto/customer/index.ts
================
// Customer DTOs
export * from './update-customer-name.dto';

================
File: backend/src/dto/customer/update-customer-name.dto.ts
================
import { IsString, IsNotEmpty, MaxLength, Matches } from 'class-validator';

export class UpdateCustomerNameDto {
  @IsString()
  @IsNotEmpty({ message: 'El nombre es requerido' })
  @MaxLength(100, { message: 'El nombre no puede tener más de 100 caracteres' })
  @Matches(/^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s]+$/, {
    message: 'El nombre solo puede contener letras y espacios'
  })
  firstName!: string;

  @IsString()
  @IsNotEmpty({ message: 'El apellido es requerido' })
  @MaxLength(100, { message: 'El apellido no puede tener más de 100 caracteres' })
  @Matches(/^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s]+$/, {
    message: 'El apellido solo puede contener letras y espacios'
  })
  lastName!: string;

  @IsString()
  @IsNotEmpty()
  otp!: string;

  @IsString()
  @IsNotEmpty()
  whatsappPhoneNumber!: string;
}

================
File: backend/src/dto/index.ts
================
/**
 * Central export for all DTOs
 * Organized by business domain
 */

// Address-related DTOs
export * from './address';

// Auth/OTP-related DTOs
export * from './auth';

// Customer-related DTOs
export * from './customer';

// Order-related DTOs
export * from './order';

// WhatsApp messaging DTOs
export * from './whatsapp';

================
File: backend/src/dto/order/create-order.dto.ts
================
import {
  IsString,
  IsArray,
  IsOptional,
  IsDateString,
  ValidateNested,
  IsNotEmpty,
  IsNumber,
  IsEnum,
} from "class-validator";
import { Type } from "class-transformer";
import { OrderType } from '@prisma/client';

class OrderItemDto {
  @IsString()
  productId: string;

  @IsOptional()
  @IsString()
  productVariantId?: string;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => SelectedPizzaCustomizationDto)
  selectedPizzaCustomizations: SelectedPizzaCustomizationDto[];

  @IsArray()
  @IsString({ each: true })
  selectedModifiers: string[]; // Array of modifier IDs

  @IsNotEmpty()
  quantity: number;

  @IsOptional()
  @IsString()
  comments?: string;
}

class SelectedPizzaCustomizationDto {
  @IsString()
  pizzaCustomizationId: string;

  @IsString()
  half: string;

  @IsString()
  action: string;
}

class DeliveryInfoDto {
  @IsString()
  @IsOptional()
  id?: string; // UUID now

  @IsString()
  @IsOptional()
  fullAddress?: string;

  @IsString()
  @IsOptional()
  street?: string;

  @IsString()
  @IsOptional()
  number?: string;

  @IsString()
  @IsOptional()
  interiorNumber?: string;

  @IsString()
  @IsOptional()
  neighborhood?: string;

  @IsString()
  @IsOptional()
  zipCode?: string;

  @IsString()
  @IsOptional()
  city?: string;

  @IsString()
  @IsOptional()
  state?: string;

  @IsString()
  @IsOptional()
  country?: string;

  @IsNumber()
  @IsOptional()
  latitude?: number;

  @IsNumber()
  @IsOptional()
  longitude?: number;

  @IsString()
  @IsOptional()
  recipientName?: string;

  @IsString()
  @IsOptional()
  recipientPhone?: string;

  @IsString()
  @IsOptional()
  deliveryInstructions?: string;

  @IsNumber()
  @IsOptional()
  preOrderId?: number;

  @IsString()
  @IsOptional()
  orderId?: string;
}

export class CreateOrderDto {
  @IsEnum(OrderType, { message: 'orderType must be a valid OrderType enum value' })
  orderType: OrderType;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => OrderItemDto)
  orderItems: OrderItemDto[];

  @IsOptional()
  @ValidateNested()
  @Type(() => DeliveryInfoDto)
  deliveryInfo?: DeliveryInfoDto;

  @IsString()
  whatsappPhoneNumber: string;

  @IsOptional()
  @IsDateString()
  scheduledAt?: string;

  @IsOptional()
  @IsNumber()
  subtotal?: number;

  @IsOptional()
  @IsNumber()
  total?: number;
}

================
File: backend/src/dto/order/index.ts
================
// Order DTOs
export * from './create-order.dto';
export * from './process-audio-order.dto';

================
File: backend/src/dto/order/process-audio-order.dto.ts
================
import { IsString, IsNotEmpty } from 'class-validator';

export class ProcessAudioOrderDto {
  @IsString()
  @IsNotEmpty()
  transcription: string;
}

================
File: backend/src/dto/whatsapp/index.ts
================
// WhatsApp DTOs
export * from './send-message.dto';

================
File: backend/src/lib/prisma.ts
================
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient();

// Handle cleanup on process termination
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});

================
File: backend/src/queues/types.ts
================
export interface WhatsAppMessageJob {
  id: string;
  from: string;
  type: string;
  timestamp: string;
  text?: any;
  interactive?: any;
  audio?: any;
}

================
File: backend/src/routes/webhook.ts
================
import { Router, Request, Response } from 'express';
import express from 'express';
import { WhatsAppService } from '../services/whatsapp';
import { StripeService } from '../services/payment/StripeService';
import { asyncHandler } from '../common/middlewares/errorHandler';

const router = Router();

// Webhook verification (GET)
router.get('/', asyncHandler(async (req: Request, res: Response) => {
  const result = WhatsAppService.verifyWebhook(req.query);
  if (result.verified) {
    res.status(200).send(result.challenge);
  } else {
    res.status(403).send('Forbidden');
  }
}));

// Webhook handler (POST)
router.post('/', express.raw({ type: '*/*' }), asyncHandler(async (req: Request, res: Response) => {
  // Check if it's a Stripe webhook
  const stripeSignature = req.headers['stripe-signature'];
  
  if (stripeSignature) {
    // Handle Stripe webhook
    await StripeService.handleWebhook(req, res);
  } else {
    // Handle WhatsApp webhook
    await WhatsAppService.handleWebhook(req, res);
  }
}));

export default router;

================
File: backend/src/run-workers.ts
================
import 'reflect-metadata';
import { envValidator } from './common/config/envValidator';
import logger from './common/utils/logger';
import { startMessageWorker, stopMessageWorker } from './queues/messageQueue';
import { prisma } from './lib/prisma';

async function startWorkers() {
  try {
    // Validate environment variables
    envValidator.validate();
    
    logger.info('Starting BullMQ workers...');
    
    // Initialize the message worker
    startMessageWorker();
    
    logger.info('Workers started successfully');
    
    // Graceful shutdown handlers
    const shutdown = async () => {
      logger.info('Shutting down workers...');
      
      try {
        await stopMessageWorker();
        await prisma.$disconnect();
        logger.info('Workers shut down successfully');
        process.exit(0);
      } catch (error) {
        logger.error('Error during shutdown:', error);
        process.exit(1);
      }
    };
    
    process.on('SIGINT', shutdown);
    process.on('SIGTERM', shutdown);
    
    // Keep the process alive
    process.on('uncaughtException', (error) => {
      logger.error('Uncaught exception in worker:', error);
      shutdown();
    });
    
    process.on('unhandledRejection', (reason, promise) => {
      logger.error('Unhandled rejection in worker:', { reason, promise });
      shutdown();
    });
    
  } catch (error) {
    logger.error('Failed to start workers:', error);
    process.exit(1);
  }
}

// Start the workers
startWorkers();

================
File: backend/src/services/ai/index.ts
================
export * from './GeminiService';
export * from './AgentService';
export * from './MenuSearchService';

================
File: backend/src/services/ai/prompts/generalAgent.prompt.ts
================
/**
 * General Agent prompt template
 * Handles general queries, intent detection, and routing to appropriate tools
 */
export function getGeneralAgentPrompt(menuJson: string, restaurantName: string): string {
  return `
      Eres un asistente virtual de ${restaurantName}. Tu función es ayudar a los clientes con sus consultas y pedidos.
      
      REGLAS ESTRICTAS:
      - SOLO puedes proporcionar información que está en tu contexto o usar las herramientas disponibles
      - NO inventes información sobre productos, precios, ingredientes o disponibilidad
      - NO asumas o adivines características de productos que no están en tu contexto
      - Si no tienes información específica, indica al cliente que no dispones de esa información
      - NUNCA proporciones precios individuales, solo a través de la herramienta "send_menu"
      
      1. DETECTAR INTENCIÓN:
         - Si el cliente quiere ordenar algo, usa la herramienta "prepare_order_context"
         - Si es una consulta general, responde directamente
      
      2. CONSULTAS GENERALES:
         - Menú completo con precios: usa "send_menu" 
         - Información del restaurante: usa "get_business_hours"
         - Tiempos de espera: usa "get_wait_times"
         - Actualizar dirección: usa "generate_address_update_link"
         - Instrucciones del bot: usa "send_bot_instructions"
         - Para otras consultas: responde SOLO con información disponible en tu contexto
      
      3. DETECCIÓN DE ÓRDENES:
         Cuando detectes intención de ordenar (palabras clave: quiero, pedir, ordenar, dame, tráeme, etc.):
         
         PRIMERO: Verifica el tipo de orden
         - Si el cliente NO ha especificado si es para llevar o entrega a domicilio:
           * PREGUNTA: "¿Tu pedido es para entrega a domicilio o para recoger en el restaurante?"
           * NO ejecutes "prepare_order_context" hasta tener esta información
         
         - Detecta el tipo de orden SOLO cuando el cliente lo especifique:
           * DELIVERY: "a domicilio", "envío", "traer", "mi casa", "mi dirección", "que me lo traigan"
           * TAKE_AWAY: "para llevar", "recoger", "paso por", "voy por", "lo recojo"
         
         DESPUÉS de confirmar el tipo de orden:
         - Extrae TODOS los artículos mencionados
         - Incluye cantidades si las menciona
         - USA "prepare_order_context" con el tipo de orden confirmado
         
         NUNCA asumas el tipo de orden - SIEMPRE debe ser especificado por el cliente
      
      4. ACTUALIZACIÓN DE DIRECCIÓN:
         Si el cliente quiere actualizar su dirección o agregar una nueva dirección de entrega:
         - Usa "generate_address_update_link" para generar un enlace seguro
         - NO agregues mensajes adicionales, la herramienta ya envía el mensaje interactivo
      
      5. INSTRUCCIONES DEL BOT:
         Si el cliente pregunta cómo usar el bot, cómo funciona, qué puede hacer, o necesita ayuda:
         - Usa "send_bot_instructions" para enviar las instrucciones completas
         - Detecta preguntas como: "cómo usar", "cómo funciona", "qué puedo hacer", "ayuda", "tutorial", "instrucciones"
      
      6. RESETEAR CONVERSACIÓN:
         Si el cliente quiere reiniciar la conversación o borrar el historial:
         - Usa "reset_conversation" para limpiar el contexto
         - Detecta frases como: "olvida lo anterior", "reinicia la conversación", "borra el historial", "empecemos de nuevo", "olvida todo", "reinicia el chat"
      
      LIMITACIONES Y RESTRICCIONES:
      - Solo puedes responder sobre productos que existen en el menú
      - No puedes inventar o sugerir productos que no están disponibles
      - No puedes modificar ingredientes base de los productos
      - No puedes prometer tiempos de entrega específicos fuera de los establecidos
      - No puedes ofrecer descuentos o promociones no autorizadas
      - Si el cliente pide algo que no está en el menú, debes indicarlo claramente
      
      MANEJO DE ERRORES:
      - Si no entiendes la solicitud: pide aclaración de manera amable
      - Si el producto no existe: sugiere alternativas del menú disponible
      - Si hay ambigüedad: pregunta para confirmar antes de proceder
      
      IMPORTANTE:
      - Responde siempre en español
      - Sé cordial y profesional pero mantente dentro de tus capacidades
      - Para órdenes, NO intentes mapear productos, solo extrae lo que el cliente dice
      - NUNCA proporciones precios individuales bajo ninguna circunstancia
      - Si preguntan por precios, SIEMPRE ejecuta "send_menu"
      
      ESTRUCTURA DEL MENÚ DISPONIBLE:
      ${menuJson}
      
      Esta estructura muestra TODO lo que puedes ofrecer. Si algo no está aquí, NO lo ofrezcas.
      Úsala para validar las solicitudes del cliente y sugerir alternativas válidas.
    `;
}

================
File: backend/src/services/ai/prompts/index.ts
================
/**
 * AI Agent Prompts
 * Centralized export for all agent prompt templates
 */
export { getGeneralAgentPrompt } from './generalAgent.prompt';
export { getOrderAgentPrompt } from './orderAgent.prompt';

================
File: backend/src/services/ai/tools/generalAgent.tools.ts
================
/**
 * General Agent tool definitions
 * These tools are available to the general agent for handling various customer requests
 */

export function getGeneralAgentTools(): any[] {
  return [
    {
      name: "send_menu",
      description: "Envía el menú completo al usuario cuando lo solicite",
      parameters: {
        type: "object",
        properties: {}
      }
    },
    {
      name: "get_business_hours",
      description: "Obtiene información completa del restaurante incluyendo ubicación, teléfonos y horarios",
      parameters: {
        type: "object",
        properties: {}
      }
    },
    {
      name: "get_wait_times",
      description: "Obtiene los tiempos de espera estimados para recolección y entrega a domicilio",
      parameters: {
        type: "object",
        properties: {}
      }
    },
    {
      name: "prepare_order_context",
      description: "Prepara el contexto para procesar una orden cuando el cliente quiere pedir algo",
      parameters: {
        type: "object",
        properties: {
          itemsSummary: {
            type: "string",
            description: "Lista de todos los artículos que el cliente mencionó (ej: '2 pizzas hawaianas grandes, 1 coca cola, papas fritas')"
          },
          orderType: {
            type: "string", 
            enum: ["DELIVERY", "TAKE_AWAY"],
            description: "Tipo de orden: DELIVERY (entrega a domicilio), TAKE_AWAY (para llevar/recoger)"
          }
        },
        required: ["itemsSummary", "orderType"]
      }
    },
    {
      name: "generate_address_update_link",
      description: "Genera un enlace seguro para que el cliente actualice o agregue una dirección de entrega",
      parameters: {
        type: "object",
        properties: {
          reason: {
            type: "string",
            description: "Razón por la cual el cliente quiere actualizar la dirección"
          }
        }
      }
    },
    {
      name: "send_bot_instructions",
      description: "Envía las instrucciones completas de cómo usar el bot cuando el cliente lo solicite",
      parameters: {
        type: "object",
        properties: {}
      }
    },
    {
      name: "reset_conversation",
      description: "Reinicia la conversación y borra el historial relevante cuando el cliente lo solicite",
      parameters: {
        type: "object",
        properties: {}
      }
    }
  ];
}

================
File: backend/src/services/ai/tools/handlers/mapOrderItemsHandler.ts
================
import { ToolHandler, ToolResponse } from '../types';
import { AIOrderItem, transformAIOrderItem } from '../../../../common/types';
import logger from '../../../../common/utils/logger';

/**
 * Handles the map_order_items function call
 * Transforms AI order items to consistent format for pre-order creation
 */
export const handleMapOrderItems: ToolHandler = async (args): Promise<ToolResponse> => {
  logger.debug('Processing map_order_items with args:', args);
  
  // Transform AI order items to consistent format
  const processedItems = (args.orderItems || []).map((item: AIOrderItem) => 
    transformAIOrderItem(item)
  );
  
  return {
    preprocessedContent: {
      orderItems: processedItems,
      orderType: args.orderType || 'DELIVERY',
      warnings: args.warnings ? [args.warnings] : [],
      scheduledAt: args.scheduledAt || null
    }
  };
};

================
File: backend/src/services/ai/tools/index.ts
================
/**
 * AI Agent Tools
 * Centralized export for all agent tool definitions
 */
export { getGeneralAgentTools } from './generalAgent.tools';
export { getOrderAgentTools } from './orderAgent.tools';

================
File: backend/src/services/ai/tools/toolHandlers.ts
================
import { ToolHandler } from './types';
import { handleMapOrderItems } from './handlers/mapOrderItemsHandler';
import { handleSendMenu } from './handlers/sendMenuHandler';
import { handleGetBusinessHours } from './handlers/getBusinessHoursHandler';
import { handlePrepareOrderContext } from './handlers/prepareOrderContextHandler';
import { handleGenerateAddressUpdateLink } from './handlers/generateAddressUpdateLinkHandler';
import { handleSendBotInstructions } from './handlers/sendBotInstructionsHandler';
import { handleGetWaitTimes } from './handlers/getWaitTimesHandler';
import { handleResetConversation } from './handlers/resetConversationHandler';

/**
 * Registry of all available tool handlers
 * Maps function names to their corresponding handler implementations
 */
export const toolHandlers: Record<string, ToolHandler> = {
  'map_order_items': handleMapOrderItems,
  'send_menu': handleSendMenu,
  'get_business_hours': handleGetBusinessHours,
  'prepare_order_context': handlePrepareOrderContext,
  'generate_address_update_link': handleGenerateAddressUpdateLink,
  'send_bot_instructions': handleSendBotInstructions,
  'get_wait_times': handleGetWaitTimes,
  'reset_conversation': handleResetConversation,
};

/**
 * Get a tool handler by name
 * @param name The name of the function to handle
 * @returns The handler function or undefined if not found
 */
export function getToolHandler(name: string): ToolHandler | undefined {
  return toolHandlers[name];
}

================
File: backend/src/services/ai/tools/types.ts
================
import { MessageContext } from '../../messaging/MessageContext';

/**
 * Base type for all tool handler functions
 */
export type ToolHandler = (args: any, context?: MessageContext) => Promise<any | null>;

/**
 * Response types that tool handlers can return
 */
export interface ToolResponse {
  text?: string;
  isRelevant?: boolean;
  sendToWhatsApp?: boolean;
  historyMarker?: string;
  urlButton?: {
    title: string;
    body: string;
    buttonText: string;
    url: string;
  };
  preprocessedContent?: any;
  confirmationMessage?: string;
}

================
File: backend/src/services/audio/AudioOrderService.ts
================
import { MenuSearchService } from '../ai/MenuSearchService';
import { GeminiService } from '../ai/GeminiService';
import { BusinessLogicError, ErrorCode, TechnicalError } from '../../common/services/errors';
import logger from '../../common/utils/logger';
import { ConfigService } from '../config/ConfigService';

// Types
interface PizzaCustomization {
  customizationId: string;
  half: "FULL" | "HALF_1" | "HALF_2";
  action: "ADD" | "REMOVE";
}

interface AIOrderItem {
  productId: string;
  variantId?: string;
  quantity: number;
  modifiers?: string[];
  pizzaCustomizations?: PizzaCustomization[];
}

interface DeliveryInfoData {
  fullAddress?: string;
  recipientName?: string;
  recipientPhone?: string;
}

interface ScheduledDeliveryData {
  time?: string; // HH:mm format
}

interface AudioProcessingResult {
  orderItems?: AIOrderItem[];
  orderType?: "DELIVERY" | "TAKE_AWAY" | "DINE_IN";
  deliveryInfo?: DeliveryInfoData;
  scheduledDelivery?: ScheduledDeliveryData;
  warnings?: string;
}

interface ProcessAudioParams {
  audioBuffer: Buffer;
  audioMimeType: string;
  transcription: string;
}

interface ProcessWithGeminiParams {
  audioBase64: string;
  audioMimeType: string;
  transcription: string;
  relevantMenu: string;
}

export class AudioOrderService {
  private static readonly MAX_AUDIO_SIZE = 10 * 1024 * 1024; // 10MB

  static async processAudioOrder(params: ProcessAudioParams): Promise<AudioProcessingResult> {
    try {
      logger.info('Starting audio order processing', {
        audioSize: params.audioBuffer.length,
        mimeType: params.audioMimeType
      });

      // Validate audio size
      if (params.audioBuffer.length > this.MAX_AUDIO_SIZE) {
        throw new BusinessLogicError(
          ErrorCode.FILE_TOO_LARGE,
          'El archivo de audio es demasiado grande. Máximo 10MB permitido.'
        );
      }

      // Process in parallel for better performance
      const [relevantMenuJson, audioBase64] = await Promise.all([
        MenuSearchService.getRelevantMenu(params.transcription),
        Promise.resolve(this.prepareAudioBase64(params.audioBuffer))
      ]);

      const searchResults = JSON.parse(relevantMenuJson);
      // Use empty array if no products found - we can still extract delivery info
      const relevantMenu = searchResults?.length > 0 ? relevantMenuJson : '[]';
      
      // Debug logging
      logger.debug('Audio processing debug info', {
        transcription: params.transcription,
        transcriptionLength: params.transcription.length,
        relevantMenuProductCount: searchResults?.length || 0,
        relevantMenu: relevantMenu
      });

      const extractedData = await this.processWithGemini({
        audioBase64,
        audioMimeType: params.audioMimeType,
        transcription: params.transcription,
        relevantMenu
      });

      logger.info('Audio order processing completed', {
        hasOrderItems: !!extractedData.orderItems?.length,
        orderType: extractedData.orderType,
        hasDeliveryInfo: !!extractedData.deliveryInfo,
        hasScheduledDelivery: !!extractedData.scheduledDelivery
      });

      return extractedData;
    } catch (error) {
      logger.error('Error processing audio order', { error });
      throw error;
    }
  }

  private static prepareAudioBase64(audioBuffer: Buffer): string {
    return audioBuffer.toString('base64');
  }

  private static async processWithGemini(params: ProcessWithGeminiParams): Promise<AudioProcessingResult> {
    const config = ConfigService.getConfig();
    const systemPrompt = this.buildAudioOrderPrompt(config.restaurantName);
    
    const orderContext = {
      transcription: params.transcription,
      relevantMenu: params.relevantMenu
    };

    // Debug log the context being sent to Gemini
    logger.debug('Gemini request context', {
      transcriptionPreview: params.transcription.substring(0, 100) + '...',
      relevantMenuPreview: params.relevantMenu.substring(0, 200) + '...',
      fullContextSize: JSON.stringify(orderContext).length
    });

    const userPrompt = `Analiza el audio del pedido. La transcripción puede tener errores, prioriza el audio.

Contexto:
${JSON.stringify(orderContext, null, 2)}

Solo extrae información mencionada EXPLÍCITAMENTE. No inventes datos.`;

    const contents = [{
      role: "user" as const,
      parts: [
        { text: userPrompt },
        { 
          inlineData: { 
            mimeType: params.audioMimeType, 
            data: params.audioBase64 
          } 
        }
      ]
    }];

    const toolDefinition = this.buildExtractOrderDataTool();

    const response = await GeminiService.generateContentWithHistory(
      contents,
      systemPrompt,
      [toolDefinition],
      {
        functionCallingConfig: {
          mode: 'ANY',
          allowedFunctionNames: ['extract_order_data']
        }
      }
    );

    const functionCall = response.candidates?.[0]?.content?.parts?.[0]?.functionCall;
    
    if (!functionCall || functionCall.name !== 'extract_order_data') {
      logger.error('Gemini response error - no function call', {
        response: JSON.stringify(response, null, 2)
      });
      throw new TechnicalError(
        ErrorCode.AI_PROCESSING_ERROR,
        'No se pudo procesar el audio'
      );
    }

    // Debug log the extracted data
    logger.debug('Gemini extracted data', {
      functionCallArgs: functionCall.args,
      hasOrderItems: !!(functionCall.args as any).orderItems?.length,
      orderType: (functionCall.args as any).orderType,
      hasDeliveryInfo: !!(functionCall.args as any).deliveryInfo,
      hasScheduledDelivery: !!(functionCall.args as any).scheduledDelivery
    });

    return functionCall.args as AudioProcessingResult;
  }

  private static buildExtractOrderDataTool() {
    return {
      name: 'extract_order_data',
      description: 'Extrae información del audio del pedido',
      parameters: {
        type: 'object',
        properties: {
          orderType: {
            type: 'string',
            enum: ['DELIVERY', 'TAKE_AWAY', 'DINE_IN'],
            description: 'Tipo de orden inferido del contexto'
          },
          orderItems: {
            type: 'array',
            description: 'Productos del menú mencionados',
            items: {
              type: 'object',
              properties: {
                productId: { type: 'string' },
                variantId: { type: 'string' },
                quantity: { type: 'number' },
                modifiers: {
                  type: 'array',
                  items: { type: 'string' }
                },
                pizzaCustomizations: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      customizationId: { type: 'string' },
                      half: { type: 'string', enum: ['FULL', 'HALF_1', 'HALF_2'] },
                      action: { type: 'string', enum: ['ADD', 'REMOVE'] }
                    },
                    required: ['customizationId', 'half', 'action']
                  }
                }
              },
              required: ['productId', 'quantity']
            }
          },
          deliveryInfo: {
            type: 'object',
            description: 'Información de entrega',
            properties: {
              fullAddress: { type: 'string' },
              recipientName: { type: 'string' },
              recipientPhone: { type: 'string' }
            }
          },
          scheduledDelivery: {
            type: 'object',
            description: 'Hora de entrega programada',
            properties: {
              time: { type: 'string', description: 'Formato HH:mm' }
            }
          },
          warnings: {
            type: 'string',
            description: 'Productos no identificados o información confusa'
          }
        }
      }
    };
  }

  private static buildAudioOrderPrompt(restaurantName: string): string {
    return `Eres un asistente de ${restaurantName} especializado en procesar pedidos de audio.

REGLAS:
1. Extrae SOLO información mencionada explícitamente en el audio
2. NO inventes datos que no se mencionen
3. Usa solo productos de relevantMenu
4. Si hasVariants: true, especifica variantId
5. Convierte horarios a formato 24h (ej: "3pm" → "15:00")
6. NO extraigas fechas, solo horas

TIPO DE ORDEN (orderType):
- DELIVERY: Si mencionan dirección de entrega o domicilio
- TAKE_AWAY: Si mencionan recoger, pasar por, o nombre para recolección sin dirección
- DINE_IN: Si no mencionan ni dirección ni recolección (por defecto)

EJEMPLOS:
- "Pizza hawaiana grande" → orderType: "DINE_IN", orderItems con producto
- "Entregar en Juárez 123" → orderType: "DELIVERY", deliveryInfo.fullAddress
- "Para recoger a nombre de Juan" → orderType: "TAKE_AWAY", deliveryInfo.recipientName
- "Mi teléfono 555-1234" → deliveryInfo.recipientPhone
- "A las 3 de la tarde" → scheduledDelivery.time: "15:00"`;
  }
}

================
File: backend/src/services/messaging/middlewares/AddressRequiredMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { sendMessageWithUrlButton } from '../../whatsapp';
import { OTPService } from '../../security/OTPService';
import { env } from '../../../common/config/envValidator';
import logger from '../../../common/utils/logger';

export class AddressRequiredMiddleware implements MessageMiddleware {
  name = 'AddressRequiredMiddleware';

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      const hasNoAddress = context.get('hasNoAddress');
      const customerId = context.message.from;
      
      // Si el cliente no tiene dirección, bloquear la conversación
      if (hasNoAddress) {
        logger.info(`Blocking conversation for customer ${customerId} - no address on file`);
        
        // Generar OTP con expiración extendida para registro de dirección
        const otp = OTPService.generateOTP();
        await OTPService.storeOTP(customerId, otp, true); // true = address registration
        
        // Crear enlace de registro - directo al formulario para primera vez
        const registrationLink = `${env.FRONTEND_BASE_URL}/address-registration/${customerId}?otp=${otp}&viewMode=form`;
        
        // Enviar mensaje con botón URL
        await sendMessageWithUrlButton(
          customerId,
          "🏠 ¡Bienvenido!",
          "Para poder tomar tu pedido, necesitamos que registres tu dirección de entrega.\n\nEs muy fácil y rápido:\n• Haz clic en el botón de abajo\n• Completa tu información\n• ¡Listo para ordenar!",
          "Registrar Dirección",
          registrationLink
        );
        
        // Detener el procesamiento - no procesar ningún mensaje hasta que tenga dirección
        context.stop();
        return context;
      }
      
      return context;
    } catch (error) {
      logger.error('Error in AddressRequiredMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/middlewares/RateLimitMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { sendWhatsAppMessage } from '../../whatsapp';
import { RATE_LIMIT_MESSAGE } from '../../../common/config/predefinedMessages';
import logger from '../../../common/utils/logger';
import { env } from '../../../common/config/envValidator';
import { RedisService } from '../../redis/RedisService';

export class RateLimitMiddleware implements MessageMiddleware {
  name = 'RateLimitMiddleware';
  
  private readonly MAX_MESSAGES = parseInt(env.RATE_LIMIT_MAX_MESSAGES);
  private readonly WINDOW_SECONDS = parseInt(env.RATE_LIMIT_TIME_WINDOW_MINUTES) * 60;

  async process(context: MessageContext): Promise<MessageContext> {
    const redisService = RedisService.getInstance();
    
    try {
      // Try to use Redis for rate limiting
      const redisClient = await this.getRedisClient(redisService);
      
      if (redisClient) {
        return await this.processWithRedis(context, redisClient);
      } else {
        // Redis not available - log warning and continue processing
        logger.warn('Redis not available for rate limiting. Allowing message through.');
        return context;
      }
    } catch (error) {
      logger.error('Error in RateLimitMiddleware:', error);
      // On error, allow the message through to avoid blocking legitimate users
      return context;
    }
  }

  private async getRedisClient(redisService: RedisService): Promise<any | null> {
    await redisService.connect();
    return redisService.getClient();
  }

  private async processWithRedis(context: MessageContext, redisClient: any): Promise<MessageContext> {
    const key = `rate-limit:${context.message.from}`;
    
    try {
      // Increment the counter atomically
      const currentCount = await redisClient.incr(key);
      
      // If this is the first message, set the expiration
      if (currentCount === 1) {
        await redisClient.expire(key, this.WINDOW_SECONDS);
      }
      
      // Check if rate limit exceeded
      if (currentCount > this.MAX_MESSAGES) {
        logger.warn(`Rate limit exceeded for customer ${context.message.from} (${currentCount}/${this.MAX_MESSAGES})`);
        
        // Only send the warning message once when limit is first exceeded
        if (currentCount === this.MAX_MESSAGES + 1) {
          await sendWhatsAppMessage(context.message.from, RATE_LIMIT_MESSAGE);
        }
        
        context.stop();
        return context;
      }
      
      logger.debug(`Rate limit check passed for ${context.message.from}: ${currentCount}/${this.MAX_MESSAGES}`);
      return context;
      
    } catch (error) {
      logger.error(`Redis error in rate limiting for ${context.message.from}:`, error);
      // On Redis error, allow the message through
      return context;
    }
  }
}

================
File: backend/src/services/messaging/middlewares/RestaurantHoursMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { RestaurantService } from '../../restaurant/RestaurantService';
import { sendWhatsAppMessage } from '../../whatsapp';
import { RESTAURANT_CLOSED_MESSAGE } from '../../../common/config/predefinedMessages';
import { getFormattedBusinessHours } from '../../../common/utils/timeUtils';
import logger from '../../../common/utils/logger';
import { getCurrentMexicoTime } from '../../../common/utils/timeUtils';

export class RestaurantHoursMiddleware implements MessageMiddleware {
  name = 'RestaurantHoursMiddleware';

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      // Get restaurant configuration
      const config = await RestaurantService.getConfig();
      
      // Check if restaurant is accepting orders
      if (!config.acceptingOrders) {
        const formattedHours = await getFormattedBusinessHours();
        const closedMessage = RESTAURANT_CLOSED_MESSAGE(formattedHours);
        await sendWhatsAppMessage(context.message.from, closedMessage);
        context.stop();
        return context;
      }

      // Get current restaurant time
      const currentTime = await getCurrentMexicoTime();
      const dayOfWeek = currentTime.day();
      const currentMinutes = currentTime.hours() * 60 + currentTime.minutes();

      // Get business hours for today
      const businessHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
      
      if (!businessHours || businessHours.isClosed || !businessHours.openingTime || !businessHours.closingTime) {
        logger.info(`Restaurant is closed on day ${dayOfWeek}`);
        const formattedHours = await getFormattedBusinessHours();
        const closedMessage = RESTAURANT_CLOSED_MESSAGE(formattedHours);
        await sendWhatsAppMessage(context.message.from, closedMessage);
        context.stop();
        return context;
      }

      // Parse opening and closing times
      const [openHour, openMinute] = businessHours.openingTime.split(':').map(Number);
      const [closeHour, closeMinute] = businessHours.closingTime.split(':').map(Number);
      
      const openTime = openHour * 60 + openMinute;
      const closeTime = closeHour * 60 + closeMinute;
      
      // Apply grace periods
      const effectiveOpenTime = openTime + (config.openingGracePeriod || 0);
      const effectiveCloseTime = closeTime - (config.closingGracePeriod || 0);

      // Check if current time is within operating hours (with grace periods)
      if (currentMinutes < effectiveOpenTime || currentMinutes > effectiveCloseTime) {
        logger.info(`Restaurant hours check failed: current=${currentMinutes}, open=${effectiveOpenTime}, close=${effectiveCloseTime}`);
        
        // Check if we're in a grace period
        let message: string;
        if (currentMinutes >= openTime && currentMinutes < effectiveOpenTime) {
          // In opening grace period
          const minutesUntilOpen = effectiveOpenTime - currentMinutes;
          message = `⏰ ¡Buenos días! Aunque nuestro restaurante ya abrió, todavía no estamos recibiendo pedidos.

🕐 Comenzaremos a tomar pedidos en ${minutesUntilOpen} minutos.

📍 *Horario de hoy:*
Apertura: ${businessHours.openingTime}
Inicio de pedidos: ${Math.floor(effectiveOpenTime / 60)}:${(effectiveOpenTime % 60).toString().padStart(2, '0')}
Cierre de pedidos: ${Math.floor(effectiveCloseTime / 60)}:${(effectiveCloseTime % 60).toString().padStart(2, '0')}
Cierre: ${businessHours.closingTime}

¡Gracias por tu paciencia! 🙏`;
        } else if (currentMinutes > effectiveCloseTime && currentMinutes <= closeTime) {
          // In closing grace period
          message = `⏰ Lo sentimos, ya no estamos recibiendo nuevos pedidos por hoy.

🕐 Dejamos de tomar pedidos ${config.closingGracePeriod} minutos antes del cierre para garantizar la calidad del servicio.

📍 *Horario de hoy:*
Último pedido: ${Math.floor(effectiveCloseTime / 60)}:${(effectiveCloseTime % 60).toString().padStart(2, '0')}
Cierre: ${businessHours.closingTime}

¡Te esperamos mañana! 😊`;
        } else {
          // Outside business hours completely
          const formattedHours = await getFormattedBusinessHours();
          const closedMessage = RESTAURANT_CLOSED_MESSAGE(formattedHours);
          message = closedMessage;
        }
        
        await sendWhatsAppMessage(context.message.from, message);
        context.stop();
        return context;
      }

      // Restaurant is open, continue processing
      return context;
    } catch (error) {
      logger.error('Error in RestaurantHoursMiddleware:', error);
      // In case of error, allow message to continue (fail open)
      return context;
    }
  }
}

================
File: backend/src/services/messaging/strategies/AudioMessageStrategy.ts
================
import { MessageStrategy } from './MessageStrategy';
import { MessageContext } from '../MessageContext';
import { GeminiService } from '../../ai';
import { sendWhatsAppMessage, getWhatsAppMediaUrl } from '../../whatsapp';
import { AUDIO_TRANSCRIPTION_ERROR } from '../../../common/config/predefinedMessages';
import { TextProcessingService } from '../TextProcessingService';
import logger from '../../../common/utils/logger';
import { env } from '../../../common/config/envValidator';
import axios from 'axios';
import { ValidationError, ErrorCode } from '../../../common/services/errors';

export class AudioMessageStrategy extends MessageStrategy {
  name = 'AudioMessageStrategy';
  
  canHandle(context: MessageContext): boolean {
    return context.message.type === 'audio';
  }
  
  async execute(context: MessageContext): Promise<void> {
    if (!context.message.audio) return;
    
    try {
      logger.info(`Processing audio message from ${context.message.from}`);
      
      // Notificar al usuario que estamos procesando
      await sendWhatsAppMessage(
        context.message.from,
        "🎤 Recibí tu mensaje de voz. Dame un momento mientras lo proceso..."
      );
      
      // Obtener URL del audio
      const audioUrl = await getWhatsAppMediaUrl(context.message.audio.id);
      if (!audioUrl) {
        throw new ValidationError(
          ErrorCode.WHATSAPP_API_ERROR,
          'Could not get audio URL',
          { metadata: { audioId: context.message.audio.id } }
        );
      }
      
      // Descargar audio
      const audioResponse = await axios.get(audioUrl, {
        responseType: 'arraybuffer',
        headers: {
          'Authorization': `Bearer ${env.WHATSAPP_ACCESS_TOKEN}`
        },
        timeout: 30000
      });
      
      // Determinar tipo MIME
      const mimeType = context.message.audio.mime_type || 'audio/ogg';
      const validMimeTypes = ['audio/ogg', 'audio/mpeg', 'audio/mp4', 'audio/wav'];
      
      if (!validMimeTypes.includes(mimeType)) {
        throw new ValidationError(
          ErrorCode.TRANSCRIPTION_ERROR,
          `Unsupported audio format: ${mimeType}`,
          { metadata: { mimeType, validMimeTypes } }
        );
      }
      
      // Convertir a base64
      const audioBase64 = Buffer.from(audioResponse.data).toString('base64');
      
      // Transcribir con el servicio centralizado de Gemini
      const transcription = await GeminiService.transcribeAudio(audioBase64, mimeType);
      
      logger.info(`Audio transcribed successfully: "${transcription}"`);
      
      // Notificar al usuario de la transcripción
      await sendWhatsAppMessage(
        context.message.from,
        `🎤 Entendí: "${transcription}"\n\nProcesando tu mensaje...`
      );
      
      // Process the transcribed text directly using the shared service
      await TextProcessingService.processTextMessage(transcription, context);
      
      // Stop the pipeline here since we've already processed the message
      context.stop();
      
    } catch (error) {
      logger.error('Error processing audio message:', error);
      await sendWhatsAppMessage(context.message.from, AUDIO_TRANSCRIPTION_ERROR);
      context.stop();
    }
  }
}

================
File: backend/src/services/redis/RedisService.ts
================
import Redis from 'ioredis';
import logger from '../../common/utils/logger';
import { env } from '../../common/config/envValidator';

export class RedisService {
  private static instance: RedisService;
  private client: Redis | null = null;
  private isConnected = false;

  private constructor() {}

  static getInstance(): RedisService {
    if (!RedisService.instance) {
      RedisService.instance = new RedisService();
    }
    return RedisService.instance;
  }

  async connect(): Promise<void> {
    if (this.isConnected && this.client) {
      return;
    }

    try {
      this.client = new Redis({
        host: env.REDIS_HOST || 'localhost',
        port: parseInt(env.REDIS_PORT || '6379', 10),
        password: env.REDIS_PASSWORD,
        retryStrategy: (times) => {
          const delay = Math.min(times * 50, 2000);
          return delay;
        },
        maxRetriesPerRequest: 3,
      });

      this.client.on('connect', () => {
        logger.info('Redis connected successfully');
        this.isConnected = true;
      });

      this.client.on('error', (error) => {
        logger.error('Redis connection error:', error);
        this.isConnected = false;
      });

      this.client.on('close', () => {
        logger.warn('Redis connection closed');
        this.isConnected = false;
      });

      await this.client.ping();
    } catch (error) {
      logger.error('Failed to connect to Redis:', error);
      // Don't throw - allow app to work without Redis (fallback to memory)
      this.client = null;
      this.isConnected = false;
    }
  }

  getClient(): Redis | null {
    return this.client;
  }

  isAvailable(): boolean {
    return this.isConnected && this.client !== null;
  }

  async set(key: string, value: string, expiresInSeconds?: number): Promise<boolean> {
    if (!this.isAvailable() || !this.client) {
      return false;
    }

    try {
      if (expiresInSeconds) {
        await this.client.set(key, value, 'EX', expiresInSeconds);
      } else {
        await this.client.set(key, value);
      }
      return true;
    } catch (error) {
      logger.error('Redis SET error:', error);
      return false;
    }
  }

  async get(key: string): Promise<string | null> {
    if (!this.isAvailable() || !this.client) {
      return null;
    }

    try {
      return await this.client.get(key);
    } catch (error) {
      logger.error('Redis GET error:', error);
      return null;
    }
  }

  async del(key: string): Promise<boolean> {
    if (!this.isAvailable() || !this.client) {
      return false;
    }

    try {
      await this.client.del(key);
      return true;
    } catch (error) {
      logger.error('Redis DEL error:', error);
      return false;
    }
  }

  async exists(key: string): Promise<boolean> {
    if (!this.isAvailable() || !this.client) {
      return false;
    }

    try {
      const result = await this.client.exists(key);
      return result === 1;
    } catch (error) {
      logger.error('Redis EXISTS error:', error);
      return false;
    }
  }

  async keys(pattern: string): Promise<string[]> {
    if (!this.isAvailable() || !this.client) {
      return [];
    }

    try {
      return await this.client.keys(pattern);
    } catch (error) {
      logger.error('Redis KEYS error:', error);
      return [];
    }
  }

  async setJSON(key: string, value: any, expiresInSeconds?: number): Promise<boolean> {
    try {
      const jsonString = JSON.stringify(value);
      return await this.set(key, jsonString, expiresInSeconds);
    } catch (error) {
      logger.error('Redis setJSON error:', error);
      return false;
    }
  }

  async getJSON<T>(key: string): Promise<T | null> {
    try {
      const value = await this.get(key);
      if (!value) return null;
      return JSON.parse(value) as T;
    } catch (error) {
      logger.error('Redis getJSON error:', error);
      return null;
    }
  }

  async disconnect(): Promise<void> {
    if (this.client) {
      await this.client.quit();
      this.client = null;
      this.isConnected = false;
      logger.info('Redis disconnected');
    }
  }
}

export const redisService = RedisService.getInstance();

================
File: backend/src/services/restaurant/RestaurantService.ts
================
import { prisma } from '../../lib/prisma';
import { RestaurantConfig, BusinessHours } from '../../common/types';
import logger from '../../common/utils/logger';
import { BusinessLogicError, ErrorCode } from '../../common/services/errors';
import { redisService } from '../redis/RedisService';

/**
 * Service for managing restaurant configuration and business hours
 */
export class RestaurantService {
  // Redis cache keys
  private static readonly REDIS_CONFIG_KEY = 'restaurant:config';
  private static readonly REDIS_BUSINESS_HOURS_KEY = 'restaurant:business_hours';
  private static readonly CACHE_TTL = 300; // 5 minutes cache
  
  // Memory cache fallback
  private static memoryConfigCache: RestaurantConfig | null = null;
  private static memoryBusinessHoursCache: BusinessHours[] | null = null;

  /**
   * Get restaurant configuration (with caching)
   */
  static async getConfig(): Promise<RestaurantConfig> {
    try {
      // Try Redis cache first
      if (redisService.isAvailable()) {
        const cached = await redisService.getJSON<RestaurantConfig>(this.REDIS_CONFIG_KEY);
        if (cached) {
          logger.debug('Restaurant config retrieved from Redis cache');
          return cached;
        }
      }
      
      // Try memory cache
      if (this.memoryConfigCache) {
        logger.debug('Restaurant config retrieved from memory cache');
        return this.memoryConfigCache;
      }

      // Get or create config from database
      let config = await prisma.restaurantConfig.findFirst();
      
      if (!config) {
        config = await prisma.restaurantConfig.create({
          data: {
            acceptingOrders: true,
            estimatedPickupTime: 20,
            estimatedDeliveryTime: 40
          }
        });
        logger.info('Created default restaurant configuration');
      }

      // Cache in Redis if available
      if (redisService.isAvailable()) {
        await redisService.setJSON(this.REDIS_CONFIG_KEY, config, this.CACHE_TTL);
      }
      
      // Cache in memory
      this.memoryConfigCache = config;
      return config;
    } catch (error) {
      logger.error('Error getting restaurant config:', error);
      // Return default config if error
      return {
        id: 1,
        acceptingOrders: true,
        estimatedPickupTime: 20,
        estimatedDeliveryTime: 40
      } as RestaurantConfig;
    }
  }

  /**
   * Update restaurant configuration
   */
  static async updateConfig(data: Partial<RestaurantConfig>): Promise<RestaurantConfig> {
    try {
      const config = await prisma.restaurantConfig.findFirst();
      
      if (!config) {
        throw new BusinessLogicError(
          ErrorCode.ORDER_NOT_FOUND,
          'Restaurant configuration not found'
        );
      }

      const { id, ...updateData } = data;
      const updated = await prisma.restaurantConfig.update({
        where: { id: config.id },
        data: updateData as any
      });

      // Clear caches
      await this.clearCache();
      
      // Clear timezone cache if timezone was updated
      if (data.timeZone) {
        const { clearTimeZoneCache } = await import('../../common/utils/timeUtils');
        clearTimeZoneCache();
      }

      logger.info('Restaurant configuration updated:', data);
      return updated;
    } catch (error) {
      logger.error('Error updating restaurant config:', error);
      throw error;
    }
  }

  /**
   * Toggle accepting orders
   */
  static async toggleAcceptingOrders(accepting: boolean): Promise<RestaurantConfig> {
    return this.updateConfig({ acceptingOrders: accepting });
  }

  /**
   * Get business hours for a specific day
   */
  static async getBusinessHoursForDay(dayOfWeek: number): Promise<BusinessHours | null> {
    try {
      const config = await this.getConfig();
      
      const businessHours = await prisma.businessHours.findUnique({
        where: {
          restaurantConfigId_dayOfWeek: {
            restaurantConfigId: config.id,
            dayOfWeek: dayOfWeek
          }
        }
      });

      return businessHours;
    } catch (error) {
      logger.error(`Error getting business hours for day ${dayOfWeek}:`, error);
      return null;
    }
  }

  /**
   * Get all business hours
   */
  static async getAllBusinessHours(): Promise<BusinessHours[]> {
    try {
      // Try Redis cache first
      if (redisService.isAvailable()) {
        const cached = await redisService.getJSON<BusinessHours[]>(this.REDIS_BUSINESS_HOURS_KEY);
        if (cached) {
          logger.debug('Business hours retrieved from Redis cache');
          return cached;
        }
      }
      
      // Try memory cache
      if (this.memoryBusinessHoursCache) {
        logger.debug('Business hours retrieved from memory cache');
        return this.memoryBusinessHoursCache;
      }

      const config = await this.getConfig();
      const businessHours = await prisma.businessHours.findMany({
        where: { restaurantConfigId: config.id },
        orderBy: { dayOfWeek: 'asc' }
      });

      // Cache in Redis if available
      if (redisService.isAvailable()) {
        await redisService.setJSON(this.REDIS_BUSINESS_HOURS_KEY, businessHours, this.CACHE_TTL);
      }
      
      // Cache in memory
      this.memoryBusinessHoursCache = businessHours;
      return businessHours;
    } catch (error) {
      logger.error('Error getting all business hours:', error);
      return [];
    }
  }

  /**
   * Update business hours for a specific day
   */
  static async updateBusinessHours(
    dayOfWeek: number, 
    data: { openingTime?: string; closingTime?: string; isClosed?: boolean }
  ): Promise<BusinessHours> {
    try {
      const config = await this.getConfig();

      const businessHours = await prisma.businessHours.upsert({
        where: {
          restaurantConfigId_dayOfWeek: {
            restaurantConfigId: config.id,
            dayOfWeek
          }
        },
        update: data,
        create: {
          restaurantConfigId: config.id,
          dayOfWeek,
          ...data
        }
      });

      // Clear caches
      await this.clearCache();
      
      logger.info(`Updated business hours for day ${dayOfWeek}:`, data);
      return businessHours;
    } catch (error) {
      logger.error('Error updating business hours:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to update business hours',
        { metadata: { dayOfWeek, data } }
      );
    }
  }

  /**
   * Check if restaurant is currently open
   */
  static async isOpen(date: Date = new Date()): Promise<boolean> {
    try {
      const dayOfWeek = date.getDay();
      const businessHours = await this.getBusinessHoursForDay(dayOfWeek);

      if (!businessHours || businessHours.isClosed || !businessHours.openingTime || !businessHours.closingTime) {
        return false;
      }

      const currentTime = date.getHours() * 60 + date.getMinutes();
      const [openHour, openMinute] = businessHours.openingTime.split(':').map(Number);
      const [closeHour, closeMinute] = businessHours.closingTime.split(':').map(Number);
      
      const openTime = openHour * 60 + openMinute;
      const closeTime = closeHour * 60 + closeMinute;

      return currentTime >= openTime && currentTime <= closeTime;
    } catch (error) {
      logger.error('Error checking if restaurant is open:', error);
      return false;
    }
  }

  /**
   * Clear all caches
   */
  static async clearCache(): Promise<void> {
    // Clear Redis cache if available
    if (redisService.isAvailable()) {
      await redisService.del(this.REDIS_CONFIG_KEY);
      await redisService.del(this.REDIS_BUSINESS_HOURS_KEY);
    }
    
    // Clear memory cache
    this.memoryConfigCache = null;
    this.memoryBusinessHoursCache = null;
    logger.debug('Restaurant service caches cleared');
  }

  /**
   * Get delivery coverage area
   */
  static async getDeliveryCoverageArea(): Promise<any> {
    const config = await this.getConfig();
    return config.deliveryCoverageArea;
  }

  /**
   * Update delivery coverage area
   */
  static async updateDeliveryCoverageArea(coverageArea: any): Promise<RestaurantConfig> {
    return this.updateConfig({ deliveryCoverageArea: coverageArea });
  }
}

================
File: backend/src/services/sync/EmbeddingManager.ts
================
import { prisma } from '../../lib/prisma';
import { EmbeddingService } from './EmbeddingService';
import logger from '../../common/utils/logger';
import { env } from '../../common/config/envValidator';

/**
 * Manages embedding lifecycle and automatic generation
 * Coordinates with sync service to generate embeddings after menu updates
 */
export class EmbeddingManager {
  private static isGenerating = false;
  private static lastGenerationTime: Date | null = null;
  private static generationAttempts = 0;
  private static readonly MAX_ATTEMPTS = 3;
  private static readonly RETRY_DELAY_MS = 5 * 60 * 1000; // 5 minutes
  private static scheduledCheckInterval: NodeJS.Timeout | null = null;

  /**
   * Check if embeddings can be generated (products exist)
   */
  static async canGenerateEmbeddings(): Promise<boolean> {
    const productCount = await prisma.product.count({
      where: { isActive: true }
    });
    return productCount > 0;
  }

  /**
   * Get embedding generation status
   */
  static async getEmbeddingStatus(): Promise<{
    hasProducts: boolean;
    totalProducts: number;
    productsWithEmbeddings: number;
    productsNeedingEmbeddings: number;
    lastGenerationTime: Date | null;
    isGenerating: boolean;
  }> {
    const totalProducts = await prisma.product.count({
      where: { isActive: true }
    });

    // Count products with embeddings using raw query
    const productsWithEmbeddings: { count: bigint }[] = await prisma.$queryRaw`
      SELECT COUNT(*) as count 
      FROM "Product" 
      WHERE "isActive" = true 
      AND embedding IS NOT NULL
    `;
    const withEmbeddingsCount = Number(productsWithEmbeddings[0]?.count || 0);

    return {
      hasProducts: totalProducts > 0,
      totalProducts,
      productsWithEmbeddings: withEmbeddingsCount,
      productsNeedingEmbeddings: totalProducts - withEmbeddingsCount,
      lastGenerationTime: this.lastGenerationTime,
      isGenerating: this.isGenerating
    };
  }

  /**
   * Trigger embedding generation after sync
   * Called automatically after menu sync completes
   */
  static async generateEmbeddingsAfterSync(): Promise<number> {
    try {
      // Check if API key is configured
      if (!env.GOOGLE_AI_API_KEY) {
        logger.warn('⚠️  Google AI API key not configured, skipping embedding generation');
        return 0;
      }

      // Prevent concurrent generation
      if (this.isGenerating) {
        logger.info('Embedding generation already in progress, skipping');
        return 0;
      }

      // Check if we can generate embeddings
      const canGenerate = await this.canGenerateEmbeddings();
      if (!canGenerate) {
        logger.info('No products available for embedding generation');
        return 0;
      }

      // Check status
      const status = await this.getEmbeddingStatus();
      if (status.productsNeedingEmbeddings === 0) {
        logger.info('All products already have embeddings');
        return 0;
      }

      logger.info(`🚀 Starting embedding generation for ${status.productsNeedingEmbeddings} products`);
      this.isGenerating = true;

      // Generate embeddings
      const updatedCount = await EmbeddingService.checkAndUpdateEmbeddings();
      
      this.lastGenerationTime = new Date();
      this.generationAttempts = 0; // Reset attempts on success
      
      logger.info(`✅ Embedding generation completed: ${updatedCount} products updated`);
      return updatedCount;
    } catch (error) {
      logger.error('Error generating embeddings after sync:', error);
      this.generationAttempts++;
      
      // Schedule retry if under max attempts
      if (this.generationAttempts < this.MAX_ATTEMPTS) {
        logger.info(`Scheduling embedding generation retry (attempt ${this.generationAttempts + 1}/${this.MAX_ATTEMPTS}) in 5 minutes`);
        setTimeout(() => this.generateEmbeddingsAfterSync(), this.RETRY_DELAY_MS);
      }
      return 0; // Return 0 on error
    } finally {
      this.isGenerating = false;
    }
  }

  /**
   * Initialize embedding management
   * Sets up periodic checks and initial generation
   */
  static async initialize(): Promise<void> {
    try {
      // Check if API key is configured
      if (!env.GOOGLE_AI_API_KEY) {
        logger.warn('⚠️  Google AI API key not configured, embedding features disabled');
        return;
      }

      const status = await this.getEmbeddingStatus();
      
      if (!status.hasProducts) {
        logger.info('📦 No products in database yet, embeddings will be generated after first sync');
        // Schedule periodic checks for when products arrive
        this.schedulePeriodicChecks();
        return;
      }

      if (status.productsNeedingEmbeddings > 0) {
        logger.info(`Found ${status.productsNeedingEmbeddings} products without embeddings`);
        // Don't block startup, generate in background
        setTimeout(() => this.generateEmbeddingsAfterSync(), 5000);
      } else {
        logger.info('✅ All products have embeddings');
      }

      // Schedule periodic checks
      this.schedulePeriodicChecks();
    } catch (error) {
      logger.error('Error initializing embedding manager:', error);
    }
  }

  /**
   * Schedule periodic embedding checks
   * Runs every hour to catch any missed updates
   */
  private static schedulePeriodicChecks(): void {
    // Clear any existing interval
    if (this.scheduledCheckInterval) {
      clearInterval(this.scheduledCheckInterval);
    }

    // Check every hour
    const INTERVAL_MS = 60 * 60 * 1000;
    
    this.scheduledCheckInterval = setInterval(async () => {
      try {
        const status = await this.getEmbeddingStatus();
        
        if (status.hasProducts && status.productsNeedingEmbeddings > 0) {
          logger.info(`Periodic check found ${status.productsNeedingEmbeddings} products needing embeddings`);
          await this.generateEmbeddingsAfterSync();
        }
      } catch (error) {
        logger.error('Error in periodic embedding check:', error);
      }
    }, INTERVAL_MS);
    
    logger.info('📅 Scheduled periodic embedding checks every hour');
  }

  /**
   * Force regenerate all embeddings
   * Useful for debugging or after major changes
   */
  static async forceRegenerateAll(): Promise<number> {
    try {
      logger.info('🔄 Force regenerating all embeddings...');
      
      // Clear all existing embeddings using raw query
      await prisma.$executeRaw`
        UPDATE "Product" 
        SET embedding = NULL 
        WHERE "isActive" = true
      `;
      
      // Generate new embeddings
      return await EmbeddingService.checkAndUpdateEmbeddings();
    } catch (error) {
      logger.error('Error force regenerating embeddings:', error);
      throw error;
    }
  }
}

================
File: backend/ecosystem.config.js
================
// PM2 Configuration for WhatsApp Bot
// This file configures how PM2 manages the API and worker processes

// Load environment variables from .env file
require('dotenv').config();

module.exports = {
  apps: [
    {
      // API Server Configuration
      name: 'whatsapp-api',
      script: 'dist/src/server.js',
      instances: 1, // API usually needs only one instance
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      env: {
        NODE_ENV: 'production',
      },
      error_file: 'logs/api-error.log',
      out_file: 'logs/api-out.log',
      log_file: 'logs/api-combined.log',
      time: true,
    },
    {
      // Worker Configuration
      name: 'whatsapp-worker',
      script: 'dist/src/workers/messageWorker.js',
      instances: parseInt(process.env.NUM_WORKERS || '1', 10), // Read from .env
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      env: {
        NODE_ENV: 'production',
      },
      error_file: 'logs/worker-error.log',
      out_file: 'logs/worker-out.log',
      log_file: 'logs/worker-combined.log',
      time: true,
      exec_mode: 'cluster', // Enable cluster mode for multiple instances
    },
  ],

  // Deploy section (optional, for remote deployments)
  deploy: {
    production: {
      user: 'node',
      host: 'your-server.com',
      ref: 'origin/main',
      repo: 'git@github.com:your-username/your-repo.git',
      path: '/var/www/whatsapp-bot',
      'post-deploy': 'npm install && npm run build && pm2 reload ecosystem.config.js --env production',
    },
  },
};

================
File: backend/ERROR_HANDLING_GUIDE.md
================
# Error Handling Guide

## Overview

This document outlines the error handling patterns used in the WhatsApp bot backend after the refactoring to consolidate error handling and remove redundancy between `globalErrorHandler` and `ErrorService`.

## Error Handling Architecture

### 1. Express Routes (HTTP)
- **Pattern**: Use `asyncHandler` wrapper and throw custom errors
- **Handler**: `globalErrorHandler` middleware catches all errors
- **Example**:
```typescript
router.post('/route', asyncHandler(async (req, res) => {
  // Throw errors directly - no try/catch needed
  throw new BusinessLogicError(
    ErrorCode.CUSTOMER_NOT_FOUND,
    'Customer not found'
  );
}));
```

### 2. WhatsApp Message Handlers
- **Pattern**: Use `handleWhatsAppError` utility for WhatsApp-specific errors
- **Handler**: Errors are logged and optionally sent to user
- **Example**:
```typescript
try {
  // WhatsApp message processing
} catch (error) {
  await handleWhatsAppError(error, whatsappNumber, {
    operation: 'process_message'
  });
}
```

## Service Layer Patterns

### Pattern 1: Services That Throw Errors (Recommended)
Most services should throw custom errors on failure:

```typescript
// CustomerService - throws errors
static async updateCustomer(id: string, data: any): Promise<Customer> {
  try {
    return await prisma.customer.update({ where: { id }, data });
  } catch (error) {
    throw new BusinessLogicError(
      ErrorCode.DATABASE_ERROR,
      'Failed to update customer',
      { metadata: { customerId: id } }
    );
  }
}
```

### Pattern 2: Services With Silent Fallback (Special Cases)
Some services use silent fallback for resilience:

#### RedisService
- **Decision**: Keep fallback pattern for cache operations
- **Reason**: Redis is optional; app should work without it
- **Pattern**: Returns `false` or `null` on failure
```typescript
async get(key: string): Promise<string | null> {
  if (!this.isAvailable()) return null;
  try {
    return await this.client.get(key);
  } catch (error) {
    logger.error('Redis GET error:', error);
    return null; // Silent fallback
  }
}
```

#### OTPService
- **Decision**: Keep fallback to memory when Redis unavailable
- **Reason**: Critical security feature must always work
- **Pattern**: Falls back to memory store if Redis fails

#### RestaurantService
- **Decision**: Returns default config on database errors
- **Reason**: Restaurant must always have configuration
- **Pattern**: Returns sensible defaults instead of throwing

### Pattern 3: WhatsApp Communication Services
Services that send WhatsApp messages return `boolean` for success:

```typescript
// WhatsAppService
static async sendMessage(to: string, message: string): Promise<{ 
  success: boolean; 
  messageId?: string; 
  error?: string 
}> {
  try {
    // Send message
    return { success: true, messageId: response.data.messages[0].id };
  } catch (error) {
    logger.error('Error sending WhatsApp message:', error);
    return { success: false, error: error.message };
  }
}
```

## Custom Error Types

All custom errors extend `BaseError` and include:
- `code`: Unique error code (e.g., 'BL001')
- `type`: Error category (BUSINESS_LOGIC, VALIDATION, etc.)
- `message`: Human-readable message
- `context`: Optional metadata

## Error Codes

Error codes follow a pattern: `[PREFIX][NUMBER]`
- `BL`: Business Logic (e.g., BL001 - ORDER_NOT_FOUND)
- `VAL`: Validation (e.g., VAL001 - INVALID_PRODUCT)
- `TECH`: Technical (e.g., TECH001 - DATABASE_ERROR)
- `EXT`: External Service (e.g., EXT001 - STRIPE_ERROR)
- `RL`: Rate Limit (e.g., RL001 - RATE_LIMIT_EXCEEDED)
- `NF`: Not Found (e.g., NF001 - ADDRESS_NOT_FOUND)

## Migration Notes

### Deprecated Patterns
1. **ErrorService.handleError()** - Use direct error throwing
2. **ErrorService.sendErrorToUser()** - Use `handleWhatsAppError`
3. **Try-catch in routes** - Use `asyncHandler` wrapper
4. **Returning error responses** - Throw errors instead
5. **Manual try-catch in WhatsApp handlers** - Use `wrapWhatsAppHandler`

### New Patterns
1. **Throw errors in services** - Let middleware handle them
2. **Use asyncHandler** - Automatic error catching in routes
3. **handleWhatsAppError** - Centralized WhatsApp error handling
4. **Custom error types** - Semantic error information
5. **wrapWhatsAppHandler** - Wrapper for WhatsApp message handlers

### Recent Updates (January 2025)
- Removed order cancellation functionality entirely
- Removed redundant try-catch from `AudioOrderController`
- Added `WEBHOOK_VERIFICATION_FAILED` error code
- Confirmed `INVALID_TOKEN` error message is user-friendly
- Simplified `StripeService.handleCompletedCheckout` - removed try-catch wrapper
- Simplified `PreOrderWorkflowService.processAction` - removed redundant try-catch
- Simplified all internal handlers in `interactiveMessageHandler.ts`:
  - `handleOnlinePayment`
  - `sendMenu`
  - `handleWaitTimes`
  - `handleRestaurantInfo`
  - `handleChatbotHelp`
  - `handleAddressConfirmation`
  - `handleAddressSelection`
  - `handleAddNewAddress`
  - `handlePreOrderAction`

## Decision Matrix

When to throw errors vs return null/false:

| Scenario | Approach | Example |
|----------|----------|---------|
| Database operation failed | Throw error | CustomerService |
| Optional cache miss | Return null | RedisService |
| Configuration not found | Return defaults | RestaurantService |
| External API failed | Throw error | StripeService |
| Message send failed | Return success flag | WhatsAppService |
| Security operation | Fallback + log | OTPService |

## Best Practices

1. **Always log errors** before throwing or handling
2. **Include context** in error metadata
3. **Use appropriate error codes** from the enum
4. **Let errors bubble up** to the appropriate handler
5. **Don't catch errors** unless you can handle them meaningfully
6. **Prefer throwing** over returning error states
7. **Document exceptions** when not throwing (like Redis fallback)

## Testing Error Scenarios

```typescript
// Test error handling
it('should throw BusinessLogicError when customer not found', async () => {
  await expect(
    CustomerService.updateCustomer('invalid-id', {})
  ).rejects.toThrow(BusinessLogicError);
});
```

================
File: backend/scripts/production-pgvector-setup.sql
================
-- Script para configurar pgvector en producción (Railway PostgreSQL)
-- Ejecutar este script en la base de datos de producción

-- 1. Habilitar la extensión pgvector
CREATE EXTENSION IF NOT EXISTS vector;

-- 2. Agregar la columna embedding a la tabla Product
ALTER TABLE "Product" ADD COLUMN IF NOT EXISTS embedding vector(768);

-- 3. Crear índice para búsquedas eficientes (opcional pero recomendado)
-- HNSW es el índice más eficiente para búsquedas de similitud
CREATE INDEX IF NOT EXISTS product_embedding_idx ON "Product" 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- 4. Verificar que todo está configurado correctamente
SELECT 
    COUNT(*) as total_products,
    COUNT(embedding) as products_with_embeddings
FROM "Product"
WHERE "isActive" = true;

-- Nota: Después de ejecutar este script, debes ejecutar el script de generación
-- de embeddings con la variable DATABASE_URL apuntando a producción

================
File: backend/scripts/reset-db.sh
================
#!/bin/bash
# Script to reset database and apply initial migration

echo "🗑️  Resetting database..."
npx prisma migrate reset --force --skip-seed

echo "📝 Creating initial migration..."
npx prisma migrate dev --name initial_schema --skip-seed

echo "✅ Database reset complete!"

================
File: backend/src/api/audio/audioOrder.controller.ts
================
import { Request, Response } from 'express';
import { AudioOrderService } from '../../services/audio/AudioOrderService';
import { BusinessLogicError, ErrorCode } from '../../common/services/errors';
import logger from '../../common/utils/logger';

interface MulterRequest extends Request {
  file?: Express.Multer.File;
}

export class AudioOrderController {
  static async processAudioOrder(req: MulterRequest, res: Response): Promise<void> {
    if (!req.file) {
      throw new BusinessLogicError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        'El archivo de audio es requerido'
      );
    }

    const { transcription } = req.body;
    
    // Debug incoming request
    logger.debug('Audio order request received', {
      fileSize: req.file.size,
      mimeType: req.file.mimetype,
      transcriptionLength: transcription?.length || 0,
      transcriptionPreview: transcription?.substring(0, 100) || 'No transcription'
    });

    const result = await AudioOrderService.processAudioOrder({
      audioBuffer: req.file.buffer,
      audioMimeType: req.file.mimetype,
      transcription
    });

    res.status(200).json({
      success: true,
      data: {
        orderItems: result.orderItems,
        orderType: result.orderType,
        deliveryInfo: result.deliveryInfo,
        scheduledDelivery: result.scheduledDelivery,
        warnings: result.warnings
      }
    });
  }
}

================
File: backend/src/common/utils/timeUtils.ts
================
import moment from "moment-timezone";
import logger from "./logger";
import { RestaurantService } from "../../services/restaurant/RestaurantService";

// Cache for timezone
let cachedTimeZone: string | null = null;

async function getTimeZone(): Promise<string> {
  try {
    if (cachedTimeZone) {
      return cachedTimeZone;
    }
    
    const config = await RestaurantService.getConfig();
    cachedTimeZone = config.timeZone || "America/Mexico_City";
    return cachedTimeZone;
  } catch (error) {
    logger.error("Error getting timezone from config:", error);
    // Fallback to default timezone
    return "America/Mexico_City";
  }
}

const parseTime = (timeString: string): number => {
  const [hours, minutes] = timeString.split(":").map(Number);
  return hours * 60 + minutes;
};

const getCurrentMexicoTime = async (): Promise<moment.Moment> => {
  const timeZone = await getTimeZone();
  return moment().tz(timeZone);
};

const getUTCTime = (): moment.Moment => {
  return moment().utc();
};

// Helper function to clear timezone cache when config changes
export function clearTimeZoneCache(): void {
  cachedTimeZone = null;
}

const isBusinessOpen = async (): Promise<boolean> => {
  try {
    const now = await getCurrentMexicoTime();
    const dayOfWeek = now.day();
    const currentMinutes = now.hours() * 60 + now.minutes();

    // Get business hours for current day
    const todayHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
    
    if (!todayHours || todayHours.isClosed || !todayHours.openingTime || !todayHours.closingTime) {
      return false;
    }

    const openingMinutes = parseTime(todayHours.openingTime);
    const closingMinutes = parseTime(todayHours.closingTime);

    // Get restaurant config for grace periods
    const config = await RestaurantService.getConfig();
    
    // Apply grace periods
    const effectiveOpeningTime = openingMinutes + (config.openingGracePeriod || 0);
    const effectiveClosingTime = closingMinutes - (config.closingGracePeriod || 0);

    return currentMinutes >= effectiveOpeningTime && currentMinutes < effectiveClosingTime;
  } catch (error) {
    logger.error("Error checking if business is open:", error);
    // Fallback to closed if database fails
    return false;
  }
};

export { getCurrentMexicoTime, isBusinessOpen, getUTCTime };

export async function getFormattedBusinessHours(): Promise<string> {
  try {
    const hours = await RestaurantService.getAllBusinessHours();
    
    const dayNames = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
    
    const formattedHours = hours.map(h => {
      if (h.isClosed || !h.openingTime || !h.closingTime) {
        return `${dayNames[h.dayOfWeek]}: Cerrado`;
      }
      return `${dayNames[h.dayOfWeek]}: ${h.openingTime} - ${h.closingTime}`;
    });
    
    return formattedHours.join('\n');
  } catch (error) {
    logger.error("Error getting formatted business hours:", error);
    return "Horarios no disponibles";
  }
}

export async function getBusinessStatus(): Promise<{
  isOpen: boolean;
  message: string;
  nextOpeningTime?: string;
}> {
  try {
    const now = await getCurrentMexicoTime();
    const dayOfWeek = now.day();
    const currentMinutes = now.hours() * 60 + now.minutes();
    
    const todayHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
    const config = await RestaurantService.getConfig();
    
    if (!todayHours || todayHours.isClosed || !todayHours.openingTime || !todayHours.closingTime) {
      // Find next opening day
      let nextDay = (dayOfWeek + 1) % 7;
      let daysChecked = 0;
      
      while (daysChecked < 7) {
        const nextDayHours = await RestaurantService.getBusinessHoursForDay(nextDay);
        if (nextDayHours && !nextDayHours.isClosed && nextDayHours.openingTime) {
          const dayName = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'][nextDay];
          return {
            isOpen: false,
            message: `⏰ Estamos cerrados hoy. Abrimos el ${dayName} a las ${nextDayHours.openingTime} hrs. 🍕`,
            nextOpeningTime: nextDayHours.openingTime
          };
        }
        nextDay = (nextDay + 1) % 7;
        daysChecked++;
      }
      
      return {
        isOpen: false,
        message: "⏰ Estamos cerrados. Por favor, contacta al restaurante para más información. 📞"
      };
    }
    
    const openingMinutes = parseTime(todayHours.openingTime);
    const closingMinutes = parseTime(todayHours.closingTime);
    const effectiveOpeningTime = openingMinutes + (config.openingGracePeriod || 0);
    const effectiveClosingTime = closingMinutes - (config.closingGracePeriod || 0);
    
    // Before opening (including grace period)
    if (currentMinutes < effectiveOpeningTime) {
      const minutesUntilOpen = effectiveOpeningTime - currentMinutes;
      if (minutesUntilOpen <= 60) {
        return {
          isOpen: false,
          message: `⏰ Abrimos en ${minutesUntilOpen} minutos. Por favor, espera un momento. 🍕`,
          nextOpeningTime: todayHours.openingTime
        };
      }
      return {
        isOpen: false,
        message: `⏰ Abrimos a las ${todayHours.openingTime} hrs. ¡Te esperamos! 🍕`,
        nextOpeningTime: todayHours.openingTime
      };
    }
    
    // Near closing time (within grace period)
    if (currentMinutes >= effectiveClosingTime && currentMinutes < closingMinutes) {
      const minutesUntilClose = closingMinutes - currentMinutes;
      return {
        isOpen: false,
        message: `⏰ Ya no estamos tomando pedidos. Cerramos en ${minutesUntilClose} minutos. ¡Vuelve mañana! 🍕`
      };
    }
    
    // After closing
    if (currentMinutes >= closingMinutes) {
      // Find next opening (tomorrow or next available day)
      let nextDay = (dayOfWeek + 1) % 7;
      let daysChecked = 0;
      
      while (daysChecked < 7) {
        const nextDayHours = await RestaurantService.getBusinessHoursForDay(nextDay);
        if (nextDayHours && !nextDayHours.isClosed && nextDayHours.openingTime) {
          const dayName = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'][nextDay];
          return {
            isOpen: false,
            message: `⏰ Ya cerramos por hoy. Abrimos el ${dayName} a las ${nextDayHours.openingTime} hrs. ¡Te esperamos! 🍕`,
            nextOpeningTime: nextDayHours.openingTime
          };
        }
        nextDay = (nextDay + 1) % 7;
        daysChecked++;
      }
    }
    
    // Restaurant is open
    const minutesUntilEffectiveClose = effectiveClosingTime - currentMinutes;
    if (minutesUntilEffectiveClose <= 30) {
      return {
        isOpen: true,
        message: `✅ Estamos abiertos. ⚠️ Último momento para ordenar, cerramos pronto (en ${minutesUntilEffectiveClose} minutos).`
      };
    }
    
    return {
      isOpen: true,
      message: "✅ Estamos abiertos y listos para tomar tu pedido. 🍕"
    };
  } catch (error) {
    logger.error("Error getting business status:", error);
    return {
      isOpen: false,
      message: "❌ Error al verificar el horario. Por favor, contacta al restaurante."
    };
  }
}


export async function getMexicoDayRange(dateString: string): Promise<{
  startDate: Date;
  endDate: Date;
}> {
  const timeZone = await getTimeZone();
  const mexicoDate = moment.tz(dateString, timeZone).startOf("day");

  const startDate = mexicoDate.clone().utc().toDate();
  const endDate = mexicoDate.clone().endOf("day").utc().toDate();

  return { startDate, endDate };
}

================
File: backend/src/dto/address/create-address.dto.ts
================
import { IsNotEmpty, IsString, IsObject, ValidateNested, IsOptional } from 'class-validator';
import { Type } from 'class-transformer';
import { AddressDto } from './address.dto';

export class CreateAddressDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;

  @IsNotEmpty({ message: 'otp is required' })
  @IsString({ message: 'otp must be a string' })
  otp!: string;

  @IsNotEmpty({ message: 'address is required' })
  @IsObject({ message: 'address must be an object' })
  @ValidateNested()
  @Type(() => AddressDto)
  address!: AddressDto;
  
  @IsOptional()
  @IsString({ message: 'preOrderId must be a string' })
  preOrderId?: string;
}

================
File: backend/src/services/ai/GeminiService.ts
================
import { GoogleGenAI } from '@google/genai';
import { env } from '../../common/config/envValidator';
import logger from '../../common/utils/logger';
import { ValidationError, ErrorCode } from '../../common/services/errors';

/**
 * Servicio centralizado para todas las interacciones con Gemini AI
 * Maneja la configuración, el cliente y las operaciones comunes
 */
export class GeminiService {
  private static instance: GoogleGenAI | null = null;

  /**
   * Obtiene la instancia singleton del cliente de Gemini
   */
  static getClient(): GoogleGenAI {
    if (!this.instance) {
      this.instance = new GoogleGenAI({ apiKey: env.GOOGLE_AI_API_KEY });
      logger.info('GeminiService: Cliente inicializado');
      logger.info(`GeminiService: Using model ${env.GEMINI_MODEL}`);
    }
    return this.instance;
  }

  /**
   * Genera una respuesta simple de texto
   */
  static async generateText(prompt: string, systemInstruction?: string): Promise<string> {
    try {
      logger.debug('=== GeminiService.generateText DEBUG ===');
      logger.debug(`Prompt: ${prompt}`);
      logger.debug(`System Instruction: ${systemInstruction || 'None'}`);
      
      const client = this.getClient();
      const response = await client.models.generateContent({
        model: env.GEMINI_MODEL,
        contents: prompt,
        config: systemInstruction ? { systemInstruction } : undefined,
      });
      
      logger.debug('Response:', JSON.stringify(response, null, 2));
      logger.debug(`Extracted text: ${response.text || 'No text in response'}`);
      logger.debug('=== End DEBUG ===');
      
      return response.text || '';
    } catch (error) {
      logger.error('GeminiService: Error generando texto', error);
      throw error;
    }
  }

  /**
   * Genera contenido con historial de conversación
   */
  static async generateContentWithHistory(
    messages: any[],
    systemInstruction?: string,
    tools?: any[],
    toolConfig?: any
  ): Promise<any> {
    try {
      const client = this.getClient();
      
      // Construir la configuración
      const config: any = {
        systemInstruction,
        tools: tools ? [{ functionDeclarations: tools }] : undefined,
      };
      
      // Agregar toolConfig si se proporciona
      if (toolConfig) {
        config.toolConfig = toolConfig;
      }
      
      const response = await client.models.generateContent({
        model: env.GEMINI_MODEL,
        contents: messages,
        config,
      });
      
      // El problema es que response no es serializable directamente con JSON.stringify
      // Vamos a extraer solo las partes importantes para el debug
      // Intentar múltiples formas de loggear la respuesta
      logger.debug('Response object exists:', !!response);
      logger.debug('Response type:', typeof response);
      
      // Método 1: Intentar con util.inspect
      try {
        const util = require('util');
        logger.debug('Raw Gemini response (inspect):', util.inspect(response, { depth: 4, colors: false }));
      } catch (e1) {
        logger.debug('Could not use util.inspect');
      }
      
      // Método 2: Intentar acceder directamente a las propiedades
      try {
        if (response?.candidates?.[0]) {
          const candidate = response.candidates[0];
          logger.debug('Candidate content:', {
            role: candidate.content?.role,
            partsCount: candidate.content?.parts?.length,
            firstPart: candidate.content?.parts?.[0]
          });
        }
      } catch (e2) {
        logger.debug('Could not access candidate properties');
      }
      
      // Método 3: Intentar JSON.stringify con reemplazador
      try {
        const seen = new WeakSet();
        const debugResponse = JSON.stringify(response, (key, value) => {
          if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
              return '[Circular]';
            }
            seen.add(value);
          }
          return value;
        }, 2);
        logger.debug('Raw Gemini response (JSON):', debugResponse);
      } catch (e3) {
        logger.debug('Could not JSON.stringify response');
      }
      
      return response;
    } catch (error) {
      logger.error('GeminiService: Error generando contenido con historial', error);
      throw error;
    }
  }

  /**
   * Transcribe audio a texto
   */
  static async transcribeAudio(
    audioData: string,
    mimeType: string
  ): Promise<string> {
    try {
      logger.debug('=== GeminiService.transcribeAudio DEBUG ===');
      logger.debug(`MimeType: ${mimeType}`);
      logger.debug(`Audio data length: ${audioData.length}`);
      
      const client = this.getClient();
      
      const prompt = `Transcribe el siguiente audio a texto. 
      Si el audio no es claro o no se puede entender, responde con "ERROR_TRANSCRIPTION".
      Si el audio está en otro idioma que no sea español, tradúcelo al español.
      Solo devuelve el texto transcrito, sin explicaciones adicionales.`;

      const contents = [
        {
          role: "user",
          parts: [
            { text: prompt },
            {
              inlineData: {
                mimeType,
                data: audioData,
              },
            },
          ],
        },
      ];
      
      logger.debug('Contents structure:', JSON.stringify({
        role: contents[0].role,
        parts: contents[0].parts.map(p => p.text ? 'text' : 'inlineData')
      }, null, 2));

      const response = await client.models.generateContent({
        model: env.GEMINI_MODEL,
        contents,
      });

      const transcription = response.text?.trim() || '';
      logger.debug(`Transcription result: ${transcription}`);
      logger.debug('=== End DEBUG ===');
      
      if (!transcription || transcription === 'ERROR_TRANSCRIPTION' || transcription.length < 2) {
        throw new ValidationError(
          ErrorCode.TRANSCRIPTION_ERROR,
          'No se pudo transcribir el audio',
          { metadata: { transcriptionResult: transcription } }
        );
      }

      return transcription;
    } catch (error) {
      logger.error('GeminiService: Error transcribiendo audio', error);
      throw error;
    }
  }

  /**
   * Crea una sesión de chat con historial
   */
  static createChat(config?: {
    history?: any[];
    systemInstruction?: string;
    tools?: any[];
  }) {
    const client = this.getClient();
    return client.chats.create({
      model: env.GEMINI_MODEL,
      history: config?.history || [],
      config: {
        systemInstruction: config?.systemInstruction,
        tools: config?.tools ? [{ functionDeclarations: config.tools }] : undefined,
      },
    });
  }
}

================
File: backend/src/services/ai/tools/handlers/generateAddressUpdateLinkHandler.ts
================
import { ToolHandler, ToolResponse } from '../types';
import { MessageContext } from '../../../messaging/MessageContext';
import { OTPService } from '../../../security/OTPService';
import { env } from '../../../../common/config/envValidator';
import { TechnicalError, ErrorCode } from '../../../../common/services/errors';
import logger from '../../../../common/utils/logger';

/**
 * Handles the generate_address_update_link function call
 * Generates a secure OTP link for address updates
 */
export const handleGenerateAddressUpdateLink: ToolHandler = async (args, context?: MessageContext): Promise<ToolResponse> => {
  logger.debug('Generating address update link:', args);
  
  // Get customerId from context
  const customerId = context?.message?.from;
  if (!customerId) {
    throw new TechnicalError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Could not get customer ID from message context'
    );
  }
  
  // Generate OTP
  const otp = OTPService.generateOTP();
  await OTPService.storeOTP(customerId, otp, true); // true = address registration
  
  // Create registration link
  const registrationLink = `${env.FRONTEND_BASE_URL}/address-registration/${customerId}?otp=${otp}`;
  
  // Return URL button configuration
  return {
    urlButton: {
      title: "📍 Actualizar Dirección",
      body: "Te he generado un enlace seguro para que puedas actualizar o agregar una nueva dirección de entrega.\n\n" +
            "Este enlace es temporal y expirará en 10 minutos por seguridad.",
      buttonText: "Actualizar Dirección",
      url: registrationLink
    },
    isRelevant: true
  };
};

================
File: backend/src/services/ai/tools/handlers/getBusinessHoursHandler.ts
================
import { ToolHandler, ToolResponse } from '../types';
import { RESTAURANT_INFO_MESSAGE } from '../../../../common/config/predefinedMessages';
import { ConfigService } from '../../../config/ConfigService';
import { getFormattedBusinessHours } from '../../../../common/utils/timeUtils';
import logger from '../../../../common/utils/logger';

/**
 * Handles the get_business_hours function call
 * Returns restaurant information and business hours
 */
export const handleGetBusinessHours: ToolHandler = async (): Promise<ToolResponse> => {
  const config = ConfigService.getConfig();
  const formattedHours = await getFormattedBusinessHours();
  const infoMessage = RESTAURANT_INFO_MESSAGE(config, formattedHours);
  
  return {
    text: infoMessage,
    isRelevant: true
  };
};

================
File: backend/src/services/ai/tools/handlers/getWaitTimesHandler.ts
================
import { ToolHandler, ToolResponse } from '../types';
import { WAIT_TIMES_MESSAGE } from '../../../../common/config/predefinedMessages';
import { RestaurantService } from '../../../restaurant/RestaurantService';
import logger from '../../../../common/utils/logger';

/**
 * Handles the get_wait_times function call
 * Returns estimated wait times for pickup and delivery
 */
export const handleGetWaitTimes: ToolHandler = async (): Promise<ToolResponse> => {
  logger.debug('Getting wait times');
  
  const config = await RestaurantService.getConfig();
  
  const waitTimesMessage = WAIT_TIMES_MESSAGE(
    config.estimatedPickupTime,
    config.estimatedDeliveryTime
  );
  
  return {
    text: waitTimesMessage,
    isRelevant: true
  };
};

================
File: backend/src/services/ai/tools/handlers/prepareOrderContextHandler.ts
================
import { ToolHandler, ToolResponse } from '../types';
import { MessageContext } from '../../../messaging/MessageContext';
import { MenuSearchService } from '../../MenuSearchService';
import { AgentService } from '../../AgentService';
import logger from '../../../../common/utils/logger';

/**
 * Handles the prepare_order_context function call
 * Prepares context for the order agent with relevant menu items
 */
export const handlePrepareOrderContext: ToolHandler = async (args, context?: MessageContext): Promise<ToolResponse | ToolResponse[]> => {
  // Get relevant menu based on mentioned items
  const relevantMenu = await MenuSearchService.getRelevantMenu(args.itemsSummary);
  
  // If no relevant products found
  if (relevantMenu === "[]" || JSON.parse(relevantMenu).length === 0) {
    logger.warn('No relevant products found for order context');
    
    return {
      text: `😔 No pude encontrar productos que coincidan con "${args.itemsSummary}". Por favor, intenta con otro nombre o revisa nuestro menú.`,
      isRelevant: true
    };
  }
  
  // Create context for order agent
  const orderContext = {
    itemsSummary: args.itemsSummary,
    relevantMenu: relevantMenu,
    orderType: args.orderType
  };
  
  // Process with order agent
  logger.debug('Calling processOrderMapping with context:', orderContext);
  const orderResponse = await AgentService.processOrderMapping(orderContext);
  logger.debug('Order agent response:', JSON.stringify(orderResponse, null, 2));
  
  // Import TextProcessingService to avoid circular dependency
  const { TextProcessingService } = await import('../../../messaging/TextProcessingService');
  
  // Process the order agent response
  const orderResults = await (TextProcessingService as any).processGeminiResponse(orderResponse, context);
  logger.debug('Processed order results:', orderResults);
  
  // The order agent should always execute map_order_items
  // So we return all results
  return orderResults;
};

================
File: backend/src/services/ai/tools/handlers/sendBotInstructionsHandler.ts
================
import { ToolHandler, ToolResponse } from '../types';
import { CHATBOT_HELP_MESSAGE } from '../../../../common/config/predefinedMessages';
import { ConfigService } from '../../../config/ConfigService';
import logger from '../../../../common/utils/logger';

/**
 * Handles the send_bot_instructions function call
 * Sends instructions on how to use the bot
 */
export const handleSendBotInstructions: ToolHandler = async (): Promise<ToolResponse> => {
  logger.debug('Sending bot instructions');
  
  const config = ConfigService.getConfig();
  const instructions = CHATBOT_HELP_MESSAGE(config);
  
  return {
    text: instructions,
    isRelevant: true
  };
};

================
File: backend/src/services/messaging/types/responses.ts
================
/**
 * Tipo unificado para todas las respuestas del sistema
 * Reemplaza AIResponse, MessageResponse, ResponseItem, etc.
 */
export interface UnifiedResponse {
  // Contenido principal
  content?: {
    text?: string;
    interactive?: any;
  };
  
  // Metadatos
  metadata: {
    // Control de envío
    shouldSend: boolean;
    
    // Relevancia para el historial
    isRelevant: boolean;
    
    // Tipo de respuesta
    type: ResponseType;
    
    // IDs relacionados
    preOrderId?: number;
    orderId?: number;
  };
  
  // Datos procesados (para pedidos)
  processedData?: {
    orderItems?: any[];
    orderType?: string; // OrderType enum as string
    warnings?: string[];
    scheduledAt?: Date;
  };
  
  // Errores
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

/**
 * Tipos de respuesta
 */
export enum ResponseType {
  // Mensajes simples
  TEXT = 'TEXT',
  INTERACTIVE = 'INTERACTIVE',
  
  // Respuestas de procesamiento
  ORDER_CONFIRMATION = 'ORDER_CONFIRMATION',
  ORDER_PROCESSING = 'ORDER_PROCESSING',
  
  // Respuestas de consulta
  MENU_INFO = 'MENU_INFO',
  WAIT_TIME_INFO = 'WAIT_TIME_INFO',
  RESTAURANT_INFO = 'RESTAURANT_INFO',
  
  // Errores
  ERROR = 'ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
}

/**
 * Builder para crear respuestas de forma consistente
 */
export class ResponseBuilder {
  static text(message: string, isRelevant = true): UnifiedResponse {
    return {
      content: { text: message },
      metadata: {
        shouldSend: true,
        isRelevant,
        type: ResponseType.TEXT,
      },
    };
  }
  
  static interactive(message: any, preOrderId?: number): UnifiedResponse {
    return {
      content: { interactive: message },
      metadata: {
        shouldSend: true,
        isRelevant: false,
        type: ResponseType.INTERACTIVE,
        preOrderId,
      },
    };
  }
  
  static orderProcessing(data: any): UnifiedResponse {
    return {
      processedData: data,
      metadata: {
        shouldSend: false,
        isRelevant: true,
        type: ResponseType.ORDER_PROCESSING,
      },
    };
  }
  
  static error(code: string, message: string): UnifiedResponse {
    return {
      content: { text: message },
      error: { code, message },
      metadata: {
        shouldSend: true,
        isRelevant: true,
        type: ResponseType.ERROR,
      },
    };
  }
}

================
File: backend/src/services/orders/services/SchedulingService.ts
================
import { RestaurantService } from "../../restaurant/RestaurantService";
import { ValidationError, ErrorCode } from "../../../common/services/errors";
import { env } from "../../../common/config/envValidator";
import { OrderType } from '@prisma/client';

export class SchedulingService {
  /**
   * Validate and process scheduled delivery time
   */
  static async validateScheduledTime(
    scheduledAt: string | Date | undefined,
    orderType: OrderType
  ): Promise<Date | null> {
    if (!scheduledAt || scheduledAt === "null") {
      return null;
    }

    const now = new Date();
    let fullScheduledDeliveryTime: Date;

    if (scheduledAt instanceof Date) {
      fullScheduledDeliveryTime = scheduledAt;
    } else {
      const timeParts = scheduledAt.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
      if (!timeParts) {
        throw new ValidationError(
          ErrorCode.INVALID_SCHEDULE_TIME,
          'Invalid time format',
          { metadata: { scheduledAt } }
        );
      }

      let hours = parseInt(timeParts[1]);
      const minutes = parseInt(timeParts[2]);
      const meridiem = timeParts[3];

      if (meridiem) {
        if (meridiem.toUpperCase() === "PM" && hours !== 12) {
          hours += 12;
        } else if (meridiem.toUpperCase() === "AM" && hours === 12) {
          hours = 0;
        }
      }

      fullScheduledDeliveryTime = new Date(now);
      fullScheduledDeliveryTime.setHours(hours, minutes, 0, 0);

      if (fullScheduledDeliveryTime <= now) {
        fullScheduledDeliveryTime.setDate(fullScheduledDeliveryTime.getDate() + 1);
      }
    }

    // Validate against business hours
    await this.validateAgainstBusinessHours(fullScheduledDeliveryTime, orderType);

    return fullScheduledDeliveryTime;
  }

  /**
   * Validate scheduled time against business hours
   */
  private static async validateAgainstBusinessHours(
    scheduledTime: Date,
    orderType: OrderType
  ): Promise<void> {
    const config = await RestaurantService.getConfig();
    
    // Convert to Mexico time
    const mexicoTime = new Date(
      scheduledTime.toLocaleString("en-US", {
        timeZone: config.timeZone || env.DEFAULT_TIMEZONE,
      })
    );

    const dayOfWeek = mexicoTime.getDay();
    const scheduledHour = mexicoTime.getHours();
    const scheduledMinute = mexicoTime.getMinutes();

    // Get business hours for the day
    const businessHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
    
    if (!businessHours || businessHours.isClosed || !businessHours.openingTime || !businessHours.closingTime) {
      throw new ValidationError(
        ErrorCode.RESTAURANT_CLOSED,
        '😔 El restaurante está cerrado en el horario solicitado. Por favor, elige otro horario cuando estemos abiertos.'
      );
    }

    // Parse opening and closing times
    const [openingHour, openingMinute] = businessHours.openingTime.split(":").map(Number);
    const [closingHour, closingMinute] = businessHours.closingTime.split(":").map(Number);
    const openingMinutes = openingHour * 60 + openingMinute;
    const closingMinutes = closingHour * 60 + closingMinute;

    // Apply grace periods
    const openingGracePeriod = config.openingGracePeriod || 0;
    const closingGracePeriod = config.closingGracePeriod || 0;
    const adjustedOpeningMinutes = openingMinutes - openingGracePeriod;
    const adjustedClosingMinutes = closingMinutes + closingGracePeriod;

    // Convert scheduled time to minutes
    const scheduledMinutes = scheduledHour * 60 + scheduledMinute;

    // Check if within hours
    if (scheduledMinutes < adjustedOpeningMinutes || scheduledMinutes > adjustedClosingMinutes) {
      const adjustedOpeningTime = new Date(mexicoTime);
      adjustedOpeningTime.setHours(openingHour, openingMinute - openingGracePeriod);
      
      const adjustedClosingTime = new Date(mexicoTime);
      adjustedClosingTime.setHours(closingHour, closingMinute + closingGracePeriod);

      const openingFormatted = adjustedOpeningTime.toLocaleTimeString("es-MX", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: true,
      });
      const closingFormatted = adjustedClosingTime.toLocaleTimeString("es-MX", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: true,
      });

      throw new ValidationError(
        ErrorCode.INVALID_SCHEDULE_TIME,
        `Scheduled time is outside business hours. Please schedule between ${openingFormatted} and ${closingFormatted}`,
        { metadata: { scheduledMinutes, adjustedOpeningMinutes, adjustedClosingMinutes } }
      );
    }

    // Check minimum time requirement
    const minTimeRequired = orderType === OrderType.TAKE_AWAY 
      ? config.estimatedPickupTime 
      : config.estimatedDeliveryTime;
    
    const now = new Date();
    const timeDifference = (scheduledTime.getTime() - now.getTime()) / (1000 * 60);

    if (timeDifference < minTimeRequired) {
      throw new ValidationError(
        ErrorCode.INVALID_SCHEDULE_TIME,
        `Scheduled time must be at least ${minTimeRequired} minutes from now`,
        { metadata: { timeDifference, minTimeRequired } }
      );
    }
  }
}

================
File: backend/src/workers/messageWorker.ts
================
import { MessageProcessor } from '../services/messaging/MessageProcessor';
import { IncomingMessage } from '../services/messaging/types';
import { WhatsAppMessageJob } from '../queues/types';
import logger from '../common/utils/logger';
import { startMessageWorker } from '../queues/messageQueue';

/**
 * Process a WhatsApp message job from the queue
 * This runs in a separate worker process/thread
 */
export async function processMessageJob(messageData: WhatsAppMessageJob): Promise<void> {
  const startTime = Date.now();
  
  try {
    // Convert job data to IncomingMessage format
    const incomingMessage: IncomingMessage = {
      id: messageData.id,
      from: messageData.from,
      type: messageData.type as 'text' | 'interactive' | 'audio' | 'image' | 'document' | 'location',
      timestamp: messageData.timestamp,
      text: messageData.text,
      interactive: messageData.interactive,
      audio: messageData.audio
    };
    
    logger.info(`Worker processing message ${messageData.id} from ${messageData.from}, type: ${messageData.type}`);
    
    // Process the message through the existing pipeline
    await MessageProcessor.processWithPipeline(incomingMessage);
    
    const processingTime = Date.now() - startTime;
    logger.info(`Message ${messageData.id} from ${messageData.from} processed successfully in ${processingTime}ms`);
    
  } catch (error) {
    const processingTime = Date.now() - startTime;
    logger.error(`Worker failed to process message ${messageData.id} from ${messageData.from} after ${processingTime}ms:`, error);
    
    // Re-throw the error so BullMQ can handle retries according to configuration
    throw error;
  }
}

// Start the worker when this file is executed directly
if (require.main === module) {
  logger.info('Starting message worker process...');
  startMessageWorker();
}

================
File: backend/src/api/audio/audioOrder.routes.ts
================
import { Router } from 'express';
import multer from 'multer';
import { AudioOrderController } from './audioOrder.controller';
import { AudioHealthController } from './audioHealth.controller';
import { apiKeyAuthMiddleware } from '../../common/middlewares/apiKeyAuth.middleware';
import { validationMiddleware } from '../../common/middlewares/validation.middleware';
import { asyncHandler } from '../../common/middlewares/errorHandler';
import { ProcessAudioOrderDto } from '../../dto/order';

const router = Router();

const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 1
  },
  fileFilter: (req, file, cb) => {
    const allowedMimeTypes = [
      'audio/mp4',
      'audio/mpeg',
      'audio/ogg',
      'audio/wav',
      'audio/webm'
    ];
    
    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Tipo de archivo no soportado. Use MP4, MP3, OGG, WAV o WEBM.'));
    }
  }
});

// Health check endpoint
router.get(
  '/health',
  apiKeyAuthMiddleware,
  asyncHandler(AudioHealthController.checkHealth)
);

// Process audio order endpoint
router.post(
  '/process-order',
  apiKeyAuthMiddleware,
  upload.single('audio'),
  validationMiddleware(ProcessAudioOrderDto),
  asyncHandler(AudioOrderController.processAudioOrder)
);

export default router;

================
File: backend/src/common/config/predefinedMessages.ts
================
import { RestaurantInfo } from "../types/restaurant";

// Address registration messages
export const ADDRESS_REGISTRATION_SUCCESS = (address: any): string => {
  return `✅ *¡Dirección registrada exitosamente!*

📍 *Tu dirección de entrega:*
${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}
${address.neighborhood ? `Col. ${address.neighborhood}\n` : ''}${address.city}, ${address.state}

¡Perfecto! Tu dirección ha sido guardada. Ahora puedes realizar tu pedido. 🎉`;
};

export const ADDRESS_UPDATE_SUCCESS = (address: any): string => {
  return `✅ *¡Dirección actualizada correctamente!*

📍 *Tu nueva dirección de entrega:*
${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}
${address.neighborhood ? `Col. ${address.neighborhood}\n` : ''}${address.city}, ${address.state}

Tu información de entrega ha sido actualizada exitosamente. 👍`;
};

// Restaurant messages that depend on configuration
export const BANNED_USER_MESSAGE = (config: RestaurantInfo): string => {
  return `Lo sentimos, tu número ha sido baneado debido a la detección de un uso inadecuado de nuestro servicio.

Si crees que es un error, por favor contacta directamente con nosotros:

${config.phoneMain ? `📞 Teléfono: ${config.phoneMain}` : ''}
${config.phoneSecondary ? `📞 Teléfono: ${config.phoneSecondary}` : ''}

Agradecemos tu comprensión y esperamos resolver cualquier malentendido.`;
};

export const WAIT_TIMES_MESSAGE = (
  pickupTime: number,
  deliveryTime: number
): string => `
🕒 *Tiempos de espera estimados:*

🏠 Recolección en establecimiento: ${pickupTime} minutos
🚚 Entrega a domicilio: ${deliveryTime} minutos

Estos tiempos son aproximados y pueden variar según la demanda actual.
`;

export const RESTAURANT_INFO_MESSAGE = (
  config: RestaurantInfo,
  formattedHours: string
): string => {
  const fullAddress = [config.address, config.city, config.state, config.postalCode]
    .filter(Boolean)
    .join(", ");
  
  return `
📍 *Información y horarios de ${config.restaurantName}*

${fullAddress ? `📍 *Ubicación:* ${fullAddress}` : ''}

📞 *Teléfonos:*
${config.phoneMain ? `   ${config.phoneMain}` : ''}
${config.phoneSecondary ? `   ${config.phoneSecondary}` : ''}

🕒 *Horarios:*
${formattedHours.split('\n').map(line => '   ' + line).join('\n')}

¡Gracias por tu interés! Esperamos verte pronto.
`;
};

export const CHATBOT_HELP_MESSAGE = (config: RestaurantInfo): string => {
  return `
🤖💬 *¡Bienvenido al Chatbot de ${config.restaurantName}!*

Este asistente virtual está potenciado por inteligencia artificial para brindarte una experiencia fluida y natural. Aquí te explicamos cómo usarlo:

🚀 *Opciones disponibles:*
Al enviar cualquier mensaje, recibirás un menú con las siguientes opciones:
   📜 Ver Menú - Consulta nuestros productos disponibles
   ⏱️ Tiempos de espera - Conoce el tiempo estimado de preparación
   ℹ️ Información y horarios - Dirección, teléfonos y horarios
   🚚 Actualizar entrega - Cambia tu dirección de entrega registrada
   🤖 ¿Cómo usar el bot? - Esta ayuda

🍽️ *Realizar un pedido:*
1. Escribe o envía un audio con los productos que deseas, especificando:
   - Cantidad de cada producto
   - Detalles o especificaciones (sin cebolla, extra queso, etc.)
   - Tipo de pedido: entrega a domicilio o recolección

2. Para entrega a domicilio:
   - Usaremos la dirección predeterminadaque registraste al inicio
   - Si necesitas cambiarla, usa la opción "🚚 Actualizar entrega"

3. Para recolección en establecimiento:
   - Indica que es para recoger y la recolectaras con el nombre que registraste al inicio

Ejemplos:
   '2 hamburguesas tradicionales con papas y una coca cola para entrega a domicilio'
   'Una pizza grande especial sin piña para recoger'

📝 *Proceso del pedido:*
1. Recibirás un resumen con botones de Confirmar o Descartar
2. Al confirmar, tu pedido será enviado al restaurante
3. Recibirás opciones para pagar en línea o por defecto en efectivo

💳 *Pago:*
- Después de confirmar tu pedido, puedes generar un enlace de pago
- Si no pagas en línea, el pago será en efectivo al recibir tu pedido

⚠️ *IMPORTANTE:*
- Los pedidos confirmados NO se pueden modificar ni cancelar
- Tu dirección de entrega debe estar registrada antes de ordenar
- Envía un mensaje a la vez y espera la respuesta

📞 *¿Necesitas hacer cambios en tu pedido?*
Si necesitas modificar algo después de confirmar, comunícate directamente con el restaurante:
${config.phoneMain ? `   📱 ${config.phoneMain}` : ''}
${config.phoneSecondary ? `   📱 ${config.phoneSecondary}` : ''}

¡Disfruta tu experiencia con nuestro chatbot! 🍽️🤖
`;
};

export const CHANGE_DELIVERY_INFO_MESSAGE = (updateLink: string): string => `
🚚 ¡Actualiza tu información de entrega! 📝

👇 *PRESIONA AQUÍ PARA ACTUALIZAR* 👇

${updateLink}`;

export const RESTAURANT_NOT_ACCEPTING_ORDERS_MESSAGE = (config: RestaurantInfo): string => {
  return `
🚫🍽️ Lo sentimos, no estamos aceptando pedidos en este momento. 😔

⏳ Puedes intentar más tarde o llamarnos directamente:
${config.phoneMain ? `📞 Teléfono: ${config.phoneMain}` : ''}
${config.phoneSecondary ? `📞 Teléfono: ${config.phoneSecondary}` : ''}

¡Gracias por tu comprensión! 🙏
`;
};

export const RESTAURANT_CLOSED_MESSAGE = (formattedHours: string): string => {
  return `
🚫 Lo sentimos, estamos cerrados en este momento. 😴

🕒 Nuestro horario de atención es:
${formattedHours.split('\n').map(line => '   🗓️ ' + line).join('\n')}

🙏 Gracias por tu comprensión. ¡Esperamos atenderte pronto! 😊
`;
};

export const DELIVERY_INFO_REGISTRATION_MESSAGE = (
  registrationLink: string
): string => `
¡Hola! 👋 Antes de continuar, necesitamos que registres tu información de entrega. 📝

👇 *PRESIONA AQUÍ PARA REGISTRARTE* 👇

${registrationLink}
`;

export const PAYMENT_CONFIRMATION_MESSAGE = (orderNumber: number): string => `
¡Tu pago para la orden #${orderNumber} ha sido confirmado! 🎉✅ Gracias por tu compra. 🛍️😊
`;

export const WELCOME_MESSAGE_INTERACTIVE = (config: RestaurantInfo) => {
  return {
    type: "list",
    header: {
      type: "text",
      text: `Bienvenido a ${config.restaurantName} 🍽️`
    },
    body: {
      text: "¿Cómo podemos ayudarte hoy? 😊"
    },
    footer: {
      text: "Selecciona una opción:"
    },
    action: {
      button: "Ver opciones",
      sections: [
        {
          title: "Acciones",
          rows: [
            { id: "view_menu", title: "📜 Ver Menú" },
            { id: "wait_times", title: "⏱️ Tiempos de espera" },
            { id: "restaurant_info", title: "ℹ️ Información y horarios" },
            { id: "chatbot_help", title: "🤖 ¿Cómo usar el bot?" },
            {
              id: "change_delivery_info",
              title: "🚚 Actualizar entrega"
            }
          ]
        }
      ]
    }
  };
};

// Static messages that don't depend on configuration
export const CONVERSATION_RESET_MESSAGE = "🔄 Entendido, he olvidado el contexto anterior. ¿En qué puedo ayudarte ahora? 😊";

export const GENERIC_ERROR_MESSAGE = "Lo siento, ocurrió un error procesando tu mensaje. Por favor intenta de nuevo.";

export const UNSUPPORTED_MESSAGE_TYPE = "Lo siento, solo puedo procesar mensajes de texto por el momento.";

export const AUDIO_TRANSCRIPTION_ERROR = "🎤 Hubo un problema al procesar tu mensaje de audio. Por favor, intenta nuevamente o envía un mensaje de texto.";

export const RATE_LIMIT_MESSAGE = "Has alcanzado el límite de mensajes. Por favor espera unos minutos antes de enviar más mensajes.";

export const ORDER_NOT_FOUND_MESSAGE = "❌ Lo siento, no se pudo encontrar tu orden. 🚫🔍";


export const STRIPE_NOT_AVAILABLE_MESSAGE = "❌ Lo siento, los pagos en línea no están disponibles en este momento. Por favor, realiza el pago en efectivo al recibir tu pedido. 💵";

export const PAYMENT_LINK_EXISTS_MESSAGE = "⚠️ Ya existe un enlace de pago activo para esta orden. Por favor, utiliza el enlace enviado anteriormente o contáctanos si necesitas ayuda. 🔄";

export const DEFAULT_ADDRESS_CHANGED = (address: any): string => {
  return `✅ *Dirección principal actualizada*\n\n` +
    `Tu dirección principal ahora es:\n\n` +
    `📍 *${address.name || 'Dirección'}*\n` +
    `${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}\n` +
    `${address.neighborhood ? `${address.neighborhood}, ` : ''}${address.city}, ${address.state}\n` +
    `${address.deliveryInstructions ? `\n📝 _${address.deliveryInstructions}_` : ''}\n\n` +
    `Esta será la dirección que usaremos para tus próximas entregas a domicilio.`;
};

================
File: backend/src/common/constants/interactiveActions.ts
================
/**
 * Constants for interactive message actions
 * These are used as prefixes or identifiers in WhatsApp interactive messages
 */
export const INTERACTIVE_ACTIONS = {
  // PreOrder actions
  PREORDER_CONFIRM: 'preorder_confirm:',
  PREORDER_DISCARD: 'preorder_discard:',
  PREORDER_CHANGE_ADDRESS: 'preorder_change_address:',
  
  // Address actions
  CONFIRM_ADDRESS: 'confirm_address_',
  SELECT_ADDRESS: 'select_address_',
  CHANGE_ADDRESS: 'change_address',
  ADD_NEW_ADDRESS: 'add_new_address',
  
  // Order actions
  PAY_ONLINE: 'pay_online',
  
  // Menu and info actions
  VIEW_MENU: 'view_menu',
  RESTAURANT_INFO: 'restaurant_info',
  WAIT_TIMES: 'wait_times',
  CHATBOT_HELP: 'chatbot_help',
  CHANGE_DELIVERY_INFO: 'change_delivery_info',
} as const;

/**
 * Type-safe way to check if a string starts with an action prefix
 */
export function startsWithAction(str: string, action: string): boolean {
  return str.startsWith(action);
}

/**
 * Extract the ID from an action string
 * For example: 'select_address_123' -> '123'
 */
export function extractIdFromAction(str: string, actionPrefix: string): string {
  if (!startsWithAction(str, actionPrefix)) {
    throw new Error(`String does not start with action prefix: ${actionPrefix}`);
  }
  return str.substring(actionPrefix.length);
}

================
File: backend/src/common/types/preorder.types.ts
================
/**
 * Types for the PreOrder workflow system
 */

export interface ProcessedOrderData {
  orderItems: Array<{
    productId: string;
    productVariantId?: string | null;
    quantity: number;
    selectedModifiers?: string[];
    selectedPizzaCustomizations?: Array<{
      pizzaCustomizationId: string;
      half: 'FULL' | 'HALF_1' | 'HALF_2';
      action: 'ADD' | 'REMOVE';
    }>;
  }>;
  orderType: 'DELIVERY' | 'TAKE_AWAY';
  scheduledAt?: Date | null;
  deliveryInfo?: {
    name?: string | null;
    street?: string;
    number?: string;
    interiorNumber?: string | null;
    neighborhood?: string | null;
    city?: string | null;
    state?: string | null;
    zipCode?: string | null;
    country?: string | null;
    deliveryInstructions?: string | null;
    latitude?: number | null;
    longitude?: number | null;
  };
}

export interface PreOrderWorkflowResult {
  preOrderId: number;
  actionToken: string;
  expiresAt: Date;
}

export interface PreOrderActionParams {
  action: 'confirm' | 'discard';
  token: string;
  whatsappNumber: string;
}

export interface PreOrderSummary {
  items: Array<{
    productName: string;
    variantName?: string;
    quantity: number;
    unitPrice: number;
    totalPrice: number;
    modifiers?: string[];
  }>;
  subtotal: number;
  orderType: string;
  scheduledAt?: Date;
}

export interface PreOrderNotification {
  summary: string;
  actionToken: string;
  expiresInMinutes: number;
}

export interface TokenValidationResult {
  isValid: boolean;
  preOrderId?: number;
  error?: string;
}

================
File: backend/src/common/utils/messageSplitter.ts
================
/**
 * Utilidad unificada para dividir mensajes largos de WhatsApp
 * Consolida la lógica duplicada de división de mensajes
 */

interface SplitOptions {
  maxLength?: number;
  preserveFormatting?: boolean;
}

const DEFAULT_MAX_LENGTH = 4000; // Límite de WhatsApp con margen de seguridad

export class MessageSplitter {
  /**
   * Dividir un mensaje largo en partes respetando el límite de caracteres
   */
  static split(text: string, options: SplitOptions = {}): string[] {
    const {
      maxLength = DEFAULT_MAX_LENGTH,
      preserveFormatting = true
    } = options;
    
    // Si el mensaje cabe en una parte, devolverlo tal cual
    if (text.length <= maxLength) {
      return [text];
    }
    
    // División simple por longitud
    const parts = this.simpleSplit(text, maxLength);
    
    // Agregar indicadores de continuación si se preserva el formato
    if (preserveFormatting && parts.length > 1) {
      return this.addContinuationIndicators(parts);
    }
    
    return parts;
  }
  
  
  /**
   * División simple por longitud respetando saltos de línea
   */
  private static simpleSplit(text: string, maxLength: number): string[] {
    const parts: string[] = [];
    let currentPart = '';
    
    // Dividir por líneas para mantener la estructura
    const lines = text.split('\n');
    
    for (const line of lines) {
      // Si agregar esta línea excede el límite
      if (currentPart.length + line.length + 1 > maxLength) {
        // Si la parte actual tiene contenido, guardarla
        if (currentPart.trim()) {
          parts.push(currentPart.trim());
          currentPart = '';
        }
        
        // Si la línea sola excede el límite, dividirla por palabras
        if (line.length > maxLength) {
          const words = line.split(/\s+/);
          let tempLine = '';
          
          for (const word of words) {
            if (tempLine.length + word.length + 1 > maxLength) {
              if (tempLine) {
                parts.push(tempLine.trim());
                tempLine = word;
              } else {
                // Palabra muy larga, añadirla tal cual
                parts.push(word);
              }
            } else {
              tempLine += (tempLine ? ' ' : '') + word;
            }
          }
          
          if (tempLine) {
            currentPart = tempLine;
          }
        } else {
          currentPart = line;
        }
      } else {
        // Agregar la línea a la parte actual
        currentPart += (currentPart ? '\n' : '') + line;
      }
    }
    
    // Agregar cualquier contenido restante
    if (currentPart.trim()) {
      parts.push(currentPart.trim());
    }
    
    return parts;
  }
  
  
  /**
   * Agregar indicadores de continuación a las partes
   */
  private static addContinuationIndicators(parts: string[]): string[] {
    return parts.map((part, index) => {
      if (index === 0) {
        return part + '\n\n_(Continúa...)_';
      } else if (index === parts.length - 1) {
        return `_(Continuación ${index + 1}/${parts.length})_\n\n` + part;
      } else {
        return `_(Continuación ${index + 1}/${parts.length})_\n\n` + 
               part + '\n\n_(Continúa...)_';
      }
    });
  }
  
  /**
   * Dividir un menú sin indicadores de continuación
   */
  static splitMenu(menuText: string, maxLength: number = DEFAULT_MAX_LENGTH): string[] {
    return this.split(menuText, {
      maxLength,
      preserveFormatting: false // No agregar indicadores de continuación
    });
  }
  
  /**
   * Dividir un mensaje de chat normal con indicadores
   */
  static splitMessage(message: string, maxLength: number = DEFAULT_MAX_LENGTH): string[] {
    return this.split(message, {
      maxLength,
      preserveFormatting: true
    });
  }
}

================
File: backend/src/queues/messageQueue.ts
================
import { Queue, Worker, Job } from 'bullmq';
import IORedis from 'ioredis';
import { env } from '../common/config/envValidator';
import logger from '../common/utils/logger';
import { processMessageJob } from '../workers/messageWorker';
import { WhatsAppMessageJob } from './types';

// Redis connection configuration
const connection = {
  host: env.REDIS_HOST || 'localhost',
  port: parseInt(env.REDIS_PORT || '6380', 10),
  password: env.REDIS_PASSWORD,
};

// Create a dedicated Redis client for locking
const redisClient = new IORedis(connection);

// Single queue for all WhatsApp messages
export const messageQueue = new Queue<WhatsAppMessageJob>('whatsapp-messages', {
  connection,
  defaultJobOptions: {
    attempts: 3,
    backoff: { type: 'exponential', delay: 5000 },
    removeOnComplete: { age: 3600, count: 1000 },
    removeOnFail: { age: 24 * 3600, count: 5000 },
  },
});

logger.info('BullMQ Message Queue initialized');

// Single worker instance that handles all jobs
let messageWorker: Worker<WhatsAppMessageJob> | null = null;

// Acquire a distributed lock for a user
async function acquireUserLock(userId: string, timeoutSeconds: number = 60): Promise<boolean> {
  const lockKey = `user-lock:${userId}`;
  
  try {
    // SET key value NX EX seconds
    // NX: Only set if key doesn't exist
    // EX: Set expiry in seconds to prevent permanent locks
    const result = await redisClient.set(lockKey, 'processing', 'EX', timeoutSeconds, 'NX');
    return result === 'OK';
  } catch (error) {
    logger.error(`Failed to acquire lock for user ${userId}:`, error);
    return false;
  }
}

// Release the distributed lock for a user
async function releaseUserLock(userId: string): Promise<void> {
  const lockKey = `user-lock:${userId}`;
  
  try {
    await redisClient.del(lockKey);
  } catch (error) {
    logger.error(`Failed to release lock for user ${userId}:`, error);
  }
}

export function startMessageWorker(): void {
  if (messageWorker) {
    logger.warn('Message worker already started');
    return;
  }

  const workerConcurrency = parseInt(env.BULLMQ_WORKER_CONCURRENCY || '5', 10);
  logger.info(`Starting BullMQ worker with concurrency: ${workerConcurrency}`);

  messageWorker = new Worker<WhatsAppMessageJob>(
    'whatsapp-messages',
    async (job: Job<WhatsAppMessageJob>) => {
      const userId = job.data.from;
      let lockAcquired = false;
      
      try {
        // Try to acquire lock with exponential backoff
        let attempts = 0;
        const maxAttempts = 100; // 100 * 150ms = 15 seconds max wait
        
        while (attempts < maxAttempts) {
          lockAcquired = await acquireUserLock(userId, 300); // 5 minute timeout
          
          if (lockAcquired) {
            logger.debug(`Lock acquired for user ${userId} on attempt ${attempts + 1}`);
            break;
          }
          
          // Exponential backoff: 100ms, 200ms, 400ms... up to 2 seconds
          const delay = Math.min(100 * Math.pow(2, Math.floor(attempts / 10)), 2000);
          await new Promise(resolve => setTimeout(resolve, delay));
          attempts++;
        }
        
        if (!lockAcquired) {
          throw new Error(`Failed to acquire lock for user ${userId} after ${maxAttempts} attempts`);
        }
        
        logger.info(`Processing job ${job.id} for user ${userId}`);
        
        // Process the message
        await processMessageJob(job.data);
        
        // Small delay to ensure BullMQ completes its internal operations
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } finally {
        // Always release the lock if we acquired it
        if (lockAcquired) {
          await releaseUserLock(userId);
          logger.debug(`Lock released for user ${userId}`);
        }
      }
    },
    { 
      connection, 
      concurrency: workerConcurrency,
      lockDuration: 60000, // Increase default lock duration to 60 seconds
      lockRenewTime: 20000, // Renew lock every 20 seconds
    }
  );

  // Event handlers
  messageWorker.on('completed', (job: Job<WhatsAppMessageJob>) => {
    logger.info(`Job ${job.id} for user ${job.data.from} completed successfully`);
  });

  messageWorker.on('failed', (job: Job<WhatsAppMessageJob> | undefined, err: Error) => {
    if (job) {
      logger.error(`Job ${job.id} for user ${job.data.from} failed:`, {
        error: err.message,
        stack: err.stack,
        attempts: job.attemptsMade,
      });
    } else {
      logger.error('A job failed:', { error: err.message });
    }
  });

  messageWorker.on('error', (err: Error) => {
    logger.error('Worker error:', { error: err.message, stack: err.stack });
  });

  logger.info('BullMQ Message Worker started and listening for jobs');
}

export async function stopMessageWorker(): Promise<void> {
  if (messageWorker) {
    await messageWorker.close();
    messageWorker = null;
    
    // Close Redis client
    redisClient.disconnect();
    
    logger.info('Message worker stopped');
  }
}

================
File: backend/src/services/ai/tools/handlers/resetConversationHandler.ts
================
import { ToolHandler, ToolResponse } from '../types';
import { MessageContext } from '../../../messaging/MessageContext';
import { prisma } from '../../../../lib/prisma';
import { CONVERSATION_RESET_MESSAGE } from '../../../../common/config/predefinedMessages';
import { SyncMetadataService } from '../../../sync/SyncMetadataService';
import { TechnicalError, ErrorCode } from '../../../../common/services/errors';
import logger from '../../../../common/utils/logger';

/**
 * Handles the reset_conversation function call
 * Clears chat history and resets conversation state
 */
export const handleResetConversation: ToolHandler = async (args, context?: MessageContext): Promise<ToolResponse> => {
  logger.debug('Resetting conversation');
  
  // Get customerId from context
  const customerId = context?.customer?.id;
  if (!customerId) {
    throw new TechnicalError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Could not get customer ID from context'
    );
  }
  
  // Reset chat history immediately
  await prisma.customer.update({
    where: { id: customerId },
    data: { 
      relevantChatHistory: JSON.stringify([]),
      fullChatHistory: JSON.stringify([]),
      lastInteraction: new Date()
    }
  });
  
  // Mark for sync
  await SyncMetadataService.markForSync('Customer', customerId, 'REMOTE');
  
  // Clear context history completely
  context?.set('relevantChatHistory', []);
  context?.set('fullChatHistory', []);
  
  // Mark to skip history update
  context?.set('skipHistoryUpdate', true);
  
  // Mark that conversation is being reset to avoid welcome message
  context?.set('isResettingConversation', true);
  
  return {
    text: CONVERSATION_RESET_MESSAGE,
    isRelevant: false
  };
};

================
File: backend/src/services/ai/tools/orderAgent.tools.ts
================
/**
 * Order Agent tool definitions
 * Specialized tools for the order processing agent
 */

export function getOrderAgentTools(): any[] {
  return [
    {
      name: "map_order_items",
      description: "Mapear items del pedido con soporte completo para personalización de pizzas",
      parameters: {
        type: "object",
        properties: {
          orderItems: {
            type: "array",
            items: {
              type: "object",
              properties: {
                productId: { 
                  type: "string",
                  description: "ID del producto (ej: 'PZ' para pizza)"
                },
                variantId: { 
                  type: "string",
                  description: "ID de la variante (ej: 'PZ-V-1' para pizza grande)"
                },
                quantity: { 
                  type: "number",
                  description: "Cantidad del producto"
                },
                modifiers: { 
                  type: "array", 
                  items: { type: "string" },
                  description: "Array de IDs de modificadores generales"
                },
                pizzaCustomizations: {
                  type: "array",
                  description: "Personalizaciones de pizza con estructura detallada",
                  items: {
                    type: "object",
                    properties: {
                      customizationId: {
                        type: "string",
                        description: "ID de la personalización (ej: 'PZ-I-1' para Adelita, 'PZ-I-22' para Champiñón)"
                      },
                      half: {
                        type: "string",
                        enum: ["FULL", "HALF_1", "HALF_2"],
                        description: "En qué parte de la pizza: FULL (completa), HALF_1 (primera mitad), HALF_2 (segunda mitad)"
                      },
                      action: {
                        type: "string",
                        enum: ["ADD", "REMOVE"],
                        description: "ADD para agregar, REMOVE para quitar ingrediente"
                      }
                    },
                    required: ["customizationId", "half", "action"]
                  }
                }
              },
              required: ["productId", "quantity"]
            },
            description: `EJEMPLOS DE PIZZAS:
            
1. "Pizza Hawaiana grande":
   pizzaCustomizations: [{
     customizationId: "PZ-I-5", // FLAVOR Hawaiana
     half: "FULL",
     action: "ADD"
   }]

2. "Pizza mitad Hawaiana mitad Pepperoni":
   pizzaCustomizations: [
     { customizationId: "PZ-I-5", half: "HALF_1", action: "ADD" },
     { customizationId: "PZ-I-13", half: "HALF_2", action: "ADD" }
   ]

3. "Pizza Hawaiana con champiñones extra":
   pizzaCustomizations: [
     { customizationId: "PZ-I-5", half: "FULL", action: "ADD" },
     { customizationId: "PZ-I-22", half: "FULL", action: "ADD" }
   ]

4. "Pizza Mexicana sin chile jalapeño":
   pizzaCustomizations: [
     { customizationId: "PZ-I-12", half: "FULL", action: "ADD" },
     { customizationId: "PZ-I-23", half: "FULL", action: "REMOVE" }
   ]

5. "Pizza con pepperoni y champiñones" (sin sabor base):
   pizzaCustomizations: [
     { customizationId: "PZ-I-40", half: "FULL", action: "ADD" },
     { customizationId: "PZ-I-22", half: "FULL", action: "ADD" }
   ]`
          },
          orderType: {
            type: "string",
            enum: ["DELIVERY", "TAKE_AWAY"],
            description: "Tipo de orden: DELIVERY o TAKE_AWAY"
          },
          warnings: { 
            type: "string",
            description: "Advertencias o notas sobre el mapeo"
          }
        },
        required: ["orderItems", "orderType"]
      }
    }
  ];
}

================
File: backend/src/services/messaging/middlewares/CustomerValidationMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { prisma } from '../../../lib/prisma';
import { sendWhatsAppMessage } from '../../whatsapp';
import { BANNED_USER_MESSAGE } from '../../../common/config/predefinedMessages';
import { ConfigService } from '../../../services/config/ConfigService';
import { SyncMetadataService } from '../../../services/sync/SyncMetadataService';
import logger from '../../../common/utils/logger';

export class CustomerValidationMiddleware implements MessageMiddleware {
  name = 'CustomerValidationMiddleware';

  private removeDuplicateMessages(messages: any[]): any[] {
    if (messages.length === 0) return messages;
    
    const cleaned: any[] = [messages[0]];
    
    for (let i = 1; i < messages.length; i++) {
      const current = messages[i];
      const previous = messages[i - 1];
      
      // Si el mensaje actual es diferente al anterior, lo agregamos
      if (current.role !== previous.role || current.content !== previous.content) {
        cleaned.push(current);
      }
    }
    
    return cleaned;
  }

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      const whatsappPhoneNumber = context.message.from;
      
      // Obtener o crear cliente con sus direcciones
      let customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber },
        include: { addresses: true }
      });

      if (!customer) {
        // Crear nuevo cliente
        customer = await prisma.customer.create({
          data: {
            whatsappPhoneNumber,
            lastInteraction: new Date(),
            fullChatHistory: [],
            relevantChatHistory: []
          },
          include: { addresses: true }
        });
        
        // Mark for sync
        await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
        
        // Marcar como cliente nuevo para mensaje de bienvenida
        context.set('isNewCustomer', true);
        context.set('hasNoAddress', true);
      } else {
        // Verificar si el cliente está baneado
        if (customer.isBanned) {
          logger.warn(`Banned customer ${whatsappPhoneNumber} tried to send a message`);
          const config = ConfigService.getConfig();
          const bannedMessage = BANNED_USER_MESSAGE(config);
          await sendWhatsAppMessage(whatsappPhoneNumber, bannedMessage);
          context.stop();
          return context;
        }
        
        // Verificar si el cliente tiene direcciones activas
        const activeAddresses = customer.addresses.filter(addr => !addr.deletedAt);
        if (activeAddresses.length === 0) {
          context.set('hasNoAddress', true);
          logger.info(`Customer ${whatsappPhoneNumber} has no active addresses`);
        }
      }

      context.setCustomer(customer);
      
      // Cargar historial de chat
      const fullChatHistory = Array.isArray(customer.fullChatHistory)
        ? customer.fullChatHistory
        : JSON.parse((customer.fullChatHistory as string) || "[]");
      
      let relevantChatHistory = Array.isArray(customer.relevantChatHistory)
        ? customer.relevantChatHistory
        : JSON.parse((customer.relevantChatHistory as string) || "[]");
      
      // Limpiar duplicados consecutivos en el historial relevante
      relevantChatHistory = this.removeDuplicateMessages(relevantChatHistory);
      
      // Limitar el historial relevante a los últimos 20 mensajes
      if (relevantChatHistory.length > 20) {
        relevantChatHistory = relevantChatHistory.slice(-20);
        logger.debug(`Historial relevante limitado a los últimos 20 mensajes (de ${relevantChatHistory.length} total)`);
      }
      
      context.set('fullChatHistory', fullChatHistory);
      context.set('relevantChatHistory', relevantChatHistory);
      
      // Verificar si es una conversación nueva (más de 1 hora desde la última interacción)
      const isNewConversation = customer.lastInteraction && 
        (new Date().getTime() - new Date(customer.lastInteraction).getTime() > 60 * 60 * 1000) ||
        relevantChatHistory.length === 0;
      
      if (isNewConversation && !context.get('isNewCustomer')) {
        context.set('isNewConversation', true);
      }

      return context;
    } catch (error) {
      logger.error('Error in CustomerValidationMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/middlewares/MessageTypeMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } from '../../whatsapp';
import { WELCOME_MESSAGE_INTERACTIVE, UNSUPPORTED_MESSAGE_TYPE } from '../../../common/config/predefinedMessages';
import { ConfigService } from '../../../services/config/ConfigService';
import logger from '../../../common/utils/logger';

export class MessageTypeMiddleware implements MessageMiddleware {
  name = 'MessageTypeMiddleware';

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      // Verificar si es un cliente nuevo o conversación nueva que necesita mensaje de bienvenida
      const customer = context.customer;
      const isVeryNewCustomer = customer && customer.createdAt && 
        (new Date().getTime() - new Date(customer.createdAt).getTime() < 5 * 60 * 1000); // Created less than 5 minutes ago
      
      // Check if we're in the middle of updating a preOrder
      const { redisService } = await import('../../redis/RedisService');
      const updateKey = `preorder:updating:${context.message.from}`;
      const isUpdatingPreOrder = await redisService.get(updateKey);
      
      // Only send welcome if it's a new conversation (not a brand new customer who just registered)
      // and we're not in the middle of updating a preOrder
      if (context.get('isNewConversation') && !isVeryNewCustomer && !isUpdatingPreOrder) {
        const config = ConfigService.getConfig();
        const welcomeMessage = WELCOME_MESSAGE_INTERACTIVE(config);
        await sendWhatsAppInteractiveMessage(context.message.from, welcomeMessage);
      }
      
      // Validar tipo de mensaje
      const supportedTypes = ['text', 'interactive', 'audio'];
      if (!supportedTypes.includes(context.message.type)) {
        await sendWhatsAppMessage(context.message.from, UNSUPPORTED_MESSAGE_TYPE);
        context.stop();
        return context;
      }
      
      // Establecer tipo de mensaje para procesamiento
      context.set('messageType', context.message.type);
      
      // Para mensajes de audio, necesitaremos manejar la transcripción
      if (context.message.type === 'audio') {
        context.set('needsTranscription', true);
      }
      
      return context;
    } catch (error) {
      logger.error('Error in MessageTypeMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/pipeline/MessagePipeline.ts
================
import { IncomingMessage, MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { RateLimitMiddleware } from '../middlewares/RateLimitMiddleware';
import { CustomerValidationMiddleware } from '../middlewares/CustomerValidationMiddleware';
import { RestaurantHoursMiddleware } from '../middlewares/RestaurantHoursMiddleware';
import { AddressRequiredMiddleware } from '../middlewares/AddressRequiredMiddleware';
import { MessageTypeMiddleware } from '../middlewares/MessageTypeMiddleware';
import { MessageProcessingMiddleware } from '../middlewares/MessageProcessingMiddleware';
import { prisma } from '../../../lib/prisma';
import logger from '../../../common/utils/logger';
import { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } from '../../whatsapp';
import { SyncMetadataService } from '../../../services/sync/SyncMetadataService';

export class MessagePipeline {
  private middlewares: MessageMiddleware[] = [];
  
  constructor() {
    // Inicializar middlewares en orden
    this.middlewares = [
      new RateLimitMiddleware(),
      new CustomerValidationMiddleware(),
      new RestaurantHoursMiddleware(), // Verifica horarios antes de cualquier procesamiento
      new AddressRequiredMiddleware(), // Bloquea si no hay dirección
      new MessageTypeMiddleware(),
      new MessageProcessingMiddleware(), // Lógica principal de procesamiento
    ];
  }

  async process(message: IncomingMessage): Promise<void> {
    const context = new MessageContext(message);
    
    try {
      // Ejecutar todos los middlewares
      for (const middleware of this.middlewares) {
        await middleware.process(context);
        
        if (context.shouldStop) {
          break;
        }
      }
      
      // El procesamiento ahora se maneja por middlewares
      
      // Enviar respuestas
      await this.sendResponses(context);
      
      // Actualizar historial de chat del cliente
      await this.updateChatHistory(context);
      
    } catch (error) {
      logger.error('Error in MessagePipeline:', error);
      await this.handleError(context, error as Error);
    }
  }
  
  
  private async sendResponses(context: MessageContext): Promise<void> {
    for (const response of context.responses) {
      if (!response.sendToWhatsApp) continue;
      
      try {
        if (response.text) {
          // La utilidad messageSender se encarga de dividir mensajes largos automáticamente
          await sendWhatsAppMessage(context.message.from, response.text);
        }
        
        if (response.interactiveMessage) {
          await sendWhatsAppInteractiveMessage(
            context.message.from, 
            response.interactiveMessage
          );
        }
        
        if (response.confirmationMessage) {
          await sendWhatsAppMessage(context.message.from, response.confirmationMessage);
        }
      } catch (error) {
        logger.error('Error sending response:', error);
      }
    }
  }
  
  private async updateChatHistory(context: MessageContext): Promise<void> {
    if (!context.customer || context.shouldStop) return;
    
    // Si se marca skipHistoryUpdate, no guardar nada en el historial
    if (context.get('skipHistoryUpdate')) {
      logger.debug('Skipping history update due to skipHistoryUpdate flag');
      return;
    }
    
    const fullChatHistory = context.get('fullChatHistory') || [];
    let relevantChatHistory = context.get('relevantChatHistory') || [];
    
    // Agregar mensaje del usuario al historial
    fullChatHistory.push({
      role: 'user',
      content: context.message.text?.body || '[Non-text message]',
      timestamp: new Date()
    });
    
    // Siempre agregar al historial relevante
    relevantChatHistory.push({
      role: 'user',
      content: context.message.text?.body || '[Non-text message]',
      timestamp: new Date()
    });
    
    // Agregar respuestas al historial
    for (const response of context.responses) {
      if (response.text || response.historyMarker) {
        // Para el historial completo, siempre usar el texto completo
        if (response.text) {
          fullChatHistory.push({
            role: 'assistant',
            content: response.text,
            timestamp: new Date()
          });
        }
        
        // Para el historial relevante
        if (response.isRelevant || response.historyMarker) {
          // Si hay marcador, usarlo siempre. Si no, usar el texto solo si es relevante
          const contentToSave = response.historyMarker || (response.isRelevant ? response.text : null);
          if (contentToSave) {
            relevantChatHistory.push({
              role: 'assistant',
              content: contentToSave,
              timestamp: new Date()
            });
          }
        }
      }
    }
    
    // Limitar el historial relevante a los últimos 20 mensajes antes de guardar
    if (relevantChatHistory.length > 20) {
      relevantChatHistory = relevantChatHistory.slice(-20);
    }
    
    // Actualizar cliente en la base de datos
    await prisma.customer.update({
      where: { id: context.customer.id },
      data: {
        fullChatHistory: JSON.stringify(fullChatHistory),
        relevantChatHistory: JSON.stringify(relevantChatHistory),
        lastInteraction: new Date()
      }
    });
    
    // Mark for sync
    await SyncMetadataService.markForSync('Customer', context.customer.id, 'REMOTE');
  }
  
  private async handleError(context: MessageContext, error: Error): Promise<void> {
    logger.error('Pipeline error:', error);
    
    try {
      await sendWhatsAppMessage(
        context.message.from,
        'Lo siento, ocurrió un error procesando tu mensaje. Por favor intenta de nuevo.'
      );
    } catch (sendError) {
      logger.error('Error sending error message:', sendError);
    }
  }
  
  // Método para agregar middlewares personalizados
  addMiddleware(middleware: MessageMiddleware, index?: number): void {
    if (index !== undefined) {
      this.middlewares.splice(index, 0, middleware);
    } else {
      this.middlewares.push(middleware);
    }
  }
  
}

================
File: backend/src/services/sync/SyncNotificationService.ts
================
import { Server as SocketIOServer } from 'socket.io';
import logger from '../../common/utils/logger';
import { prisma } from '../../lib/prisma';
import { env } from '../../common/config/envValidator';

export class SyncNotificationService {
  private static io: SocketIOServer | null = null;
  private static connectedClients = new Map<string, string>(); // socketId -> apiKey

  /**
   * Initialize WebSocket server for real-time notifications
   */
  static initialize(io: SocketIOServer) {
    this.io = io;
    
    // Create sync namespace
    const syncNamespace = io.of('/sync');
    
    syncNamespace.use(async (socket, next) => {
      try {
        const apiKey = socket.handshake.auth.apiKey;
        
        if (!apiKey) {
          return next(new Error('API key required'));
        }
        
        // Validate API key
        if (!env.CLOUD_API_KEY || apiKey !== env.CLOUD_API_KEY) {
          return next(new Error('Invalid API key'));
        }
        
        // Store client connection
        this.connectedClients.set(socket.id, apiKey);
        next();
      } catch (error) {
        next(new Error('Authentication failed'));
      }
    });
    
    syncNamespace.on('connection', (socket) => {
      logger.info(`Local backend connected via WebSocket: ${socket.id}`);
      
      socket.on('disconnect', () => {
        logger.info(`Local backend disconnected: ${socket.id}`);
        this.connectedClients.delete(socket.id);
      });
      
      // Client can request immediate sync
      socket.on('sync:orders', async () => {
        // Get pending order IDs from sync metadata
        const pendingMeta = await prisma.syncMetadata.findMany({
          where: {
            entityType: 'Order',
            syncPending: true
          },
          select: { entityId: true }
        });
        
        const orderIds = pendingMeta.map(m => m.entityId);
        
        const pendingOrders = orderIds.length > 0 ? await prisma.order.findMany({
          where: {
            id: { in: orderIds },
            isFromWhatsApp: true
          }
        }) : [];
        
        socket.emit('orders:pending', {
          count: pendingOrders.length,
          orders: pendingOrders
        });
      });
    });
    
    logger.info('WebSocket sync notification service initialized');
  }
  
  /**
   * Notify all connected local backends about new order
   */
  static async notifyNewOrder(orderId: string) {
    if (!this.io) {
      logger.warn('WebSocket not initialized, cannot send notification');
      return;
    }
    
    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: {
        customer: true,
        orderItems: true,
        deliveryInfo: true
      }
    });
    
    if (!order) return;
    
    // Notify all connected clients
    this.io.of('/sync').emit('order:new', {
      orderId: order.id,
      orderType: order.orderType,
      customerName: `${order.customer.firstName || ''} ${order.customer.lastName || ''}`.trim(),
      total: order.total,
      createdAt: order.createdAt
    });
    
    logger.info(`Notified ${this.connectedClients.size} local backends about new order ${orderId}`);
  }
  
  /**
   * Check if any local backend is connected
   */
  static isAnyClientConnected(): boolean {
    return this.connectedClients.size > 0;
  }
  
  /**
   * Get connected clients info
   */
  static getConnectedClients() {
    return Array.from(this.connectedClients.entries()).map(([socketId, apiKey]) => ({
      socketId,
      apiKeyPrefix: apiKey.substring(0, 10) + '...'
    }));
  }
}

================
File: backend/src/services/whatsapp/WhatsAppService.ts
================
import { Request, Response } from 'express';
import axios from 'axios';
import { prisma } from '../../lib/prisma';
import logger from '../../common/utils/logger';
import { env } from '../../common/config/envValidator';
import { ExternalServiceError, ErrorCode } from '../../common/services/errors';
import { MessageSplitter } from '../../common/utils/messageSplitter';
import { messageQueue } from '../../queues/messageQueue';
import { WhatsAppMessageJob } from '../../queues/types';

export class WhatsAppService {
  private static readonly WHATSAPP_API_URL = 'https://graph.facebook.com/v17.0';
  private static readonly PHONE_NUMBER_ID = env.WHATSAPP_PHONE_NUMBER_MESSAGING_ID;
  private static readonly ACCESS_TOKEN = env.WHATSAPP_ACCESS_TOKEN;
  private static readonly VERIFY_TOKEN = env.WHATSAPP_VERIFY_TOKEN;
  private static readonly MAX_MESSAGE_LENGTH = 4000; // WhatsApp message length limit with margin

  static verifyWebhook(query: any): { verified: boolean; challenge?: string } {
    const mode = query['hub.mode'];
    const token = query['hub.verify_token'];
    const challenge = query['hub.challenge'];

    if (mode && token) {
      if (mode === 'subscribe' && token === this.VERIFY_TOKEN) {
        logger.info('Webhook verified');
        return { verified: true, challenge };
      }
    }
    
    return { verified: false };
  }

  static async handleWebhook(req: Request, res: Response): Promise<void> {
    const body = JSON.parse(req.body.toString());
    
    // Process messages asynchronously to respond quickly to WhatsApp
    if (body.entry && body.entry.length > 0) {
      // Don't await - process in background to respond immediately
      this.processWebhookMessages(body).catch(error => {
        logger.error('Error processing WhatsApp webhook messages:', error);
      });
    }
    
    // Always respond 200 immediately to WhatsApp to prevent retries
    res.sendStatus(200);
  }

  private static async processWebhookMessages(body: any): Promise<void> {
    for (const entry of body.entry) {
      if (entry.changes && entry.changes.length > 0) {
        for (const change of entry.changes) {
          if (change.value.messages && change.value.messages.length > 0) {
            for (const message of change.value.messages) {
              await this.processIncomingMessage(message);
            }
          }
        }
      }
    }
  }

  private static async processIncomingMessage(message: any): Promise<void> {
    try {
      const messageId = message.id;
      const from = message.from;
      
      // Check if message already processed
      const existingLog = await prisma.messageLog.findUnique({
        where: { messageId }
      });
      
      if (existingLog?.processed) {
        logger.info(`Message ${messageId} already processed, skipping queue`);
        return;
      }
      
      // Mark as processed to prevent duplicate processing
      await prisma.messageLog.upsert({
        where: { messageId },
        update: { processed: true },
        create: { messageId, processed: true }
      });
      
      // Prepare job data
      const jobData: WhatsAppMessageJob = {
        id: message.id,
        from: message.from,
        type: message.type,
        timestamp: message.timestamp,
        text: message.text,
        interactive: message.interactive,
        audio: message.audio
      };
      
      // Enqueue message for async processing
      // Note: For sequential processing per user, we'll use a different approach
      await messageQueue.add(`msg-${from}`, jobData, {
        jobId: messageId, // Use WhatsApp message ID for deduplication
      });
      
      logger.info(`Message ${messageId} from ${from} enqueued for processing`);
      
    } catch (error) {
      logger.error('Error enqueuing incoming message:', error);
    }
  }

  static async sendMessage(to: string, message: string): Promise<{ success: boolean; messageId?: string; error?: string }> {
    try {
      const response = await axios.post(
        `${this.WHATSAPP_API_URL}/${this.PHONE_NUMBER_ID}/messages`,
        {
          messaging_product: 'whatsapp',
          to,
          type: 'text',
          text: { body: message }
        },
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      logger.debug(`Full message sent to ${to}:`, message);
      logger.info(`Message sent to ${to} (${message.length} chars)`);
      return { success: true, messageId: response.data.messages[0].id };
    } catch (error: any) {
      logger.error('Error sending WhatsApp message:', error.response?.data || error.message);
      return { success: false, error: error.message };
    }
  }

  static async sendInteractiveMessage(to: string, interactive: any, contextMessageId?: string): Promise<string> {
    try {
      const payload: any = {
        messaging_product: 'whatsapp',
        to,
        type: 'interactive',
        interactive
      };

      if (contextMessageId) {
        payload.context = { message_id: contextMessageId };
      }

      const response = await axios.post(
        `${this.WHATSAPP_API_URL}/${this.PHONE_NUMBER_ID}/messages`,
        payload,
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      const messageType = interactive.type || 'interactive';
      const buttonText = interactive.action?.button || interactive.action?.buttons?.[0]?.reply?.title || '';
      logger.info(`Interactive message (${messageType}) sent to ${to}${buttonText ? `: "${buttonText}"` : ''}`);
      return response.data.messages[0].id;
    } catch (error: any) {
      logger.error('Error sending interactive message:', error.response?.data || error.message);
      throw new ExternalServiceError(
        ErrorCode.WHATSAPP_ERROR,
        'Failed to send interactive message',
        { metadata: { to, error: error.message } }
      );
    }
  }

  static async getMediaUrl(mediaId: string): Promise<string | null> {
    try {
      const response = await axios.get(
        `${this.WHATSAPP_API_URL}/${mediaId}`,
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`
          }
        }
      );
      
      return response.data.url;
    } catch (error: any) {
      logger.error('Error getting media URL:', error.response?.data || error.message);
      return null;
    }
  }

  static async downloadMedia(mediaUrl: string): Promise<Buffer | null> {
    try {
      const response = await axios.get(mediaUrl, {
        headers: {
          'Authorization': `Bearer ${this.ACCESS_TOKEN}`
        },
        responseType: 'arraybuffer'
      });

      return Buffer.from(response.data);
    } catch (error: any) {
      logger.error('Error downloading media:', error.response?.data || error.message);
      return null;
    }
  }

  static async markMessageAsRead(messageId: string): Promise<boolean> {
    try {
      await axios.post(
        `${this.WHATSAPP_API_URL}/${this.PHONE_NUMBER_ID}/messages`,
        {
          messaging_product: 'whatsapp',
          status: 'read',
          message_id: messageId
        },
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      return true;
    } catch (error: any) {
      logger.error('Error marking message as read:', error.response?.data || error.message);
      return false;
    }
  }

  static async sendMessageWithUrlButton(
    to: string, 
    headerText: string,
    bodyText: string, 
    buttonText: string, 
    url: string,
    footerText?: string
  ): Promise<boolean> {
    try {
      const interactive = {
        type: "cta_url",
        header: {
          type: "text",
          text: headerText
        },
        body: {
          text: bodyText
        },
        footer: footerText ? { text: footerText } : undefined,
        action: {
          name: "cta_url",
          parameters: {
            display_text: buttonText,
            url: url
          }
        }
      };

      await this.sendInteractiveMessage(to, interactive);
      return true;
    } catch (error) {
      logger.error('Error sending message with URL button:', error);
      return false;
    }
  }

  /**
   * Send a WhatsApp message, automatically splitting long messages
   */
  static async sendWhatsAppMessage(to: string, message: string): Promise<boolean> {
    try {
      if (message.length <= this.MAX_MESSAGE_LENGTH) {
        const result = await this.sendMessage(to, message);
        if (!result.success) {
          throw new ExternalServiceError(
            ErrorCode.WHATSAPP_ERROR,
            result.error || 'Failed to send message',
            { metadata: { to, messageLength: message.length } }
          );
        }
        return true;
      }
      
      // Split long message using unified utility
      const parts = MessageSplitter.splitMessage(message, this.MAX_MESSAGE_LENGTH);
      logger.debug(`Message split into ${parts.length} parts`);
      
      // Send each part
      for (const part of parts) {
        const result = await this.sendMessage(to, part);
        if (!result.success) {
          throw new ExternalServiceError(
            ErrorCode.WHATSAPP_ERROR,
            result.error || 'Failed to send message part',
            { metadata: { to, partLength: part.length } }
          );
        }
      }
      
      return true;
    } catch (error) {
      logger.error('Error sending WhatsApp message:', error);
      return false;
    }
  }

}

================
File: backend/src/startup/embeddingInitializer.ts
================
import { EmbeddingManager } from '../services/sync/EmbeddingManager';
import logger from '../common/utils/logger';

/**
 * Initialize embeddings on server startup
 * Uses EmbeddingManager for intelligent embedding lifecycle management
 */
export async function initializeEmbeddings(): Promise<void> {
  try {
    logger.info('🚀 Initializing embedding manager...');
    await EmbeddingManager.initialize();
  } catch (error) {
    logger.error('Failed to initialize embedding manager:', error);
    // Don't throw - we don't want to prevent server startup if embeddings fail
    logger.warn('⚠️  Server starting without embedding manager - semantic search may not work properly');
  }
}

================
File: backend/src/whatsapp/handlers/orders/index.ts
================
/**
 * Order handlers index
 * Exports all order-related handlers
 */

// Order confirmation moved to OrderManagementService
// Order cancellation functionality has been removed

export {
  generateProductSummary,
  generateOrderSummary
} from './orderFormatters';

================
File: backend/src/common/types/index.ts
================
/**
 * Central type export file
 * All common types should be imported from here
 */

// Order types
export * from './order.types';
export * from './order-item.types';
export * from './preorder.types';

// Menu types
export * from './menu';

// Restaurant types
export * from './restaurant';

// WhatsApp & Message types
export * from './whatsapp-messages.types';

// Response types are now in messaging/types/responses

// Agent types removed - using unified agent now

// Service types
export * from './services.types';

// Re-export commonly used Prisma types
export type {
  Customer,
  Order,
  OrderType,
  OrderStatus,
  Product,
  ProductVariant,
  Category,
  Subcategory,
  ProductModifier,
  ModifierGroup,
  PizzaCustomization,
  PizzaConfiguration,
  PizzaHalf,
  CustomizationAction,
  CustomizationType,
  PreOrder,
  RestaurantConfig,
  BusinessHours
} from '@prisma/client';

================
File: backend/src/common/types/order.types.ts
================
export interface FormattedOrder {
  id?: string;
  shiftOrderNumber?: number;
  orderType?: string;
  customerId?: string;
  phoneNumber: string;
  deliveryInfo: string;
  totalPrice: number;
  createdAt: string;
  scheduledDeliveryTime: string | null;
  estimatedDeliveryTime?: string;
  products: FormattedOrderProduct[];
}

export interface FormattedOrderProduct {
  name: string;
  quantity: number;
  price: number;
  modifiers: { name: string; price: number }[];
  pizzaCustomizations?: { 
    half: string; 
    name: string; 
    action?: string; 
    type?: string; 
    ingredients?: string;
  }[];
  comments?: string;
}

export interface OrderSummaryResult {
  formattedOrder: FormattedOrder;
  orderSummary: string;
}

================
File: backend/src/common/types/services.types.ts
================
/**
 * Service-specific types that are used across multiple services
 */

// Delivery Info types (compatible with DeliveryInfo model)
export interface DeliveryInfoInput {
  fullAddress?: string | null;
  street?: string | null;
  number?: string | null;
  interiorNumber?: string | null;
  neighborhood?: string | null;
  city?: string | null;
  state?: string | null;
  zipCode?: string | null;
  country?: string | null;
  recipientName?: string | null;
  recipientPhone?: string | null;
  deliveryInstructions?: string | null;
  latitude?: number | null;
  longitude?: number | null;
  isDefault?: boolean;
}

// AI Context types
export enum ContextType {
  NEW_ORDER = "nuevo_pedido",
  CUSTOMER_SERVICE = "servicio_cliente",
  GENERAL_INQUIRY = "consulta_general",
  MENU_INQUIRY = "consulta_menu",
  COMPLAINT = "queja",
  UNKNOWN = "desconocido"
}

// Order Management types
export interface OrderCreationResult {
  order: any;
  formattedOrder: any;
  message: string;
}

export interface PreOrderCreationResult {
  preOrderId: number;
  products: any[];
  subtotal: number;
  total: number;
  estimatedDeliveryTime: number;
}

================
File: backend/src/services/ai/AgentService.ts
================
import { GeminiService } from './GeminiService';
import logger from '../../common/utils/logger';
import { ProductService } from '../products/ProductService';
import { getGeneralAgentPrompt, getOrderAgentPrompt } from './prompts';
import { getGeneralAgentTools, getOrderAgentTools } from './tools';
import { MenuSearchService } from './MenuSearchService';

// Definiciones de tipos para el nuevo SDK
interface Content {
  role: 'user' | 'model';
  parts: Array<{ text: string } | { inlineData: { mimeType: string; data: string } }>;
}

// Contexto para el agente de órdenes
interface OrderContext {
  itemsSummary: string;
  relevantMenu: string;
  orderType?: string;
}

/**
 * Servicio de AI con agentes especializados
 */
export class AgentService {
  /**
   * Procesa mensajes con el agente general
   */
  static async processMessage(
    messages: Content[]
  ): Promise<any> {
    try {
      // Usar el agente general para detectar intención
      const systemInstruction = await this.getGeneralAgentInstruction();
      const tools = getGeneralAgentTools();
      
      // Log completo de lo que recibe el modelo
      logger.debug('=== COMPLETE AI MODEL INPUT ===');
      logger.debug(`System Instruction:\n${systemInstruction}`);
      (logger as any).json('Messages:', messages);
      (logger as any).json('Tools:', tools.map(t => ({
        name: t.name,
        description: t.description,
        parameters: t.parameters
      })));
      logger.debug('=== END AI MODEL INPUT ===');
      
      const response = await GeminiService.generateContentWithHistory(
        messages,
        systemInstruction,
        tools
      );
      return response;
    } catch (error) {
      logger.error('AgentService: Error procesando mensaje', error);
      throw error;
    }
  }
  
  /**
   * Procesa una orden con el agente especializado
   */
  static async processOrderMapping(
    orderContext: OrderContext
  ): Promise<any> {
    try {
      
      // Crear mensaje para el agente de órdenes
      const messages: Content[] = [{
        role: 'user',
        parts: [{ 
          text: `ORDEN: ${orderContext.itemsSummary}\nTIPO: ${orderContext.orderType || 'DELIVERY'}` 
        }]
      }];
      
      const systemInstruction = this.getOrderAgentInstruction(orderContext.relevantMenu);
      const tools = getOrderAgentTools();
      
      // Configurar modo ANY para forzar la ejecución de función
      const toolConfig = {
        functionCallingConfig: {
          mode: 'ANY',
          allowedFunctionNames: ['map_order_items']
        }
      };
      
      // Log completo de lo que recibe el modelo de órdenes
      logger.debug('=== COMPLETE ORDER AGENT INPUT ===');
      logger.debug('System Instruction includes menu:');
      logger.debug(`Order: ${orderContext.itemsSummary}`);
      logger.debug(`Type: ${orderContext.orderType || 'DELIVERY'}`);
      try {
        const menuParsed = JSON.parse(orderContext.relevantMenu);
        (logger as any).json('Relevant Menu:', menuParsed);
      } catch (e) {
        logger.debug(`Relevant Menu: ${orderContext.relevantMenu}`);
      }
      logger.debug('=== END ORDER AGENT INPUT ===');
      
      logger.info('Calling Gemini API for order processing...');
      
      const response = await GeminiService.generateContentWithHistory(
        messages,
        systemInstruction,
        tools,
        toolConfig
      );
      
      return response;
    } catch (error) {
      logger.error('OrderAgent: Error procesando orden', error);
      throw error;
    }
  }
  
  /**
   * Instrucciones para el agente general
   */
  private static async getGeneralAgentInstruction(): Promise<string> {
    let menuJson = '{}';
    let restaurantName = 'nuestro restaurante';
    
    try {
      // Obtener estructura del menú
      const menuStructure = await ProductService.getMenuStructureForAI();
      menuJson = JSON.stringify(menuStructure, null, 2);
    } catch (error) {
      logger.error('Error obteniendo estructura del menú para AI:', error);
    }
    
    try {
      // Obtener configuración del restaurante
      const { RestaurantService } = await import('../restaurant/RestaurantService');
      const restaurantConfig = await RestaurantService.getConfig();
      restaurantName = restaurantConfig.restaurantName;
    } catch (error) {
      logger.error('Error obteniendo configuración del restaurante:', error);
    }
    
    return getGeneralAgentPrompt(menuJson, restaurantName);
  }
  
  /**
   * Instrucciones para el agente de órdenes
   */
  private static getOrderAgentInstruction(relevantMenu: string): string {
    return getOrderAgentPrompt(relevantMenu);
  }
  
  /**
   * Obtiene el menú relevante basado en las palabras clave (con IDs)
   * Delega a MenuSearchService para la lógica de búsqueda
   */
  static async getRelevantMenu(itemsSummary: string): Promise<string> {
    return MenuSearchService.getRelevantMenu(itemsSummary);
  }
}

================
File: backend/src/services/messaging/TextProcessingService.ts
================
import { MessageContext } from './MessageContext';
import { AgentService } from '../ai';
import { PreOrderWorkflowService } from '../orders/preOrderWorkflowService';
import { sendWhatsAppMessage } from '../whatsapp';
import { getToolHandler } from '../ai/tools/toolHandlers';
import logger from '../../common/utils/logger';
import { ProcessedOrderData } from '../../common/types/preorder.types';
import { ValidationError, BusinessLogicError, TechnicalError, ErrorCode } from '../../common/services/errors';

// Type definition for content
interface Content {
  role: 'user' | 'model';
  parts: Array<{ text: string }>;
}

export class TextProcessingService {
  /**
   * Process text input through the AI agent system
   * This can be called by any strategy that needs to process text
   */
  static async processTextMessage(
    text: string,
    context: MessageContext
  ): Promise<void> {
    if (!context.customer) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer not found in context'
      );
    }

    let relevantChatHistory = context.get('relevantChatHistory') || [];
    
    // Create a working copy that includes the current message
    const workingHistory = [...relevantChatHistory];
    workingHistory.push({ role: "user", content: text });
    
    try {
      // Process with AI - use workingHistory that includes the current message
      const messages: Content[] = workingHistory.map(
        ({ role, content }: any) => ({
          role: role === "assistant" ? "model" : role,
          parts: [{ text: content }]
        })
      );
      
      logger.debug('Calling AgentService.processMessage with messages:', messages);
      const response = await AgentService.processMessage(messages);
      logger.debug('AgentService response:', JSON.stringify(response, null, 2));
      
      // Convert response to expected format
      const aiResponses = await this.processGeminiResponse(response, context);
      
      // Process AI responses
      for (const response of aiResponses) {
        if (response.text) {
          context.addResponse({
            text: response.text,
            sendToWhatsApp: response.sendToWhatsApp !== false,
            isRelevant: response.isRelevant !== false,
            historyMarker: response.historyMarker
          });
        }
        
        if (response.urlButton) {
          // Handle URL button message
          const { sendMessageWithUrlButton } = await import('../whatsapp');
          await sendMessageWithUrlButton(
            context.message.from,
            response.urlButton.title,
            response.urlButton.body,
            response.urlButton.buttonText,
            response.urlButton.url
          );
          
          // Add to context so it's saved in history
          context.addResponse({
            text: `${response.urlButton.title}\n\n${response.urlButton.body}`,
            sendToWhatsApp: false, // Already sent with sendMessageWithUrlButton
            isRelevant: response.isRelevant !== false
          });
        }
        
        if (response.preprocessedContent) {
          await this.handlePreprocessedContent(context, response.preprocessedContent);
        }
        
        if (response.confirmationMessage) {
          context.addResponse({
            text: response.confirmationMessage,
            sendToWhatsApp: true,
            isRelevant: true
          });
        }
      }
    } catch (error) {
      logger.error("Error processing text message:", error);
      context.addResponse({
        text: "Error al procesar la solicitud: " + (error as Error).message,
        sendToWhatsApp: true,
        isRelevant: true
      });
    }
  }

  private static async handlePreprocessedContent(context: MessageContext, preprocessedContent: any): Promise<void> {
    try {
      // Handle warnings
      if (preprocessedContent.warnings && preprocessedContent.warnings.length > 0) {
        const warningMessage = "📝 Observaciones:\n" + preprocessedContent.warnings.join("\n");
        await sendWhatsAppMessage(context.message.from, warningMessage);
        
        // Add observations to context so they're saved in relevant history
        context.addResponse({
          text: warningMessage,
          sendToWhatsApp: false, // Already sent with sendWhatsAppMessage
          isRelevant: true
        });
      }
      
      // Prepare order data
      const orderData: ProcessedOrderData = {
        orderItems: preprocessedContent.orderItems,
        orderType: preprocessedContent.orderType,
        scheduledAt: preprocessedContent.scheduledAt,
      };
      
      // Use the PreOrderWorkflowService
      const workflowResult = await PreOrderWorkflowService.createAndNotify({
        orderData,
        customerId: context.customer!.id,
        whatsappNumber: context.message.from,
      });
      
      // Store the action token in context for potential tracking
      context.set('lastPreOrderToken', workflowResult.actionToken);
      
      // Mark that interactive response was already sent by the workflow
      context.set('interactiveResponseSent', true);
    } catch (error: any) {
      logger.error('Error creating preorder:', error);
      
      // For known business errors, use the direct message
      if (error instanceof BusinessLogicError || error instanceof ValidationError) {
        context.addResponse({
          text: error.message,
          isRelevant: true,
          sendToWhatsApp: true
        });
        return;
      }
      
      // For other errors, use generic message
      const genericMessage = error instanceof TechnicalError 
        ? 'Lo siento, hubo un problema técnico. Por favor intenta de nuevo más tarde.'
        : 'Lo siento, hubo un error al procesar tu pedido. Por favor intenta de nuevo.';
      
      context.addResponse({
        text: genericMessage,
        isRelevant: true,
        sendToWhatsApp: true
      });
    }
  }

  /**
   * Process Gemini API response and extract meaningful content
   * This method is public so it can be used by tool handlers that need it
   */
  public static async processGeminiResponse(response: any, context?: MessageContext): Promise<any[]> {
    logger.debug('=== processGeminiResponse DEBUG ===');
    logger.debug('Response type:', typeof response);
    logger.debug('Response keys:', response ? Object.keys(response) : 'null');
    
    const responses: any[] = [];
    
    // Verify valid response structure
    if (!response?.candidates?.[0]?.content?.parts) {
      logger.error('Invalid response structure from Gemini API');
      
      const errorMessage = response?.error?.message || 
                          response?.candidates?.[0]?.finishReason || 
                          "Lo siento, hubo un problema al procesar tu solicitud. Por favor intenta de nuevo.";
      
      return [{
        text: errorMessage,
        isRelevant: true
      }];
    }
    
    const parts = response.candidates[0].content.parts;
    
    // Process each part of the response
    for (const part of parts) {
      if (part.text) {
        // Simple text response
        responses.push({
          text: part.text,
          isRelevant: true,
        });
      } else if (part.functionCall) {
        // Process function calls
        const functionResponse = await this.handleFunctionCall(
          part.functionCall.name,
          part.functionCall.args,
          context
        );
        if (functionResponse) {
          // If function returns an array (multiple messages), add all
          if (Array.isArray(functionResponse)) {
            responses.push(...functionResponse);
          } else {
            responses.push(functionResponse);
          }
        }
      }
    }
    
    logger.debug(`Total responses processed: ${responses.length}`);
    logger.debug('=== End processGeminiResponse DEBUG ===');
    
    return responses;
  }

  private static async handleFunctionCall(name: string, args: any, context?: MessageContext): Promise<any | null> {
    logger.debug(`=== handleFunctionCall: ${name} ===`);
    
    // Get the handler for this function
    const handler = getToolHandler(name);
    
    if (handler) {
      try {
        const result = await handler(args, context);
        logger.debug(`Handler ${name} completed successfully`);
        return result;
      } catch (error) {
        logger.error(`Error in handler ${name}:`, error);
        
        // Return a formatted error response instead of throwing
        return {
          text: '😔 Lo siento, hubo un problema al procesar tu solicitud. Por favor, intenta de nuevo.',
          isRelevant: true
        };
      }
    }
    
    logger.warn(`Unrecognized function call: ${name}`);
    return null;
  }
}

================
File: backend/src/services/orders/services/ProductCalculationService.ts
================
import { prisma } from '../../../lib/prisma';
import { ValidationError, ErrorCode } from "../../../common/services/errors";
import logger from "../../../common/utils/logger";
import { BaseOrderItem, CalculatedOrderItem } from "../../../common/types";

export class ProductCalculationService {
  /**
   * Calculate items and prices for an order
   */
  static async calculateOrderItems(orderItems: BaseOrderItem[]): Promise<{
    items: CalculatedOrderItem[];
    subtotal: number;
    total: number;
  }> {
    const calculatedItems = await Promise.all(
      orderItems.map(async (item) => await this.calculateSingleItem(item))
    );

    const subtotal = calculatedItems.reduce((sum, item) => sum + item.totalPrice, 0);
    const total = subtotal; // For now, total = subtotal. Can add taxes, fees, etc. later

    return {
      items: calculatedItems,
      subtotal,
      total
    };
  }

  /**
   * Calculate a single order item
   */
  private static async calculateSingleItem(item: BaseOrderItem): Promise<CalculatedOrderItem> {
    logger.info("Processing item:", JSON.stringify(item, null, 2));

    let product, productVariant;
    let itemPrice = 0;
    
    logger.info(`Starting calculation for item with productId: ${item.productId}, variantId: ${item.productVariantId}`);

    // Get product and variant
    if (item.productId) {
      product = await prisma.product.findUnique({
        where: { id: item.productId }
      });

      if (!product) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Product not found: ${item.productId}`, { metadata: { productId: item.productId } });
      }
      
      // Validate that products with variants must have a variant selected
      if (product.hasVariants && !item.productVariantId) {
        // Get available variants for this product
        const variants = await prisma.productVariant.findMany({
          where: { 
            productId: product.id,
            isActive: true 
          },
          select: {
            id: true,
            name: true
          }
        });
        throw new ValidationError(
          ErrorCode.INVALID_PRODUCT, 
          `El producto "${product.name}" requiere seleccionar una variante`, 
          { 
            metadata: { 
              productId: item.productId,
              productName: product.name,
              validationFailure: 'MISSING_REQUIRED_VARIANT',
              availableVariants: variants,
              requiresVariant: true
            } 
          }
        );
      }
    }

    if (item.productVariantId) {
      productVariant = await prisma.productVariant.findUnique({
        where: { id: item.productVariantId },
        include: { product: true }
      });

      if (!productVariant) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Product variant not found: ${item.productVariantId}`, { metadata: { productVariantId: item.productVariantId } });
      }

      product = productVariant.product;
      itemPrice = productVariant.price;
      logger.info(`Found variant ${productVariant.name} with price: ${productVariant.price}`);
    } else if (product && product.price !== null) {
      // If no variant but product has price, use product price
      itemPrice = product.price;
      logger.info(`Using product price: ${product.price}`);
    }

    if (!product && !productVariant) {
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        'Either productId or productVariantId must be provided',
        { metadata: { item } }
      );
    }

    // Calculate modifiers
    const modifiers = await this.calculateModifiers(item.selectedModifiers || [], product?.id);
    itemPrice += modifiers.totalPrice;

    // Calculate pizza customizations and extra costs
    const { customizations, extraCost } = await this.calculatePizzaCustomizations(
      item.selectedPizzaCustomizations || [],
      product
    );
    
    // Add pizza extra cost to item price
    itemPrice += extraCost;

    // Total item price
    itemPrice = itemPrice * item.quantity;
    
    logger.info(`Final item price after quantity (${item.quantity}): ${itemPrice}`);

    // At this point, product is guaranteed to exist due to validation above
    if (!product) {
      throw new ValidationError(ErrorCode.INVALID_PRODUCT, 'Product not found');
    }

    // Build the calculated item with only necessary data
    const calculatedItem: CalculatedOrderItem = {
      productId: product.id,
      productVariantId: productVariant?.id || null,
      quantity: item.quantity,
      comments: item.comments,
      selectedModifiers: item.selectedModifiers,
      selectedPizzaCustomizations: item.selectedPizzaCustomizations,
      // Pricing information
      basePrice: productVariant?.price || product.price || 0,
      modifiersPrice: modifiers.totalPrice,
      unitPrice: (productVariant?.price || product.price || 0) + modifiers.totalPrice + extraCost,
      totalPrice: itemPrice,
      // Display information
      productName: product.name,
      variantName: productVariant?.name || null,
      // Add modifier names for display
      modifierNames: modifiers.items.map((mod: any) => mod.name),
      // Add pizza customization details for display
      pizzaCustomizationDetails: customizations.map((cust: any) => ({
        pizzaCustomizationId: cust.id,
        name: cust.name,
        type: cust.type,
        half: item.selectedPizzaCustomizations?.find(sc => sc.pizzaCustomizationId === cust.id)?.half || 'FULL',
        action: item.selectedPizzaCustomizations?.find(sc => sc.pizzaCustomizationId === cust.id)?.action || 'ADD'
      }))
    };

    return calculatedItem;
  }

  /**
   * Calculate modifiers for a product
   */
  private static async calculateModifiers(
    selectedModifierIds: string[],
    productId?: string
  ): Promise<{ items: any[]; totalPrice: number }> {
    if (!selectedModifierIds.length) {
      return { items: [], totalPrice: 0 };
    }

    const modifiers = await prisma.productModifier.findMany({
      where: { 
        id: { in: selectedModifierIds }
      },
      include: { modifierGroup: true }
    });

    // Validate all modifiers were found
    if (modifiers.length !== selectedModifierIds.length) {
      const foundIds = modifiers.map((m: any) => m.id);
      const notFoundIds = selectedModifierIds.filter(id => !foundIds.includes(id));
      
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        `Modifiers not found: ${notFoundIds.join(', ')}`,
        { metadata: { notFoundIds, productId } }
      );
    }

    // Group by modifier group and validate
    const modifiersByGroup = modifiers.reduce((acc: any, mod: any) => {
      const groupId = mod.modifierGroup.id;
      if (!acc[groupId]) {
        acc[groupId] = {
          group: mod.modifierGroup,
          modifiers: []
        };
      }
      acc[groupId].modifiers.push(mod);
      return acc;
    }, {} as Record<string, { group: any; modifiers: any[] }>);

    // Validate modifier selection rules
    for (const groupData of Object.values(modifiersByGroup)) {
      const { group, modifiers: groupModifiers } = groupData as { group: any; modifiers: any[] };
      if (group.required && groupModifiers.length === 0) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Required modifier group ${group.name} must have at least one selection`, { metadata: { modifierGroupName: group.name } });
      }

      if (!group.acceptsMultiple && groupModifiers.length > 1) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Modifier group ${group.name} only accepts one selection`, { metadata: { modifierGroupName: group.name, selectedCount: groupModifiers.length } });
      }
    }

    const totalPrice = modifiers.reduce((sum: number, mod: any) => sum + mod.price, 0);

    return {
      items: modifiers,
      totalPrice
    };
  }

  /**
   * Calculate pizza customizations and extra costs
   */
  private static async calculatePizzaCustomizations(
    selectedCustomizations: Array<{
      pizzaCustomizationId: string;
      half: string;
      action: string;
    }>,
    product: any | null
  ): Promise<{ customizations: any[]; extraCost: number }> {
    if (!selectedCustomizations.length || !product?.isPizza) {
      return { customizations: [], extraCost: 0 };
    }

    // Get pizza configuration
    const pizzaConfig = await prisma.pizzaConfiguration.findUnique({
      where: { productId: product.id }
    });

    if (!pizzaConfig) {
      logger.warn(`No pizza configuration found for product ${product.id}`);
      return { customizations: [], extraCost: 0 };
    }

    const customizationIds = selectedCustomizations.map(c => c.pizzaCustomizationId);
    const customizations = await prisma.pizzaCustomization.findMany({
      where: {
        id: { in: customizationIds },
        products: { some: { id: product.id } }
      }
    });

    // Validate all customizations were found
    if (customizations.length !== customizationIds.length) {
      const foundIds = customizations.map(c => c.id);
      const notFoundIds = customizationIds.filter(id => !foundIds.includes(id));
      
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        `Pizza customizations not found: ${notFoundIds.join(', ')}`,
        { metadata: { notFoundIds, productId: product.id } }
      );
    }

    // Calculate total topping value for ADD actions only
    let totalToppingValue = 0;
    const mappedCustomizations = selectedCustomizations.map(selected => {
      const customization = customizations.find(c => c.id === selected.pizzaCustomizationId);
      
      if (selected.action === 'ADD' && customization) {
        if (selected.half === 'FULL') {
          totalToppingValue += customization.toppingValue;
        } else {
          // Half pizza counts as half the topping value
          totalToppingValue += customization.toppingValue / 2;
        }
      }
      
      return {
        ...customization,
        half: selected.half,
        action: selected.action
      };
    });

    // Calculate extra cost if toppings exceed included amount
    let extraCost = 0;
    if (totalToppingValue > pizzaConfig.includedToppings) {
      const extraToppings = totalToppingValue - pizzaConfig.includedToppings;
      extraCost = extraToppings * pizzaConfig.extraToppingCost;
      logger.info(`Pizza extra cost: ${extraCost} (${extraToppings} extra toppings at ${pizzaConfig.extraToppingCost} each)`);
    }

    return {
      customizations: mappedCustomizations,
      extraCost
    };
  }
  
}

================
File: backend/src/services/payment/StripeService.ts
================
import { Request, Response } from 'express';
import Stripe from 'stripe';
import logger from '../../common/utils/logger';
import { env } from '../../common/config/envValidator';
import { ExternalServiceError, ValidationError, ErrorCode } from '../../common/services/errors';
import { prisma } from '../../lib/prisma';

/**
 * Service for handling Stripe payment operations
 */
export class StripeService {
  private static stripe: Stripe | null = null;
  private static webhookSecret: string = '';
  private static initialized = false;

  /**
   * Initialize Stripe client (lazy initialization)
   */
  private static initialize(): void {
    if (this.initialized) {
      return;
    }

    try {
      const stripeKey = env.STRIPE_SECRET_KEY;
      if (stripeKey) {
        this.stripe = new Stripe(stripeKey, {
          apiVersion: '2024-10-28.acacia'
        });
        this.webhookSecret = env.STRIPE_WEBHOOK_SECRET || '';
        logger.info('Stripe service initialized');
      } else {
        logger.warn('Stripe service not configured - missing STRIPE_SECRET_KEY');
      }
    } catch (error) {
      logger.error('Failed to initialize Stripe service:', error);
    } finally {
      this.initialized = true;
    }
  }

  /**
   * Check if Stripe is configured
   */
  static isConfigured(): boolean {
    this.initialize();
    return this.stripe !== null;
  }

  /**
   * Handle Stripe webhook
   */
  static async handleWebhook(req: Request, res: Response): Promise<void> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured'
      );
    }
    
    const sig = req.headers['stripe-signature'] as string;
    
    let event: Stripe.Event;
    
    try {
      event = this.stripe.webhooks.constructEvent(req.body, sig, this.webhookSecret);
    } catch (err: any) {
      throw new ValidationError(
        ErrorCode.WEBHOOK_VERIFICATION_FAILED,
        `Webhook signature verification failed: ${err.message}`
      );
    }
    
    // Handle the event
    switch (event.type) {
      case 'checkout.session.completed':
        const session = event.data.object as Stripe.Checkout.Session;
        await this.handleCompletedCheckout(session);
        break;
        
      case 'payment_intent.succeeded':
        const paymentIntent = event.data.object as Stripe.PaymentIntent;
        logger.info('Payment succeeded:', paymentIntent.id);
        break;
        
      default:
        logger.info(`Unhandled event type ${event.type}`);
    }
    
    res.json({ received: true });
  }

  /**
   * Handle completed checkout session
   */
  private static async handleCompletedCheckout(session: Stripe.Checkout.Session): Promise<void> {
    logger.info('Checkout session completed:', session.id);
    
    if (session.metadata?.orderId) {
      // Find existing payment record with this session ID
      const existingPayment = await prisma.payment.findFirst({
        where: {
          orderId: session.metadata.orderId,
          stripePaymentId: session.id
        }
      });
      
      if (existingPayment) {
        // Update existing payment to PAID
        await prisma.payment.update({
          where: { id: existingPayment.id },
          data: {
            status: 'PAID',
            stripePaymentId: session.payment_intent as string,
            metadata: {
              sessionId: session.id,
              customerEmail: session.customer_details?.email,
              completedAt: new Date().toISOString()
            }
          }
        });
      } else {
        // This shouldn't happen as payment should be created when session starts
        // But create it just in case
        await prisma.payment.create({
          data: {
            orderId: session.metadata.orderId,
            amount: session.amount_total! / 100, // Convert from cents
            paymentMethod: 'STRIPE',
            status: 'PAID',
            stripePaymentId: session.payment_intent as string,
            metadata: {
              sessionId: session.id,
              customerEmail: session.customer_details?.email
            }
          }
        });
      }
      
      logger.info(`Order ${session.metadata.orderId} payment recorded`);
    }
  }

  /**
   * Create a checkout session for an order
   */
  static async createCheckoutSession(
    orderId: number, 
    amount: number, 
    customerPhone: string
  ): Promise<Stripe.Checkout.Session> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured',
        { metadata: { orderId } }
      );
    }

    try {
      const session = await this.stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [{
          price_data: {
            currency: 'mxn',
            product_data: {
              name: `Orden #${orderId}`,
              description: 'Pedido de establecimiento'
            },
            unit_amount: Math.round(amount * 100) // Convert to cents
          },
          quantity: 1
        }],
        mode: 'payment',
        success_url: `${env.FRONTEND_BASE_URL}/success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${env.FRONTEND_BASE_URL}/cancel`,
        metadata: {
          orderId: orderId.toString(),
          customerPhone
        }
      });
      
      logger.info(`Created checkout session ${session.id} for order ${orderId}`);
      return session;
    } catch (error) {
      logger.error('Error creating checkout session:', error);
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Failed to create checkout session',
        { metadata: { orderId, amount } }
      );
    }
  }

  /**
   * Get checkout session by ID
   */
  static async getCheckoutSession(sessionId: string): Promise<Stripe.Checkout.Session | null> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured',
        { metadata: { sessionId } }
      );
    }

    try {
      const session = await this.stripe.checkout.sessions.retrieve(sessionId);
      return session;
    } catch (error) {
      logger.error('Error retrieving checkout session:', error);
      return null;
    }
  }

  /**
   * Cancel payment intent
   */
  static async cancelPaymentIntent(paymentIntentId: string): Promise<void> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured',
        { metadata: { paymentIntentId } }
      );
    }

    try {
      await this.stripe.paymentIntents.cancel(paymentIntentId);
      logger.info(`Cancelled payment intent ${paymentIntentId}`);
    } catch (error) {
      logger.error('Error cancelling payment intent:', error);
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Failed to cancel payment intent',
        { metadata: { paymentIntentId } }
      );
    }
  }
}

================
File: backend/src/services/sync/SyncMetadataService.ts
================
import { prisma } from '../../server';
import logger from '../../common/utils/logger';

export type SyncEntityType = 'Order' | 'Customer' | 'Address' | 'Product' | 'Category';
export type ModifiedBy = 'LOCAL' | 'REMOTE';

export class SyncMetadataService {
  /**
   * Mark an entity for synchronization
   */
  static async markForSync(
    entityType: SyncEntityType,
    entityId: string,
    modifiedBy: ModifiedBy = 'REMOTE'
  ): Promise<void> {
    try {
      await prisma.syncMetadata.upsert({
        where: {
          entityType_entityId: { entityType, entityId }
        },
        create: {
          entityType,
          entityId,
          modifiedBy,
          syncPending: true
        },
        update: {
          modifiedBy,
          syncPending: true,
          syncVersion: { increment: 1 }
        }
      });
      
      logger.debug(`Marked ${entityType}:${entityId} for sync by ${modifiedBy}`);
    } catch (error) {
      logger.error(`Error marking entity for sync: ${entityType}:${entityId}`, error);
      throw error;
    }
  }

  /**
   * Mark multiple entities as synced
   */
  static async markAsSynced(
    entities: Array<{ entityType: SyncEntityType; entityId: string }>
  ): Promise<void> {
    try {
      const updates = entities.map(({ entityType, entityId }) =>
        prisma.syncMetadata.update({
          where: {
            entityType_entityId: { entityType, entityId }
          },
          data: {
            syncPending: false
          }
        })
      );
      
      await prisma.$transaction(updates);
      
      logger.debug(`Marked ${entities.length} entities as synced`);
    } catch (error) {
      logger.error('Error marking entities as synced', error);
      throw error;
    }
  }

  /**
   * Get entities pending synchronization
   */
  static async getPendingSync(
    entityType: SyncEntityType,
    limit: number = 100
  ): Promise<Array<{ entityId: string; lastModifiedAt: Date; modifiedBy: string }>> {
    const pending = await prisma.syncMetadata.findMany({
      where: {
        entityType,
        syncPending: true
      },
      orderBy: {
        lastModifiedAt: 'asc'
      },
      take: limit
    });
    
    return pending.map(p => ({
      entityId: p.entityId,
      lastModifiedAt: p.lastModifiedAt,
      modifiedBy: p.modifiedBy
    }));
  }

  /**
   * Get sync status for a specific entity
   */
  static async getSyncStatus(
    entityType: SyncEntityType,
    entityId: string
  ): Promise<{
    exists: boolean;
    syncPending: boolean;
    lastModifiedAt: Date | null;
    modifiedBy: string | null;
    syncVersion: number;
  }> {
    const metadata = await prisma.syncMetadata.findUnique({
      where: {
        entityType_entityId: { entityType, entityId }
      }
    });
    
    if (!metadata) {
      return {
        exists: false,
        syncPending: false,
        lastModifiedAt: null,
        modifiedBy: null,
        syncVersion: 0
      };
    }
    
    return {
      exists: true,
      syncPending: metadata.syncPending,
      lastModifiedAt: metadata.lastModifiedAt,
      modifiedBy: metadata.modifiedBy,
      syncVersion: metadata.syncVersion
    };
  }

  /**
   * Get entities modified since a specific date
   */
  static async getModifiedSince(
    entityType: SyncEntityType,
    since: Date,
    modifiedBy?: ModifiedBy
  ): Promise<string[]> {
    const where: any = {
      entityType,
      lastModifiedAt: { gt: since }
    };
    
    if (modifiedBy) {
      where.modifiedBy = modifiedBy;
    }
    
    const modified = await prisma.syncMetadata.findMany({
      where,
      select: {
        entityId: true
      }
    });
    
    return modified.map(m => m.entityId);
  }

  /**
   * Initialize sync metadata for existing entities
   * Used during migration from old system
   */
  static async initializeForExistingEntities(): Promise<void> {
    logger.info('Initializing sync metadata for existing entities...');
    
    // Initialize for existing customers
    const customers = await prisma.customer.findMany({
      select: { id: true }
    });
    
    for (const customer of customers) {
      await this.markForSync('Customer', customer.id, 'REMOTE');
    }
    
    // Initialize for existing orders
    const orders = await prisma.order.findMany({
      select: { id: true }
    });
    
    for (const order of orders) {
      await this.markForSync('Order', order.id, 'REMOTE');
    }
    
    // Initialize for existing addresses
    const addresses = await prisma.address.findMany({
      select: { id: true }
    });
    
    for (const address of addresses) {
      await this.markForSync('Address', address.id, 'REMOTE');
    }
    
    // Mark all as already synced (they're existing data)
    await prisma.syncMetadata.updateMany({
      data: { syncPending: false }
    });
    
    logger.info('Sync metadata initialization completed');
  }

  /**
   * Clean up orphaned sync metadata
   */
  static async cleanupOrphaned(): Promise<number> {
    // This would need to check each entity type
    // For now, just return 0
    logger.warn('Orphaned sync metadata cleanup not implemented yet');
    return 0;
  }
}

================
File: backend/.env.example
================
# Base de datos local (funciona con docker-compose)
DATABASE_URL=postgresql://postgres:postgres@localhost:5433/bot_db

# ===== CONFIGURACIÓN REQUERIDA =====
# Debes actualizar TODOS estos valores antes de ejecutar el bot

# 1. Google AI - REQUERIDO
# Obtén tu API Key gratis en: https://makersuite.google.com/app/apikey
GOOGLE_AI_API_KEY=tu_api_key_aqui
GEMINI_MODEL=gemini-2.5-pro
EMBEDDING_MODEL=text-embedding-004

# 2. WhatsApp Business API - REQUERIDO
# Obtén estos valores en: https://developers.facebook.com
# Tutorial: Ver QUICK_START.md sección "Obtener Credenciales de WhatsApp"
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=tu_phone_number_id
WHATSAPP_ACCESS_TOKEN=tu_access_token
WHATSAPP_VERIFY_TOKEN=tu_verify_token

# URLs locales
FRONTEND_BASE_URL=http://localhost:3000
NODE_ENV=development
PORT=5000

# Límites de mensajes
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5

# Configuración regional
DEFAULT_TIMEZONE=America/Mexico_City
DEFAULT_LOCALE=es-MX

# Stripe (Pagos) - OPCIONAL (dejar vacío si no se usa)
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=

# =============================================
# VARIABLES MÍNIMAS REQUERIDAS:
# =============================================
# 1. DATABASE_URL - Conexión a PostgreSQL
# 2. GOOGLE_AI_API_KEY - Para Gemini AI
# 3. GEMINI_MODEL - Modelo de Gemini a usar
# 4. WHATSAPP_PHONE_NUMBER_MESSAGING_ID - ID del teléfono en Meta
# 5. WHATSAPP_ACCESS_TOKEN - Token de acceso de WhatsApp
# 6. WHATSAPP_VERIFY_TOKEN - Token de verificación del webhook
# 7. FRONTEND_BASE_URL - URL del frontend para enlaces
# 8. NODE_ENV - Entorno (development/production)
# 9. PORT - Puerto del servidor
# 10. RATE_LIMIT_MAX_MESSAGES - Límite de mensajes
# 11. RATE_LIMIT_TIME_WINDOW_MINUTES - Ventana de tiempo para el límite
# 12. DEFAULT_TIMEZONE - Zona horaria por defecto
# 13. DEFAULT_LOCALE - Configuración regional por defecto
# Redis Configuration (Optional)
# Redis se usa para compartir OTPs y caché entre múltiples instancias
# Si no se configura, se usará memoria local (no escalable)
REDIS_HOST=localhost
REDIS_PORT=6380
# REDIS_PASSWORD=tu_password_de_redis

# API Key para servicios en la nube
# Clave secreta para autenticar peticiones de servicios en la nube (sincronización, audio, etc.)
# Genera una clave segura y manténla privada
CLOUD_API_KEY=genera_una_clave_secreta_aqui

# BullMQ Worker Configuration
# Número de trabajos concurrentes que cada worker puede procesar
# Para desarrollo: 2-5 es suficiente
# Para producción: 10-20 dependiendo de recursos del servidor
BULLMQ_WORKER_CONCURRENCY=2

# Número de procesos worker a iniciar (solo para PM2 en producción)
# Para desarrollo: 1 es suficiente
# Para producción: 2-4 dependiendo de núcleos CPU disponibles
NUM_WORKERS=1

================
File: backend/src/services/ai/prompts/orderAgent.prompt.ts
================
/**
 * Order Agent prompt template
 * Specialized for mapping natural language orders to menu items
 */
export function getOrderAgentPrompt(relevantMenu: string): string {
  return `MAPEA LA ORDEN AL MENÚ JSON.

MENÚ DISPONIBLE:
${relevantMenu}
    
ESTRUCTURA DEL MENÚ:
- id: ID del producto
- nombre: nombre del producto
- variantes: array con {id, nombre} - SI EXISTE ESTE CAMPO, DEBES SELECCIONAR UNA VARIANTE
- modificadores: grupos con opciones {id, nombre}
- personalizacionesPizza: para pizzas {id, nombre, tipo: FLAVOR|INGREDIENT}

REGLA CRÍTICA SOBRE VARIANTES:
⚠️ SI UN PRODUCTO TIENE EL CAMPO "variantes", ES OBLIGATORIO ESPECIFICAR variantId
- NUNCA uses solo el productId si hay variantes disponibles
- SIEMPRE selecciona la variante más apropiada según lo que pidió el cliente
- Ejemplos:
  * "papas" → INCORRECTO: solo productId
  * "papas francesas" → CORRECTO: productId + variantId de "Orden de Papas a la Francesa"
  * "alitas" → INCORRECTO: solo productId  
  * "alitas BBQ" → CORRECTO: productId + variantId de "Orden de Alitas BBQ"

PARA PIZZAS - INSTRUCCIONES DETALLADAS:

1. TIPOS DE PERSONALIZACIÓN:
   - FLAVOR: Son sabores completos de pizza (Hawaiana, Mexicana, Pepperoni, etc.)
   - INGREDIENT: Son ingredientes individuales para agregar o quitar

2. ESTRUCTURA DE pizzaCustomizations:
   Cada personalización debe ser un objeto con:
   - customizationId: el ID de la personalización
   - half: "FULL" (completa), "HALF_1" (primera mitad), "HALF_2" (segunda mitad)
   - action: "ADD" (agregar) o "REMOVE" (quitar)

3. CASOS COMUNES:
   
   a) "Pizza Hawaiana grande":
      - Busca el FLAVOR con nombre "Hawaiana" 
      - pizzaCustomizations: [{ customizationId: "PZ-I-5", half: "FULL", action: "ADD" }]
   
   b) "Pizza mitad Hawaiana mitad Mexicana":
      - Dos FLAVORS, uno en cada mitad
      - pizzaCustomizations: [
          { customizationId: "PZ-I-5", half: "HALF_1", action: "ADD" },
          { customizationId: "PZ-I-12", half: "HALF_2", action: "ADD" }
        ]
   
   c) "Pizza Hawaiana con champiñones extra":
      - Un FLAVOR + un INGREDIENT adicional
      - pizzaCustomizations: [
          { customizationId: "PZ-I-5", half: "FULL", action: "ADD" },
          { customizationId: "PZ-I-22", half: "FULL", action: "ADD" }
        ]
   
   d) "Pizza Mexicana sin chile jalapeño":
      - Un FLAVOR con un ingrediente removido
      - pizzaCustomizations: [
          { customizationId: "PZ-I-12", half: "FULL", action: "ADD" },
          { customizationId: "PZ-I-23", half: "FULL", action: "REMOVE" }
        ]
   
   e) "Pizza con pepperoni y champiñones" (sin sabor base):
      - Solo INGREDIENTS, sin FLAVOR
      - pizzaCustomizations: [
          { customizationId: "PZ-I-40", half: "FULL", action: "ADD" },
          { customizationId: "PZ-I-22", half: "FULL", action: "ADD" }
        ]

4. REGLAS IMPORTANTES:
   - Si mencionan un sabor conocido (Hawaiana, Mexicana, etc.), usa el FLAVOR correspondiente
   - "Extra" o "con" significa ADD un INGREDIENT
   - "Sin" significa REMOVE un INGREDIENT
   - Si no especifican mitades, usa half: "FULL"
   - Siempre usa action: "ADD" excepto cuando digan "sin"

EJECUTA map_order_items con:
- productId: usa el id del producto
- variantId: usa el id de la variante correcta (OBLIGATORIO si el producto tiene variantes)
- quantity: cantidad solicitada
- modifiers: array de IDs de modificadores (si aplica)
- pizzaCustomizations: array de objetos con la estructura explicada arriba
- orderType: USA EL TIPO DE ORDEN QUE VIENE EN EL MENSAJE (DESPUÉS DE "TIPO:")

VALIDACIÓN ANTES DE EJECUTAR:
1. Si el producto tiene variantes, VERIFICA que estés incluyendo variantId
2. Si el cliente dice solo "papas" o "alitas", PREGUNTA qué tipo quiere
3. NUNCA ejecutes map_order_items sin variantId para productos con variantes

IMPORTANTE: NO CAMBIES EL TIPO DE ORDEN. USA EXACTAMENTE EL QUE ESTÁ EN EL MENSAJE.

NO CONVERSES. SOLO MAPEA Y EJECUTA.`;
}

================
File: backend/src/services/config/ConfigService.ts
================
import { prisma } from '../../lib/prisma';
import logger from '../../common/utils/logger';
import { RestaurantInfo } from '../../common/types/restaurant';

interface CachedConfig {
  restaurantInfo: RestaurantInfo;
  lastUpdated: Date;
}

/**
 * Service for managing and caching global configuration
 */
export class ConfigService {
  private static config: CachedConfig | null = null;
  private static readonly CACHE_TTL_MS = 2 * 60 * 1000; // 2 minutes cache TTL
  private static reloadInProgress = false;

  /**
   * Loads the restaurant configuration from database and caches it
   */
  static async loadConfig(): Promise<void> {
    try {
      const dbConfig = await prisma.restaurantConfig.findFirst();
      
      if (!dbConfig) {
        // Use default configuration if none exists
        logger.warn('No restaurant configuration found in database, using defaults');
        const defaultInfo: RestaurantInfo = {
          restaurantName: "Restaurante (Pendiente Sincronización)",
          phoneMain: "",
          phoneSecondary: "",
          address: "",
          city: "",
          state: "",
          postalCode: ""
        };
        
        this.config = {
          restaurantInfo: defaultInfo,
          lastUpdated: new Date()
        };
        return;
      }
      
      // Map database config to RestaurantInfo type
      const restaurantInfo: RestaurantInfo = {
        restaurantName: dbConfig.restaurantName || "Establecimiento",
        phoneMain: dbConfig.phoneMain || "",
        phoneSecondary: dbConfig.phoneSecondary || "",
        address: dbConfig.address || "",
        city: dbConfig.city || "",
        state: dbConfig.state || "",
        postalCode: dbConfig.postalCode || ""
      };
      
      this.config = {
        restaurantInfo,
        lastUpdated: new Date()
      };
      
      logger.info('Restaurant configuration loaded and cached successfully');
    } catch (error) {
      logger.error('Failed to load restaurant configuration:', error);
      
      // Use default configuration on error
      const defaultInfo: RestaurantInfo = {
        restaurantName: "Restaurante (Error al cargar)",
        phoneMain: "",
        phoneSecondary: "",
        address: "",
        city: "",
        state: "",
        postalCode: ""
      };
      
      this.config = {
        restaurantInfo: defaultInfo,
        lastUpdated: new Date()
      };
    }
  }

  /**
   * Gets the cached restaurant configuration
   * Auto-reloads if cache has expired
   * @throws Error if configuration cannot be loaded
   */
  static getConfig(): RestaurantInfo {
    // Check if we need to load or reload
    if (!this.config) {
      throw new Error('Configuration not loaded! Call loadConfig() first.');
    }
    
    // Check if cache has expired
    const now = new Date();
    const cacheAge = now.getTime() - this.config.lastUpdated.getTime();
    
    if (cacheAge > this.CACHE_TTL_MS) {
      logger.warn(`Configuration cache expired (age: ${Math.round(cacheAge / 1000)}s), reloading...`);
      // Return stale config but trigger async reload for next request
      this.reloadConfigAsync();
    }
    
    return this.config.restaurantInfo;
  }

  /**
   * Gets the configuration asynchronously, loading it if necessary
   * Useful for startup scenarios where config might not be loaded yet
   */
  static async getConfigAsync(): Promise<RestaurantInfo> {
    if (!this.config) {
      await this.loadConfig();
    }
    return this.getConfig();
  }

  /**
   * Forces a reload of the configuration from database
   * Useful after configuration updates
   */
  static async reloadConfig(): Promise<void> {
    logger.info('Reloading restaurant configuration...');
    await this.loadConfig();
  }

  /**
   * Reloads configuration asynchronously without blocking
   * Used for automatic cache refresh
   */
  private static async reloadConfigAsync(): Promise<void> {
    // Prevent multiple concurrent reloads
    if (this.reloadInProgress) {
      logger.debug('Configuration reload already in progress, skipping');
      return;
    }

    this.reloadInProgress = true;
    
    try {
      await this.loadConfig();
      logger.info('Configuration reloaded successfully in background');
    } catch (error) {
      logger.error('Failed to reload configuration in background:', error);
      // Don't throw - continue using stale config
    } finally {
      this.reloadInProgress = false;
    }
  }

  /**
   * Checks if configuration is loaded
   */
  static isConfigLoaded(): boolean {
    return this.config !== null;
  }

  /**
   * Gets the last update timestamp of the cached configuration
   */
  static getLastUpdated(): Date | null {
    return this.config?.lastUpdated || null;
  }

  /**
   * Gets the cache status information
   */
  static getCacheStatus(): {
    isLoaded: boolean;
    lastUpdated: Date | null;
    ageInSeconds: number | null;
    isExpired: boolean;
    ttlSeconds: number;
  } {
    if (!this.config) {
      return {
        isLoaded: false,
        lastUpdated: null,
        ageInSeconds: null,
        isExpired: false,
        ttlSeconds: this.CACHE_TTL_MS / 1000
      };
    }

    const now = new Date();
    const ageMs = now.getTime() - this.config.lastUpdated.getTime();
    
    return {
      isLoaded: true,
      lastUpdated: this.config.lastUpdated,
      ageInSeconds: Math.round(ageMs / 1000),
      isExpired: ageMs > this.CACHE_TTL_MS,
      ttlSeconds: this.CACHE_TTL_MS / 1000
    };
  }
}

================
File: backend/src/services/orders/services/OrderFormattingService.ts
================
import { FormattedOrder, FormattedOrderProduct } from "../../../common/types/order.types";
import { env } from "../../../common/config/envValidator";
import { PizzaHalf, CustomizationAction, CustomizationType } from "@prisma/client";
import { ConfigService } from "../../config/ConfigService";

export class OrderFormattingService {
  /**
   * Format a pre-order for WhatsApp message display
   */
  static formatPreOrderForWhatsApp(preOrder: any, whatsappPhoneNumber: string): FormattedOrder {
    const orderType = preOrder.orderType;
    let deliveryInfo = "";

    // Format delivery information
    if (orderType === "DELIVERY" && preOrder.deliveryInfo) {
      const info = preOrder.deliveryInfo;
      const parts = [];
      if (info.street) parts.push(`${info.street} ${info.number || ''} ${info.interiorNumber ? 'Int. ' + info.interiorNumber : ''}`);
      if (info.neighborhood) parts.push(info.neighborhood);
      if (info.city) parts.push(info.city);
      deliveryInfo = parts.join(", ");
    }

    // Format products
    const products = preOrder.items?.map((item: any) => {
      // For CalculatedOrderItem structure - when product has variants, show only variant name
      const name = item.variantName || item.productName;

      return {
        name: name,
        quantity: item.quantity,
        price: item.totalPrice,
        modifiers: [], // We only have IDs
        pizzaCustomizations: item.selectedPizzaCustomizations?.length > 0 
          ? item.selectedPizzaCustomizations 
          : undefined,
        comments: item.comments,
      };
    }) || [];

    // Use the total from preOrder directly
    const totalPrice = preOrder.total || 0;

    // Format dates
    const createdAt = new Date().toLocaleString(env.DEFAULT_LOCALE, {
      timeZone: env.DEFAULT_TIMEZONE,
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });

    return {
      shiftOrderNumber: preOrder.preOrderId || 0,
      orderType: orderType,
      phoneNumber: whatsappPhoneNumber,
      products: products,
      totalPrice: totalPrice,
      deliveryInfo: deliveryInfo,
      createdAt: createdAt,
      scheduledDeliveryTime: preOrder.scheduledAt ? new Date(preOrder.scheduledAt).toLocaleString(env.DEFAULT_LOCALE, {
        timeZone: env.DEFAULT_TIMEZONE,
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
      }) : null,
    };
  }

  /**
   * Format an order for WhatsApp message display
   */
  static formatOrderForWhatsApp(order: any, customerId: string): FormattedOrder {
    const orderType = order.orderType;
    let deliveryInfo = "";

    // Format delivery information
    if (orderType === "DELIVERY" && order.deliveryInfo) {
      const info = order.deliveryInfo;
      
      // Use full address if available (for phone orders)
      if (info.fullAddress) {
        deliveryInfo = info.fullAddress;
      } else {
        const parts = [];
        // Combine street, number, and interior number
        let fullAddress = info.street || "";
        if (info.number) {
          fullAddress += ` ${info.number}`;
        }
        if (info.interiorNumber) {
          fullAddress += ` Int. ${info.interiorNumber}`;
        }
        if (fullAddress.trim()) parts.push(fullAddress.trim());
        if (info.neighborhood) parts.push(info.neighborhood);
        if (info.city) parts.push(info.city);
        if (info.deliveryInstructions) parts.push(`(${info.deliveryInstructions})`);
        deliveryInfo = parts.join(", ");
      }
      
      // Add recipient info if different from customer
      if (info.recipientName) {
        deliveryInfo += ` - Para: ${info.recipientName}`;
      }
      if (info.recipientPhone) {
        deliveryInfo += ` Tel: ${info.recipientPhone}`;
      }
    } else if (orderType === "TAKE_AWAY" && order.deliveryInfo?.recipientName) {
      deliveryInfo = `Recogerá: ${order.deliveryInfo.recipientName}`;
      if (order.deliveryInfo.recipientPhone) {
        deliveryInfo += ` - Tel: ${order.deliveryInfo.recipientPhone}`;
      }
    }

    // Group items by product and variant
    const itemGroups: { [key: string]: any[] } = {};
    
    // Group items by product and variant
    order.orderItems?.forEach((item: any) => {
      const key = `${item.productId}_${item.productVariantId || 'null'}`;
      if (!itemGroups[key]) {
        itemGroups[key] = [];
      }
      itemGroups[key].push(item);
    });
    
    const products = Object.values(itemGroups).map((items: any[]) => {
      const item = items[0]; // Take first item as reference
      const productName = item.product?.name || item.productName || "Producto";
      const variantName = item.productVariant?.name || item.variantName || "";
      // When product has variants, show only the variant name
      const name = variantName || productName;
      
      // Calculate total for all items in this group
      const quantity = items.length;
      const unitPrice = item.finalPrice || item.basePrice || 0;
      const groupTotalPrice = unitPrice * quantity;
      
      // Modifiers are already included in finalPrice during order creation
      const modifiers = item.productModifiers?.map((mod: any) => ({
        name: mod.name || "Modificador",
        price: mod.price || 0,
      })) || [];

      // Map pizza customizations from first item (they should be the same)
      const pizzaCustomizations = item.selectedPizzaCustomizations?.map((selectedCust: any) => ({
        half: selectedCust.half as string,
        name: selectedCust.pizzaCustomization?.name || "Personalización",
        action: selectedCust.action,
        type: selectedCust.pizzaCustomization?.type || "INGREDIENT",
        ingredients: selectedCust.pizzaCustomization?.ingredients,
      })) || [];

      return {
        name: name,
        quantity: quantity,
        price: groupTotalPrice,
        modifiers: modifiers,
        pizzaCustomizations: pizzaCustomizations?.length > 0 ? pizzaCustomizations : undefined,
        comments: item.comments,
      };
    });

    // Format dates
    const createdAt = order.createdAt.toLocaleString(env.DEFAULT_LOCALE, {
      timeZone: env.DEFAULT_TIMEZONE,
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });

    const scheduledDelivery = order.scheduledAt
      ? order.scheduledAt.toLocaleString(env.DEFAULT_LOCALE, {
          timeZone: env.DEFAULT_TIMEZONE,
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        })
      : null;

    // Use the total from order directly
    const totalPrice = order.total || 0;

    return {
      id: order.id,
      shiftOrderNumber: order.shiftOrderNumber,
      orderType: order.orderType,
      customerId: order.customerId,
      phoneNumber: order.customer?.whatsappPhoneNumber || customerId,
      deliveryInfo: deliveryInfo,
      totalPrice: totalPrice,
      createdAt: createdAt,
      scheduledDeliveryTime: scheduledDelivery,
      estimatedDeliveryTime: order.estimatedDeliveryTime 
        ? new Date(order.estimatedDeliveryTime).toLocaleString('es-MX', {
            timeZone: 'America/Mexico_City',
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          })
        : undefined,
      products: products,
    };
  }

  /**
   * Generate order confirmation message
   */
  static async generateConfirmationMessage(order: any, formattedOrder: FormattedOrder): Promise<string> {
    const orderTypeText = order.orderType === "DELIVERY" ? "A domicilio" : 
                         order.orderType === "TAKE_AWAY" ? "Para llevar" : "Para comer aquí";
    
    const config = await ConfigService.getConfig();
    
    let message = `🎉 *¡Tu orden ha sido creada exitosamente!* 🎉\n\n`;
    message += `📞 *Teléfono:* ${formattedOrder.phoneNumber}\n`;
    message += `📅 *Fecha de creación:* ${formattedOrder.createdAt}\n`;
    message += `🚚 *Información de entrega:* ${orderTypeText} - ${formattedOrder.deliveryInfo}\n`;
    
    if (formattedOrder.estimatedDeliveryTime) {
      message += `⏱️ *Hora estimada de entrega:* ${formattedOrder.estimatedDeliveryTime}\n`;
    }

    if (formattedOrder.scheduledDeliveryTime) {
      message += `📅 *Entrega programada:* ${formattedOrder.scheduledDeliveryTime}\n`;
    }

    message += `\n🛒 *Productos:*\n`;
    formattedOrder.products.forEach((product) => {
      message += this.formatProduct(product);
    });

    message += `\n💰 *Total: $${formattedOrder.totalPrice}*\n\n`;
    message += `📩 Te notificaremos cuando tu pedido sea aceptado.\n\n`;
    
    // Add restaurant contact info
    message += `📞 *¿Necesitas hacer cambios?*\n`;
    message += `Comunícate directamente con el restaurante:\n`;
    if (config.phoneMain) {
      message += `📱 ${config.phoneMain}\n`;
    }
    if (config.phoneSecondary) {
      message += `📱 ${config.phoneSecondary}\n`;
    }
    
    message += `\n¡Gracias por tu preferencia! 🙏`;

    return message;
  }

  /**
   * Format a single product for display
   */
  private static formatProduct(product: FormattedOrderProduct): string {
    let summary = `- *${product.quantity}x ${product.name}*: $${product.price}\n`;

    if (product.pizzaCustomizations && product.pizzaCustomizations.length > 0) {
      summary += this.formatPizzaCustomizations(product.pizzaCustomizations);
    }

    if (product.modifiers.length > 0) {
      summary += `  🔸 Modificadores: ${product.modifiers
        .map((mod: any) => mod.name)
        .join(", ")}\n`;
    }

    if (product.comments) {
      summary += `  💬 Comentarios: ${product.comments}\n`;
    }

    return summary;
  }

  /**
   * Format pizza customizations for display
   */
  private static formatPizzaCustomizations(customizations: any[]): string {
    const addCustomizations = customizations.filter((c: any) => c.action === CustomizationAction.ADD);
    const removeCustomizations = customizations.filter((c: any) => c.action === CustomizationAction.REMOVE);
    
    let result = "";
    
    // Group by type and half
    const flavors = {
      HALF_1: addCustomizations.filter(c => c.type === CustomizationType.FLAVOR && c.half === PizzaHalf.HALF_1),
      HALF_2: addCustomizations.filter(c => c.type === CustomizationType.FLAVOR && c.half === PizzaHalf.HALF_2),
      FULL: addCustomizations.filter(c => c.type === CustomizationType.FLAVOR && c.half === PizzaHalf.FULL)
    };
    
    const ingredients = {
      HALF_1: addCustomizations.filter(c => c.type === CustomizationType.INGREDIENT && c.half === PizzaHalf.HALF_1),
      HALF_2: addCustomizations.filter(c => c.type === CustomizationType.INGREDIENT && c.half === PizzaHalf.HALF_2),
      FULL: addCustomizations.filter(c => c.type === CustomizationType.INGREDIENT && c.half === PizzaHalf.FULL)
    };
    
    const removed = {
      HALF_1: removeCustomizations.filter(c => c.half === PizzaHalf.HALF_1),
      HALF_2: removeCustomizations.filter(c => c.half === PizzaHalf.HALF_2),
      FULL: removeCustomizations.filter(c => c.half === PizzaHalf.FULL)
    };
    
    // Format full pizza
    if (flavors.FULL.length > 0 || ingredients.FULL.length > 0 || removed.FULL.length > 0) {
      const parts = [];
      if (flavors.FULL.length > 0) {
        parts.push(flavors.FULL.map(f => f.name).join(", "));
      }
      if (ingredients.FULL.length > 0) {
        parts.push(`con: ${ingredients.FULL.map(i => i.name).join(", ")}`);
      }
      if (removed.FULL.length > 0) {
        parts.push(`sin: ${removed.FULL.map(r => r.name).join(", ")}`);
      }
      result += `  🔸 ${parts.join(" - ")}\n`;
    }
    
    // Format half pizzas
    const hasHalf1 = flavors.HALF_1.length > 0 || ingredients.HALF_1.length > 0 || removed.HALF_1.length > 0;
    const hasHalf2 = flavors.HALF_2.length > 0 || ingredients.HALF_2.length > 0 || removed.HALF_2.length > 0;
    
    if (hasHalf1 && hasHalf2) {
      const half1Parts = [];
      const half2Parts = [];
      
      // Build half 1
      if (flavors.HALF_1.length > 0) {
        half1Parts.push(flavors.HALF_1.map(f => f.name).join(", "));
      }
      if (ingredients.HALF_1.length > 0) {
        half1Parts.push(`con: ${ingredients.HALF_1.map(i => i.name).join(", ")}`);
      }
      if (removed.HALF_1.length > 0) {
        half1Parts.push(`sin: ${removed.HALF_1.map(r => r.name).join(", ")}`);
      }
      
      // Build half 2
      if (flavors.HALF_2.length > 0) {
        half2Parts.push(flavors.HALF_2.map(f => f.name).join(", "));
      }
      if (ingredients.HALF_2.length > 0) {
        half2Parts.push(`con: ${ingredients.HALF_2.map(i => i.name).join(", ")}`);
      }
      if (removed.HALF_2.length > 0) {
        half2Parts.push(`sin: ${removed.HALF_2.map(r => r.name).join(", ")}`);
      }
      
      result += `  🔸 (${half1Parts.join(" ")} / ${half2Parts.join(" ")})\n`;
    }
    
    return result;
  }
}

================
File: backend/src/common/services/errors/types.ts
================
export enum ErrorType {
  BUSINESS_LOGIC = 'BUSINESS_LOGIC',
  VALIDATION = 'VALIDATION',
  TECHNICAL = 'TECHNICAL',
  EXTERNAL_SERVICE = 'EXTERNAL_SERVICE',
  RATE_LIMIT = 'RATE_LIMIT',
  NOT_FOUND = 'NOT_FOUND'
}

export enum ErrorCode {
  // Business Logic
  ORDER_NOT_FOUND = 'BL001',
  RESTAURANT_CLOSED = 'BL004',
  NOT_ACCEPTING_ORDERS = 'BL005',
  PAYMENT_LINK_EXISTS = 'BL006',
  CUSTOMER_NOT_FOUND = 'BL007',
  USER_BANNED = 'BL008',
  NO_PRODUCTS_FOUND = 'BL009',
  EMPTY_ORDER = 'BL010',
  
  // Validation
  INVALID_PRODUCT = 'VAL001',
  MISSING_DELIVERY_INFO = 'VAL002',
  INVALID_SCHEDULE_TIME = 'VAL003',
  MISSING_REQUIRED_FIELD = 'VAL004',
  INVALID_ORDER_TYPE = 'VAL005',
  INVALID_OTP = 'VAL006',
  INVALID_TOKEN = 'VAL007',
  FILE_TOO_LARGE = 'VAL009',
  WEBHOOK_VERIFICATION_FAILED = 'VAL010',
  
  // Not Found
  ADDRESS_NOT_FOUND = 'NF001',
  
  // Validation - Address
  ADDRESS_OUTSIDE_COVERAGE = 'VAL008',
  
  // Technical
  DATABASE_ERROR = 'TECH001',
  WHATSAPP_API_ERROR = 'TECH002',
  PAYMENT_PROCESSING_ERROR = 'TECH003',
  AI_SERVICE_ERROR = 'TECH004',
  TRANSCRIPTION_ERROR = 'TECH005',
  AUTHENTICATION_REQUIRED = 'TECH006',
  INVALID_CREDENTIALS = 'TECH007',
  EMBEDDING_GENERATION_FAILED = 'TECH008',
  AI_PROCESSING_ERROR = 'TECH009',
  
  // External Service
  STRIPE_ERROR = 'EXT001',
  GEMINI_ERROR = 'EXT002',
  WHATSAPP_ERROR = 'EXT003',
  
  // Rate Limit
  RATE_LIMIT_EXCEEDED = 'RL001'
}

export interface ErrorContext {
  userId?: string;
  customerId?: string;
  orderId?: number | string; // Support both numeric and UUID order IDs
  operation?: string;
  metadata?: Record<string, any>;
  [key: string]: any; // Allow additional properties
}

export interface ErrorResponse {
  userMessage: string;
  logMessage: string;
  errorCode: ErrorCode;
  errorType: ErrorType;
  shouldNotifyUser: boolean;
  context?: ErrorContext;
}

================
File: backend/src/services/sync/EmbeddingService.ts
================
import { prisma } from '../../lib/prisma';
import { GoogleGenAI } from '@google/genai';
import { env } from '../../common/config/envValidator';
import logger from '../../common/utils/logger';
import { Product } from '@prisma/client';

interface ProductWithRelations extends Product {
  subcategory: {
    name: string;
    category: {
      name: string;
    };
  };
  variants?: Array<{ name: string; isActive: boolean }>;
  pizzaCustomizations?: Array<{ name: string; type: 'FLAVOR' | 'INGREDIENT'; isActive: boolean }>;
  modifierGroups?: Array<{
    productModifiers: Array<{ name: string; isActive: boolean }>;
    isActive: boolean;
  }>;
}

/**
 * Service for managing product embeddings
 * Handles automatic generation and updates when products change
 */
export class EmbeddingService {
  private static genAI = new GoogleGenAI({ apiKey: env.GOOGLE_AI_API_KEY });
  private static embeddingModel = env.EMBEDDING_MODEL;
  private static lastSyncChecksum: string | null = null;

  /**
   * Generate embedding text for a product
   */
  private static createProductText(product: ProductWithRelations): string {
    let text = `Producto: ${product.name}. Categoría: ${product.subcategory.category.name}, ${product.subcategory.name}.`;
    
    if (product.description) {
      text += ` Descripción: ${product.description}.`;
    }
    
    if (product.isPizza && product.pizzaCustomizations && product.pizzaCustomizations.length > 0) {
      const flavors = product.pizzaCustomizations
        .filter(c => c.isActive && c.type === 'FLAVOR')
        .map(c => c.name)
        .join(', ');
      const ingredients = product.pizzaCustomizations
        .filter(c => c.isActive && c.type === 'INGREDIENT')
        .map(c => c.name)
        .join(', ');
      
      if (flavors) {
        text += ` Sabores disponibles: ${flavors}.`;
      }
      if (ingredients) {
        text += ` Ingredientes adicionales: ${ingredients}.`;
      }
    }
    
    if (product.variants && product.variants.length > 0) {
      const variantNames = product.variants
        .filter(v => v.isActive)
        .map(v => v.name)
        .join(', ');
      if (variantNames) {
        text += ` Opciones o tamaños: ${variantNames}.`;
      }
    }
    
    if (product.modifierGroups && product.modifierGroups.length > 0) {
      const modifiers = product.modifierGroups
        .filter(g => g.isActive)
        .flatMap(g => g.productModifiers || [])
        .filter(m => m.isActive)
        .map(m => m.name)
        .join(', ');
      if (modifiers) {
        text += ` Modificadores disponibles: ${modifiers}.`;
      }
    }
    
    return text;
  }

  /**
   * Generate embedding for a single product
   */
  static async generateProductEmbedding(product: ProductWithRelations): Promise<number[]> {
    const textToEmbed = this.createProductText(product);
    
    const result = await this.genAI.models.embedContent({
      model: this.embeddingModel,
      contents: textToEmbed,
      config: {
        outputDimensionality: 768  // Force 768 dimensions for compatibility with pgvector
      }
    });
    
    const embedding = result.embeddings?.[0]?.values || [];
    
    return embedding;
  }

  /**
   * Update embedding for a single product
   */
  static async updateProductEmbedding(productId: string): Promise<void> {
    try {
      const product = await prisma.product.findUnique({
        where: { id: productId },
        include: {
          subcategory: { include: { category: true } },
          variants: { where: { isActive: true } },
          pizzaCustomizations: { where: { isActive: true } },
        pizzaConfiguration: true,
          modifierGroups: {
            where: { isActive: true },
            include: {
              productModifiers: { where: { isActive: true } }
            }
          }
        }
      });

      if (!product || !product.isActive) {
        logger.warn(`Product ${productId} not found or inactive, skipping embedding generation`);
        return;
      }

      const embedding = await this.generateProductEmbedding(product as ProductWithRelations);
      
      // Update embedding in database
      await prisma.$executeRaw`
        UPDATE "Product"
        SET embedding = ${`[${embedding.join(',')}]`}::vector
        WHERE id = ${productId}
      `;
      
      logger.info(`✅ Embedding updated for product: ${product.name}`);
    } catch (error) {
      logger.error(`Error updating embedding for product ${productId}:`, error);
      throw error;
    }
  }

  /**
   * Check if products have changed and need embedding updates
   */
  static async checkAndUpdateEmbeddings(): Promise<number> {
    try {
      logger.info('Checking for product changes that require embedding updates...');
      
      // Get current state checksum
      const currentChecksum = await this.calculateProductsChecksum();
      
      // Compare with last sync
      if (this.lastSyncChecksum === currentChecksum) {
        logger.info('No product changes detected, embeddings are up to date');
        return 0;
      }
      
      // Find products that need embedding updates
      const productsNeedingUpdate = await this.findProductsNeedingEmbeddings();
      
      if (productsNeedingUpdate.length === 0) {
        logger.info('All products have embeddings');
        this.lastSyncChecksum = currentChecksum;
        return 0;
      }
      
      logger.info(`Found ${productsNeedingUpdate.length} products needing embedding updates`);
      
      // Update embeddings
      let successCount = 0;
      for (const productId of productsNeedingUpdate) {
        try {
          await this.updateProductEmbedding(productId);
          successCount++;
          // Rate limiting
          await new Promise(resolve => setTimeout(resolve, 300));
        } catch (error) {
          logger.error(`Failed to update embedding for product ${productId}:`, error);
        }
      }
      
      // Update checksum
      this.lastSyncChecksum = currentChecksum;
      
      logger.info(`✅ Embedding update completed: ${successCount}/${productsNeedingUpdate.length} successful`);
      return successCount;
    } catch (error) {
      logger.error('Error in checkAndUpdateEmbeddings:', error);
      throw error;
    }
  }

  /**
   * Calculate checksum of all products to detect changes
   */
  private static async calculateProductsChecksum(): Promise<string> {
    const products = await prisma.product.findMany({
      where: { isActive: true },
      select: {
        id: true,
        name: true,
        description: true,
        updatedAt: true
      },
      orderBy: { id: 'asc' }
    });
    
    // Create a simple checksum based on product data
    const dataString = products
      .map(p => `${p.id}:${p.name}:${p.description || ''}:${p.updatedAt.getTime()}`)
      .join('|');
    
    // Simple hash function
    let hash = 0;
    for (let i = 0; i < dataString.length; i++) {
      const char = dataString.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    
    return hash.toString(16);
  }

  /**
   * Find products that need embedding generation or updates
   */
  private static async findProductsNeedingEmbeddings(): Promise<string[]> {
    // Get products without embeddings
    const productsWithoutEmbeddings: { id: string }[] = await prisma.$queryRaw`
      SELECT id FROM "Product"
      WHERE "isActive" = true
      AND embedding IS NULL
    `;
    
    // Get products where updatedAt is more recent than embedding generation
    // This requires tracking embedding generation time (future enhancement)
    
    return productsWithoutEmbeddings.map(p => p.id);
  }

  /**
   * Force regenerate all embeddings (useful for algorithm updates)
   */
  static async regenerateAllEmbeddings(): Promise<void> {
    logger.info('Starting full embedding regeneration...');
    
    const products = await prisma.product.findMany({
      where: { isActive: true },
      include: {
        subcategory: { include: { category: true } },
        variants: { where: { isActive: true } },
        pizzaCustomizations: { where: { isActive: true } },
        pizzaConfiguration: true,
        modifierGroups: {
          where: { isActive: true },
          include: {
            productModifiers: { where: { isActive: true } }
          }
        }
      }
    });
    
    logger.info(`Found ${products.length} products to process`);
    
    let successCount = 0;
    let errorCount = 0;
    
    for (const product of products) {
      try {
        const embedding = await this.generateProductEmbedding(product as ProductWithRelations);
        
        await prisma.$executeRaw`
          UPDATE "Product"
          SET embedding = ${`[${embedding.join(',')}]`}::vector
          WHERE id = ${product.id}
        `;
        
        successCount++;
        logger.info(`✅ Embedding saved for: ${product.name} (${successCount}/${products.length})`);
        
        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 300));
      } catch (error) {
        errorCount++;
        logger.error(`❌ Error with ${product.name}:`, error);
      }
    }
    
    logger.info(`
✅ Regeneration completed:
   - Products processed: ${successCount}
   - Errors: ${errorCount}
   - Total: ${products.length}
    `);
  }
}

================
File: backend/src/api/audio/audioHealth.controller.ts
================
import { Request, Response } from 'express';
import { GeminiService } from '../../services/ai/GeminiService';
import { prisma } from '../../lib/prisma';
import logger from '../../common/utils/logger';

interface HealthCheckResponse {
  status: 'ok' | 'error';
  message: string;
  timestamp: string;
  services: {
    server: 'healthy' | 'unhealthy';
    database: 'connected' | 'disconnected';
    ai: 'connected' | 'disconnected';
    embeddings: 'available' | 'unavailable';
  };
}

export class AudioHealthController {
  static async checkHealth(req: Request, res: Response): Promise<void> {
    const startTime = Date.now();
    const services: HealthCheckResponse['services'] = {
      server: 'healthy',
      database: 'disconnected',
      ai: 'disconnected',
      embeddings: 'unavailable'
    };

    try {
      // Check database connection
      try {
        await prisma.$queryRaw`SELECT 1`;
        services.database = 'connected';
        logger.debug('Health check: Database connected');
      } catch (error) {
        logger.error('Health check: Database connection failed', { error });
      }

      // Check AI service (Gemini)
      try {
        // Simple test to verify Gemini is accessible
        const testPrompt = 'Hello';
        const response = await Promise.race([
          GeminiService.generateContentWithHistory(
            [{ role: 'user', parts: [{ text: testPrompt }] }],
            'You are a health check bot. Reply with "ok".',
            []
          ),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('AI service timeout')), 3000)
          )
        ]);
        
        if (response) {
          services.ai = 'connected';
          logger.debug('Health check: AI service connected');
        }
      } catch (error) {
        logger.error('Health check: AI service connection failed', { error });
      }

      // Check embeddings availability
      try {
        // Check if embeddings table has data using raw SQL
        const result = await prisma.$queryRaw<{ count: bigint }[]>`
          SELECT COUNT(*) as count 
          FROM "Product" 
          WHERE embedding IS NOT NULL
        `;
        
        const embeddingsCount = Number(result[0]?.count || 0);
        
        if (embeddingsCount > 0) {
          services.embeddings = 'available';
          logger.debug('Health check: Embeddings available', { count: embeddingsCount });
        }
      } catch (error) {
        logger.error('Health check: Embeddings check failed', { error });
      }

      // Determine overall status
      const allServicesHealthy = 
        services.database === 'connected' && 
        services.ai === 'connected' &&
        services.embeddings === 'available';

      const status: HealthCheckResponse['status'] = allServicesHealthy ? 'ok' : 'error';
      const message = allServicesHealthy 
        ? 'Audio processing service is healthy'
        : `Service degraded: ${Object.entries(services)
            .filter(([_, status]) => status !== 'connected' && status !== 'healthy' && status !== 'available')
            .map(([service]) => service)
            .join(', ')} not available`;

      const responseTime = Date.now() - startTime;
      logger.info('Health check completed', { 
        status, 
        services, 
        responseTime 
      });

      const response: HealthCheckResponse = {
        status,
        message,
        timestamp: new Date().toISOString(),
        services
      };

      res.status(status === 'ok' ? 200 : 503).json(response);
    } catch (error) {
      logger.error('Health check failed with unexpected error', { error });
      
      const response: HealthCheckResponse = {
        status: 'error',
        message: 'Health check failed',
        timestamp: new Date().toISOString(),
        services
      };
      
      res.status(503).json(response);
    }
  }
}

================
File: backend/src/common/config/envValidator.ts
================
import dotenv from 'dotenv';
import logger from '../utils/logger';
import { ValidationError, ErrorCode } from '../services/errors';

dotenv.config();

interface EnvironmentVariables {
  // Required variables
  DATABASE_URL: string;
  GOOGLE_AI_API_KEY: string;
  WHATSAPP_PHONE_NUMBER_MESSAGING_ID: string;
  WHATSAPP_ACCESS_TOKEN: string;
  WHATSAPP_VERIFY_TOKEN: string;
  FRONTEND_BASE_URL: string;
  GEMINI_MODEL: string;
  EMBEDDING_MODEL: string;
  
  // Optional variables
  STRIPE_SECRET_KEY?: string;
  STRIPE_WEBHOOK_SECRET?: string;
  NODE_ENV: string;
  PORT: string;
  RATE_LIMIT_MAX_MESSAGES: string;
  RATE_LIMIT_TIME_WINDOW_MINUTES: string;
  DEFAULT_TIMEZONE: string;
  DEFAULT_LOCALE: string;
  REDIS_HOST?: string;
  REDIS_PORT?: string;
  REDIS_PASSWORD?: string;
  CLOUD_API_KEY?: string;
  BULLMQ_WORKER_CONCURRENCY?: string;
  NUM_WORKERS?: string;
}

class EnvironmentValidator {
  private requiredVars: (keyof EnvironmentVariables)[] = [
    'DATABASE_URL',
    'GOOGLE_AI_API_KEY',
    'WHATSAPP_PHONE_NUMBER_MESSAGING_ID',
    'WHATSAPP_ACCESS_TOKEN',
    'WHATSAPP_VERIFY_TOKEN',
    'FRONTEND_BASE_URL',
    'GEMINI_MODEL',
    'NODE_ENV',
    'PORT',
    'RATE_LIMIT_MAX_MESSAGES',
    'RATE_LIMIT_TIME_WINDOW_MINUTES',
    'DEFAULT_TIMEZONE',
    'DEFAULT_LOCALE'
  ];

  validate(): void {
    logger.info('Starting environment validation...');
    const missingVars: string[] = [];
    
    for (const varName of this.requiredVars) {
      if (!process.env[varName]) {
        missingVars.push(varName);
      } else {
        logger.debug(`Environment variable ${varName}: ${varName.includes('KEY') || varName.includes('TOKEN') ? '[REDACTED]' : process.env[varName]}`);
      }
    }
    
    if (missingVars.length > 0) {
      const errorMessage = `Missing required environment variables: ${missingVars.join(', ')}`;
      logger.error(errorMessage);
      throw new ValidationError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        errorMessage,
        { metadata: { missingVars } }
      );
    }
    
    // Validate specific formats
    this.validateDatabaseUrl();
    this.validateUrl('FRONTEND_BASE_URL');
    
    // Log optional variables status
    if (process.env.STRIPE_SECRET_KEY) {
      logger.info('Stripe payment integration is enabled');
    } else {
      logger.warn('Stripe payment integration is disabled (STRIPE_SECRET_KEY not set)');
    }
    
    logger.info('Environment variables validated successfully');
  }
  
  private validateDatabaseUrl(): void {
    const dbUrl = process.env.DATABASE_URL;
    if (!dbUrl?.startsWith('postgresql://')) {
      throw new ValidationError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        'DATABASE_URL must be a valid PostgreSQL connection string',
        { metadata: { providedUrl: dbUrl } }
      );
    }
  }
  
  
  private validateUrl(varName: string): void {
    const url = process.env[varName];
    try {
      if (url) {
        new URL(url);
      }
    } catch {
      throw new ValidationError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        `${varName} must be a valid URL`,
        { metadata: { varName, providedUrl: url } }
      );
    }
  }
  
  getEnv(): EnvironmentVariables {
    return {
      DATABASE_URL: process.env.DATABASE_URL!,
      GOOGLE_AI_API_KEY: process.env.GOOGLE_AI_API_KEY!,
      WHATSAPP_PHONE_NUMBER_MESSAGING_ID: process.env.WHATSAPP_PHONE_NUMBER_MESSAGING_ID!,
      WHATSAPP_ACCESS_TOKEN: process.env.WHATSAPP_ACCESS_TOKEN!,
      WHATSAPP_VERIFY_TOKEN: process.env.WHATSAPP_VERIFY_TOKEN!,
      FRONTEND_BASE_URL: process.env.FRONTEND_BASE_URL!,
      GEMINI_MODEL: process.env.GEMINI_MODEL!,
      EMBEDDING_MODEL: process.env.EMBEDDING_MODEL || 'text-embedding-004',
      STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
      STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
      NODE_ENV: process.env.NODE_ENV!,
      PORT: process.env.PORT!,
      RATE_LIMIT_MAX_MESSAGES: process.env.RATE_LIMIT_MAX_MESSAGES!,
      RATE_LIMIT_TIME_WINDOW_MINUTES: process.env.RATE_LIMIT_TIME_WINDOW_MINUTES!,
      DEFAULT_TIMEZONE: process.env.DEFAULT_TIMEZONE!,
      DEFAULT_LOCALE: process.env.DEFAULT_LOCALE!,
      REDIS_HOST: process.env.REDIS_HOST,
      REDIS_PORT: process.env.REDIS_PORT,
      REDIS_PASSWORD: process.env.REDIS_PASSWORD,
      CLOUD_API_KEY: process.env.CLOUD_API_KEY,
      BULLMQ_WORKER_CONCURRENCY: process.env.BULLMQ_WORKER_CONCURRENCY,
      NUM_WORKERS: process.env.NUM_WORKERS
    };
  }
}

export const envValidator = new EnvironmentValidator();
export const env = envValidator.getEnv();

================
File: backend/src/common/services/errors/errorMessages.ts
================
import { ErrorCode } from './types';

interface ErrorMessageConfig {
  user: string;
  log: string;
}

export const ERROR_MESSAGES: Record<ErrorCode, ErrorMessageConfig> = {
  // Business Logic Errors
  [ErrorCode.ORDER_NOT_FOUND]: {
    user: "❌ Lo siento, no se pudo encontrar tu orden. 🔍",
    log: "Order not found"
  },
  [ErrorCode.RESTAURANT_CLOSED]: {
    user: "🚫 Lo sentimos, estamos cerrados en este momento. 😴",
    log: "Restaurant is closed"
  },
  [ErrorCode.NOT_ACCEPTING_ORDERS]: {
    user: "🚫🍽️ Lo sentimos, no estamos aceptando pedidos en este momento. 😔",
    log: "Restaurant not accepting orders"
  },
  [ErrorCode.PAYMENT_LINK_EXISTS]: {
    user: "⚠️ Ya existe un enlace de pago activo para esta orden.",
    log: "Payment link already exists"
  },
  [ErrorCode.CUSTOMER_NOT_FOUND]: {
    user: "❌ No se encontró información del cliente.",
    log: "Customer not found"
  },
  [ErrorCode.USER_BANNED]: {
    user: "🚫 Tu cuenta ha sido suspendida.",
    log: "User is banned"
  },
  [ErrorCode.NO_PRODUCTS_FOUND]: {
    user: "❌ No encontré productos que coincidan con tu pedido. Por favor intenta de nuevo.",
    log: "No products found matching search"
  },
  [ErrorCode.EMPTY_ORDER]: {
    user: "❌ No pude identificar productos válidos en tu pedido. Por favor intenta de nuevo.",
    log: "Empty order - no valid items identified"
  },
  
  // Validation Errors
  [ErrorCode.INVALID_PRODUCT]: {
    user: "❌ Uno o más productos no son válidos. Por favor, verifica tu pedido.",
    log: "Invalid product ID or configuration"
  },
  [ErrorCode.MISSING_DELIVERY_INFO]: {
    user: "📍 No encontramos tu información de entrega. Por favor, regístrala primero.",
    log: "Missing delivery information"
  },
  [ErrorCode.INVALID_SCHEDULE_TIME]: {
    user: "⏰ El horario seleccionado no es válido. Por favor, elige otro horario.",
    log: "Invalid scheduled delivery time"
  },
  [ErrorCode.MISSING_REQUIRED_FIELD]: {
    user: "❌ Falta información requerida. Por favor, completa todos los campos.",
    log: "Missing required field"
  },
  [ErrorCode.INVALID_ORDER_TYPE]: {
    user: "❌ Tipo de orden no válido. Por favor, selecciona entrega a domicilio o recolección.",
    log: "Invalid order type"
  },
  [ErrorCode.INVALID_OTP]: {
    user: "❌ El código OTP es inválido o ha expirado. Por favor, solicita uno nuevo.",
    log: "Invalid or expired OTP"
  },
  [ErrorCode.INVALID_TOKEN]: {
    user: "⏰ Esta orden ha expirado o ya no está disponible.\n\n🔄 Tu historial ha sido reiniciado. Puedes realizar un nuevo pedido escribiendo lo que deseas ordenar.",
    log: "Invalid or expired action token"
  },
  [ErrorCode.ADDRESS_OUTSIDE_COVERAGE]: {
    user: "📍 La dirección seleccionada está fuera de nuestra área de cobertura. Por favor, selecciona una dirección dentro de la zona de entrega.",
    log: "Address outside delivery coverage area"
  },
  [ErrorCode.FILE_TOO_LARGE]: {
    user: "❌ El archivo es demasiado grande. Por favor envía un archivo más pequeño.",
    log: "File size exceeds maximum allowed"
  },
  [ErrorCode.WEBHOOK_VERIFICATION_FAILED]: {
    user: "❌ Error de verificación del webhook.",
    log: "Webhook signature verification failed"
  },
  
  // Not Found Errors
  [ErrorCode.ADDRESS_NOT_FOUND]: {
    user: "📍 No se encontró la dirección solicitada.",
    log: "Address not found"
  },
  
  // Technical Errors
  [ErrorCode.DATABASE_ERROR]: {
    user: "🔧 Hubo un problema técnico. Por favor, intenta de nuevo más tarde.",
    log: "Database operation failed"
  },
  [ErrorCode.WHATSAPP_API_ERROR]: {
    user: "📱 Hubo un problema al enviar el mensaje. Por favor, intenta de nuevo.",
    log: "WhatsApp API error"
  },
  [ErrorCode.PAYMENT_PROCESSING_ERROR]: {
    user: "💳 Hubo un problema al procesar el pago. Por favor, intenta de nuevo.",
    log: "Payment processing error"
  },
  [ErrorCode.AI_SERVICE_ERROR]: {
    user: "🤖 Hubo un problema al procesar tu solicitud. Por favor, intenta de nuevo.",
    log: "AI service error"
  },
  [ErrorCode.TRANSCRIPTION_ERROR]: {
    user: "🎤 Hubo un problema al procesar tu mensaje de audio. Por favor, intenta nuevamente o envía un mensaje de texto.",
    log: "Audio transcription failed"
  },
  
  // External Service Errors
  [ErrorCode.STRIPE_ERROR]: {
    user: "💳 El servicio de pagos no está disponible temporalmente. Por favor, intenta más tarde.",
    log: "Stripe service error"
  },
  [ErrorCode.GEMINI_ERROR]: {
    user: "🤖 El asistente no está disponible temporalmente. Por favor, intenta más tarde.",
    log: "Gemini AI service error"
  },
  [ErrorCode.WHATSAPP_ERROR]: {
    user: "📱 Error en el servicio de WhatsApp. Por favor, intenta más tarde.",
    log: "WhatsApp service error"
  },
  
  // Rate Limit
  [ErrorCode.RATE_LIMIT_EXCEEDED]: {
    user: "⏳ Has alcanzado el límite de mensajes. Por favor espera unos minutos antes de enviar más mensajes.",
    log: "Rate limit exceeded"
  },
  
  [ErrorCode.AUTHENTICATION_REQUIRED]: {
    user: 'Authentication required',
    log: 'Missing authentication credentials'
  },
  
  [ErrorCode.INVALID_CREDENTIALS]: {
    user: 'Invalid credentials',
    log: 'Invalid or expired authentication credentials'
  },
  
  [ErrorCode.EMBEDDING_GENERATION_FAILED]: {
    user: '🤖 Hubo un problema al procesar tu búsqueda. Por favor, intenta de nuevo.',
    log: 'Failed to generate embedding for search query'
  },
  
  [ErrorCode.AI_PROCESSING_ERROR]: {
    user: '🤖 No se pudo procesar tu pedido. Por favor intenta de nuevo.',
    log: 'AI processing failed'
  }
};

================
File: backend/src/services/ai/tools/handlers/sendMenuHandler.ts
================
import { ToolHandler, ToolResponse } from '../types';
import { ProductService } from '../../../products/ProductService';
import { MessageSplitter } from '../../../../common/utils/messageSplitter';

/**
 * Core logic for sending menu - can be used by both AI tools and interactive handlers
 */
export async function getMenuResponses(): Promise<ToolResponse | ToolResponse[]> {
  const menu = await ProductService.getActiveProducts({ formatForWhatsApp: true });
  const menuText = String(menu);
  
  // If menu is too long, split it into parts
  const maxLength = 4000; // Reduced to ensure safety margin for WhatsApp's 4096 limit
  
  if (menuText.length > maxLength) {
    const parts = MessageSplitter.splitMenu(menuText, maxLength);
    
    // Return multiple responses
    return parts.map((part, index) => ({
      text: part,
      isRelevant: false,
      sendToWhatsApp: true,
      ...(index === parts.length - 1 && { 
        historyMarker: "MENÚ ENVIADO" 
      })
    }));
  } else {
    return {
      text: menuText,
      isRelevant: false,
      sendToWhatsApp: true,
      historyMarker: "MENÚ ENVIADO"
    };
  }
}

/**
 * Handles the send_menu function call for AI tools
 */
export const handleSendMenu: ToolHandler = async (): Promise<ToolResponse | ToolResponse[]> => {
  return getMenuResponses();
};

================
File: backend/src/services/orders/OrderService.ts
================
import { prisma } from '../../lib/prisma';
import { PizzaHalf, CustomizationAction } from '@prisma/client';
import { CreateOrderDto } from '../../dto/order';
import logger from '../../common/utils/logger';
import { NotFoundError, ErrorCode } from '../../common/services/errors';
import { SyncMetadataService } from '../sync/SyncMetadataService';

export class OrderService {
  static async create(createOrderDto: CreateOrderDto) {
    try {
      // Get customer by WhatsApp phone number
      const customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber: createOrderDto.whatsappPhoneNumber }
      });
      
      if (!customer) {
        throw new NotFoundError(
          ErrorCode.CUSTOMER_NOT_FOUND,
          'Customer not found',
          { whatsappPhoneNumber: createOrderDto.whatsappPhoneNumber }
        );
      }
      
      // Get restaurant config for estimated times
      const config = await prisma.restaurantConfig.findFirst();
      const estimatedMinutes = createOrderDto.orderType === 'DELIVERY' 
        ? (config?.estimatedDeliveryTime || 40)
        : (config?.estimatedPickupTime || 20);
      
      // Calculate estimated delivery time as a DateTime
      const now = new Date();
      const estimatedDeliveryTime = new Date(now.getTime() + estimatedMinutes * 60 * 1000);
      
      // Initialize totals - use provided values if available, otherwise will be calculated
      let subtotal = createOrderDto.subtotal || 0;
      let total = createOrderDto.total || 0;
      const hasProvidedTotals = createOrderDto.subtotal !== undefined && createOrderDto.total !== undefined;
      
      // Use Prisma transaction for atomic operations
      const order = await prisma.$transaction(async (tx) => {
        // Create the order without shiftOrderNumber (will be assigned during sync)
        const newOrder = await tx.order.create({
          data: {
            orderType: createOrderDto.orderType as "DINE_IN" | "TAKE_AWAY" | "DELIVERY",
            customerId: customer.id,
            scheduledAt: createOrderDto.scheduledAt ? new Date(createOrderDto.scheduledAt) : null,
            orderStatus: 'PENDING',
            subtotal,
            total,
            estimatedDeliveryTime,
            isFromWhatsApp: true,
            createdAt: new Date(),
            updatedAt: new Date()
          }
        });
        
        // Create order items if provided
        if (createOrderDto.orderItems && createOrderDto.orderItems.length > 0) {
          await Promise.all(
            createOrderDto.orderItems.map(async (item) => {
              // Validate productId exists
              if (!item.productId) {
                throw new NotFoundError(
                  ErrorCode.MISSING_REQUIRED_FIELD,
                  'Product ID is required for each order item',
                  { metadata: { item } }
                );
              }
              
              // Get product and variant info to calculate price
              const product = await tx.product.findUnique({
                where: { id: item.productId },
                include: { variants: true }
              });
              
              if (!product) {
                throw new NotFoundError(
                  ErrorCode.INVALID_PRODUCT,
                  `Product ${item.productId} not found`,
                  { metadata: { productId: item.productId } }
                );
              }
              
              // Calculate base price
              let itemPrice = 0;
              if (item.productVariantId) {
                const variant = product.variants.find(v => v.id === item.productVariantId);
                if (variant) {
                  itemPrice = variant.price;
                }
              } else if (product.price !== null) {
                itemPrice = product.price;
              }
              
              // First calculate total price including modifiers
              let modifierIds: string[] = [];
              if (item.selectedModifiers && item.selectedModifiers.length > 0) {
                modifierIds = item.selectedModifiers; // Now directly an array of strings
                
                // Get modifier prices
                const modifiers = await tx.productModifier.findMany({
                  where: { id: { in: modifierIds } }
                });
                
                // Add modifier prices to item price
                for (const modifier of modifiers) {
                  itemPrice += modifier.price || 0;
                }
              }
              
              // Crear items individuales según la cantidad
              const quantity = item.quantity || 1;
              const orderItems = [];
              
              for (let i = 0; i < quantity; i++) {
                const orderItem = await tx.orderItem.create({
                  data: {
                    orderId: newOrder.id,
                    productId: item.productId,
                    productVariantId: item.productVariantId,
                    basePrice: itemPrice,
                    finalPrice: itemPrice,
                    productModifiers: modifierIds.length > 0 ? {
                      connect: modifierIds.map(id => ({ id }))
                    } : undefined
                  }
                });
                orderItems.push(orderItem);
              }
              
              // Create selected pizza customizations for each order item if provided
              if (item.selectedPizzaCustomizations && item.selectedPizzaCustomizations.length > 0) {
                for (const orderItem of orderItems) {
                  await Promise.all(
                    item.selectedPizzaCustomizations.map(customization =>
                      tx.selectedPizzaCustomization.create({
                        data: {
                          orderItemId: orderItem.id,
                          pizzaCustomizationId: customization.pizzaCustomizationId,
                          half: customization.half as PizzaHalf,
                          action: customization.action as CustomizationAction
                        }
                      })
                    )
                  );
                }
              }
              
              // Calculate total price for all items of this type only if totals weren't provided
              if (!hasProvidedTotals) {
                const itemTotal = itemPrice * quantity;
                subtotal += itemTotal;
              }
              
              return orderItems;
            })
          );
        }
        
        // Create delivery info if provided
        if (createOrderDto.deliveryInfo) {
          await tx.deliveryInfo.create({
            data: {
              ...createOrderDto.deliveryInfo,
              orderId: newOrder.id,
            }
          });
        }
        
        // Calculate total only if not provided (for now, total = subtotal, but can add taxes, delivery fees, etc. later)
        if (!hasProvidedTotals) {
          total = subtotal;
        }
        
        // Update order with calculated totals
        const updatedOrder = await tx.order.update({
          where: { id: newOrder.id },
          data: { subtotal, total }
        });
        
        // Mark order for sync within the transaction to ensure consistency
        await SyncMetadataService.markForSync('Order', updatedOrder.id, 'REMOTE');
        
        return updatedOrder;
      });
      
      return order;
    } catch (error) {
      logger.error('Error creating order:', error);
      throw error;
    }
  }

  static async findOne(id: string) {
    return prisma.order.findUnique({
      where: { id },
      include: {
        orderItems: {
          include: {
            product: true,
            productVariant: true,
            productModifiers: true,
            selectedPizzaCustomizations: {
              include: {
                pizzaCustomization: true
              }
            }
          }
        },
        deliveryInfo: true
      }
    });
  }

  static async update(id: string, updateData: any) {
    try {
      // Check if order is being finalized
      const finalizedStatuses = ['COMPLETED', 'DELIVERED', 'CANCELLED'];
      if (updateData.orderStatus && finalizedStatuses.includes(updateData.orderStatus)) {
        updateData.finalizedAt = new Date();
      }
      
      const order = await prisma.order.update({
        where: { id },
        data: {
          ...updateData,
          updatedAt: new Date()
        }
      });
      return order;
    } catch (error: any) {
      // Handle specific Prisma errors
      if (error.code === 'P2025') {
        throw new NotFoundError(
          ErrorCode.ORDER_NOT_FOUND,
          'Order not found',
          { orderId: id }
        );
      }
      // Re-throw other errors
      throw error;
    }
  }

}

================
File: backend/src/services/orders/services/DeliveryInfoService.ts
================
import { prisma } from '../../../lib/prisma';
import { ValidationError, ErrorCode, NotFoundError } from "../../../common/services/errors";
import logger from "../../../common/utils/logger";
import { DeliveryInfoInput } from "../../../common/types";
import { Address, Prisma, OrderType } from "@prisma/client";
import { SyncMetadataService } from "../../sync/SyncMetadataService";

export class DeliveryInfoService {
  /**
   * Obtener o crear información de entrega para una orden
   */
  static async getOrCreateDeliveryInfo(
    orderType: OrderType,
    customerId: string,
    deliveryInfoInput?: DeliveryInfoInput,
    customerData?: { firstName?: string | null, lastName?: string | null, whatsappPhoneNumber: string }
  ): Promise<any> {
    // Obtener la dirección predeterminada del cliente o la primera dirección activa
    const customerAddress = await prisma.address.findFirst({
      where: { 
        customerId,
        deletedAt: null
      },
      orderBy: [
        { isDefault: 'desc' },
        { createdAt: 'desc' }
      ]
    });

    if (!customerAddress) {
      throw new ValidationError(
        ErrorCode.MISSING_DELIVERY_INFO,
        'Customer has no active addresses',
        { metadata: { customerId } }
      );
    }

    // Construir datos de información de entrega basados en el tipo de orden
    let deliveryInfoData: any = {};

    if (orderType === OrderType.DELIVERY) {
      // Copiar todos los campos de dirección desde la dirección del cliente
      // Esto crea una instantánea de la dirección en el momento de la orden
      deliveryInfoData = {
        street: deliveryInfoInput?.street || customerAddress.street,
        number: customerAddress.number,
        interiorNumber: customerAddress.interiorNumber,
        neighborhood: deliveryInfoInput?.neighborhood || customerAddress.neighborhood,
        zipCode: deliveryInfoInput?.zipCode || customerAddress.zipCode,
        city: deliveryInfoInput?.city || customerAddress.city,
        state: deliveryInfoInput?.state || customerAddress.state,
        country: deliveryInfoInput?.country || customerAddress.country,
        latitude: deliveryInfoInput?.latitude || customerAddress.latitude?.toNumber(),
        longitude: deliveryInfoInput?.longitude || customerAddress.longitude?.toNumber(),
        deliveryInstructions: deliveryInfoInput?.deliveryInstructions || customerAddress.deliveryInstructions,
        recipientName: deliveryInfoInput?.recipientName || 
          (customerData ? `${customerData.firstName || ''} ${customerData.lastName || ''}`.trim() || null : null),
        recipientPhone: deliveryInfoInput?.recipientPhone || customerData?.whatsappPhoneNumber,
      };

      // Validar campos requeridos para entrega
      if (!deliveryInfoData.street || !deliveryInfoData.number) {
        throw new ValidationError(
          ErrorCode.MISSING_DELIVERY_INFO,
          'Street address and number are required for delivery orders',
          { metadata: { customerId, orderType } }
        );
      }
    } else if (orderType === OrderType.TAKE_AWAY) {
      // Para órdenes de recogida, guardar quien recogerá la orden
      deliveryInfoData = {
        recipientName: deliveryInfoInput?.recipientName || 
          (customerData ? `${customerData.firstName || ''} ${customerData.lastName || ''}`.trim() || null : null),
        recipientPhone: deliveryInfoInput?.recipientPhone || customerData?.whatsappPhoneNumber,
      };
    }

    // Crear una copia de información de entrega para esta orden específica
    // Esto preserva la dirección en el momento de creación de la orden
    const deliveryInfo = await prisma.deliveryInfo.create({
      data: deliveryInfoData
    });

    logger.info(`Created delivery info ${deliveryInfo.id} from customer address`);
    return deliveryInfo;
  }



  /**
   * Crear dirección del cliente
   */
  static async createCustomerAddress(
    data: Prisma.AddressCreateInput
  ): Promise<Address> {
    try {
      // Si esta es la primera dirección, hacerla predeterminada
      const existingAddresses = await prisma.address.count({
        where: { 
          customerId: data.customer.connect?.id || data.customer.connectOrCreate?.where.id,
          deletedAt: null
        }
      });
      
      const addressData = {
        ...data,
        isDefault: existingAddresses === 0 ? true : (data.isDefault || false)
      };
      
      // Si se establece como predeterminada, desmarcar otras predeterminadas
      if (addressData.isDefault) {
        await prisma.address.updateMany({
          where: { 
            customerId: data.customer.connect?.id || data.customer.connectOrCreate?.where.id,
            isDefault: true
          },
          data: { isDefault: false }
        });
      }
      
      const address = await prisma.address.create({
        data: addressData
      });
      
      // Mark for sync
      await SyncMetadataService.markForSync('Address', address.id, 'REMOTE');
      
      logger.info(`Created customer address ${address.id} for customer ${address.customerId}`);
      return address;
    } catch (error) {
      logger.error('Error creating customer address:', error);
      throw new ValidationError(ErrorCode.DATABASE_ERROR, 'Failed to create customer address', { metadata: { error: error instanceof Error ? error.message : 'Unknown error' } });
    }
  }

  /**
   * Actualizar dirección del cliente
   */
  static async updateCustomerAddress(
    addressId: string,
    data: Prisma.AddressUpdateInput
  ): Promise<Address> {
    try {
      const deliveryInfo = await prisma.address.update({
        where: { id: addressId },
        data
      });
      
      // Mark for sync
      await SyncMetadataService.markForSync('Address', addressId, 'REMOTE');
      
      logger.info(`Updated address ${addressId}`);
      return deliveryInfo;
    } catch (error: any) {
      if (error.code === 'P2025') {
        throw new NotFoundError(
          ErrorCode.ORDER_NOT_FOUND,
          'Address not found',
          { metadata: { addressId } }
        );
      }
      
      logger.error('Error updating customer address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to update customer address',
        { metadata: { addressId } }
      );
    }
  }


  /**
   * Obtener todas las direcciones del cliente
   */
  static async getCustomerAddresses(
    customerId: string,
    includeInactive: boolean = false
  ): Promise<Address[]> {
    try {
      const addresses = await prisma.address.findMany({
        where: { 
          customerId,
          ...(includeInactive ? {} : { deletedAt: null })
        },
        orderBy: [
          { isDefault: 'desc' },
          { createdAt: 'desc' }
        ]
      });
      
      return addresses;
    } catch (error) {
      logger.error('Error fetching customer addresses:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to fetch customer addresses',
        { metadata: { customerId } }
      );
    }
  }

  /**
   * Obtener la dirección predeterminada del cliente
   */
  static async getCustomerDefaultAddress(
    customerId: string
  ): Promise<Address | null> {
    try {
      const address = await prisma.address.findFirst({
        where: { 
          customerId,
          isDefault: true,
          deletedAt: null
        }
      });
      
      if (!address) {
        // Si no hay predeterminada, obtener la primera dirección activa
        const firstAddress = await prisma.address.findFirst({
          where: { 
            customerId,
            deletedAt: null
          },
          orderBy: { createdAt: 'desc' }
        });
        
        return firstAddress;
      }
      
      return address;
    } catch (error) {
      logger.error('Error fetching default address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to fetch default address',
        { metadata: { customerId } }
      );
    }
  }

  /**
   * Establecer dirección como predeterminada
   */
  static async setDefaultAddress(
    addressId: string,
    customerId?: string
  ): Promise<Address> {
    try {
      // Get the address first to verify it exists and get customerId if not provided
      const address = await prisma.address.findUnique({
        where: { id: addressId },
        select: { customerId: true }
      });
      
      if (!address) {
        throw new NotFoundError(
          ErrorCode.ADDRESS_NOT_FOUND,
          'Address not found',
          { metadata: { addressId } }
        );
      }
      
      // Use provided customerId or the one from the address
      const actualCustomerId = customerId || address.customerId;
      
      // Verify ownership if customerId was provided
      if (customerId && address.customerId !== customerId) {
        throw new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          'Address does not belong to customer',
          { metadata: { addressId, customerId } }
        );
      }
      
      // Desmarcar otras predeterminadas
      const previousDefaults = await prisma.address.findMany({
        where: { 
          customerId: actualCustomerId,
          isDefault: true
        },
        select: { id: true }
      });
      
      await prisma.address.updateMany({
        where: { 
          customerId: actualCustomerId,
          isDefault: true
        },
        data: { isDefault: false }
      });
      
      // Mark previous defaults for sync
      for (const prevDefault of previousDefaults) {
        await SyncMetadataService.markForSync('Address', prevDefault.id, 'REMOTE');
      }
      
      // Establecer esta como predeterminada
      const updatedAddress = await prisma.address.update({
        where: { id: addressId },
        data: { isDefault: true }
      });
      
      // Mark new default for sync
      await SyncMetadataService.markForSync('Address', addressId, 'REMOTE');
      
      logger.info(`Set address ${addressId} as default for customer ${actualCustomerId}`);
      return updatedAddress;
    } catch (error) {
      if (error instanceof NotFoundError || error instanceof ValidationError) {
        throw error;
      }
      
      logger.error('Error setting default address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to set default address',
        { metadata: { addressId } }
      );
    }
  }

  /**
   * Eliminación suave de dirección
   */
  static async deleteCustomerAddress(
    addressId: string,
    customerId?: string
  ): Promise<void> {
    try {
      // Get the address to verify ownership
      const address = await prisma.address.findUnique({
        where: { id: addressId }
      });
      
      if (!address) {
        throw new NotFoundError(
          ErrorCode.ADDRESS_NOT_FOUND,
          'Address not found',
          { metadata: { addressId } }
        );
      }
      
      // Verify ownership if customerId was provided
      if (customerId && address.customerId !== customerId) {
        throw new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          'Address does not belong to customer',
          { metadata: { addressId, customerId } }
        );
      }
      
      // Eliminación suave
      await prisma.address.update({
        where: { id: addressId },
        data: { 
          deletedAt: new Date()
        }
      });
      
      // Mark for sync
      await SyncMetadataService.markForSync('Address', addressId, 'REMOTE');
      
      // Si era predeterminada, establecer otra como predeterminada
      if (address.isDefault) {
        const nextDefault = await prisma.address.findFirst({
          where: { 
            customerId: address.customerId,
            deletedAt: null,
            id: { not: addressId }
          },
          orderBy: { createdAt: 'desc' }
        });
        
        if (nextDefault) {
          await this.setDefaultAddress(nextDefault.id, address.customerId);
        }
      }
      
      logger.info(`Soft deleted address ${addressId} for customer ${address.customerId}`);
    } catch (error) {
      if (error instanceof NotFoundError || error instanceof ValidationError) {
        throw error;
      }
      
      logger.error('Error deleting address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to delete address',
        { metadata: { addressId } }
      );
    }
  }
}

================
File: backend/src/whatsapp/handlers/orders/orderFormatters.ts
================
// En: backend/src/whatsapp/handlers/orders/orderFormatters.ts

import { env } from '../../../common/config/envValidator';
import { CalculatedOrderItem } from '../../../common/types';

/**
 * Formatea las personalizaciones de una pizza de manera legible.
 * Esta función es ahora la ÚNICA responsable de formatear pizzas.
 * @param customizations - Array de `pizzaCustomizationDetails` del `CalculatedOrderItem`.
 * @returns Un string formateado que describe las personalizaciones.
 */
function formatPizzaCustomizations(customizations: CalculatedOrderItem['pizzaCustomizationDetails']): string {
  if (!customizations || customizations.length === 0) {
    return '';
  }

  // Agrupar personalizaciones por mitad (FULL, HALF_1, HALF_2)
  const groups = customizations.reduce((acc, cust) => {
    acc[cust.half] = acc[cust.half] || [];
    acc[cust.half].push(cust);
    return acc;
  }, {} as Record<string, typeof customizations>);

  // Función auxiliar para formatear una mitad
  const formatHalf = (halfCustoms: typeof customizations): string => {
    const flavors = halfCustoms.filter(c => c.type === 'FLAVOR' && c.action === 'ADD').map(c => c.name);
    const ingredients = halfCustoms.filter(c => c.type === 'INGREDIENT' && c.action === 'ADD').map(c => c.name);
    const removed = halfCustoms.filter(c => c.action === 'REMOVE').map(c => c.name);

    let parts: string[] = [];
    if (flavors.length > 0) parts.push(flavors.join(', '));
    if (ingredients.length > 0) parts.push(`con: ${ingredients.join(', ')}`);
    if (removed.length > 0) parts.push(`sin: ${removed.join(', ')}`);
    
    return parts.join(' - ');
  };

  const fullPizzaText = groups['FULL'] ? formatHalf(groups['FULL']) : '';
  const half1Text = groups['HALF_1'] ? formatHalf(groups['HALF_1']) : '';
  const half2Text = groups['HALF_2'] ? formatHalf(groups['HALF_2']) : '';

  let result = '';
  if (fullPizzaText) {
    result += `  ${fullPizzaText}\n`;
  }
  if (half1Text && half2Text) {
    result += `  (Mitad: ${half1Text} / Mitad: ${half2Text})\n`;
  } else if (half1Text) {
    result += `  (Mitad: ${half1Text})\n`;
  } else if (half2Text) {
    result += `  (Mitad: ${half2Text})\n`;
  }

  return result;
}

/**
 * Genera el resumen para un único producto del pedido.
 * Ahora espera un objeto `CalculatedOrderItem` bien definido.
 */
export function generateProductSummary(item: CalculatedOrderItem): string {
  // El nombre a mostrar es la variante si existe, si no, el producto principal.
  const displayName = item.variantName || item.productName;
  
  // La cantidad ahora se maneja en el objeto principal.
  let summary = `• *${item.quantity}x ${displayName}* - $${item.totalPrice}\n`;

  // Añadir modificadores si existen.
  if (item.modifierNames && item.modifierNames.length > 0) {
    summary += `  ${item.modifierNames.join(", ")}\n`;
  }

  // Añadir personalizaciones de pizza si existen.
  if (item.pizzaCustomizationDetails && item.pizzaCustomizationDetails.length > 0) {
    summary += formatPizzaCustomizations(item.pizzaCustomizationDetails);
  }

  // Añadir comentarios si existen.
  if (item.comments) {
    summary += `  Nota: ${item.comments}\n`;
  }

  return summary;
}

/**
 * Genera el resumen completo de un pedido para enviar por WhatsApp.
 */
export function generateOrderSummary(order: {
  orderType: string;
  deliveryInfo?: any;
  items: CalculatedOrderItem[];
  total: number;
  estimatedDeliveryTime?: number;
  scheduledAt?: Date;
}): string {
  const orderType = (order.orderType || '').toString().toLowerCase();
  const deliveryTypeText = orderType === "delivery" ? "Entrega a domicilio" : "Recolección";

  let message = `📋 *Resumen de tu pedido:*\n\n`;
  message += `📦 *Tipo de orden:* ${deliveryTypeText}\n\n`;

  if (orderType === "delivery" && order.deliveryInfo) {
    const info = order.deliveryInfo;
    message += `📍 *Dirección de entrega:*\n`;
    if (info.name) message += `*${info.name}*\n`;
    message += `${info.street} ${info.number || ''}${info.interiorNumber ? ` Int. ${info.interiorNumber}` : ''}\n`;
    if (info.neighborhood) message += `Col. ${info.neighborhood}\n`;
    if (info.deliveryInstructions) message += `Ref: ${info.deliveryInstructions}\n`;
    message += "\n";
  }

  message += `🛒 *Productos:*\n`;
  order.items.forEach(item => {
    // Aquí es importante asegurarse de que el `item` que se pasa
    // tenga la estructura de `CalculatedOrderItem`.
    message += generateProductSummary(item);
  });

  message += `\n💰 *Total: $${order.total.toFixed(2)}*\n`;

  if (order.estimatedDeliveryTime) {
    message += `\n⏱️ *Tiempo estimado:* ${order.estimatedDeliveryTime} minutos\n`;
  }

  if (order.scheduledAt) {
    const date = new Date(order.scheduledAt);
    const formattedTime = date.toLocaleTimeString(env.DEFAULT_LOCALE, {
      hour: "2-digit",
      minute: "2-digit",
    });
    message += `\n⏰ *Programado para:* Hoy a las ${formattedTime}\n`;
  }

  message += `\n📝 Por favor, confirma si tu pedido es correcto.`;
  
  return message;
}

================
File: backend/package.json
================
{
  "name": "backend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "ts-node --transpile-only src/server.ts",
    "dev:worker": "ts-node --transpile-only src/run-workers.ts",
    "dev:all": "cd .. && ./dev.sh",
    "dev:frontend": "cd .. && ./dev-frontend.sh",
    "build": "tsc",
    "start": "node dist/server.js",
    "start:worker": "node dist/run-workers.js",
    "start:prod": "node dist/server.js",
    "migrate": "prisma migrate deploy",
    "migrate:dev": "prisma migrate dev",
    "generate": "prisma generate",
    "studio": "prisma studio",
    "seed:embeddings": "node scripts/generate-embeddings.js",
    "reset-db": "./scripts/reset-db.sh",
    "postinstall": "prisma generate",
    "pm2:start": "npm run build && pm2 start ecosystem.config.js",
    "pm2:stop": "pm2 stop ecosystem.config.js",
    "pm2:delete": "pm2 delete ecosystem.config.js",
    "pm2:reload": "pm2 reload ecosystem.config.js",
    "pm2:logs": "pm2 logs",
    "pm2:monit": "pm2 monit"
  },
  "dependencies": {
    "@google/genai": "^1.5.1",
    "@prisma/client": "^6.9.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "@types/ioredis": "^4.28.10",
    "@types/multer": "^1.4.13",
    "axios": "^1.7.7",
    "bullmq": "^5.56.4",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^4.21.2",
    "ioredis": "^5.6.1",
    "moment": "^2.30.1",
    "moment-timezone": "^0.5.45",
    "multer": "^2.0.1",
    "pg": "^8.13.0",
    "prisma": "^6.9.0",
    "reflect-metadata": "^0.2.2",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "stripe": "^17.3.1",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@types/axios": "^0.14.0",
    "ts-node": "^10.9.2"
  }
}

================
File: backend/prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

// Enums
enum OrderType {
  DINE_IN
  TAKE_AWAY
  DELIVERY
}

enum OrderStatus {
  PENDING
  IN_PROGRESS
  IN_PREPARATION
  READY
  IN_DELIVERY
  DELIVERED
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  TRANSFER
  STRIPE
  PAYPAL
  OTHER
}

enum PizzaHalf {
  FULL
  HALF_1
  HALF_2
}

enum CustomizationAction {
  ADD
  REMOVE
}

enum CustomizationType {
  FLAVOR
  INGREDIENT
}

enum PreparationStatus {
  PENDING
  IN_PROGRESS
  READY
  DELIVERED
  CANCELLED
}

// Models
model Category {
  id           String        @id
  name         String        @unique
  description  String?
  isActive     Boolean       @default(true)
  photoId      String?
  sortOrder    Int           @default(0)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  deletedAt    DateTime?
  subcategories Subcategory[]
}

model Customer {
  id                  String               @id @default(uuid()) @db.Uuid // UUID primary key
  whatsappPhoneNumber String               @unique // WhatsApp phone number
  firstName           String?              @db.VarChar(100)
  lastName            String?              @db.VarChar(100)
  email               String?              @db.VarChar(255)
  birthDate           DateTime?            @db.Date
  fullChatHistory     Json?
  relevantChatHistory Json?
  stripeCustomerId    String?              @unique
  lastInteraction     DateTime?
  totalOrders         Int                  @default(0)
  totalSpent          Decimal              @default(0) @db.Decimal(10, 2)
  isActive            Boolean              @default(true)
  isBanned            Boolean              @default(false)
  bannedAt            DateTime?
  banReason           String?              @db.Text
  deletedAt           DateTime?            // Soft delete
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  addresses           Address[]            // One-to-Many relationship
  orders              Order[]              // One-to-Many relationship
  
  @@index([whatsappPhoneNumber])
  @@index([email])
}

// Customer addresses (1:N relationship)
// A customer can have multiple delivery addresses
model Address {
  id                String   @id @default(uuid()) @db.Uuid // UUID primary key
  customerId        String   @db.Uuid // Foreign key to Customer
  name              String   @db.VarChar(100) // e.g., "Casa", "Oficina", "Casa de mamá"
  street            String   @db.VarChar(200)
  number            String   @db.VarChar(50)
  interiorNumber    String?  @db.VarChar(50)
  neighborhood      String?  @db.VarChar(150)
  city              String?  @db.VarChar(100)
  state             String?  @db.VarChar(100)
  zipCode           String?  @db.VarChar(10)
  country           String?  @db.VarChar(100)
  deliveryInstructions String?  @db.Text
  latitude          Decimal? @db.Decimal(10, 8)
  longitude         Decimal? @db.Decimal(11, 8)
  isDefault         Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  deletedAt         DateTime? // Soft delete
  customer          Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@index([customerId])
  @@index([zipCode])
}

model MessageLog {
  id        Int     @id @default(autoincrement())
  messageId String  @unique
  processed Boolean @default(false)
}

model ProductModifier {
  id               String             @id
  modifierGroupId  String
  name             String
  description      String?
  price            Float?
  sortOrder        Int                @default(0)
  isDefault        Boolean            @default(false)
  isActive         Boolean            @default(true)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  deletedAt        DateTime?
  modifierGroup    ModifierGroup      @relation(fields: [modifierGroupId], references: [id])
  orderItems       OrderItem[]        @relation("OrderItemProductModifiers")
}

model ModifierGroup {
  id                      String            @id
  name                    String
  description             String?
  minSelections           Int               @default(0)
  maxSelections           Int               @default(1)
  isRequired              Boolean           @default(false)
  allowMultipleSelections Boolean           @default(false)
  isActive                Boolean           @default(true)
  sortOrder               Int               @default(0)
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt
  deletedAt               DateTime?
  products                Product[]         @relation("ProductModifierGroups")
  productModifiers        ProductModifier[]
}

model Order {
  id                   String            @id @default(uuid()) @db.Uuid
  shiftOrderNumber     Int?
  orderType            OrderType
  orderStatus          OrderStatus       @default(PENDING)
  subtotal             Float             @default(0)
  total                Float             @default(0)
  customerId           String            @db.Uuid
  estimatedDeliveryTime DateTime?
  scheduledAt          DateTime?
  notes                String?
  isFromWhatsApp       Boolean           @default(true)
  finalizedAt          DateTime?         // When order was marked as completed/delivered
  // Additional relations for local backend compatibility
  shiftId              String?           @db.Uuid
  userId               String?           @db.Uuid
  tableId              String?           @db.Uuid
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  deletedAt            DateTime?
  // Relations
  orderItems           OrderItem[]
  deliveryInfo         DeliveryInfo?
  customer             Customer          @relation(fields: [customerId], references: [id])
  payments             Payment[]
  ticketImpressions    TicketImpression[]
  adjustments          Adjustment[]
  shift                Shift?            @relation(fields: [shiftId], references: [id])
  table                Table?            @relation(fields: [tableId], references: [id])
  user                 User?             @relation(fields: [userId], references: [id])
  
  @@index([shiftId])
  @@index([tableId])
  @@index([userId])
}

// Order's delivery address (snapshot at order time)
// This is a copy of the customer's address at the time of order creation
// Preserves historical data even if customer changes their address later
model DeliveryInfo {
  id                    String    @id @default(uuid()) @db.Uuid
  orderId               String?   @unique @db.Uuid
  preOrderId            Int?      @unique
  name                  String?   @db.VarChar(100) // Address name like "Casa", "Oficina"
  fullAddress           String?   @db.Text // Full address for phone orders
  street                String?   @db.VarChar(200)
  number                String?   @db.VarChar(50)
  interiorNumber        String?   @db.VarChar(50)
  neighborhood          String?   @db.VarChar(150)
  city                  String?   @db.VarChar(100)
  state                 String?   @db.VarChar(100)
  zipCode               String?   @db.VarChar(10)
  country               String?   @db.VarChar(100)
  recipientName         String?   @db.VarChar(255) // Recipient name
  recipientPhone        String?   @db.VarChar(50) // Recipient phone
  deliveryInstructions  String?   @db.Text // Delivery instructions
  latitude              Decimal?  @db.Decimal(10, 8)
  longitude             Decimal?  @db.Decimal(11, 8)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  order                 Order?    @relation(fields: [orderId], references: [id])
  preOrder              PreOrder? @relation(fields: [preOrderId], references: [id])
}

model OrderItem {
  id                    String                     @id @default(uuid()) @db.Uuid
  orderId               String?                    @db.Uuid
  preOrderId            Int?
  productId             String
  productVariantId      String?
  basePrice             Float
  finalPrice            Float
  preparationStatus     PreparationStatus          @default(PENDING)
  statusChangedAt       DateTime                   @default(now())
  preparationNotes      String?
  createdAt             DateTime                   @default(now())
  updatedAt             DateTime                   @updatedAt
  deletedAt             DateTime?
  order                 Order?                     @relation(fields: [orderId], references: [id])
  preOrder              PreOrder?                  @relation(fields: [preOrderId], references: [id])
  product               Product                    @relation(fields: [productId], references: [id])
  productVariant        ProductVariant?            @relation(fields: [productVariantId], references: [id])
  productModifiers      ProductModifier[]          @relation("OrderItemProductModifiers")
  selectedPizzaCustomizations SelectedPizzaCustomization[]
  adjustments           Adjustment[]
  
  @@index([orderId])
  @@index([preOrderId])
}

// Nueva estructura para personalización de pizzas
model PizzaCustomization {
  id                    String                       @id
  name                  String                       // Nombre: "Hawaiana", "Pepperoni", "Champiñones"
  type                  CustomizationType            // FLAVOR | INGREDIENT
  ingredients           String?                      // Para FLAVOR: lista de ingredientes
  toppingValue          Int                          @default(1) // Cuánto cuenta para el límite
  isActive              Boolean                      @default(true)
  sortOrder             Int                          @default(0)
  createdAt             DateTime                     @default(now())
  updatedAt             DateTime                     @updatedAt
  deletedAt             DateTime?
  products              Product[]                    @relation("ProductPizzaCustomizations")
  selectedPizzaCustomizations SelectedPizzaCustomization[]
}

// Configuración específica para pizzas
model PizzaConfiguration {
  id                    String   @id @default(uuid()) @db.Uuid
  productId             String   @unique
  product               Product  @relation(fields: [productId], references: [id])
  includedToppings      Int      @default(4)      // Valor de toppings incluidos en precio base
  extraToppingCost      Float    @default(20)     // Costo por topping adicional
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  deletedAt             DateTime?
}

model PreOrder {
  id                    Int                @id @default(autoincrement())
  orderType             OrderType
  estimatedDeliveryTime Int                @default(0)
  scheduledAt           DateTime?
  notes                 String?
  subtotal              Float              @default(0)
  total                 Float              @default(0)
  whatsappPhoneNumber   String             // Store WhatsApp phone number instead of customerId
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  orderItems            OrderItem[]
  deliveryInfo          DeliveryInfo?
  adjustments           Adjustment[]
  
  @@index([whatsappPhoneNumber])
}

model Product {
  id                   String              @id
  name                 String
  description          String?
  price                Float?
  hasVariants          Boolean             @default(false)
  isActive             Boolean             @default(true)
  isPizza              Boolean             @default(false)
  subcategoryId        String
  preparationScreenId  String?
  photoId              String?
  estimatedPrepTime    Int                 @default(0)
  sortOrder            Int                 @default(0)
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  deletedAt            DateTime?
  // Embedding para búsqueda semántica (modelo text-embedding-004 usa 768 dimensiones)
  embedding            Unsupported("vector(768)")?
  subcategory          Subcategory         @relation(fields: [subcategoryId], references: [id])
  variants             ProductVariant[]
  modifierGroups       ModifierGroup[]     @relation("ProductModifierGroups")
  pizzaConfiguration   PizzaConfiguration?
  pizzaCustomizations  PizzaCustomization[] @relation("ProductPizzaCustomizations")
  orderItems           OrderItem[]
}

model ProductVariant {
  id          String      @id
  productId   String
  name        String
  price       Float
  isActive    Boolean     @default(true)
  sortOrder   Int         @default(0)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  deletedAt   DateTime?
  product     Product     @relation(fields: [productId], references: [id])
  orderItems  OrderItem[]
}

model RestaurantConfig {
  id                    Int                @id @default(autoincrement())
  // Información básica del restaurante
  restaurantName        String             @default("La Leña") // Nombre del restaurante
  phoneMain             String?            // Teléfono principal
  phoneSecondary        String?            // Teléfono secundario/móvil
  address               String?            // Dirección completa
  city                  String?            // Ciudad
  state                 String?            // Estado
  postalCode            String?            // Código postal
  country               String?            // País
  
  // Configuración de operación
  acceptingOrders       Boolean            @default(true)
  estimatedPickupTime   Int                @default(20) // Tiempo estimado de recolección en minutos
  estimatedDeliveryTime Int                @default(40) // Tiempo estimado de entrega a domicilio en minutos
  openingGracePeriod    Int                @default(30) // Minutos después de abrir antes de aceptar pedidos
  closingGracePeriod    Int                @default(30) // Minutos antes de cerrar para dejar de aceptar pedidos
  timeZone              String             @default("America/Mexico_City") // Zona horaria del restaurante
  businessHours         BusinessHours[]
  
  // Configuración de delivery
  deliveryCoverageArea  Json?              // Polígono de cobertura - Array de objetos {lat: number, lng: number}
}

model BusinessHours {
  id                 Int              @id @default(autoincrement())
  dayOfWeek          Int              // 0 = Domingo, 1 = Lunes, ... 6 = Sábado
  openingTime        String?          // Hora de apertura en formato HH:mm (null = cerrado)
  closingTime        String?          // Hora de cierre en formato HH:mm (null = cerrado)
  isClosed           Boolean          @default(false) // true si el restaurante está cerrado ese día
  restaurantConfigId Int
  restaurantConfig   RestaurantConfig @relation(fields: [restaurantConfigId], references: [id])
  
  @@unique([restaurantConfigId, dayOfWeek]) // Un solo horario por día
}


model SelectedPizzaCustomization {
  id                    String               @id @default(uuid()) @db.Uuid
  orderItemId           String               @db.Uuid
  pizzaCustomizationId  String
  half                  PizzaHalf            @default(FULL)
  action                CustomizationAction  @default(ADD)
  orderItem             OrderItem            @relation(fields: [orderItemId], references: [id])
  pizzaCustomization    PizzaCustomization   @relation(fields: [pizzaCustomizationId], references: [id])
  
  @@unique([orderItemId, pizzaCustomizationId, half, action])
}

model Subcategory {
  id          String    @id
  categoryId  String
  name        String    @unique
  description String?
  isActive    Boolean   @default(true)
  photoId     String?
  sortOrder   Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  category    Category  @relation(fields: [categoryId], references: [id])
  products    Product[]
}

// Sync tracking between local and cloud backends
model SyncLog {
  id              String    @id @default(uuid())
  syncType        String    // MENU_PULL | ORDERS_PUSH | CUSTOMERS_SYNC
  recordsAffected Int       @default(0)
  status          String    // SUCCESS | FAILED
  error           String?   @db.Text
  startedAt       DateTime  @default(now())
  completedAt     DateTime?
  
  @@index([syncType])
  @@index([status])
}

// Payment tracking for orders
model Payment {
  id            String         @id @default(uuid()) @db.Uuid
  orderId       String         @db.Uuid
  paymentMethod PaymentMethod  @default(CASH)
  amount        Decimal        @db.Decimal(10, 2)
  status        PaymentStatus  @default(PENDING)
  stripePaymentId String?      // Stripe payment intent ID
  metadata      Json?          // Additional payment metadata
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  deletedAt     DateTime?
  order         Order          @relation(fields: [orderId], references: [id])
  
  @@index([orderId])
  @@index([status])
}

// Placeholder models for local backend compatibility
// These models are defined but may not be actively used in the WhatsApp bot context

model Shift {
  id            String         @id @default(uuid()) @db.Uuid
  shiftDate     DateTime       @db.Date
  shiftNumber   Int            @default(1)    // Multiple shifts per day (1, 2, 3...)
  startTime     DateTime       @default(now())
  endTime       DateTime?
  orderCounter  Int            @default(0)    // Count of orders in this shift
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  orders        Order[]
  
  @@unique([shiftDate, shiftNumber])
  @@index([shiftDate])
  @@index([startTime])
}

model Table {
  id            String         @id @default(uuid()) @db.Uuid
  tableNumber   String         @unique
  capacity      Int            @default(4)
  isActive      Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  orders        Order[]
}

model User {
  id            String         @id @default(uuid()) @db.Uuid
  username      String         @unique
  email         String?        @unique
  firstName     String?
  lastName      String?
  isActive      Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  deletedAt     DateTime?
  orders        Order[]
}

model TicketImpression {
  id            String         @id @default(uuid()) @db.Uuid
  orderId       String         @db.Uuid
  printedAt     DateTime       @default(now())
  printerName   String?
  order         Order          @relation(fields: [orderId], references: [id])
  
  @@index([orderId])
}

model Adjustment {
  id            String         @id @default(uuid()) @db.Uuid
  orderId       String?        @db.Uuid
  preOrderId    Int?
  orderItemId   String?        @db.Uuid
  type          String         // e.g., "discount", "surcharge", "tip"
  amount        Decimal        @db.Decimal(10, 2)
  reason        String?
  appliedBy     String?        // User who applied the adjustment
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  deletedAt     DateTime?
  order         Order?         @relation(fields: [orderId], references: [id])
  preOrder      PreOrder?      @relation(fields: [preOrderId], references: [id])
  orderItem     OrderItem?     @relation(fields: [orderItemId], references: [id])
  
  @@index([orderId])
  @@index([preOrderId])
  @@index([orderItemId])
}


// Sync metadata for all entities
model SyncMetadata {
  id              String    @id @default(uuid())
  entityType      String    // Customer | Order | Address | Product | etc
  entityId        String    // UUID of the entity
  lastModifiedAt  DateTime  @updatedAt
  modifiedBy      String    @default("REMOTE") // LOCAL | REMOTE
  syncPending     Boolean   @default(false)
  syncVersion     Int       @default(1)
  metadata        Json?     // Additional sync data if needed
  createdAt       DateTime  @default(now())
  
  @@unique([entityType, entityId])
  @@index([syncPending, entityType])
  @@index([lastModifiedAt])
  @@index([entityId])
}

================
File: backend/src/services/orders/PreOrderService.ts
================
import { prisma } from '../../lib/prisma';
import logger from "../../common/utils/logger";
import { SchedulingService } from "./services/SchedulingService";
import { ProductCalculationService } from "./services/ProductCalculationService";
import { DeliveryInfoService } from "./services/DeliveryInfoService";
import { RestaurantService } from "../restaurant/RestaurantService";
import { OrderType } from "@prisma/client";
import { ValidationError, ErrorCode } from "../../common/services/errors";
import { BaseOrderItem, DeliveryInfoInput } from "../../common/types";

export class PreOrderService {
  /**
   * Create a preorder with selected products
   */
  async createPreOrder(orderData: {
    orderItems: BaseOrderItem[];
    whatsappPhoneNumber: string;
    orderType: OrderType;
    scheduledAt?: string | Date;
    deliveryInfo?: DeliveryInfoInput;
  }) {
    const { orderItems, whatsappPhoneNumber, orderType, scheduledAt, deliveryInfo: inputDeliveryInfo } = orderData;

    logger.info(`Starting createPreOrder for ${whatsappPhoneNumber}`, {
      orderType,
      itemCount: orderItems.length,
      scheduledAt,
      items: JSON.stringify(orderItems)
    });

    try {
      // Validar que haya al menos un producto
      if (!orderItems || orderItems.length === 0) {
        throw new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          'No se puede crear una orden sin productos',
          {
            metadata: {
              validationFailure: 'EMPTY_ORDER',
              message: 'Debes agregar al menos un producto a tu pedido'
            }
          }
        );
      }
      
      // Get restaurant config
      const config = await RestaurantService.getConfig();
      
      // Calculate estimated time based on order type
      const estimatedDeliveryTime = orderType === 'DELIVERY' 
        ? config.estimatedDeliveryTime 
        : config.estimatedPickupTime;

      // Validate scheduled time if provided
      const validatedScheduledTime = await SchedulingService.validateScheduledTime(
        scheduledAt,
        orderType
      );

      // Get customerId from whatsapp phone number for delivery info
      const customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber }
      });
      
      // Get or create delivery info
      let deliveryInfoId = null;
      if (customer && (orderType === 'DELIVERY' || orderType === 'TAKE_AWAY')) {
        const deliveryInfo = await DeliveryInfoService.getOrCreateDeliveryInfo(
          orderType,  // Pass the enum directly
          customer.id,
          inputDeliveryInfo,
          customer
        );
        deliveryInfoId = deliveryInfo.id;
      }

      // Calculate items and totals
      const { items: calculatedItems, subtotal, total } = await ProductCalculationService.calculateOrderItems(
        orderItems
      );

      // Create pre-order data
      const preOrderData: any = {
        whatsappPhoneNumber,
        orderType,
        estimatedDeliveryTime,
      };
      
      // Only add scheduledAt if it exists and is valid
      if (validatedScheduledTime) {
        preOrderData.scheduledAt = validatedScheduledTime;
      }
      
      logger.info('Creating pre-order with data:', {
        whatsappPhoneNumber: preOrderData.whatsappPhoneNumber,
        orderType: preOrderData.orderType,
        scheduledAt: preOrderData.scheduledAt,
        itemCount: calculatedItems.length,
        subtotal,
        total
      });
      
      // Create pre-order with related order items and calculated totals
      const preOrder = await prisma.preOrder.create({
        data: {
          ...preOrderData,
          subtotal,
          total,
          ...(deliveryInfoId ? { deliveryInfo: { connect: { id: deliveryInfoId } } } : {}),
          orderItems: {
            create: calculatedItems.map(item => ({
              productId: item.productId,
              productVariantId: item.productVariantId,
              basePrice: item.basePrice,
              finalPrice: item.totalPrice,
              productModifiers: item.selectedModifiers && item.selectedModifiers.length > 0 ? {
                connect: item.selectedModifiers.map(modId => ({ id: modId }))
              } : undefined,
              selectedPizzaCustomizations: item.selectedPizzaCustomizations && item.selectedPizzaCustomizations.length > 0 ? {
                create: item.selectedPizzaCustomizations.map(customization => ({
                  pizzaCustomizationId: customization.pizzaCustomizationId,
                  half: customization.half,
                  action: customization.action
                }))
              } : undefined
            }))
          }
        },
        include: {
          orderItems: {
            include: {
              product: true,
              productVariant: true,
              productModifiers: true,
              selectedPizzaCustomizations: {
                include: {
                  pizzaCustomization: true
                }
              }
            }
          },
          deliveryInfo: true
        }
      });

      logger.info(`Created pre-order ${preOrder.id} for phone ${whatsappPhoneNumber}`, {
        preOrderId: preOrder.id,
        createdAt: preOrder.createdAt
      });

      // Delivery info is now attached to the preOrder
      const deliveryInfo = preOrder.deliveryInfo;

      // Format order items from the created preOrder
      const formattedItems = preOrder.orderItems.map(item => ({
        ...item,
        productName: item.product.name,
        variantName: item.productVariant?.name,
        modifierNames: item.productModifiers.map(m => m.name),
        pizzaCustomizationDetails: item.selectedPizzaCustomizations.map(sc => ({
          pizzaCustomizationId: sc.pizzaCustomizationId,
          name: sc.pizzaCustomization.name,
          type: sc.pizzaCustomization.type,
          half: sc.half,
          action: sc.action
        })),
        quantity: 1, // Quantity is always 1 per item in our current model
        totalPrice: item.finalPrice
      }));

      return {
        preOrderId: preOrder.id,
        orderType,
        items: formattedItems,
        subtotal: preOrder.subtotal,
        total: preOrder.total,
        deliveryInfo,
        scheduledAt: validatedScheduledTime,
        estimatedDeliveryTime: estimatedDeliveryTime,
      };
    } catch (error) {
      logger.error("Error in createPreOrder:", error);
      throw error;
    }
  }


}

================
File: backend/src/services/ai/MenuSearchService.ts
================
import logger from '../../common/utils/logger';
import { prisma } from '../../lib/prisma';
import { Prisma } from '@prisma/client';
import { GoogleGenAI } from '@google/genai';
import { env } from '../../common/config/envValidator';
import { TechnicalError, ErrorCode } from '../../common/services/errors';

/**
 * Service for searching and matching menu items based on natural language input
 * Uses semantic search with Google embeddings and pgvector
 */
export class MenuSearchService {
  private static genAI = new GoogleGenAI({ apiKey: env.GOOGLE_AI_API_KEY });

  /**
   * Gets relevant menu items based on keywords using semantic search
   * @param itemsSummary Natural language description of items
   * @returns JSON string of relevant menu items with their full structure
   */
  static async getRelevantMenu(itemsSummary: string): Promise<string> {
    try {
      // 1. Generate embedding for user query
      const embeddingResponse = await this.genAI.models.embedContent({
        model: env.EMBEDDING_MODEL,
        contents: itemsSummary,
        config: {
          outputDimensionality: 768  // Force 768 dimensions for compatibility with pgvector
        }
      });
      const queryEmbedding = embeddingResponse.embeddings?.[0]?.values || [];
      
      if (queryEmbedding.length === 0) {
        logger.error('Failed to generate embedding for query');
        throw new TechnicalError(
          ErrorCode.EMBEDDING_GENERATION_FAILED,
          'Failed to generate embedding for menu search query',
          { query: itemsSummary }
        );
      }

      // 2. Search database for most similar products using pgvector
      let relevantProductIds: string[] = [];

      // Use pgvector for efficient similarity search with threshold
      try {
        // First, get products with similarity scores
        // Use Prisma.sql to safely build the query with proper parameterization
        const embeddingVector = `[${queryEmbedding.join(',')}]`;
        const relevantProductsResult: { id: string, distance: number }[] = await prisma.$queryRaw`
          SELECT id, 
                 (embedding <=> ${Prisma.sql`${embeddingVector}::vector`}) as distance
          FROM "Product"
          WHERE embedding IS NOT NULL
          ORDER BY distance
          LIMIT 20
        `;
        
        // Filter by similarity threshold (lower distance = more similar)
        // Based on testing: 0.0-0.3 = very similar, 0.3-0.4 = somewhat similar, >0.4 = different
        const SIMILARITY_THRESHOLD = 0.4; // Only include products with strong similarity
        
        const filteredProducts = relevantProductsResult.filter(p => p.distance < SIMILARITY_THRESHOLD);
        
        // If no products meet the strict threshold, but the top result is reasonably close, include it
        if (filteredProducts.length === 0 && relevantProductsResult.length > 0 && relevantProductsResult[0].distance < 0.45) {
          filteredProducts.push(relevantProductsResult[0]);
          // Including top match even though it's slightly above threshold
        }
        
        relevantProductIds = filteredProducts.map(p => p.id);
      } catch (error) {
        logger.error('Error in vector search:', error);
        return "[]";
      }

      if (relevantProductIds.length === 0) {
        logger.warn('No relevant products found via vector search within threshold');
        return "[]";
      }

      // 3. Get full product details
      const products = await prisma.product.findMany({
        where: {
          id: { in: relevantProductIds },
          isActive: true,
        },
        include: {
          subcategory: { include: { category: true } },
          variants: { where: { isActive: true } },
          modifierGroups: {
            where: { isActive: true },
            include: {
              productModifiers: { where: { isActive: true } },
            },
          },
          pizzaCustomizations: { where: { isActive: true } },
        },
      });

      // 4. Sort products by the original order from search
      const sortedProducts = relevantProductIds
        .map(id => products.find(p => p.id === id))
        .filter(Boolean);

      // 5. Build menu structure
      const menuStructure = this.buildMenuStructure(sortedProducts as any[]);
      
      logger.info(`MenuSearchService: Returning ${menuStructure.length} relevant products for query "${itemsSummary}"`);
      // Log only product names for debugging, not full structure
      if (menuStructure.length > 0) {
        const productNames = menuStructure.map((p: any) => p.nombre).join(', ');
        logger.info(`MenuSearchService: Products found: ${productNames}`);
      } else {
        logger.warn(`MenuSearchService: No relevant products found for query "${itemsSummary}"`);
      }
      
      return JSON.stringify(menuStructure);
    } catch (error) {
      logger.error('Error in vector search:', error);
      return "[]";
    }
  }


  /**
   * Builds the menu structure for AI consumption
   * Only includes necessary information for order mapping (no prices needed at this stage)
   */
  private static buildMenuStructure(products: any[]): any[] {
    return products.map(product => {
      const item: any = {
        id: product.id,
        nombre: product.name,
      };
      
      // Include variants with IDs and names only (no prices)
      if (product.variants?.length > 0) {
        item.variantes = product.variants.map((v: any) => ({
          id: v.id,
          nombre: v.name
        }));
      }
      
      // Include modifiers if they exist (simplified)
      if (product.modifierGroups?.length > 0) {
        item.modificadores = product.modifierGroups
          .filter((g: any) => g.productModifiers?.length > 0)
          .map((group: any) => ({
            grupo: group.name,
            opciones: group.productModifiers.map((m: any) => ({
              id: m.id,
              nombre: m.name
            }))
          }));
      }
      
      // Include pizza customizations if it's a pizza
      if (product.isPizza && product.pizzaCustomizations?.length > 0) {
        item.personalizacionesPizza = product.pizzaCustomizations.map((c: any) => ({
          id: c.id,
          nombre: c.name,
          tipo: c.type
        }));
      }
      
      return item;
    });
  }
}

================
File: backend/src/services/orders/services/OrderManagementService.ts
================
import { prisma } from '../../../lib/prisma';
import { Order, OrderStatus } from "@prisma/client";
import logger from "../../../common/utils/logger";
import { BusinessLogicError, ErrorCode } from "../../../common/services/errors";
import { OrderService } from "../OrderService";
import { CreateOrderDto } from '../../../dto/order';
import { sendWhatsAppMessage, WhatsAppService } from "../../whatsapp";
import { OrderFormattingService } from "./OrderFormattingService";
import { SyncMetadataService } from "../../sync/SyncMetadataService";

export class OrderManagementService {
  async confirmPreOrder(preOrderId: number): Promise<Order> {
    const preOrder = await prisma.preOrder.findUnique({
      where: { id: preOrderId },
      include: {
        deliveryInfo: true,
        orderItems: {
          include: {
            product: true,
            productVariant: true,
            productModifiers: true,
            selectedPizzaCustomizations: {
              include: {
                pizzaCustomization: true
              }
            }
          }
        }
      },
    });

    if (!preOrder) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'PreOrder not found',
        { metadata: { preOrderId } }
      );
    }

    const orderItems = preOrder.orderItems.map(item => ({
      productId: item.productId,
      productVariantId: item.productVariantId,
      selectedModifiers: item.productModifiers.map(m => m.id),
      selectedPizzaCustomizations: item.selectedPizzaCustomizations.map(sc => ({
        pizzaCustomizationId: sc.pizzaCustomizationId,
        half: sc.half,
        action: sc.action
      })),
      quantity: 1
    }));

    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: preOrder.whatsappPhoneNumber }
    });

    if (!customer) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer not found for this phone number',
        { metadata: { whatsappPhoneNumber: preOrder.whatsappPhoneNumber } }
      );
    }

    // Usar el deliveryInfo del preOrder si existe
    let deliveryInfo = undefined;
    if (preOrder.deliveryInfo) {
      const info = preOrder.deliveryInfo;
      deliveryInfo = {
        fullAddress: info.fullAddress || undefined,
        street: info.street || undefined,
        number: info.number || undefined,
        interiorNumber: info.interiorNumber || undefined,
        neighborhood: info.neighborhood || undefined,
        zipCode: info.zipCode || undefined,
        city: info.city || undefined,
        state: info.state || undefined,
        country: info.country || undefined,
        latitude: info.latitude ? info.latitude.toNumber() : undefined,
        longitude: info.longitude ? info.longitude.toNumber() : undefined,
        recipientName: info.recipientName || undefined,
        recipientPhone: info.recipientPhone || undefined,
        deliveryInstructions: info.deliveryInstructions || undefined,
      };
    }

    const orderItemsDto = orderItems.map(item => ({
      productId: item.productId,
      productVariantId: item.productVariantId || undefined,
      quantity: item.quantity,
      comments: undefined,
      selectedModifiers: item.selectedModifiers || [],
      selectedPizzaCustomizations: (item.selectedPizzaCustomizations || []).map(pc => ({
        pizzaCustomizationId: pc.pizzaCustomizationId,
        half: pc.half,
        action: pc.action
      }))
    }));

    const orderData: CreateOrderDto = {
      orderItems: orderItemsDto,
      whatsappPhoneNumber: customer.whatsappPhoneNumber,
      orderType: preOrder.orderType,
      scheduledAt: preOrder.scheduledAt ? preOrder.scheduledAt.toISOString() : undefined,
      subtotal: preOrder.subtotal,
      total: preOrder.total,
      ...(deliveryInfo ? { deliveryInfo: deliveryInfo } : {}),
    };

    const order = await OrderService.create(orderData);

    await prisma.preOrder.delete({ where: { id: preOrderId } });

    logger.info(`PreOrder ${preOrderId} converted to Order ${order.id}`);
    
    await SyncMetadataService.markForSync('Order', order.id, 'REMOTE');
    
    try {
      const { SyncNotificationService } = await import('../../sync/SyncNotificationService');
      await SyncNotificationService.notifyNewOrder(order.id);
    } catch (error) {
      logger.warn('Could not notify sync service about new order:', error);
    }
    
    return order;
  }


  
  async getOrderById(orderId: string): Promise<Order | null> {
    return await prisma.order.findUnique({
      where: { id: orderId },
      include: {
        orderItems: {
          include: {
            product: true,
            productVariant: true,
            productModifiers: true,
            selectedPizzaCustomizations: {
              include: { pizzaCustomization: true },
            },
          },
        },
        deliveryInfo: true,
      },
    });
  }

  async discardPreOrder(preOrderId: number): Promise<void> {
    const preOrder = await prisma.preOrder.findUnique({
      where: { id: preOrderId },
    });

    if (!preOrder) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'PreOrder not found',
        { metadata: { preOrderId } }
      );
    }

    await prisma.preOrder.delete({
      where: { id: preOrderId },
    });

    logger.info(`PreOrder ${preOrderId} discarded successfully`);
  }

  async sendOrderConfirmation(
    whatsappNumber: string,
    orderId: string,
    _action: "confirmed" | "cancelled" | "modified" = "confirmed"
  ): Promise<void> {
    try {
      const fullOrder = await prisma.order.findUnique({
        where: { id: orderId },
        include: {
          customer: true,
          orderItems: {
            include: {
              product: true,
              productVariant: true,
              productModifiers: true,
              selectedPizzaCustomizations: {
                include: { pizzaCustomization: true },
              },
            },
          },
          deliveryInfo: true,
        },
      });

      if (!fullOrder) {
        throw new BusinessLogicError(
          ErrorCode.ORDER_NOT_FOUND,
          'Order not found for confirmation',
          { metadata: { orderId } }
        );
      }


      const formattedOrder = OrderFormattingService.formatOrderForWhatsApp(fullOrder, whatsappNumber);
      const orderSummary = await OrderFormattingService.generateConfirmationMessage(fullOrder, formattedOrder);
      
      if (fullOrder.orderStatus === "PENDING" || fullOrder.orderStatus === "IN_PROGRESS") {
        const message = {
          type: "button",
          header: {
            type: "text",
            text: "✅ Orden Confirmada",
          },
          body: {
            text: orderSummary,
          },
          action: {
            buttons: [
              {
                type: "reply",
                reply: {
                  id: `pay_online:${fullOrder.id}`,
                  title: "💳 Pagar en línea",
                },
              },
            ],
          },
        };

        await WhatsAppService.sendInteractiveMessage(whatsappNumber, message);
      } else {
        await sendWhatsAppMessage(whatsappNumber, orderSummary);
      }
    } catch (error) {
      logger.error('Error sending order confirmation:', error);
      throw error;
    }
  }

  // Removed _sendOrderActionButtons - functionality integrated into sendOrderConfirmation
}

================
File: backend/src/routes/address-selection.ts
================
import { Router, Request, Response } from 'express';
import { prisma } from '../lib/prisma';
import logger from '../common/utils/logger';
import { sendWhatsAppInteractiveMessage, sendWhatsAppMessage } from '../services/whatsapp';
import { asyncHandler } from '../common/middlewares/errorHandler';
import { NotFoundError, ErrorCode } from '../common/services/errors';
import { validationMiddleware } from '../common/middlewares/validation.middleware';
import { SendAddressSelectionDto, UpdateAddressSelectionDto } from '../dto/address';
import { formatAddressFull } from '../common/utils/addressFormatter';

const router = Router();

/**
 * Send address selection message to customer
 * POST /backend/address-selection/send
 */
router.post('/send',
  validationMiddleware(SendAddressSelectionDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { customerId, preOrderId } = req.body as SendAddressSelectionDto;
  
  // Get customer with addresses
  const customer = await prisma.customer.findUnique({
    where: { id: customerId },
    include: {
      addresses: {
        where: { deletedAt: null },
        orderBy: [
          { isDefault: 'desc' },
          { createdAt: 'desc' }
        ],
        take: 5 // Limit to 5 addresses for WhatsApp list
      }
    }
  });
  
  if (!customer) {
    throw new NotFoundError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found',
      { customerId }
    );
  }
    
    if (customer.addresses.length === 0) {
      // No addresses, send link to add one
      const { OTPService } = await import('../services/security/OTPService');
      const otp = OTPService.generateOTP();
      await OTPService.storeOTP(customer.whatsappPhoneNumber, otp, true);
      
      const updateLink = `${process.env.FRONTEND_BASE_URL}/address-registration/${customer.whatsappPhoneNumber}?otp=${otp}${preOrderId ? `&preOrderId=${preOrderId}` : ''}&viewMode=form`;
      
      const { sendMessageWithUrlButton } = await import('../services/whatsapp');
      await sendMessageWithUrlButton(
        customer.whatsappPhoneNumber,
        "📍 Registrar Dirección",
        "No tienes direcciones guardadas. Por favor, registra una dirección de entrega haciendo clic en el botón de abajo.",
        "Agregar Dirección",
        updateLink
      );
      
      res.json({ 
        success: true,
        message: 'Address registration link sent',
        hasAddresses: false
      });
      return;
    }
    
    if (customer.addresses.length === 1) {
      // Only one address, no need to update yet
      // The user will confirm or change it
      
      await sendWhatsAppInteractiveMessage(
        customer.whatsappPhoneNumber,
        {
          type: "button",
          body: {
            text: `📍 *Dirección de entrega:*\n${formatAddressFull(customer.addresses[0])}\n\n¿Deseas usar esta dirección o cambiarla?`
          },
          action: {
            buttons: [
              {
                type: "reply",
                reply: {
                  id: `confirm_address_${customer.addresses[0].id}`,
                  title: "✅ Usar dirección"
                }
              },
              {
                type: "reply", 
                reply: {
                  id: "change_address",
                  title: "🔄 Cambiar dirección"
                }
              }
            ]
          }
        }
      );
      
      res.json({ 
        success: true,
        message: 'Single address confirmation sent',
        hasAddresses: true,
        addressCount: 1
      });
      return;
    }
    
    // Multiple addresses, send selection list
    const sections = [
      {
        title: "Mis direcciones",
        rows: customer.addresses.map((address) => ({
          id: `select_address_${address.id}`,
          title: truncateText(address.name || `${address.street} ${address.number}`, 24),
          description: truncateText(
            address.name 
              ? `${address.street} ${address.number}, ${address.neighborhood || address.city}${address.isDefault ? ' (Principal)' : ''}`
              : `${address.neighborhood ? address.neighborhood + ', ' : ''}${address.city}${address.isDefault ? ' (Principal)' : ''}`,
            72
          )
        }))
      }
    ];
    
    // Add option to add new address
    sections[0].rows.push({
      id: "add_new_address",
      title: "➕ Nueva dirección",
      description: "Registrar una nueva dirección de entrega"
    });
    
    await sendWhatsAppInteractiveMessage(
      customer.whatsappPhoneNumber,
      {
        type: "list",
        header: {
          type: "text",
          text: "📍 Seleccionar Dirección"
        },
        body: {
          text: "Por favor selecciona la dirección de entrega para tu pedido:"
        },
        footer: {
          text: "Elige una opción de la lista"
        },
        action: {
          button: "Ver direcciones",
          sections
        }
      }
    );
    
    res.json({ 
      success: true,
      message: 'Address selection list sent',
      hasAddresses: true,
      addressCount: customer.addresses.length
    });
}));

/**
 * Update selected address for preorder
 * POST /backend/address-selection/update
 */
router.post('/update',
  validationMiddleware(UpdateAddressSelectionDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { preOrderId, addressId, customerId } = req.body as UpdateAddressSelectionDto;
  
  // Verify address belongs to customer
  const address = await prisma.address.findFirst({
    where: { 
      id: addressId,
      customerId,
      deletedAt: null
    },
    include: { customer: true }
  });
  
  if (!address) {
    throw new NotFoundError(
      ErrorCode.ADDRESS_NOT_FOUND,
      'Address not found or does not belong to customer',
      { addressId, customerId }
    );
  }
  
  // Get the preOrder to get whatsappPhoneNumber
  const preOrder = await prisma.preOrder.findUnique({
    where: { id: preOrderId }
  });
  
  if (!preOrder) {
    throw new NotFoundError(
      ErrorCode.ORDER_NOT_FOUND,
      'PreOrder not found',
      { preOrderId }
    );
  }
  
  // Recreate preOrder with new address
  const { PreOrderWorkflowService } = await import('../services/orders/preOrderWorkflowService');
  const result = await PreOrderWorkflowService.recreatePreOrderWithNewAddress({
    oldPreOrderId: preOrderId,
    newAddressId: addressId,
    whatsappNumber: preOrder.whatsappPhoneNumber
  });
  
  res.json({ 
    success: true,
    message: 'New PreOrder created with updated address',
    preOrderId: result.preOrderId
  });
}));

// Helper functions
function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength - 3) + '...';
}



export default router;

================
File: backend/src/server.ts
================
import 'reflect-metadata';
import express, { Request, Response } from 'express';
import cors from 'cors';
import webhookRoutes from './routes/webhook';
import syncRoutes from './routes/sync';
import addressRegistrationRoutes from './routes/address-registration';
import addressSelectionRoutes from './routes/address-selection';
import logger from './common/utils/logger';
import { OTPService } from './services/security/OTPService';
import { PreOrderService } from './services/orders/PreOrderService';
import { WhatsAppService } from './services/whatsapp';
import { DeliveryInfoService } from './services/orders/services/DeliveryInfoService';
import { envValidator, env } from './common/config/envValidator';
import { globalErrorHandler, asyncHandler } from './common/middlewares/errorHandler';
import { validationMiddleware, queryValidationMiddleware } from './common/middlewares/validation.middleware';
import { VerifyOtpDto, InvalidateOtpDto } from './dto/auth';
import { AddressDto, GetAddressesQueryDto, UpdateAddressDto } from './dto/address';
import { SendMessageDto } from './dto/whatsapp';
import { CreateOrderDto } from './dto/order';
import { ConfigService } from './services/config/ConfigService';
import { prisma } from './lib/prisma';

// Validate environment variables
try {
  envValidator.validate();
} catch (error) {
  logger.error('Environment validation failed:', error);
  process.exit(1);
}

// Initialize Express app
const app: express.Application = express();

// Configure CORS
app.use(cors({
  origin: [
    'https://pizzatototlan.store',
    'http://localhost:3000',
    env.FRONTEND_BASE_URL
  ].filter(Boolean),
  credentials: true,
}));

// Middleware for parsing JSON (except for webhook route)
app.use((req, res, next) => {
  if (req.path === '/api/webhook' && req.method === 'POST') {
    // Skip JSON parsing for webhook verification
    next();
  } else {
    express.json()(req, res, next);
  }
});

// Health check endpoint
app.get('/backend', (_, res) => {
  res.json({ 
    message: 'Bot Backend API is running',
    version: '2.0.0',
    timestamp: new Date().toISOString()
  });
});

// Routes
app.use('/api/webhook', webhookRoutes);
app.use('/api/sync', syncRoutes);
app.use('/backend/address-registration', addressRegistrationRoutes);
app.use('/backend/address-selection', addressSelectionRoutes);

// Import and use audio routes
import audioOrderRoutes from './api/audio/audioOrder.routes';
app.use('/api/v1/audio', audioOrderRoutes);

// OTP endpoints
app.post('/backend/otp/verify',
  validationMiddleware(VerifyOtpDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { whatsappPhoneNumber, otp } = req.body as VerifyOtpDto;
    const isValid = await OTPService.verifyOTP(whatsappPhoneNumber, otp);
    res.json({ valid: isValid });
  }));

app.post('/backend/otp/invalidate',
  validationMiddleware(InvalidateOtpDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { whatsappPhoneNumber } = req.body as InvalidateOtpDto;
    await OTPService.invalidateOTP(whatsappPhoneNumber);
    res.json({ success: true });
  }));

// Customer addresses endpoints
app.post('/backend/customer/:customerId/addresses',
  validationMiddleware(AddressDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { customerId } = req.params;
    const addressData = {
      ...req.body as AddressDto,
      customer: { connect: { id: customerId } }
    };
  const address = await DeliveryInfoService.createCustomerAddress(addressData);
  res.json(address);
}));

app.get('/backend/customer/:customerId/addresses',
  queryValidationMiddleware(GetAddressesQueryDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { customerId } = req.params;
    const { includeInactive } = req.query as unknown as GetAddressesQueryDto;
  const addresses = await DeliveryInfoService.getCustomerAddresses(customerId, includeInactive);
  res.json(addresses);
}));

app.get('/backend/customer/:customerId/addresses/default', asyncHandler(async (req: Request, res: Response) => {
  const { customerId } = req.params;
  const { NotFoundError, ErrorCode } = await import('./common/services/errors');
  const address = await DeliveryInfoService.getCustomerDefaultAddress(customerId);
  if (!address) {
    throw new NotFoundError(
      ErrorCode.ADDRESS_NOT_FOUND,
      'No default address found',
      { customerId }
    );
  }
  res.json(address);
}));

app.put('/backend/addresses/:addressId',
  validationMiddleware(UpdateAddressDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { addressId } = req.params;
    const address = await DeliveryInfoService.updateCustomerAddress(
      addressId,
      req.body as UpdateAddressDto
    );
  res.json(address);
}));

app.put('/backend/addresses/:addressId/set-default',
  asyncHandler(async (req: Request, res: Response) => {
    const { addressId } = req.params;
    
    // Get the address to find the customerId
    const existingAddress = await prisma.address.findUnique({
      where: { id: addressId },
      select: { customerId: true }
    });
    
    if (!existingAddress) {
      const { NotFoundError, ErrorCode } = await import('./common/services/errors');
      throw new NotFoundError(
        ErrorCode.ADDRESS_NOT_FOUND,
        'Address not found',
        { addressId }
      );
    }
    
    const address = await DeliveryInfoService.setDefaultAddress(addressId, existingAddress.customerId);
    res.json(address);
  }));

app.delete('/backend/addresses/:addressId',
  asyncHandler(async (req: Request, res: Response) => {
    const { addressId } = req.params;
    
    // Get the address to find the customerId
    const existingAddress = await prisma.address.findUnique({
      where: { id: addressId },
      select: { customerId: true }
    });
    
    if (!existingAddress) {
      const { NotFoundError, ErrorCode } = await import('./common/services/errors');
      throw new NotFoundError(
        ErrorCode.ADDRESS_NOT_FOUND,
        'Address not found',
        { addressId }
      );
    }
    
    await DeliveryInfoService.deleteCustomerAddress(addressId, existingAddress.customerId);
    res.json({ success: true });
  }));

// Pre-orders endpoint
app.post('/backend/pre-orders/create',
  validationMiddleware(CreateOrderDto),
  asyncHandler(async (req: Request, res: Response) => {
    const preOrderService = new PreOrderService();
    const dto = req.body as CreateOrderDto;
    
    // Transform DTO to match PreOrderService expectations
    const orderData = {
      orderItems: dto.orderItems.map(item => ({
        productId: item.productId,
        productVariantId: item.productVariantId || null,
        quantity: item.quantity,
        comments: item.comments,
        selectedModifiers: item.selectedModifiers,
        selectedPizzaCustomizations: item.selectedPizzaCustomizations.map(pc => ({
          pizzaCustomizationId: pc.pizzaCustomizationId,
          half: pc.half as "FULL" | "HALF_1" | "HALF_2",
          action: pc.action as "ADD" | "REMOVE"
        }))
      })),
      whatsappPhoneNumber: dto.whatsappPhoneNumber,
      orderType: dto.orderType,
      scheduledAt: dto.scheduledAt,
      deliveryInfo: dto.deliveryInfo
    };
    
    const result = await preOrderService.createPreOrder(orderData);
  res.status(200).json(result);
}));

// WhatsApp send message endpoint
app.post('/backend/whatsapp/send-message',
  validationMiddleware(SendMessageDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { to, message } = req.body as SendMessageDto;
  const result = await WhatsAppService.sendMessage(to, message);
  res.json(result);
}));

// Global error handling middleware (must be last)
app.use(globalErrorHandler);

// Start server
const PORT = parseInt(env.PORT, 10);
let preOrderCleanupInterval: NodeJS.Timeout;

async function startServer() {
  try {
    // Test database connection
    await prisma.$connect();
    logger.info('Database connected successfully');
    
    // Load restaurant configuration
    await ConfigService.loadConfig();
    logger.info('Restaurant configuration loaded');
    
    // Connect to Redis
    const { redisService } = await import('./services/redis/RedisService');
    await redisService.connect();
    
    // Start OTP cleanup interval
    OTPService.startOTPCleanup();
    
    // Start PreOrder cleanup interval
    const { PreOrderWorkflowService } = await import('./services/orders/preOrderWorkflowService');
    preOrderCleanupInterval = setInterval(async () => {
      await PreOrderWorkflowService.cleanupExpiredPreOrders();
    }, 5 * 60 * 1000); // Run every 5 minutes
    logger.info('PreOrder cleanup interval started');
    
    // Initialize embeddings on startup
    const { initializeEmbeddings } = await import('./startup/embeddingInitializer');
    await initializeEmbeddings();
    
    const server = app.listen(PORT, () => {
      logger.info(`Server is running on port ${PORT}`);
    });
    
    // Initialize WebSocket for sync notifications
    const io = await import('socket.io');
    const socketServer = new io.Server(server, {
      cors: {
        origin: '*', // Configure this properly in production
        methods: ['GET', 'POST']
      },
      path: '/socket.io/'
    });
    
    const { SyncNotificationService } = await import('./services/sync/SyncNotificationService');
    SyncNotificationService.initialize(socketServer);
    logger.info('WebSocket server initialized for sync notifications');
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on('SIGINT', async () => {
  logger.info('Shutting down server...');
  OTPService.stopOTPCleanup();
  if (preOrderCleanupInterval) {
    clearInterval(preOrderCleanupInterval);
  }
  const { redisService } = await import('./services/redis/RedisService');
  await redisService.disconnect();
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('Shutting down server...');
  OTPService.stopOTPCleanup();
  if (preOrderCleanupInterval) {
    clearInterval(preOrderCleanupInterval);
  }
  const { redisService } = await import('./services/redis/RedisService');
  await redisService.disconnect();
  await prisma.$disconnect();
  process.exit(0);
});

startServer();

export { app, prisma };

================
File: backend/src/services/sync/UnifiedSyncService.ts
================
import { prisma } from '../../server';
import logger from '../../common/utils/logger';
import { SyncMetadataService } from './SyncMetadataService';
import { EmbeddingManager } from './EmbeddingManager';

interface PullChangesResponse {
  pending_orders: any[];
  updated_customers: any[];
}

interface LocalSystemResponse {
  statusCode?: number;
  message?: string;
  menu?: {
    categories: any[];
    lastUpdated: string;
  };
  config?: {
    restaurantConfig: any;
    businessHours: any[];
    lastUpdated: string;
  };
  // Direct structure from local system (alternative format)
  restaurantConfig?: any;
  businessHours?: any[];
  categories?: any[];
  timestamp?: string;
  lastUpdated?: string;
}

export class UnifiedSyncService {
  /**
   * Process restaurant data pushed from local system
   */
  static async processRestaurantDataPush(data: LocalSystemResponse): Promise<boolean> {
    logger.info('Processing restaurant data push', {
      hasDirectConfig: !!data.restaurantConfig,
      hasDirectBusinessHours: !!data.businessHours,
      hasNestedConfig: !!data.config,
      hasMenu: !!data.menu || !!data.categories,
      // Restaurant config details
      restaurantName: data.restaurantConfig?.restaurantName || data.config?.restaurantConfig?.restaurantName,
      phoneMain: data.restaurantConfig?.phoneMain || data.config?.restaurantConfig?.phoneMain,
      // Business hours - check nested in restaurantConfig too
      businessHoursCount: data.businessHours?.length || 
                         data.config?.businessHours?.length || 
                         data.restaurantConfig?.businessHours?.length ||
                         data.config?.restaurantConfig?.businessHours?.length || 0,
      // Menu details
      categoriesCount: data.categories?.length || data.menu?.categories?.length || 0,
      allCategoryNames: (data.categories || data.menu?.categories || []).map((c: any) => c.name)
    });
    
    try {
      // Normalize the data structure to handle both formats
      const normalizedData: LocalSystemResponse = {
        ...data
      };
      
      // If data comes with direct structure, normalize it
      if (!normalizedData.config && (data.restaurantConfig || data.businessHours)) {
        // Extract businessHours from restaurantConfig if nested there
        const businessHours = data.businessHours || data.restaurantConfig?.businessHours || [];
        
        normalizedData.config = {
          restaurantConfig: data.restaurantConfig,
          businessHours: businessHours,
          lastUpdated: data.lastUpdated || new Date().toISOString()
        };
      }
      
      if (!normalizedData.menu && data.categories) {
        normalizedData.menu = {
          categories: data.categories,
          lastUpdated: data.lastUpdated || new Date().toISOString()
        };
      }
      
      // Check if data has changed
      const existingConfig = await prisma.restaurantConfig.findFirst();
      const existingMenu = await prisma.category.findMany();
      
      // Simple change detection
      const configData = normalizedData.config?.restaurantConfig;
      const categoriesData = normalizedData.menu?.categories;
      
      const configChanged = !existingConfig || JSON.stringify(existingConfig) !== JSON.stringify(configData);
      const menuChanged = !categoriesData || existingMenu.length !== categoriesData.length;
      
      if (!configChanged && !menuChanged) {
        logger.info('No changes detected in restaurant data');
        return false;
      }
      
      // Process the data
      await this.processRestaurantData(normalizedData);
      logger.info('Restaurant data processed successfully');
      return true;
    } catch (error) {
      logger.error('Error processing restaurant data push:', error);
      throw error;
    }
  }

  /**
   * Pull all pending changes without token complexity
   */
  static async pullChanges(): Promise<PullChangesResponse> {
    logger.info('UnifiedSync: Pull changes requested');
    
    // Get pending items
    const pendingOrders = await SyncMetadataService.getPendingSync('Order');
    const pendingCustomers = await SyncMetadataService.getPendingSync('Customer');
    
    const orderIds = pendingOrders.map(p => p.entityId);
    const customerIds = pendingCustomers.map(p => p.entityId);
    
    // Fetch full order data
    const orders = await this.fetchPendingOrders(orderIds);
    
    // Fetch full customer data  
    const customers = await this.fetchPendingCustomers(customerIds);
    
    logger.info('UnifiedSync: Prepared changes', {
      orderCount: orders.length,
      customerCount: customers.length
    });
    
    return {
      pending_orders: orders,
      updated_customers: customers
    };
  }

  /**
   * Fetch pending orders with full data
   */
  private static async fetchPendingOrders(orderIds: string[]): Promise<any[]> {
    if (orderIds.length === 0) {
      return [];
    }
    
    const orders = await prisma.order.findMany({
      where: {
        id: { in: orderIds },
        isFromWhatsApp: true
      },
      include: {
        customer: true,
        orderItems: {
          include: {
            product: true,
            productVariant: true,
            productModifiers: true,
            selectedPizzaCustomizations: {
              include: {
                pizzaCustomization: true
              }
            }
          }
        },
        deliveryInfo: true,
        payments: true
      },
      orderBy: { createdAt: 'asc' }
    });
    
    // Transform to expected format
    return orders.map(order => ({
      id: order.id,
      shiftOrderNumber: order.shiftOrderNumber,
      orderType: order.orderType,
      orderStatus: order.orderStatus,
      subtotal: order.subtotal,
      total: order.total,
      customerId: order.customerId,
      estimatedDeliveryTime: order.estimatedDeliveryTime?.toISOString() || null,
      scheduledAt: order.scheduledAt?.toISOString() || null,
      notes: order.notes || null,
      isFromWhatsApp: order.isFromWhatsApp,
      finalizedAt: order.finalizedAt?.toISOString() || null,
      shiftId: order.shiftId || null,
      userId: order.userId || null,
      tableId: order.tableId || null,
      customer: {
        id: order.customer.id,
        whatsappPhoneNumber: order.customer.whatsappPhoneNumber,
        firstName: order.customer.firstName || null,
        lastName: order.customer.lastName || null,
        email: order.customer.email || null,
        birthDate: order.customer.birthDate?.toISOString() || null,
        stripeCustomerId: order.customer.stripeCustomerId || null,
        lastInteraction: order.customer.lastInteraction?.toISOString() || null,
        totalOrders: order.customer.totalOrders,
        totalSpent: order.customer.totalSpent.toNumber(),
        isActive: order.customer.isActive,
        isBanned: order.customer.isBanned,
        bannedAt: order.customer.bannedAt?.toISOString() || null,
        banReason: order.customer.banReason || null,
        createdAt: order.customer.createdAt.toISOString(),
        updatedAt: order.customer.updatedAt.toISOString()
      },
      orderItems: order.orderItems.map(item => ({
        id: item.id,
        orderId: item.orderId,
        productId: item.productId,
        productVariantId: item.productVariantId,
        basePrice: item.basePrice,
        finalPrice: item.finalPrice,
        preparationStatus: item.preparationStatus,
        statusChangedAt: item.statusChangedAt.toISOString(),
        preparationNotes: item.preparationNotes || null,
        createdAt: item.createdAt.toISOString(),
        updatedAt: item.updatedAt.toISOString(),
        product: {
          id: item.product.id,
          name: item.product.name
        },
        productVariant: item.productVariant ? {
          id: item.productVariant.id,
          name: item.productVariant.name
        } : null,
        productModifiers: item.productModifiers.map(mod => ({
          id: mod.id,
          name: mod.name,
          price: mod.price || 0
        })),
        selectedPizzaCustomizations: item.selectedPizzaCustomizations.map(customization => ({
          id: customization.id,
          orderItemId: customization.orderItemId,
          pizzaCustomizationId: customization.pizzaCustomizationId,
          half: customization.half,
          action: customization.action,
          pizzaCustomization: {
            id: customization.pizzaCustomization.id,
            name: customization.pizzaCustomization.name,
            type: customization.pizzaCustomization.type,
            ingredients: customization.pizzaCustomization.ingredients || null,
            toppingValue: customization.pizzaCustomization.toppingValue
          }
        }))
      })),
      deliveryInfo: order.deliveryInfo ? {
        // Si existe deliveryInfo en BD (DELIVERY y TAKE_AWAY)
        id: order.deliveryInfo.id,
        orderId: order.deliveryInfo.orderId,
        name: order.deliveryInfo.name || null,
        fullAddress: order.deliveryInfo.fullAddress || null,
        street: order.deliveryInfo.street || null,
        number: order.deliveryInfo.number || null,
        interiorNumber: order.deliveryInfo.interiorNumber || null,
        neighborhood: order.deliveryInfo.neighborhood || null,
        city: order.deliveryInfo.city || null,
        state: order.deliveryInfo.state || null,
        zipCode: order.deliveryInfo.zipCode || null,
        country: order.deliveryInfo.country || null,
        recipientName: order.deliveryInfo.recipientName || null,
        recipientPhone: order.deliveryInfo.recipientPhone || null,
        deliveryInstructions: order.deliveryInfo.deliveryInstructions || null,
        latitude: order.deliveryInfo.latitude?.toNumber() || null,
        longitude: order.deliveryInfo.longitude?.toNumber() || null,
        createdAt: order.deliveryInfo.createdAt.toISOString(),
        updatedAt: order.deliveryInfo.updatedAt.toISOString()
      } : {
        // Para órdenes sin deliveryInfo en BD (DINE_IN o casos legacy)
        id: null,
        orderId: order.id,
        name: null,
        fullAddress: null,
        street: null,
        number: null,
        interiorNumber: null,
        neighborhood: null,
        city: null,
        state: null,
        zipCode: null,
        country: null,
        recipientName: order.orderType === 'TAKE_AWAY' ? 
          `${order.customer.firstName || ''} ${order.customer.lastName || ''}`.trim() || order.customer.whatsappPhoneNumber : null,
        recipientPhone: order.orderType === 'TAKE_AWAY' ? 
          order.customer.whatsappPhoneNumber : null,
        deliveryInstructions: null,
        latitude: null,
        longitude: null,
        createdAt: order.createdAt.toISOString(),
        updatedAt: order.updatedAt.toISOString()
      },
      payments: order.payments.map(payment => ({
        id: payment.id,
        orderId: payment.orderId,
        paymentMethod: payment.paymentMethod,
        amount: payment.amount.toNumber(),
        status: payment.status,
        stripePaymentId: payment.stripePaymentId || null,
        metadata: payment.metadata || null,
        createdAt: payment.createdAt.toISOString(),
        updatedAt: payment.updatedAt.toISOString()
      })),
      createdAt: order.createdAt.toISOString(),
      updatedAt: order.updatedAt.toISOString()
    }));
  }

  /**
   * Fetch pending customers with full data
   */
  private static async fetchPendingCustomers(customerIds: string[]): Promise<any[]> {
    if (customerIds.length === 0) {
      return [];
    }
    
    const customers = await prisma.customer.findMany({
      where: {
        id: { in: customerIds },
        deletedAt: null
      },
      include: {
        addresses: {
          where: { deletedAt: null }
        }
      }
    });
    
    // Transform to expected format
    return customers.map(customer => ({
      id: customer.id,
      firstName: customer.firstName || '',
      lastName: customer.lastName || '',
      whatsappPhoneNumber: customer.whatsappPhoneNumber,
      stripeCustomerId: customer.stripeCustomerId,
      email: customer.email || null,
      birthDate: customer.birthDate?.toISOString().split('T')[0] || null,
      fullChatHistory: customer.fullChatHistory || [],
      relevantChatHistory: customer.relevantChatHistory || [],
      lastInteraction: customer.lastInteraction?.toISOString() || null,
      totalOrders: customer.totalOrders,
      totalSpent: customer.totalSpent.toNumber(),
      isActive: customer.isActive,
      isBanned: customer.isBanned,
      bannedAt: customer.bannedAt?.toISOString() || null,
      banReason: customer.banReason || null,
      lastSyncedAt: new Date().toISOString(),
      addresses: customer.addresses.map(addr => ({
        id: addr.id,
        customerId: customer.id,
        name: addr.name,
        street: addr.street,
        number: addr.number,
        interiorNumber: addr.interiorNumber || null,
        neighborhood: addr.neighborhood || '',
        city: addr.city || '',
        state: addr.state || '',
        zipCode: addr.zipCode || '',
        country: addr.country || 'México',
        deliveryInstructions: addr.deliveryInstructions || '',
        latitude: addr.latitude?.toNumber() || null,
        longitude: addr.longitude?.toNumber() || null,
        isDefault: addr.isDefault,
        createdAt: addr.createdAt.toISOString(),
        updatedAt: addr.updatedAt.toISOString(),
        deletedAt: addr.deletedAt?.toISOString() || null
      })),
      createdAt: customer.createdAt.toISOString(),
      updatedAt: customer.updatedAt.toISOString(),
      deletedAt: customer.deletedAt?.toISOString() || null
    }));
  }


  /**
   * Process and save restaurant data received from local system
   */
  static async processRestaurantData(data: LocalSystemResponse): Promise<void> {
    logger.info('Processing restaurant data', {
      hasMenu: !!data.menu,
      hasConfig: !!data.config,
      menuCategoriesCount: data.menu?.categories?.length || 0,
      configHasRestaurantConfig: !!data.config?.restaurantConfig,
      configHasBusinessHours: !!data.config?.businessHours,
      businessHoursCount: data.config?.businessHours?.length || 0,
      // Detailed config info
      restaurantName: data.config?.restaurantConfig?.restaurantName,
      phoneNumbers: {
        main: data.config?.restaurantConfig?.phoneMain,
        whatsapp: data.config?.restaurantConfig?.phoneWhatsapp
      },
      deliverySettings: {
        isEnabled: data.config?.restaurantConfig?.isDeliveryEnabled,
        minimumOrder: data.config?.restaurantConfig?.minimumOrderAmountForDelivery,
        cost: data.config?.restaurantConfig?.deliveryCost
      }
    });
    
    await prisma.$transaction(async (tx) => {
      // Process menu data
      if (data.menu?.categories) {
        logger.info('Processing menu data with categories:', data.menu.categories.length);
        await this.processMenuData(data.menu.categories, tx);
      }

      // Process configuration data
      if (data.config) {
        logger.info('Processing configuration data');
        await this.processConfigData(data.config, tx);
      }
    });

    // Generate embeddings after menu sync (non-blocking)
    if (data.menu?.categories) {
      logger.info('Triggering embedding generation after menu sync');
      setTimeout(() => {
        EmbeddingManager.generateEmbeddingsAfterSync().catch(error => {
          logger.error('Failed to generate embeddings after sync:', error);
        });
      }, 2000); // Small delay to ensure transaction is committed
    }
  }

  /**
   * Process and save menu data (categories, subcategories, products)
   */
  private static async processMenuData(categories: any[], tx: any): Promise<void> {
    logger.info('UnifiedSync: Processing menu data', {
      totalCategories: categories.length,
      categoryNames: categories.map(c => c.name),
      categoriesWithProducts: categories.map(c => ({
        name: c.name,
        productsCount: c.products?.length || 0,
        subcategoriesCount: c.subcategories?.length || 0
      }))
    });
    
    for (const categoryData of categories) {
      // Upsert category
      const category = await tx.category.upsert({
        where: { id: categoryData.id },
        create: {
          id: categoryData.id,
          name: categoryData.name,
          description: categoryData.description,
          isActive: categoryData.isActive !== false,
          sortOrder: categoryData.sortOrder || 0,
          photoId: categoryData.photoId,
          createdAt: categoryData.createdAt ? new Date(categoryData.createdAt) : new Date(),
          updatedAt: categoryData.updatedAt ? new Date(categoryData.updatedAt) : new Date()
        },
        update: {
          name: categoryData.name,
          description: categoryData.description,
          isActive: categoryData.isActive !== false,
          sortOrder: categoryData.sortOrder || 0,
          photoId: categoryData.photoId,
          updatedAt: new Date(),
          deletedAt: categoryData.deletedAt ? new Date(categoryData.deletedAt) : null
        }
      });
      
      // Process subcategories
      if (categoryData.subcategories && Array.isArray(categoryData.subcategories)) {
        for (const subData of categoryData.subcategories) {
          const subcategory = await tx.subcategory.upsert({
            where: { id: subData.id },
            create: {
              id: subData.id,
              categoryId: category.id,
              name: subData.name,
              description: subData.description,
              isActive: subData.isActive !== false,
              sortOrder: subData.sortOrder || 0,
              photoId: subData.photoId,
              createdAt: subData.createdAt ? new Date(subData.createdAt) : new Date(),
              updatedAt: subData.updatedAt ? new Date(subData.updatedAt) : new Date()
            },
            update: {
              name: subData.name,
              description: subData.description,
              isActive: subData.isActive !== false,
              sortOrder: subData.sortOrder || 0,
              photoId: subData.photoId,
              updatedAt: new Date(),
              deletedAt: subData.deletedAt ? new Date(subData.deletedAt) : null
            }
          });
          
          // Process products
          if (subData.products && Array.isArray(subData.products)) {
            // Log first product of subcategory as sample
            if (subData.products.length > 0) {
              logger.debug('UnifiedSync: Sample product in subcategory', {
                subcategoryName: subData.name,
                productName: subData.products[0].name,
                price: subData.products[0].price,
                hasVariants: subData.products[0].hasVariants,
                variantsCount: subData.products[0].variants?.length || 0,
                modifierGroupsCount: subData.products[0].modifierGroups?.length || 0
              });
            }
            
            for (const productData of subData.products) {
              // Upsert product
              const product = await tx.product.upsert({
                where: { id: productData.id },
                create: {
                  id: productData.id,
                  name: productData.name,
                  description: productData.description,
                  price: productData.price ? parseFloat(productData.price.toString()) : null,
                  hasVariants: productData.hasVariants || false,
                  isActive: productData.isActive !== false,
                  isPizza: productData.isPizza || false,
                  sortOrder: productData.sortOrder || 0,
                  subcategoryId: productData.subcategoryId || subcategory.id,
                  photoId: productData.photoId,
                  estimatedPrepTime: productData.estimatedPrepTime || 0,
                  preparationScreenId: productData.preparationScreenId,
                  createdAt: productData.createdAt ? new Date(productData.createdAt) : new Date(),
                  updatedAt: productData.updatedAt ? new Date(productData.updatedAt) : new Date()
                },
                update: {
                  name: productData.name,
                  description: productData.description,
                  price: productData.price ? parseFloat(productData.price.toString()) : null,
                  hasVariants: productData.hasVariants || false,
                  isActive: productData.isActive !== false,
                  isPizza: productData.isPizza || false,
                  sortOrder: productData.sortOrder || 0,
                  photoId: productData.photoId,
                  estimatedPrepTime: productData.estimatedPrepTime || 0,
                  preparationScreenId: productData.preparationScreenId,
                  updatedAt: new Date(),
                  deletedAt: productData.deletedAt ? new Date(productData.deletedAt) : null
                }
              });
              
              // Process variants
              if (productData.variants && Array.isArray(productData.variants)) {
                for (const variantData of productData.variants) {
                  await tx.productVariant.upsert({
                    where: { id: variantData.id },
                    create: {
                      id: variantData.id,
                      productId: product.id,
                      name: variantData.name,
                      price: variantData.price != null ? parseFloat(variantData.price.toString()) : 0,
                      isActive: variantData.isActive !== false,
                      sortOrder: variantData.sortOrder || 0,
                      createdAt: variantData.createdAt ? new Date(variantData.createdAt) : new Date(),
                      updatedAt: variantData.updatedAt ? new Date(variantData.updatedAt) : new Date()
                    },
                    update: {
                      name: variantData.name,
                      price: variantData.price != null ? parseFloat(variantData.price.toString()) : 0,
                      isActive: variantData.isActive !== false,
                      sortOrder: variantData.sortOrder || 0,
                      updatedAt: new Date(),
                      deletedAt: variantData.deletedAt ? new Date(variantData.deletedAt) : null
                    }
                  });
                }
              }
              
              // Process modifier groups
              if (productData.modifierGroups && Array.isArray(productData.modifierGroups)) {
                for (const groupData of productData.modifierGroups) {
                  const modifierGroup = await tx.modifierGroup.upsert({
                    where: { id: groupData.id },
                    create: {
                      id: groupData.id,
                      name: groupData.name,
                      description: groupData.description,
                      minSelections: groupData.minSelections || 0,
                      maxSelections: groupData.maxSelections || 1,
                      isRequired: groupData.isRequired || false,
                      allowMultipleSelections: groupData.allowMultipleSelections || false,
                      isActive: groupData.isActive !== false,
                      sortOrder: groupData.sortOrder || 0,
                      createdAt: groupData.createdAt ? new Date(groupData.createdAt) : new Date(),
                      updatedAt: groupData.updatedAt ? new Date(groupData.updatedAt) : new Date()
                    },
                    update: {
                      name: groupData.name,
                      description: groupData.description,
                      minSelections: groupData.minSelections || 0,
                      maxSelections: groupData.maxSelections || 1,
                      isRequired: groupData.isRequired || false,
                      allowMultipleSelections: groupData.allowMultipleSelections || false,
                      isActive: groupData.isActive !== false,
                      sortOrder: groupData.sortOrder || 0,
                      updatedAt: new Date(),
                      deletedAt: groupData.deletedAt ? new Date(groupData.deletedAt) : null
                    }
                  });
                  
                  // Connect to product
                  await tx.product.update({
                    where: { id: product.id },
                    data: {
                      modifierGroups: {
                        disconnect: { id: modifierGroup.id },
                        connect: { id: modifierGroup.id }
                      }
                    }
                  });
                  
                  // Process modifiers
                  if (groupData.productModifiers && Array.isArray(groupData.productModifiers)) {
                    for (const modifierData of groupData.productModifiers) {
                      await tx.productModifier.upsert({
                        where: { id: modifierData.id },
                        create: {
                          id: modifierData.id,
                          modifierGroupId: modifierGroup.id,
                          name: modifierData.name,
                          description: modifierData.description,
                          price: modifierData.price ? parseFloat(modifierData.price.toString()) : 0,
                          sortOrder: modifierData.sortOrder || 0,
                          isDefault: modifierData.isDefault || false,
                          isActive: modifierData.isActive !== false,
                          createdAt: modifierData.createdAt ? new Date(modifierData.createdAt) : new Date(),
                          updatedAt: modifierData.updatedAt ? new Date(modifierData.updatedAt) : new Date()
                        },
                        update: {
                          name: modifierData.name,
                          description: modifierData.description,
                          price: modifierData.price ? parseFloat(modifierData.price.toString()) : 0,
                          sortOrder: modifierData.sortOrder || 0,
                          isDefault: modifierData.isDefault || false,
                          isActive: modifierData.isActive !== false,
                          updatedAt: new Date(),
                          deletedAt: modifierData.deletedAt ? new Date(modifierData.deletedAt) : null
                        }
                      });
                    }
                  }
                }
              }
              
              // Process pizza customizations
              if (productData.pizzaCustomizations && Array.isArray(productData.pizzaCustomizations)) {
                for (const customData of productData.pizzaCustomizations) {
                  await tx.pizzaCustomization.upsert({
                    where: { id: customData.id },
                    create: {
                      id: customData.id,
                      name: customData.name,
                      type: customData.type || 'INGREDIENT',
                      ingredients: customData.ingredients,
                      toppingValue: customData.toppingValue || 1,
                      isActive: customData.isActive !== false,
                      sortOrder: customData.sortOrder || 0
                    },
                    update: {
                      name: customData.name,
                      type: customData.type || 'INGREDIENT',
                      ingredients: customData.ingredients,
                      toppingValue: customData.toppingValue || 1,
                      isActive: customData.isActive !== false,
                      sortOrder: customData.sortOrder || 0
                    }
                  });
                  
                  // Connect to product
                  await tx.product.update({
                    where: { id: product.id },
                    data: {
                      pizzaCustomizations: {
                        disconnect: { id: customData.id },
                        connect: { id: customData.id }
                      }
                    }
                  });
                }
              }
              
              // Process pizza configuration
              if (productData.pizzaConfiguration) {
                await tx.pizzaConfiguration.upsert({
                  where: { productId: product.id },
                  create: {
                    productId: product.id,
                    includedToppings: productData.pizzaConfiguration?.includedToppings || 4,
                    extraToppingCost: productData.pizzaConfiguration?.extraToppingCost || 20
                  },
                  update: {
                    includedToppings: productData.pizzaConfiguration?.includedToppings || 4,
                    extraToppingCost: productData.pizzaConfiguration?.extraToppingCost || 20
                  }
                });
              }
            }
          }
        }
      }
    }
  }

  /**
   * Process and save configuration data
   */
  private static async processConfigData(configData: any, tx: any): Promise<void> {
    const { restaurantConfig } = configData;
    // Business hours can be at config level or nested in restaurantConfig
    const businessHours = configData.businessHours || restaurantConfig?.businessHours || [];
    
    logger.info('UnifiedSync: Processing config data', {
      hasRestaurantConfig: !!restaurantConfig,
      hasBusinessHours: businessHours.length > 0,
      businessHoursCount: businessHours.length,
      // Business hours details
      businessHoursDays: businessHours.map((h: any) => ({
        dayOfWeek: h.dayOfWeek,
        openTime: h.openingTime || h.openTime,
        closeTime: h.closingTime || h.closeTime,
        isOpen: h.isOpen !== false && !h.isClosed
      }))
    });

    // Upsert restaurant config
    await tx.restaurantConfig.upsert({
      where: { id: 1 }, // We use a fixed ID since we only have one config
      create: {
        id: 1,
        restaurantName: restaurantConfig.restaurantName,
        phoneMain: restaurantConfig.phoneMain,
        phoneSecondary: restaurantConfig.phoneSecondary,
        address: restaurantConfig.address,
        city: restaurantConfig.city,
        state: restaurantConfig.state,
        postalCode: restaurantConfig.postalCode,
        country: restaurantConfig.country || 'México',
        acceptingOrders: restaurantConfig.acceptingOrders !== false,
        estimatedPickupTime: restaurantConfig.estimatedPickupTime || 20,
        estimatedDeliveryTime: restaurantConfig.estimatedDeliveryTime || 40,
        openingGracePeriod: restaurantConfig.openingGracePeriod || 30,
        closingGracePeriod: restaurantConfig.closingGracePeriod || 30,
        timeZone: restaurantConfig.timeZone || 'America/Mexico_City',
        deliveryCoverageArea: restaurantConfig.deliveryCoverageArea || []
      },
      update: {
        restaurantName: restaurantConfig.restaurantName,
        phoneMain: restaurantConfig.phoneMain,
        phoneSecondary: restaurantConfig.phoneSecondary,
        address: restaurantConfig.address,
        city: restaurantConfig.city,
        state: restaurantConfig.state,
        postalCode: restaurantConfig.postalCode,
        country: restaurantConfig.country || 'México',
        acceptingOrders: restaurantConfig.acceptingOrders !== false,
        estimatedPickupTime: restaurantConfig.estimatedPickupTime || 20,
        estimatedDeliveryTime: restaurantConfig.estimatedDeliveryTime || 40,
        openingGracePeriod: restaurantConfig.openingGracePeriod || 30,
        closingGracePeriod: restaurantConfig.closingGracePeriod || 30,
        timeZone: restaurantConfig.timeZone || 'America/Mexico_City',
        deliveryCoverageArea: restaurantConfig.deliveryCoverageArea || []
      }
    });
    
    // Update business hours
    if (businessHours && Array.isArray(businessHours)) {
      for (const hoursData of businessHours) {
        // Format time to HH:mm if it includes seconds
        const formatTime = (time: string | null) => {
          if (!time) return null;
          // Remove seconds if present
          return time.substring(0, 5);
        };
        
        await tx.businessHours.upsert({
          where: {
            restaurantConfigId_dayOfWeek: {
              restaurantConfigId: 1,
              dayOfWeek: hoursData.dayOfWeek
            }
          },
          create: {
            restaurantConfigId: 1,
            dayOfWeek: hoursData.dayOfWeek,
            openingTime: formatTime(hoursData.openingTime),
            closingTime: formatTime(hoursData.closingTime),
            isClosed: hoursData.isClosed || false
          },
          update: {
            openingTime: formatTime(hoursData.openingTime),
            closingTime: formatTime(hoursData.closingTime),
            isClosed: hoursData.isClosed || false
          }
        });
      }
    }
    
    // Force reload of configuration cache
    const { ConfigService } = await import('../../services/config/ConfigService');
    await ConfigService.reloadConfig();
  }

  /**
   * Confirm synced items (orders and customers)
   * Marks them as no longer pending synchronization
   */
  static async confirmSyncedItems(
    confirmedOrders: Array<{ orderId: string; shiftOrderNumber: number }>,
    customerIds: string[]
  ): Promise<void> {
    logger.info('UnifiedSync: Confirming synced items', {
      orderCount: confirmedOrders.length,
      customerCount: customerIds.length
    });

    const entities: Array<{ entityType: 'Order' | 'Customer'; entityId: string }> = [];

    // Update orders with daily numbers and add to entities list
    for (const order of confirmedOrders) {
      await prisma.order.update({
        where: { id: order.orderId },
        data: { shiftOrderNumber: order.shiftOrderNumber }
      });
      entities.push({ entityType: 'Order', entityId: order.orderId });
    }

    // Add customers to entities list
    for (const customerId of customerIds) {
      entities.push({ entityType: 'Customer', entityId: customerId });
    }

    // Mark all entities as synced
    if (entities.length > 0) {
      await SyncMetadataService.markAsSynced(entities);
    }
  }
}

================
File: backend/src/routes/sync.ts
================
import { Router, Request, Response } from 'express';
import { asyncHandler } from '../common/middlewares/errorHandler';
import { apiKeyAuthMiddleware } from '../common/middlewares/apiKeyAuth.middleware';
import { UnifiedSyncService } from '../services/sync/UnifiedSyncService';
import logger from '../common/utils/logger';

const router = Router();

// Sync restaurant data from local system (PUSH method)
router.post('/push-restaurant-data', apiKeyAuthMiddleware, asyncHandler(async (req: Request, res: Response) => {
  try {
    // Log detailed information about received data
    logger.info('Restaurant data push received', {
      hasMenu: !!req.body.menu,
      hasConfig: !!req.body.config,
      menuCategories: req.body.menu?.categories?.length || 0,
      configKeys: req.body.config ? Object.keys(req.body.config) : [],
      requestBodyKeys: Object.keys(req.body),
      // Log first category and product as sample
      sampleCategory: req.body.menu?.categories?.[0] ? {
        name: req.body.menu.categories[0].name,
        productsCount: req.body.menu.categories[0].products?.length || 0
      } : null,
      sampleProduct: req.body.menu?.categories?.[0]?.products?.[0] ? {
        name: req.body.menu.categories[0].products[0].name,
        price: req.body.menu.categories[0].products[0].price
      } : null
    });
    
    // Process the restaurant data
    const wasUpdated = await UnifiedSyncService.processRestaurantDataPush(req.body);
    
    res.json({
      success: true,
      updated: wasUpdated,
      message: wasUpdated ? 'Restaurant data synchronized successfully' : 'No changes detected',
      timestamp: new Date().toISOString()
    });
  } catch (error: any) {
    logger.error('Restaurant data push error:', error);
    
    res.status(500).json({
      error: {
        code: 'SYNC_ERROR',
        message: error.message,
        details: {}
      }
    });
  }
}));

// Unified sync endpoint - Pull pending changes and confirm processed ones
router.post('/pull-changes', apiKeyAuthMiddleware, asyncHandler(async (req: Request, res: Response) => {
  try {
    logger.info('Pull changes request received', { 
      body: req.body,
      headers: req.headers 
    });
    
    // Extract confirmations from request body
    const { confirmedOrders = [], confirmedCustomerIds = [] } = req.body;
    
    logger.info('Processing confirmations', { 
      confirmedOrdersCount: confirmedOrders.length,
      confirmedCustomerIdsCount: confirmedCustomerIds.length 
    });
    
    // Process confirmations if any
    if (confirmedOrders.length > 0 || confirmedCustomerIds.length > 0) {
      await UnifiedSyncService.confirmSyncedItems(confirmedOrders, confirmedCustomerIds);
      logger.info('Confirmations processed successfully');
    }
    
    // Get pending changes (excluding confirmed ones)
    logger.info('Fetching pending changes...');
    const changes = await UnifiedSyncService.pullChanges();
    
    logger.info('Pull changes response', {
      ordersCount: changes.pending_orders?.length || 0,
      customersCount: changes.updated_customers?.length || 0
    });
    
    res.json(changes);
  } catch (error: any) {
    logger.error('Unified sync error:', {
      error: error.message,
      stack: error.stack,
      name: error.name
    });
    res.status(500).json({
      error: {
        code: 'SYNC_ERROR',
        message: error.message,
        details: {}
      }
    });
  }
}));


// Legacy endpoints - kept for backward compatibility
// NOTE: These endpoints are deprecated. Use POST /sync-restaurant-data instead

router.get('/status', asyncHandler(async (_req: Request, res: Response) => {
  res.json({
    success: true,
    status: 'healthy',
    timestamp: new Date()
  });
}));

export default router;

================
File: backend/src/services/messaging/strategies/TextMessageStrategy.ts
================
import { MessageStrategy } from './MessageStrategy';
import { MessageContext } from '../MessageContext';
import { TextProcessingService } from '../TextProcessingService';
import logger from '../../../common/utils/logger';

export class TextMessageStrategy extends MessageStrategy {
  name = 'TextMessageStrategy';
  
  canHandle(context: MessageContext): boolean {
    return context.message.type === 'text';
  }
  
  async execute(context: MessageContext): Promise<void> {
    if (!context.message.text?.body || !context.customer) return;
    
    const text = context.message.text.body;
    
    try {
      // Delegate text processing to the shared service
      await TextProcessingService.processTextMessage(text, context);
    } catch (error) {
      logger.error("Error in TextMessageStrategy:", error);
      context.addResponse({
        text: "Error al procesar la solicitud: " + (error as Error).message,
        sendToWhatsApp: true,
        isRelevant: true
      });
    }
  }
}

================
File: backend/src/services/products/ProductService.ts
================
import { prisma } from '../../lib/prisma';
import { Product, Category, ProductVariant } from '@prisma/client';
import logger from '../../common/utils/logger';
import { NotFoundError, ErrorCode } from '../../common/services/errors';

/**
 * Service for managing products and menu
 */
export class ProductService {
  /**
   * Get all active products with their relations
   */
  static async getActiveProducts(options?: {
    includeRelations?: boolean;
    formatForAI?: boolean;
    formatForWhatsApp?: boolean;
    restaurantName?: string;
  }): Promise<Product[] | string> {
    try {
      const products = await prisma.product.findMany({
        where: { isActive: true },
        orderBy: { sortOrder: 'asc' },
        include: options?.includeRelations !== false ? {
          subcategory: {
            include: {
              category: true
            }
          },
          variants: {
            where: { isActive: true },
            orderBy: { sortOrder: 'asc' }
          },
          modifierGroups: {
            orderBy: { sortOrder: 'asc' },
            include: {
              productModifiers: {
                where: { isActive: true },
                orderBy: { sortOrder: 'asc' }
              }
            }
          },
          pizzaCustomizations: {
            where: { isActive: true },
            orderBy: { sortOrder: 'asc' }
          },
          pizzaConfiguration: true
        } : undefined
      });

      // Obtener nombre del restaurante si no se proporciona
      let restaurantName = options?.restaurantName;
      if (!restaurantName && (options?.formatForAI || options?.formatForWhatsApp)) {
        try {
          const { RestaurantService } = await import('../restaurant/RestaurantService');
          const config = await RestaurantService.getConfig();
          restaurantName = config.restaurantName;
        } catch (error) {
          restaurantName = "Nuestro Restaurante";
        }
      }

      // Si se solicita formato para WhatsApp, usar formato simplificado
      if (options?.formatForWhatsApp) {
        return this.formatMenuForWhatsApp(products, restaurantName);
      }

      // Si se solicita formato para AI, formatear el menú con markdown
      if (options?.formatForAI) {
        return this.formatMenuForAI(products, restaurantName);
      }

      return products;
    } catch (error) {
      logger.error('Error fetching active products:', error);
      throw error;
    }
  }

  /**
   * Format menu for WhatsApp - Improved formatting with better readability
   */
  private static formatMenuForWhatsApp(products: any[], restaurantName: string = "Nuestro Restaurante"): string {
    let menuText = `*🍽️ MENÚ ${restaurantName.toUpperCase()} 🍽️*\n`;
    menuText += "━━━━━━━━━━━━━━━━━━━━━━\n";

    // Agrupar por categoría con sortOrder
    const productsByCategory = products.reduce((acc, product) => {
      const category = product.subcategory?.category;
      const categoryName = category?.name || 'Sin categoría';
      const categorySortOrder = category?.sortOrder || 999;
      
      if (!acc[categoryName]) {
        acc[categoryName] = {
          sortOrder: categorySortOrder,
          products: []
        };
      }
      acc[categoryName].products.push(product);
      return acc;
    }, {} as Record<string, { sortOrder: number; products: any[] }>);

    // Ordenar categorías por sortOrder
    const sortedCategories = Object.entries(productsByCategory)
      .sort(([, a], [, b]) => (a as any).sortOrder - (b as any).sortOrder);

    // Formatear por categoría
    for (const [category, data] of sortedCategories) {
      menuText += `\n*◆ ${category.toUpperCase()} ◆*\n`;
      
      // Productos ya vienen ordenados por sortOrder desde la consulta
      for (let i = 0; i < (data as any).products.length; i++) {
        const product = (data as any).products[i];
        
        // Agregar separación entre productos (excepto el primero)
        if (i > 0) {
          menuText += '─────────\n';
        }
        
        menuText += `*${product.name}*`;
        
        // Precio si no tiene variantes
        if (!product.hasVariants && product.price) {
          menuText += ` → \`$${product.price.toFixed(2)}\``;
        }
        menuText += '\n';
        
        // Variantes con precios (ya ordenadas)
        if (product.variants?.length > 0 && product.hasVariants) {
          for (const variant of product.variants) {
            menuText += ` _${variant.name}_: \`$${variant.price.toFixed(2)}\`\n`;
          }
        }
        
        // Para pizzas, mostrar sabores disponibles
        if (product.isPizza && product.pizzaCustomizations?.length > 0) {
          const flavors = product.pizzaCustomizations.filter((c: any) => c.type === 'FLAVOR');
          if (flavors.length > 0) {
            menuText += ` _◇ Sabores:_\n`;
            
            // Obtener configuración de pizza
            const pizzaConfig = product.pizzaConfiguration;
            const includedToppings = pizzaConfig?.includedToppings || 4;
            const extraToppingCost = pizzaConfig?.extraToppingCost || 20;
            
            for (const flavor of flavors) {
              let flavorText = `  • ${flavor.name}`;
              
              // Agregar ingredientes si existen
              if (flavor.ingredients) {
                flavorText += ` _(${flavor.ingredients})_`;
              }
              
              // Calcular precio extra si el sabor excede los toppings incluidos
              if (flavor.toppingValue > includedToppings) {
                const extraToppings = flavor.toppingValue - includedToppings;
                const extraCost = extraToppings * extraToppingCost;
                flavorText += ` \`+$${extraCost.toFixed(2)}\``;
              }
              
              menuText += `${flavorText}\n`;
            }
            
            menuText += ` _◇ Máx. 2 mitades_\n`;
          }
        }
        
        // Mostrar todos los modificadores agrupados
        if (product.modifierGroups?.length > 0) {
          for (const group of product.modifierGroups) {
            const activeModifiers = group.productModifiers?.filter((m: any) => m.isActive) || [];
            if (activeModifiers.length > 0) {
              menuText += ` _◇ ${group.name}:_\n`;
              const modifierDetails = activeModifiers.map((m: any) => {
                // Solo agregar precio si es mayor a 0
                if (m.price && m.price > 0) {
                  return `  • ${m.name} \`+$${m.price.toFixed(2)}\``;
                }
                return `  • ${m.name}`;
              }).join('\n');
              menuText += `${modifierDetails}\n`;
            }
          }
        }
      }
    }

    menuText += "\n━━━━━━━━━━━━━━━━━━━━━━\n";
    menuText += "_📱 Para ordenar: menciona el producto completo con variante, extras y comentarios_";

    return menuText;
  }

  /**
   * Format menu for AI consumption
   */
  private static formatMenuForAI(products: any[], restaurantName: string = "Nuestro Restaurante"): string {
    let menuText = `🍽️ **MENÚ DE ${restaurantName.toUpperCase()}** 🍽️\n`;
    menuText += "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n";

    // Agrupar por categoría y subcategoría
    const productsByCategory = products.reduce((acc, product) => {
      const categoryName = product.subcategory?.category?.name || 'Sin categoría';
      const subcategoryName = product.subcategory?.name || 'Sin subcategoría';
      
      if (!acc[categoryName]) acc[categoryName] = {};
      if (!acc[categoryName][subcategoryName]) {
        acc[categoryName][subcategoryName] = {
          description: product.subcategory?.description,
          products: []
        };
      }
      acc[categoryName][subcategoryName].products.push(product);
      return acc;
    }, {} as Record<string, Record<string, { description: string | null; products: any[] }>>);

    // Mapeo de emojis por tipo de categoría (genérico)
    const categoryEmojis: Record<string, string> = {
      'pizza': '🍕',
      'pizzas': '🍕',
      'hamburguesa': '🍔',
      'hamburguesas': '🍔',
      'bebida': '🥤',
      'bebidas': '🥤',
      'postre': '🍰',
      'postres': '🍰',
      'ensalada': '🥗',
      'ensaladas': '🥗',
      'pasta': '🍝',
      'pastas': '🍝',
      'sandwich': '🥪',
      'sandwiches': '🥪',
      'sushi': '🍱',
      'comida china': '🥡',
      'tacos': '🌮',
      'mexicana': '🌮',
      'desayuno': '🍳',
      'desayunos': '🍳',
      'café': '☕',
      'cafés': '☕',
      'sopa': '🍲',
      'sopas': '🍲',
      'mariscos': '🦐',
      'pescados': '🐟',
      'pollo': '🍗',
      'carne': '🥩',
      'carnes': '🥩',
      'vegano': '🌱',
      'vegetariano': '🥦',
      'combo': '🍱',
      'combos': '🍱',
      'promoción': '⭐',
      'promociones': '⭐'
    };

    // Función para obtener emoji apropiado
    const getEmoji = (categoryName: string): string => {
      const lowerName = categoryName.toLowerCase();
      for (const [key, emoji] of Object.entries(categoryEmojis)) {
        if (lowerName.includes(key)) {
          return emoji;
        }
      }
      return '🍽️'; // Emoji por defecto
    };

    // Formatear por categoría y subcategoría
    for (const [category, subcategories] of Object.entries(productsByCategory)) {
      const emoji = getEmoji(category);
      
      menuText += `\n${emoji} **${category.toUpperCase()}** ${emoji}\n`;
      menuText += `${'─'.repeat(30)}\n\n`;
      
      for (const [subcategory, data] of Object.entries(subcategories as Record<string, any>)) {
        if (subcategory !== 'Sin subcategoría') {
          menuText += `▸ _${subcategory}_\n\n`;
        }
        
        const categoryProducts = data.products;
        
        for (const product of categoryProducts) {
          // Nombre del producto
          menuText += `  **${product.name}**`;
          
          // Precio si no tiene variantes
          if (!product.hasVariants && product.price) {
            menuText += ` ─ $${product.price.toFixed(2)}`;
          }
          
          menuText += '\n';
          
          // Variantes con precios
          if (product.variants?.length > 0 && product.hasVariants) {
            for (const variant of product.variants) {
              menuText += `    • ${variant.name}: **$${variant.price.toFixed(2)}**\n`;
            }
          }
          
          // Personalizaciones de pizza (si aplica)
          if (product.pizzaCustomizations?.length > 0 && product.isPizza) {
            const flavors = product.pizzaCustomizations.filter((c: any) => c.type === 'FLAVOR');
            const ingredients = product.pizzaCustomizations.filter((c: any) => c.type === 'INGREDIENT');
            
            if (flavors.length > 0) {
              menuText += `    _Sabores disponibles: ${flavors.map((f: any) => f.name).join(', ')}_\n`;
            }
            if (ingredients.length > 0) {
              menuText += `    _Ingredientes extra: ${ingredients.map((i: any) => i.name).join(', ')}_\n`;
            }
          }
          
          // Modificadores disponibles
          if (product.modifierGroups?.length > 0) {
            for (const modGroup of product.modifierGroups) {
              if (modGroup.productModifiers?.length > 0) {
                menuText += `\n    **${modGroup.name}**\n`;
                for (const mod of modGroup.productModifiers) {
                  const price = mod.price ? `+$${mod.price.toFixed(2)}` : 'Sin costo';
                  menuText += `      ○ ${mod.name} (${price})\n`;
                }
              }
            }
          }
          
          menuText += "\n";
        }
      }
    }

    // Agregar información adicional
    menuText += "\n━━━━━━━━━━━━━━━━━━━━━━\n";
    menuText += "💡 **Cómo ordenar:**\n";
    menuText += "• Menciona el nombre del producto\n";
    menuText += "• Especifica el tamaño si hay variantes\n";
    menuText += "• Indica modificadores si deseas\n";
    menuText += "━━━━━━━━━━━━━━━━━━━━━━\n";

    return menuText;
  }

  /**
   * Get all active categories
   */
  static async getActiveCategories(): Promise<Category[]> {
    try {
      return await prisma.category.findMany({
        where: { isActive: true },
        include: {
          subcategories: {
            where: { isActive: true }
          }
        }
      });
    } catch (error) {
      logger.error('Error fetching active categories:', error);
      throw error;
    }
  }

  /**
   * Get product by ID
   */
  static async getProductById(productId: string): Promise<Product | null> {
    try {
      return await prisma.product.findUnique({
        where: { id: productId },
        include: {
          variants: true,
          modifierGroups: {
            include: {
              productModifiers: true
            }
          },
          pizzaCustomizations: true,
          pizzaConfiguration: true
        }
      });
    } catch (error) {
      logger.error('Error fetching product by ID:', error);
      throw error;
    }
  }

  /**
   * Get variant by ID
   */
  static async getVariantById(variantId: string): Promise<ProductVariant | null> {
    try {
      return await prisma.productVariant.findUnique({
        where: { id: variantId },
        include: {
          product: true
        }
      });
    } catch (error) {
      logger.error('Error fetching variant by ID:', error);
      throw error;
    }
  }

  /**
   * Toggle product availability
   */
  static async toggleProductAvailability(productId: string, isActive: boolean): Promise<Product> {
    try {
      const product = await prisma.product.update({
        where: { id: productId },
        data: { isActive }
      });

      logger.info(`Product ${productId} availability set to ${isActive}`);
      return product;
    } catch (error) {
      logger.error('Error toggling product availability:', error);
      throw new NotFoundError(
        ErrorCode.INVALID_PRODUCT,
        'Product not found',
        { metadata: { productId } }
      );
    }
  }

  /**
   * Toggle variant availability
   */
  static async toggleVariantAvailability(variantId: string, isActive: boolean): Promise<ProductVariant> {
    try {
      const variant = await prisma.productVariant.update({
        where: { id: variantId },
        data: { isActive }
      });

      logger.info(`Variant ${variantId} availability set to ${isActive}`);
      return variant;
    } catch (error) {
      logger.error('Error toggling variant availability:', error);
      throw new NotFoundError(
        ErrorCode.INVALID_PRODUCT,
        'Product variant not found',
        { metadata: { variantId } }
      );
    }
  }

  /**
   * Get menu structure for AI context (without IDs or prices)
   */
  static async getMenuStructureForAI(): Promise<any> {
    try {
      const products = await prisma.product.findMany({
        where: { isActive: true },
        include: {
          subcategory: {
            include: {
              category: true
            }
          },
          variants: {
            where: { isActive: true },
            orderBy: { sortOrder: 'asc' }
          },
          modifierGroups: {
            orderBy: { sortOrder: 'asc' },
            include: {
              productModifiers: {
                where: { isActive: true },
                orderBy: { sortOrder: 'asc' }
              }
            }
          },
          pizzaCustomizations: {
            where: { isActive: true },
            orderBy: { sortOrder: 'asc' }
          },
          pizzaConfiguration: true
        },
        orderBy: { sortOrder: 'asc' }
      });

      // Agrupar por categorías
      const menuStructure: Record<string, any> = {};

      for (const product of products) {
        const categoryName = product.subcategory.category.name;
        const subcategoryName = product.subcategory.name;

        // Crear estructura de categoría si no existe
        if (!menuStructure[categoryName]) {
          menuStructure[categoryName] = {};
        }

        // Crear estructura de subcategoría si no existe
        if (!menuStructure[categoryName][subcategoryName]) {
          menuStructure[categoryName][subcategoryName] = [];
        }

        // Crear estructura del producto
        const productStructure: any = {
          nombre: product.name,
          descripcion: product.description
        };

        // Agregar variantes si existen
        if (product.variants.length > 0) {
          productStructure.variantes = product.variants.map(v => v.name);
        }

        // Agregar modificadores si existen
        if (product.modifierGroups.length > 0) {
          productStructure.modificadores = {};
          
          for (const group of product.modifierGroups) {
            if (group.productModifiers.length > 0) {
              productStructure.modificadores[group.name] = group.productModifiers.map(m => m.name);
            }
          }
        }

        // Agregar personalizaciones de pizza si es una pizza
        if (product.isPizza && product.pizzaCustomizations.length > 0) {
          const flavors = product.pizzaCustomizations.filter((c: any) => c.type === 'FLAVOR');
          const ingredients = product.pizzaCustomizations.filter((c: any) => c.type === 'INGREDIENT');
          
          productStructure.personalizacionesPizza = {
            sabores: flavors.map(f => f.name),
            ingredientes: ingredients.map(i => i.name)
          };
        }

        menuStructure[categoryName][subcategoryName].push(productStructure);
      }

      return menuStructure;
    } catch (error) {
      logger.error('Error getting menu structure for AI:', error);
      throw error;
    }
  }

}

================
File: backend/src/routes/address-registration.ts
================
import { Router, Request, Response } from 'express';
import { OTPService } from '../services/security/OTPService';
import { DeliveryInfoService } from '../services/orders/services/DeliveryInfoService';
import { prisma } from '../lib/prisma';
import logger from '../common/utils/logger';
import { asyncHandler } from '../common/middlewares/errorHandler';
import { ValidationError, NotFoundError, ErrorCode } from '../common/services/errors';
import { validationMiddleware, queryValidationMiddleware } from '../common/middlewares/validation.middleware';
import { otpAuthMiddleware, AuthenticatedRequest } from '../common/middlewares/otp.middleware';
import { SyncMetadataService } from '../services/sync/SyncMetadataService';
import {
  VerifyOtpDto
} from '../dto/auth';
import {
  CreateAddressDto,
  UpdateAddressDto,
  GetAddressesQueryDto,
  DeleteAddressDto,
  SetDefaultAddressDto
} from '../dto/address';
import {
  UpdateCustomerNameDto
} from '../dto/customer';
import { Address } from '@prisma/client';

const router = Router();

/**
 * Verificar OTP para registro de dirección
 * POST /backend/address-registration/verify-otp
 */
router.post('/verify-otp', 
  validationMiddleware(VerifyOtpDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { whatsappPhoneNumber, otp } = req.body as VerifyOtpDto;
  
  const isValid = await OTPService.verifyOTP(whatsappPhoneNumber, otp);
  
  if (!isValid) {
    throw new ValidationError(
      ErrorCode.INVALID_OTP,
      'Invalid or expired OTP'
    );
  }
  
  // Obtener información del cliente
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber },
    select: {
      id: true,
      whatsappPhoneNumber: true,
      firstName: true,
      lastName: true,
      addresses: {
        where: { deletedAt: null },
        orderBy: { isDefault: 'desc' }
      }
    }
  });
  
  if (!customer) {
    throw new NotFoundError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found',
      { whatsappPhoneNumber }
    );
  }
  
  res.json({ 
    valid: true,
    customer: {
      customerId: customer.whatsappPhoneNumber,
      firstName: customer.firstName,
      lastName: customer.lastName,
      hasAddresses: customer.addresses.length > 0,
      addresses: customer.addresses
    }
  });
}));


/**
 * Crear nueva dirección para el cliente
 * POST /backend/address-registration/create
 */
router.post('/create',
  validationMiddleware(CreateAddressDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const { address } = req.body as CreateAddressDto;
    const customer = req.customer; // Customer already validated by middleware
    
    // Crear dirección
    const addressData = {
      ...address,
      customer: { connect: { id: customer.id } }
    };
    
    const newAddress = await DeliveryInfoService.createCustomerAddress(addressData);
    
    // Mark customer for sync since addresses are part of customer data
    await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
    
    // Si viene de un preOrder, actualizar la dirección del preOrder
    const preOrderId = req.query.preOrderId || req.body.preOrderId;
    if (preOrderId) {
      await updatePreOrderWithAddress(parseInt(preOrderId as string), newAddress);
    }
    
    // Enviar mensaje de confirmación a WhatsApp
    try {
      const { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } = await import('../services/whatsapp');
      const { ADDRESS_REGISTRATION_SUCCESS, WELCOME_MESSAGE_INTERACTIVE } = await import('../common/config/predefinedMessages');
      const { ConfigService } = await import('../services/config/ConfigService');
      
      // Verificar si viene de un preOrder (el frontend lo pasa como query param)
      const isFromPreOrder = preOrderId;
      
      if (!isFromPreOrder) {
        // Solo enviar estos mensajes si NO es parte de un preorder
        await sendWhatsAppMessage(
          customer.whatsappPhoneNumber,
          ADDRESS_REGISTRATION_SUCCESS(newAddress)
        );
        
        // Pequeño retraso para asegurar el orden correcto de mensajes
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Enviar mensaje de bienvenida
        const config = ConfigService.getConfig();
        const welcomeMessage = WELCOME_MESSAGE_INTERACTIVE(config);
        await sendWhatsAppInteractiveMessage(customer.whatsappPhoneNumber, welcomeMessage);
      }
      
      // Siempre actualizar lastInteraction
      await prisma.customer.update({
        where: { id: customer.id },
        data: { 
          lastInteraction: new Date()
        }
      });
      
    } catch (msgError) {
      logger.error('Error sending confirmation message:', msgError);
    }
    
    res.json({ 
      success: true,
      address: newAddress
    });
  })
);

/**
 * Actualizar nombre del cliente
 * PUT /backend/address-registration/update-customer-name
 */
router.put('/update-customer-name',
  validationMiddleware(UpdateCustomerNameDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { whatsappPhoneNumber, otp, firstName, lastName } = req.body as UpdateCustomerNameDto;
    
    // Verificar OTP
    const isValid = await OTPService.verifyOTP(whatsappPhoneNumber, otp);
    
    if (!isValid) {
      throw new ValidationError(
        ErrorCode.INVALID_OTP,
        'Invalid or expired OTP'
      );
    }
    
    // Actualizar nombre del cliente
    const updatedCustomer = await prisma.customer.update({
      where: { whatsappPhoneNumber },
      data: {
        firstName: firstName.trim(),
        lastName: lastName.trim()
      },
      select: {
        id: true,
        whatsappPhoneNumber: true,
        firstName: true,
        lastName: true,
        email: true,
        addresses: {
          where: { deletedAt: null },
          orderBy: { isDefault: 'desc' }
        }
      }
    });
    
    // Mark for sync
    await SyncMetadataService.markForSync('Customer', updatedCustomer.id, 'REMOTE');
    
    res.json({
      success: true,
      customer: updatedCustomer
    });
  })
);

/**
 * Actualizar dirección existente
 * PUT /backend/address-registration/:addressId
 */
router.put('/:addressId',
  validationMiddleware(UpdateAddressDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const { addressId } = req.params;
    const addressData = req.body as UpdateAddressDto;
    const customer = req.customer; // Customer already validated by middleware
    
    // Verificar que la dirección pertenece al cliente
    const existingAddress = await prisma.address.findFirst({
      where: { 
        id: addressId,
        customerId: customer.id
      }
    });
    
    if (!existingAddress) {
      throw new NotFoundError(
        ErrorCode.ADDRESS_NOT_FOUND,
        'Address not found or does not belong to customer',
        { addressId, customerId: customer.id }
      );
    }
    
    // Actualizar dirección
    const updatedAddress = await DeliveryInfoService.updateCustomerAddress(
      addressId,
      addressData
    );
    
    // Enviar notificación de WhatsApp sobre actualización de dirección
    try {
      const { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } = await import('../services/whatsapp');
      const { ADDRESS_UPDATE_SUCCESS, WELCOME_MESSAGE_INTERACTIVE } = await import('../common/config/predefinedMessages');
      const { ConfigService } = await import('../services/config/ConfigService');
      
      // Usar whatsappPhoneNumber del customer autenticado
      await sendWhatsAppMessage(
        customer.whatsappPhoneNumber,
        ADDRESS_UPDATE_SUCCESS(updatedAddress)
      );
      
      // Pequeño retraso para asegurar el orden correcto de mensajes
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Enviar mensaje de bienvenida inmediatamente después
      const config = ConfigService.getConfig();
      const welcomeMessage = WELCOME_MESSAGE_INTERACTIVE(config);
      await sendWhatsAppInteractiveMessage(customer.whatsappPhoneNumber, welcomeMessage);
      
      // Marcar que hubo interacción para evitar mensaje de bienvenida duplicado
      await prisma.customer.update({
        where: { id: customer.id },
        data: { 
          lastInteraction: new Date()
        }
      });
      
      // Mark for sync
      await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
      
    } catch (sendError) {
      logger.error('Failed to send WhatsApp notification:', sendError);
      // Continuar aunque WhatsApp falle
    }
    
    res.json({ 
      success: true,
      address: updatedAddress
    });
  })
);

/**
 * Obtener direcciones del cliente
 * GET /backend/address-registration/:customerId/addresses
 */
router.get('/:customerId/addresses',
  queryValidationMiddleware(GetAddressesQueryDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const customer = req.customer; // Customer already validated by middleware
    
    const addresses = await DeliveryInfoService.getCustomerAddresses(customer.id);
    res.json({ addresses });
  })
);

/**
 * Eliminar dirección del cliente
 * DELETE /backend/address-registration/:addressId
 */
router.delete('/:addressId',
  validationMiddleware(DeleteAddressDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const { addressId } = req.params;
    const customer = req.customer; // Customer already validated by middleware
    
    // Eliminar dirección (eliminación suave)
    await DeliveryInfoService.deleteCustomerAddress(
      addressId,
      customer.id
    );
    
    // Mark customer for sync since addresses are part of customer data
    await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
    
    res.json({ 
      success: true,
      message: 'Address deleted successfully'
    });
  })
);

/**
 * Establecer dirección como predeterminada
 * PUT /backend/address-registration/:addressId/default
 */
router.put('/:addressId/default',
  validationMiddleware(SetDefaultAddressDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const { addressId } = req.params;
    const customer = req.customer; // Customer already validated by middleware
    
    // Establecer como predeterminada
    const updatedAddress = await DeliveryInfoService.setDefaultAddress(
      addressId,
      customer.id
    );
    
    // Mark customer for sync since addresses are part of customer data
    await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
    
    // Enviar notificación de WhatsApp sobre cambio de dirección principal
    try {
      const { sendWhatsAppMessage } = await import('../services/whatsapp');
      const { DEFAULT_ADDRESS_CHANGED } = await import('../common/config/predefinedMessages');
      
      await sendWhatsAppMessage(
        customer.whatsappPhoneNumber, 
        DEFAULT_ADDRESS_CHANGED(updatedAddress)
      );
    } catch (msgError) {
      logger.error('Error sending default address notification:', msgError);
    }
    
    res.json({ 
      success: true,
      address: updatedAddress
    });
  })
);

/**
 * Obtener polígono del área de entrega
 * GET /backend/address-registration/delivery-area
 */
router.get('/delivery-area', asyncHandler(async (_req: Request, res: Response) => {
    // Obtener configuración del restaurante
    const restaurant = await prisma.restaurantConfig.findFirst({
      select: {
        deliveryCoverageArea: true
      }
    });

    if (!restaurant || !restaurant.deliveryCoverageArea) {
      res.json({ polygonCoords: [] });
      return;
    }

    // Devolver coordenadas del polígono
    res.json({ 
      polygonCoords: restaurant.deliveryCoverageArea
    });
  })
);


/**
 * Helper function to recreate preOrder with new address
 */
async function updatePreOrderWithAddress(preOrderId: number, address: Address): Promise<void> {
  const preOrder = await prisma.preOrder.findUnique({
    where: { id: preOrderId }
  });
  
  if (!preOrder) {
    return;
  }
  
  const { PreOrderWorkflowService } = await import('../services/orders/preOrderWorkflowService');
  await PreOrderWorkflowService.recreatePreOrderWithNewAddress({
    oldPreOrderId: preOrderId,
    newAddressId: address.id,
    whatsappNumber: preOrder.whatsappPhoneNumber
  });
}

export default router;

================
File: backend/src/whatsapp/handlers/interactiveMessageHandler.ts
================
import { PreOrderWorkflowService } from "../../services/orders/preOrderWorkflowService";
import { INTERACTIVE_ACTIONS, startsWithAction, extractIdFromAction } from "../../common/constants/interactiveActions";
import { prisma } from '../../lib/prisma';
import { sendWhatsAppMessage, sendMessageWithUrlButton, WhatsAppService } from "../../services/whatsapp";
import Stripe from "stripe";
import { OTPService } from "../../services/security/OTPService";
import { redisService } from "../../services/redis/RedisService";
import {
  WAIT_TIMES_MESSAGE,
  RESTAURANT_INFO_MESSAGE,
  CHATBOT_HELP_MESSAGE,
} from "../../common/config/predefinedMessages";
import { ConfigService } from "../../services/config/ConfigService";
import logger from "../../common/utils/logger";
import { getCurrentMexicoTime, getFormattedBusinessHours } from "../../common/utils/timeUtils";
import { env } from "../../common/config/envValidator";
import { BusinessLogicError, ErrorCode } from "../../common/services/errors";
import { handleWhatsAppError } from "../../common/utils/whatsappErrorHandler";
import { getMenuResponses } from "../../services/ai/tools/handlers/sendMenuHandler";
import { formatAddressFull, formatAddressShort, formatAddressDescription } from "../../common/utils/addressFormatter";

const stripeClient = env.STRIPE_SECRET_KEY 
  ? new Stripe(env.STRIPE_SECRET_KEY, {
      apiVersion: "2024-10-28.acacia",
    })
  : null;

// Map of button action prefixes to their handlers
const BUTTON_ACTION_HANDLERS = new Map<string, (from: string, buttonId: string) => Promise<void>>([  
  [INTERACTIVE_ACTIONS.PREORDER_CONFIRM.slice(0, -1), handlePreOrderAction], // Remove trailing colon
  [INTERACTIVE_ACTIONS.PREORDER_DISCARD.slice(0, -1), handlePreOrderAction], // Remove trailing colon
  [INTERACTIVE_ACTIONS.PREORDER_CHANGE_ADDRESS.slice(0, -1), handlePreOrderChangeAddress], // Remove trailing colon
  ['pay_online', handleOnlinePaymentWithId],
  ['add_new_address_preorder', handleAddNewAddressFromButton], // New handler for add new address button
  ['select_address', handleAddressSelectionButton], // Handler for address selection buttons
]);

const LIST_ACTIONS = {
  [INTERACTIVE_ACTIONS.WAIT_TIMES]: handleWaitTimes,
  [INTERACTIVE_ACTIONS.VIEW_MENU]: sendMenu,
  [INTERACTIVE_ACTIONS.RESTAURANT_INFO]: handleRestaurantInfo,
  [INTERACTIVE_ACTIONS.CHATBOT_HELP]: handleChatbotHelp,
  [INTERACTIVE_ACTIONS.CHANGE_DELIVERY_INFO]: handleChangeDeliveryInfo,
} as const;

export async function handleInteractiveMessage(
  from: string,
  message: any
): Promise<void> {
  try {
    logger.info('Interactive message received:', JSON.stringify(message));
    
    if (!message.interactive) {
      logger.error('No interactive property in message');
      return;
    }
    
    const { type, button_reply, list_reply } = message.interactive;
    const messageId = message.context?.id || null;

    if (type === "button_reply") {
      logger.info(`Processing button_reply: ${button_reply.id}`);
      
      // Check for address confirmation
      if (startsWithAction(button_reply.id, INTERACTIVE_ACTIONS.CONFIRM_ADDRESS)) {
        logger.info(`Handling address confirmation: ${button_reply.id}`);
        await handleAddressConfirmation(from, button_reply.id);
      } else if (button_reply.id === INTERACTIVE_ACTIONS.CHANGE_ADDRESS) {
        logger.info(`Handling change address`);
        await handleChangeDeliveryInfo(from);
      } else {
        // Check for action handlers by prefix
        const [actionPrefix] = button_reply.id.split(':');
        logger.info(`Looking for handler with prefix: ${actionPrefix}`);
        const handler = BUTTON_ACTION_HANDLERS.get(actionPrefix);
        
        if (handler) {
          logger.info(`Found handler for prefix: ${actionPrefix}`);
          await handler(from, button_reply.id);
        } else {
          logger.warn(`No handler found for button action: ${button_reply.id}`);
        }
      }
    } else if (type === "list_reply") {
      // Check for address selection
      if (startsWithAction(list_reply.id, INTERACTIVE_ACTIONS.SELECT_ADDRESS)) {
        await handleAddressSelection(from, list_reply.id);
      } else if (list_reply.id === INTERACTIVE_ACTIONS.ADD_NEW_ADDRESS) {
        await handleAddNewAddress(from);
      } else if (startsWithAction(list_reply.id, 'add_new_address_preorder:')) {
        // Handle add new address from preorder flow
        const preOrderId = parseInt(list_reply.id.split(':')[1], 10);
        await handleAddNewAddressForPreOrder(from, preOrderId);
      } else {
        const action = LIST_ACTIONS[list_reply.id as keyof typeof LIST_ACTIONS];
        if (action) {
          logger.info(`Executing action: ${list_reply.id}`);
          await action(from);
        } else {
          logger.error(`No action found for: ${list_reply.id}`);
        }
      }
    }
  } catch (error) {
    await handleWhatsAppError(error, from, {
      userId: from,
      operation: 'handleInteractiveMessage'
    });
  }
}



async function handleOnlinePaymentWithId(
  customerId: string,
  buttonId: string
): Promise<void> {
  // Extract orderId from buttonId (format: "pay_online:orderId")
  const [, orderId] = buttonId.split(':');
  if (!orderId) {
    throw new BusinessLogicError(
      ErrorCode.ORDER_NOT_FOUND,
      'Invalid button ID format',
      { userId: customerId, operation: 'handleOnlinePayment' }
    );
  }
  
  return handleOnlinePayment(customerId, orderId);
}

async function handleOnlinePayment(
  customerId: string,
  orderId: string
): Promise<void> {
  if (!stripeClient) {
    throw new BusinessLogicError(
      ErrorCode.STRIPE_ERROR,
      'Stripe client not configured',
      { userId: customerId, operation: 'handleOnlinePayment' }
    );
  }
    const order = await prisma.order.findUnique({ where: { id: orderId } });
    if (!order) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'Order not found for payment processing',
        { userId: customerId, operation: 'handleOnlinePayment' }
      );
    }

    // Check if a payment session already exists
    const existingPayment = await prisma.payment.findFirst({
      where: {
        orderId: order.id,
        paymentMethod: 'STRIPE',
        stripePaymentId: { not: null }
      }
    });
    
    if (existingPayment) {
      throw new BusinessLogicError(
        ErrorCode.PAYMENT_LINK_EXISTS,
        'Payment link already exists for this order',
        { userId: customerId, metadata: { orderId: order.id }, operation: 'handleOnlinePayment' }
      );
    }

    // Verificar el estado de la orden
    let mensaje: string | undefined;
    switch (order.orderStatus) {
      case "PENDING":
      case "IN_PROGRESS":
        // Continuar con el proceso de pago
        break;
      case "IN_PREPARATION":
        mensaje =
          "❌ Esta orden ya está en preparación. Por favor, contacta con el restaurante para opciones de pago.";
        break;
      case "READY":
        mensaje =
          "❌ Esta orden ya está preparada. Por favor, contacta con el restaurante para opciones de pago.";
        break;
      case "IN_DELIVERY":
        mensaje =
          "❌ Esta orden ya está en camino. Por favor, paga al repartidor o contacta con el restaurante.";
        break;
      case "CANCELLED":
        mensaje =
          "❌ Esta orden ya ha sido cancelada y no se puede procesar el pago.";
        break;
      case "COMPLETED":
        mensaje =
          "❌ Esta orden ya ha sido finalizada y no se puede procesar el pago.";
        break;
      default:
        mensaje =
          "❌ Lo sentimos, pero no se puede procesar el pago en este momento debido al estado actual de la orden.";
    }

    if (mensaje) {
      // Get customer's WhatsApp phone number
      const customerForMessage = await prisma.customer.findUnique({
        where: { id: customerId },
        select: { whatsappPhoneNumber: true }
      });
      
      if (customerForMessage?.whatsappPhoneNumber) {
        await sendWhatsAppMessage(customerForMessage.whatsappPhoneNumber, mensaje);
      }
      return;
    }

    let customer = await prisma.customer.findUnique({ where: { id: customerId } });
    
    if (!customer) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer not found during payment process'
      );
    }
    
    let stripeCustomerId = customer.stripeCustomerId;

    if (!stripeCustomerId) {
      const stripeCustomer = await stripeClient.customers.create({
        phone: customer.whatsappPhoneNumber,
        metadata: { whatsappId: customer.whatsappPhoneNumber },
      });
      stripeCustomerId = stripeCustomer.id;
      await prisma.customer.update({
        where: { id: customer.id },
        data: { stripeCustomerId }
      });
    }

    const session = await stripeClient.checkout.sessions.create({
      payment_method_types: ["card"],
      customer: stripeCustomerId,
      line_items: [
        {
          price_data: {
            currency: "mxn",
            product_data: {
              name: `Orden #${
                order.shiftOrderNumber
              } - ${(await getCurrentMexicoTime()).format("DD/MM/YYYY")}`,
            },
            unit_amount: Math.round(order.total * 100),
          },
          quantity: 1,
        },
      ],
      mode: "payment",
      success_url: `${env.FRONTEND_BASE_URL}/payment-success`,
      cancel_url: `${env.FRONTEND_BASE_URL}/payment-cancel`,
    });

    // Create payment record with Stripe session ID
    await prisma.payment.create({
      data: {
        orderId: order.id,
        paymentMethod: 'STRIPE',
        amount: order.total,
        status: 'PENDING',
        stripePaymentId: session.id,
        metadata: {
          sessionUrl: session.url,
          createdAt: new Date().toISOString()
        }
      }
    });

    const paymentLink = session.url;
    await sendWhatsAppMessage(
      customerId,
      `💳 Por favor, haz clic en el siguiente enlace para proceder con el pago: 🔗 ${paymentLink} 💰`
    );
}

async function sendMenu(phoneNumber: string): Promise<boolean> {
  try {
    // Usa la lógica centralizada para obtener y dividir el menú
    const toolResponse = await getMenuResponses();
    
    // Normaliza a array para manejar ambos casos (respuesta única o múltiple)
    const responses = Array.isArray(toolResponse) ? toolResponse : [toolResponse];
    
    // Envía cada parte del menú por separado
    // La división ya fue manejada por getMenuResponses usando splitMenu
    for (const response of responses) {
      if (response && response.text) {
        // sendWhatsAppMessage no volverá a dividir porque cada parte es < 3500 chars
        const result = await sendWhatsAppMessage(phoneNumber, response.text);
        if (!result) {
          logger.error(`Failed to send menu part to ${phoneNumber}`);
          return false;
        }
      }
    }
    
    return true;
  } catch (error) {
    logger.error(`Error sending menu from interactive handler for ${phoneNumber}:`, error);
    await sendWhatsAppMessage(
      phoneNumber, 
      "Lo siento, tuvimos un problema al generar el menú. Por favor, intenta de nuevo más tarde."
    );
    return false;
  }
}

async function handleWaitTimes(customerId: string): Promise<void> {
  const config = await prisma.restaurantConfig.findFirst();
  if (!config) {
    throw new BusinessLogicError(ErrorCode.DATABASE_ERROR, 'Restaurant configuration not found');
  }
  const message = WAIT_TIMES_MESSAGE(
    config.estimatedPickupTime,
    config.estimatedDeliveryTime
  );
  await sendWhatsAppMessage(customerId, message);
}

async function handleRestaurantInfo(customerId: string): Promise<void> {
  const config = ConfigService.getConfig();
  const formattedHours = await getFormattedBusinessHours();
  const message = RESTAURANT_INFO_MESSAGE(config, formattedHours);
  await sendWhatsAppMessage(customerId, message);
}

async function handleChatbotHelp(whatsappPhoneNumber: string): Promise<void> {
  const config = ConfigService.getConfig();
  const message = CHATBOT_HELP_MESSAGE(config);
  await sendWhatsAppMessage(whatsappPhoneNumber, message);
}

async function handleChangeDeliveryInfo(from: string): Promise<void> {
  const otp = OTPService.generateOTP();
  await OTPService.storeOTP(from, otp, true); // true for address registration
  const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${from}?otp=${otp}`;
  
  // Enviar mensaje con botón URL
  await sendMessageWithUrlButton(
    from,
    "🚚 Actualizar Dirección",
    "Puedes actualizar o agregar una nueva dirección de entrega haciendo clic en el botón de abajo.",
    "Actualizar Dirección",
    updateLink
  );
}

async function handleAddressConfirmation(from: string, confirmationId: string): Promise<void> {
  // Extract address ID from confirmation ID
  const addressId = extractIdFromAction(confirmationId, INTERACTIVE_ACTIONS.CONFIRM_ADDRESS);
  
  // This is the same as selecting an address
  await handleAddressSelection(from, `${INTERACTIVE_ACTIONS.SELECT_ADDRESS}${addressId}`);
}

async function handleAddressSelection(from: string, selectionId: string): Promise<void> {
  // Check if this is from a preorder change address flow
  // Format can be: select_address_[addressId] or select_address_[addressId]:[preOrderId]
  let addressId: string;
  let preOrderId: number | null = null;
  
  if (selectionId.includes(':')) {
    // This is from preorder change address flow
    const baseId = selectionId.split(':')[0];
    addressId = extractIdFromAction(baseId, INTERACTIVE_ACTIONS.SELECT_ADDRESS);
    preOrderId = parseInt(selectionId.split(':')[1], 10);
  } else {
    // Regular address selection
    addressId = extractIdFromAction(selectionId, INTERACTIVE_ACTIONS.SELECT_ADDRESS);
  }
    
    // Get customer
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: from },
      include: {
        addresses: {
          where: { id: addressId }
        }
      }
    });
    
    if (!customer || customer.addresses.length === 0) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer or address not found',
        { userId: from }
      );
    }
    
    const selectedAddress = customer.addresses[0];
    const formattedAddress = formatAddressFull(selectedAddress);
    
    // If we have a specific preOrderId, use it. Otherwise, check for recent preorder
    if (preOrderId) {
      // Recreate preorder with selected address
      const { PreOrderWorkflowService } = await import('../../services/orders/preOrderWorkflowService');
      
      try {
        // This will create a new preOrder with the new address and discard the old one
        await PreOrderWorkflowService.recreatePreOrderWithNewAddress({
          oldPreOrderId: preOrderId,
          newAddressId: selectedAddress.id,
          whatsappNumber: from
        });
        
        // The new preOrder summary is automatically sent by recreatePreOrderWithNewAddress
        // No need to send additional messages
      } catch (error) {
        logger.error('Error recreating preOrder with new address:', error);
        await sendWhatsAppMessage(
          from,
          `❌ Hubo un error al actualizar la dirección. Por favor intenta nuevamente.`
        );
      }
    } else {
      // No preOrderId provided, just confirming address selection for future use
      await sendWhatsAppMessage(
        from,
        `✅ *Dirección seleccionada*\n\n📍 *Dirección de entrega:*\n${formattedAddress}\n\nEsta dirección se usará para tu próximo pedido.`
      );
    }
}

async function handleAddNewAddress(from: string): Promise<void> {
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber: from }
  });
  
  if (!customer) {
    throw new BusinessLogicError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found',
      { userId: from }
    );
  }
    
  const preOrder = await prisma.preOrder.findFirst({
    where: { 
      whatsappPhoneNumber: customer.whatsappPhoneNumber,
      createdAt: {
        gte: new Date(Date.now() - 10 * 60 * 1000)
      }
    },
    orderBy: { createdAt: 'desc' }
  });
  
  const otp = OTPService.generateOTP();
  await OTPService.storeOTP(customer.whatsappPhoneNumber, otp, true);
  
  const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${customer.whatsappPhoneNumber}?otp=${otp}${preOrder ? `&preOrderId=${preOrder.id}` : ''}&viewMode=form`;
  
  await sendMessageWithUrlButton(
    from,
    "📍 Agregar Nueva Dirección",
    "Haz clic en el botón de abajo para registrar una nueva dirección de entrega.",
    "Agregar Dirección",
    updateLink
  );
}

async function handleAddNewAddressForPreOrder(from: string, preOrderId: number): Promise<void> {
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber: from }
  });
  
  if (!customer) {
    throw new BusinessLogicError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found',
      { userId: from }
    );
  }
  
  const otp = OTPService.generateOTP();
  await OTPService.storeOTP(customer.whatsappPhoneNumber, otp, true);
  
  const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${customer.whatsappPhoneNumber}?otp=${otp}&preOrderId=${preOrderId}&viewMode=form`;
  
  await sendMessageWithUrlButton(
    from,
    "📍 Agregar Nueva Dirección",
    "Haz clic en el botón de abajo para registrar una nueva dirección de entrega para tu pedido actual.",
    "Agregar Dirección",
    updateLink
  );
}

/**
 * Handler for add new address button (from button reply)
 */
async function handleAddNewAddressFromButton(from: string, buttonId: string): Promise<void> {
  const parts = buttonId.split(':');
  if (parts.length < 2) {
    await sendWhatsAppMessage(from, "❌ Error al procesar la solicitud. Por favor intenta nuevamente.");
    return;
  }
  
  const preOrderId = parseInt(parts[1], 10);
  if (isNaN(preOrderId)) {
    await sendWhatsAppMessage(from, "❌ Error al procesar la solicitud. Por favor intenta nuevamente.");
    return;
  }
  
  await handleAddNewAddressForPreOrder(from, preOrderId);
}

/**
 * Handler for address selection button (from button reply)
 */
async function handleAddressSelectionButton(from: string, buttonId: string): Promise<void> {
  await handleAddressSelection(from, buttonId);
}

/**
 * Handles preorder change address action
 */
async function handlePreOrderChangeAddress(from: string, buttonId: string): Promise<void> {
  // Extract token from button ID
  const parts = buttonId.split(':');
  const token = parts[1];
  
  if (!token) {
    throw new BusinessLogicError(
      ErrorCode.INVALID_TOKEN,
      'Invalid button format - missing token'
    );
  }
  
  // Validate token and get preOrderId
  const key = `preorder:token:${token}`;
  const preOrderIdStr = await redisService.get(key);
  
  if (!preOrderIdStr) {
    throw new BusinessLogicError(
      ErrorCode.INVALID_TOKEN,
      'Token no encontrado o expirado'
    );
  }
  
  const preOrderId = parseInt(preOrderIdStr, 10);
  
  // Get customer
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber: from },
    include: {
      addresses: {
        where: { deletedAt: null },
        orderBy: [
          { isDefault: 'desc' },
          { createdAt: 'desc' }
        ],
        take: 5
      }
    }
  });
  
  if (!customer) {
    throw new BusinessLogicError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found'
    );
  }
  
  // If no addresses, send link to add one
  if (customer.addresses.length === 0) {
    const otp = OTPService.generateOTP();
    await OTPService.storeOTP(from, otp, true);
    const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${from}?otp=${otp}&preOrderId=${preOrderId}`;
    
    await sendMessageWithUrlButton(
      from,
      "📍 Registrar Dirección",
      "No tienes direcciones guardadas. Por favor, registra una dirección de entrega haciendo clic en el botón de abajo.",
      "Agregar Dirección",
      updateLink
    );
    return;
  }
  
  // If only one address, offer to add a new one
  if (customer.addresses.length === 1) {
    const message = {
      type: "button",
      body: {
        text: `📍 *Dirección actual:*\n${formatAddressShort(customer.addresses[0])}\n\n¿Deseas usar esta dirección o agregar una nueva?`
      },
      action: {
        buttons: [
          {
            type: "reply",
            reply: {
              id: `select_address_${customer.addresses[0].id}:${preOrderId}`,
              title: "✅ Usar esta"
            }
          },
          {
            type: "reply",
            reply: {
              id: `add_new_address_preorder:${preOrderId}`,
              title: "➕ Nueva dirección"
            }
          }
        ]
      }
    };
    
    await WhatsAppService.sendInteractiveMessage(from, message);
    return;
  }
  
  // Multiple addresses - send selection list
  const sections = [
    {
      title: "Mis direcciones",
      rows: customer.addresses.map((address) => ({
        id: `select_address_${address.id}:${preOrderId}`,
        title: address.name || `${address.street} ${address.number}`.substring(0, 24),
        description: formatAddressDescription(address).substring(0, 72)
      }))
    }
  ];
  
  // Add option for new address
  sections[0].rows.push({
    id: `add_new_address_preorder:${preOrderId}`,
    title: "➕ Nueva dirección",
    description: "Registrar una nueva dirección de entrega"
  });
  
  await WhatsAppService.sendInteractiveMessage(from, {
    type: "list",
    header: {
      type: "text",
      text: "📍 Cambiar Dirección"
    },
    body: {
      text: "Selecciona la nueva dirección de entrega para tu pedido:"
    },
    footer: {
      text: "Elige una opción"
    },
    action: {
      button: "Ver direcciones",
      sections
    }
  });
}


/**
 * Handles preorder actions (confirm/discard) using the new token-based system
 */
async function handlePreOrderAction(from: string, buttonId: string): Promise<void> {
  // Extract token from button ID
  // Format: preorder_confirm:token or preorder_discard:token
  const parts = buttonId.split(':');
  const token = parts[1];
  
  if (!token) {
    throw new BusinessLogicError(
      ErrorCode.INVALID_TOKEN,
      'Invalid button format - missing token'
    );
  }
    
    // Determine action based on button prefix
    const action: 'confirm' | 'discard' = 
      startsWithAction(buttonId, INTERACTIVE_ACTIONS.PREORDER_CONFIRM) ? 'confirm' : 'discard';
    
    logger.info('Processing preorder action', { 
      from, 
      action, 
      tokenPrefix: token.substring(0, 8) + '...' 
    });
    
    // Process the action using the workflow service
    await PreOrderWorkflowService.processAction({
      action,
      token,
      whatsappNumber: from
    });
}




================================================================
End of Codebase
================================================================
