This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.claude/
  settings.local.json
.repomix/
  bundles.json
backend/
  docs/
    SERVICE_ARCHITECTURE.md
    TYPES_STRUCTURE.md
  prisma/
    migrations/
      20250618053254_initial_refactor_uuid/
        migration.sql
      20250619223940_add_preorder_fields/
        migration.sql
      migration_lock.toml
    schema.prisma
    seed.ts
  src/
    common/
      config/
        envValidator.ts
        predefinedMessages.ts
      services/
        errors/
          CustomErrors.ts
          errorMessages.ts
          ErrorService.ts
          index.ts
          types.ts
      types/
        index.ts
        menu.ts
        order.types.ts
        otp.types.ts
        restaurant.ts
        services.types.ts
        webhook.types.ts
        whatsapp.types.ts
      utils/
        geoUtils.ts
        logger.ts
        messageSplitter.ts
        textUtils.ts
        timeUtils.ts
    routes/
      address-registration.ts
      address-selection.ts
      sync.ts
      webhook.ts
    services/
      ai/
        AgentService.ts
        GeminiService.ts
        index.ts
      customer/
        CustomerService.ts
      messaging/
        middlewares/
          AddressRequiredMiddleware.ts
          CustomerValidationMiddleware.ts
          MessageProcessingMiddleware.ts
          MessageTypeMiddleware.ts
          RateLimitMiddleware.ts
          RestaurantHoursMiddleware.ts
        pipeline/
          MessagePipeline.ts
        strategies/
          AudioMessageStrategy.ts
          InteractiveMessageStrategy.ts
          MessageStrategy.ts
          TextMessageStrategy.ts
        types/
          responses.ts
        index.ts
        MessageContext.ts
        MessageProcessor.ts
        README.md
        types.ts
      orders/
        dto/
          create-order.dto.ts
        services/
          DeliveryInfoService.ts
          OrderFormattingService.ts
          OrderManagementService.ts
          ProductCalculationService.ts
          SchedulingService.ts
        OrderService.ts
        PreOrderService.ts
      payment/
        StripeService.ts
      products/
        ProductService.ts
      restaurant/
        RestaurantService.ts
      security/
        OTPService.ts
      sync/
        SyncService.ts
      whatsapp/
        index.ts
        WhatsAppService.ts
    whatsapp/
      handlers/
        orders/
          cancellationHandler.ts
          confirmationHandler.ts
          index.ts
          orderFormatters.ts
          preOrderHandler.ts
        interactiveMessageHandler.ts
        orderHandlers.ts
    server.ts
  .env.example
  .gitignore
  package.json
  railway.json
  README.md
  tsconfig.json
frontend-app/
  public/
    delivery-address.svg
    restaurant.svg
  src/
    components/
      AddressForm/
        AddressForm.tsx
        index.ts
      AddressManager/
        AddressManager2.tsx
        index.ts
      AddressSelector/
        AddressSelector.tsx
        index.ts
      BasicMap/
        BasicMap.tsx
        index.ts
      ui/
        Button.tsx
        index.ts
        Input.tsx
        WhatsAppButton.tsx
    config/
      index.ts
    i18n/
      index.ts
      translations.ts
    services/
      api.ts
      customer.service.ts
    styles/
      toast-animations.css
    types/
      api.types.ts
      customer.types.ts
    utils/
      loadGoogleMaps.ts
      polygonUtils.ts
    AddressRegistration.tsx
    app.css
    App.tsx
    index.css
    main.tsx
    Router.tsx
    vite-env.d.ts
  .env.example
  .gitignore
  eslint.config.js
  index.html
  package.json
  postcss.config.js
  README.md
  tailwind.config.js
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
.eslintrc.json
.gitignore
CLAUDE.md
DEPLOY_RAILWAY.md
docker-compose.yml
LOCAL_DEVELOPMENT.md
package.json
QUICK_START.md
README.md
start-local.sh

================================================================
Files
================================================================

================
File: .claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(git rm:*)",
      "Bash(ls:*)",
      "Bash(grep:*)",
      "Bash(find:*)",
      "Bash(npm install)",
      "Bash(npm run build:*)",
      "Bash(rm:*)",
      "Bash(npm install:*)",
      "Bash(npx prisma:*)",
      "Bash(mkdir:*)",
      "Bash(npm uninstall:*)",
      "Bash(git restore:*)",
      "Bash(git checkout:*)",
      "Bash(cp:*)",
      "Bash(chmod:*)",
      "Bash(node:*)",
      "Bash(npx tsc:*)",
      "Bash(npm run dev:*)",
      "mcp__ide__getDiagnostics",
      "Bash(od:*)",
      "Bash(pkill:*)",
      "Bash(true)",
      "Bash(NODE_ENV=development npx ts-node --transpile-only src/server.ts)",
      "Bash(npx ts-node:*)",
      "Bash(npm run seed:complete:*)",
      "Bash(mv:*)",
      "Bash(diff:*)",
      "Bash(md5sum:*)",
      "Bash(npm run seed:*)",
      "Bash(kill:*)",
      "Bash(npm run seed:*)",
      "Bash(rg:*)",
      "Bash(tree:*)",
      "Bash(npx tsx:*)",
      "Bash(npm run generate:*)",
      "Bash(npm run migrate:dev:*)",
      "Bash(curl:*)",
      "Bash(cat:*)",
      "Bash(./start-local.sh:*)",
      "Bash(npm run sync-env:*)",
      "Bash(PGPASSWORD=postgres psql:*)",
      "Bash(npm run typecheck:*)",
      "Bash(npm run:*)",
      "Bash(git ls-tree:*)",
      "Bash(git reset:*)",
      "Bash(git fetch:*)",
      "Bash(git push:*)"
    ],
    "deny": []
  }
}

================
File: .eslintrc.json
================
{
  "extends": "next/core-web-vitals",
  "parser": "@babel/eslint-parser",
  "parserOptions": {
    "requireConfigFile": false,
    "babelOptions": {
      "presets": ["@babel/preset-react"]
    }
  }
}

================
File: backend/docs/SERVICE_ARCHITECTURE.md
================
# Service Architecture Standards

## Overview
This document defines the standard architecture for all services in the backend application.

## Service Patterns

### 1. Stateless Services (Recommended Default)
Use **static class methods** for services that don't maintain state between calls.

```typescript
export class DomainService {
  static async performAction(params: ActionParams): Promise<Result> {
    // Implementation
  }
}
```

### 2. Stateful Services
Use **class instances** only when the service needs to maintain state or configuration.

```typescript
export class ConfigurableService {
  private config: ServiceConfig;

  constructor(config: ServiceConfig) {
    this.config = config;
  }

  async performAction(params: ActionParams): Promise<Result> {
    // Use this.config
  }
}
```

### 3. Singleton Services
For services that need global state (e.g., caching), use a singleton pattern.

```typescript
export class CacheService {
  private static instance: CacheService;
  private cache: Map<string, any>;

  private constructor() {
    this.cache = new Map();
  }

  static getInstance(): CacheService {
    if (!CacheService.instance) {
      CacheService.instance = new CacheService();
    }
    return CacheService.instance;
  }

  get(key: string): any {
    return this.cache.get(key);
  }
}
```

## Naming Conventions

1. **File Names**: `[Domain]Service.ts` (PascalCase)
   - ✅ `OrderService.ts`
   - ✅ `CustomerService.ts`
   - ❌ `customers.ts`
   - ❌ `order-service.ts`

2. **Class Names**: `[Domain]Service` (PascalCase)
   - ✅ `OrderService`
   - ✅ `CustomerService`

3. **Method Names**: camelCase, descriptive verbs
   - ✅ `createOrder()`
   - ✅ `validateCustomer()`
   - ❌ `order()`
   - ❌ `validate()`

## Directory Structure

```
src/
├── services/
│   ├── ai/                    # AI-related services
│   │   ├── AgentService.ts
│   │   └── GeminiService.ts
│   ├── communication/         # External communication
│   │   ├── WhatsAppService.ts
│   │   └── EmailService.ts
│   ├── customer/              # Customer domain
│   │   └── CustomerService.ts
│   ├── messaging/             # Internal message processing
│   │   └── MessagePipeline.ts
│   ├── order/                 # Order domain
│   │   ├── OrderService.ts
│   │   ├── PreOrderService.ts
│   │   └── MenuService.ts
│   ├── payment/               # Payment processing
│   │   └── StripeService.ts
│   ├── restaurant/            # Restaurant configuration
│   │   └── RestaurantService.ts
│   └── security/              # Security services
│       └── OTPService.ts
```

## Service Responsibilities

Each service should:
1. Handle a single domain/responsibility
2. Expose a clear public API
3. Hide implementation details
4. Use dependency injection where appropriate
5. Return consistent response types
6. Handle errors appropriately (throw custom errors)

## Dependencies

### Database Access
- Services should import `prisma` from the server file
- Consider creating a repository layer for complex queries

### Other Services
- Import services directly, don't create circular dependencies
- Use interfaces for loose coupling when needed

### External APIs
- Wrap all external API calls in service methods
- Handle API-specific errors and convert to domain errors

## Error Handling

Services should:
1. Use the centralized error service
2. Throw domain-specific errors
3. Let handlers decide how to respond to users

```typescript
import { BusinessLogicError, ErrorCode } from '@/common/services/errors';

export class OrderService {
  static async createOrder(data: CreateOrderDto): Promise<Order> {
    const customer = await prisma.customer.findUnique({
      where: { id: data.customerId }
    });

    if (!customer) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer not found',
        { customerId: data.customerId }
      );
    }

    // Continue with order creation
  }
}
```

## Migration Checklist

When refactoring existing services:
- [ ] Convert to class with static methods (if stateless)
- [ ] Use PascalCase for file and class names
- [ ] Move to appropriate domain directory
- [ ] Add proper TypeScript types
- [ ] Implement error handling with custom errors
- [ ] Add JSDoc documentation
- [ ] Update all imports

================
File: backend/docs/TYPES_STRUCTURE.md
================
# Type Definitions Structure

This directory contains all shared type definitions for the backend application.

## Organization

### Core Types
- `index.ts` - Central export file, import all types from here
- `order.types.ts` - Order-related types (NewOrder, OrderProduct, etc.)
- `menu.ts` - Menu and product types
- `restaurant.ts` - Restaurant configuration types
- `agents.ts` - AI agent types

### Communication Types
- `whatsapp.types.ts` - WhatsApp message types (outgoing)
- `webhook.types.ts` - Webhook and incoming message types
- `responses.ts` - Legacy response types (being migrated to UnifiedResponse)

### Service Types
- `services.types.ts` - Types used across multiple services
- `otp.types.ts` - OTP-related types

### Error Types
Located in `/common/services/errors/types.ts`:
- Error codes and types
- Error context and response types

## Type Naming Conventions

### WhatsApp Messages
- `IncomingWhatsAppMessage` - Messages received via webhook
- `OutgoingWhatsAppMessage` - Messages sent to users
- `OutgoingWhatsAppInteractiveMessage` - Interactive messages sent to users

### Response Types
We're migrating from multiple response types to a unified system:
- ❌ `AIResponse` (legacy)
- ❌ `MessageResponse` (legacy)
- ✅ `UnifiedResponse` (current standard)

### Import Best Practices

Always import types from the central index:
```typescript
// ✅ Good
import { Order, OrderType, DeliveryInfoInput } from '@/common/types';

// ❌ Bad
import { Order } from '@prisma/client';
import { DeliveryInfoInput } from '@/common/types/services.types';
```

## Prisma Types

Common Prisma types are re-exported through `index.ts` for convenience:
- Models: Customer, Order, Product, etc.
- Enums: OrderType, OrderStatus, PaymentStatus, etc.

## Migration Notes

### In Progress
1. Migrating all responses to use `UnifiedResponse`
2. Consolidating duplicate type definitions
3. Moving inline interfaces to `services.types.ts`

### Completed
1. Renamed WhatsApp types to avoid conflicts
2. Created central export file
3. Consolidated service-specific types

================
File: backend/prisma/migrations/20250618053254_initial_refactor_uuid/migration.sql
================
-- CreateEnum
CREATE TYPE "OrderType" AS ENUM ('DINE_IN', 'TAKE_AWAY', 'DELIVERY');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'IN_PREPARATION', 'READY', 'IN_DELIVERY', 'DELIVERED', 'COMPLETED', 'CANCELLED');

-- CreateEnum
CREATE TYPE "PaymentStatus" AS ENUM ('PENDING', 'PAID');

-- CreateEnum
CREATE TYPE "PizzaHalf" AS ENUM ('LEFT', 'RIGHT', 'FULL');

-- CreateEnum
CREATE TYPE "IngredientAction" AS ENUM ('ADD', 'REMOVE');

-- CreateEnum
CREATE TYPE "PreparationStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'READY', 'DELIVERED', 'CANCELLED');

-- CreateTable
CREATE TABLE "Category" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "photoId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Category_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Customer" (
    "id" UUID NOT NULL,
    "whatsappPhoneNumber" TEXT NOT NULL,
    "firstName" VARCHAR(100),
    "lastName" VARCHAR(100),
    "email" VARCHAR(255),
    "birthDate" DATE,
    "fullChatHistory" JSONB,
    "relevantChatHistory" JSONB,
    "stripeCustomerId" TEXT,
    "lastInteraction" TIMESTAMP(3),
    "totalOrders" INTEGER NOT NULL DEFAULT 0,
    "totalSpent" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "isBanned" BOOLEAN NOT NULL DEFAULT false,
    "bannedAt" TIMESTAMP(3),
    "banReason" TEXT,
    "deletedAt" TIMESTAMP(3),
    "lastSyncAt" TIMESTAMP(3),
    "syncVersion" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Customer_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Address" (
    "id" UUID NOT NULL,
    "customerId" UUID NOT NULL,
    "street" VARCHAR(200) NOT NULL,
    "number" VARCHAR(50) NOT NULL,
    "interiorNumber" VARCHAR(50),
    "neighborhood" VARCHAR(150),
    "city" VARCHAR(100),
    "state" VARCHAR(100),
    "zipCode" VARCHAR(10),
    "country" VARCHAR(100),
    "references" TEXT,
    "latitude" DECIMAL(10,8),
    "longitude" DECIMAL(11,8),
    "isDefault" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Address_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "MessageLog" (
    "id" SERIAL NOT NULL,
    "messageId" TEXT NOT NULL,
    "processed" BOOLEAN NOT NULL DEFAULT false,

    CONSTRAINT "MessageLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "MessageRateLimit" (
    "id" SERIAL NOT NULL,
    "whatsappPhoneNumber" TEXT NOT NULL,
    "messageCount" INTEGER NOT NULL DEFAULT 0,
    "lastMessageTime" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "MessageRateLimit_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductModifier" (
    "id" TEXT NOT NULL,
    "groupId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "price" DOUBLE PRECISION,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "isDefault" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "ProductModifier_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ModifierGroup" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "minSelections" INTEGER NOT NULL DEFAULT 0,
    "maxSelections" INTEGER NOT NULL DEFAULT 1,
    "isRequired" BOOLEAN NOT NULL DEFAULT false,
    "allowMultipleSelections" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "productId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "ModifierGroup_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Order" (
    "id" TEXT NOT NULL,
    "dailyOrderNumber" INTEGER NOT NULL,
    "orderType" "OrderType" NOT NULL,
    "status" "OrderStatus" NOT NULL DEFAULT 'PENDING',
    "paymentStatus" "PaymentStatus",
    "totalCost" DOUBLE PRECISION NOT NULL,
    "customerId" UUID NOT NULL,
    "estimatedTime" INTEGER NOT NULL DEFAULT 0,
    "scheduledDeliveryTime" TIMESTAMP(3),
    "messageId" TEXT,
    "stripeSessionId" TEXT,
    "finishedAt" TIMESTAMP(3),
    "syncedWithLocal" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Order_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "OrderDeliveryInfo" (
    "id" SERIAL NOT NULL,
    "street" VARCHAR(200),
    "number" VARCHAR(50),
    "interiorNumber" VARCHAR(50),
    "neighborhood" VARCHAR(150),
    "city" VARCHAR(100),
    "state" VARCHAR(100),
    "zipCode" VARCHAR(10),
    "country" VARCHAR(100),
    "references" TEXT,
    "latitude" DECIMAL(10,8),
    "longitude" DECIMAL(11,8),
    "pickupName" TEXT,
    "preOrderId" INTEGER,
    "orderId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "OrderDeliveryInfo_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "OrderItem" (
    "id" TEXT NOT NULL,
    "orderId" TEXT NOT NULL,
    "productId" TEXT NOT NULL,
    "productVariantId" TEXT,
    "basePrice" DOUBLE PRECISION NOT NULL,
    "finalPrice" DOUBLE PRECISION NOT NULL,
    "preparationStatus" "PreparationStatus" NOT NULL DEFAULT 'PENDING',
    "statusChangedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "preparationNotes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "OrderItem_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PizzaIngredient" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "ingredientValue" INTEGER NOT NULL DEFAULT 1,
    "ingredients" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "productIds" TEXT[],
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "PizzaIngredient_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PreOrder" (
    "id" SERIAL NOT NULL,
    "orderItems" JSONB NOT NULL,
    "orderType" "OrderType" NOT NULL,
    "scheduledDeliveryTime" TIMESTAMP(3),
    "customerId" UUID NOT NULL,
    "messageId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "PreOrder_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Product" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "price" DOUBLE PRECISION,
    "hasVariants" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "isPizza" BOOLEAN NOT NULL DEFAULT false,
    "subcategoryId" TEXT NOT NULL,
    "preparationScreenId" TEXT,
    "photoId" TEXT,
    "estimatedPrepTime" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Product_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductVariant" (
    "id" TEXT NOT NULL,
    "productId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price" DOUBLE PRECISION NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "ProductVariant_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "RestaurantConfig" (
    "id" SERIAL NOT NULL,
    "restaurantName" TEXT NOT NULL DEFAULT 'La Leña',
    "phoneMain" TEXT,
    "phoneSecondary" TEXT,
    "address" TEXT,
    "city" TEXT,
    "state" TEXT,
    "postalCode" TEXT,
    "country" TEXT,
    "acceptingOrders" BOOLEAN NOT NULL DEFAULT true,
    "estimatedPickupTime" INTEGER NOT NULL DEFAULT 20,
    "estimatedDeliveryTime" INTEGER NOT NULL DEFAULT 40,
    "openingGracePeriod" INTEGER NOT NULL DEFAULT 30,
    "closingGracePeriod" INTEGER NOT NULL DEFAULT 30,
    "timeZone" TEXT NOT NULL DEFAULT 'America/Mexico_City',
    "deliveryCoverageArea" JSONB,

    CONSTRAINT "RestaurantConfig_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "BusinessHours" (
    "id" SERIAL NOT NULL,
    "dayOfWeek" INTEGER NOT NULL,
    "openingTime" TEXT,
    "closingTime" TEXT,
    "isClosed" BOOLEAN NOT NULL DEFAULT false,
    "restaurantConfigId" INTEGER NOT NULL,

    CONSTRAINT "BusinessHours_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SeederControl" (
    "id" TEXT NOT NULL,
    "lastRun" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "SeederControl_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SelectedPizzaIngredient" (
    "id" SERIAL NOT NULL,
    "half" "PizzaHalf" NOT NULL DEFAULT 'FULL',
    "pizzaIngredientId" TEXT NOT NULL,
    "orderItemId" TEXT NOT NULL,
    "action" "IngredientAction" NOT NULL DEFAULT 'ADD',

    CONSTRAINT "SelectedPizzaIngredient_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Subcategory" (
    "id" TEXT NOT NULL,
    "categoryId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "photoId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Subcategory_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SyncLog" (
    "id" SERIAL NOT NULL,
    "entityType" TEXT NOT NULL,
    "entityId" TEXT NOT NULL,
    "action" TEXT NOT NULL,
    "syncDirection" TEXT NOT NULL,
    "syncStatus" TEXT NOT NULL,
    "errorMessage" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "SyncLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_OrderItemProductModifiers" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_OrderItemProductModifiers_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateTable
CREATE TABLE "_ProductPizzaIngredients" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_ProductPizzaIngredients_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE UNIQUE INDEX "Category_name_key" ON "Category"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Customer_whatsappPhoneNumber_key" ON "Customer"("whatsappPhoneNumber");

-- CreateIndex
CREATE UNIQUE INDEX "Customer_stripeCustomerId_key" ON "Customer"("stripeCustomerId");

-- CreateIndex
CREATE INDEX "Customer_whatsappPhoneNumber_idx" ON "Customer"("whatsappPhoneNumber");

-- CreateIndex
CREATE INDEX "Customer_email_idx" ON "Customer"("email");

-- CreateIndex
CREATE INDEX "Customer_lastSyncAt_idx" ON "Customer"("lastSyncAt");

-- CreateIndex
CREATE INDEX "Address_customerId_idx" ON "Address"("customerId");

-- CreateIndex
CREATE INDEX "Address_zipCode_idx" ON "Address"("zipCode");

-- CreateIndex
CREATE UNIQUE INDEX "MessageLog_messageId_key" ON "MessageLog"("messageId");

-- CreateIndex
CREATE UNIQUE INDEX "MessageRateLimit_whatsappPhoneNumber_key" ON "MessageRateLimit"("whatsappPhoneNumber");

-- CreateIndex
CREATE UNIQUE INDEX "OrderDeliveryInfo_orderId_key" ON "OrderDeliveryInfo"("orderId");

-- CreateIndex
CREATE UNIQUE INDEX "BusinessHours_restaurantConfigId_dayOfWeek_key" ON "BusinessHours"("restaurantConfigId", "dayOfWeek");

-- CreateIndex
CREATE UNIQUE INDEX "Subcategory_name_key" ON "Subcategory"("name");

-- CreateIndex
CREATE INDEX "SyncLog_entityType_entityId_idx" ON "SyncLog"("entityType", "entityId");

-- CreateIndex
CREATE INDEX "SyncLog_syncStatus_idx" ON "SyncLog"("syncStatus");

-- CreateIndex
CREATE INDEX "_OrderItemProductModifiers_B_index" ON "_OrderItemProductModifiers"("B");

-- CreateIndex
CREATE INDEX "_ProductPizzaIngredients_B_index" ON "_ProductPizzaIngredients"("B");

-- AddForeignKey
ALTER TABLE "Address" ADD CONSTRAINT "Address_customerId_fkey" FOREIGN KEY ("customerId") REFERENCES "Customer"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductModifier" ADD CONSTRAINT "ProductModifier_groupId_fkey" FOREIGN KEY ("groupId") REFERENCES "ModifierGroup"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ModifierGroup" ADD CONSTRAINT "ModifierGroup_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_customerId_fkey" FOREIGN KEY ("customerId") REFERENCES "Customer"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderDeliveryInfo" ADD CONSTRAINT "OrderDeliveryInfo_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderDeliveryInfo" ADD CONSTRAINT "OrderDeliveryInfo_preOrderId_fkey" FOREIGN KEY ("preOrderId") REFERENCES "PreOrder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_productVariantId_fkey" FOREIGN KEY ("productVariantId") REFERENCES "ProductVariant"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "PreOrder" ADD CONSTRAINT "PreOrder_customerId_fkey" FOREIGN KEY ("customerId") REFERENCES "Customer"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_subcategoryId_fkey" FOREIGN KEY ("subcategoryId") REFERENCES "Subcategory"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductVariant" ADD CONSTRAINT "ProductVariant_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BusinessHours" ADD CONSTRAINT "BusinessHours_restaurantConfigId_fkey" FOREIGN KEY ("restaurantConfigId") REFERENCES "RestaurantConfig"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SelectedPizzaIngredient" ADD CONSTRAINT "SelectedPizzaIngredient_orderItemId_fkey" FOREIGN KEY ("orderItemId") REFERENCES "OrderItem"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SelectedPizzaIngredient" ADD CONSTRAINT "SelectedPizzaIngredient_pizzaIngredientId_fkey" FOREIGN KEY ("pizzaIngredientId") REFERENCES "PizzaIngredient"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Subcategory" ADD CONSTRAINT "Subcategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_OrderItemProductModifiers" ADD CONSTRAINT "_OrderItemProductModifiers_A_fkey" FOREIGN KEY ("A") REFERENCES "OrderItem"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_OrderItemProductModifiers" ADD CONSTRAINT "_OrderItemProductModifiers_B_fkey" FOREIGN KEY ("B") REFERENCES "ProductModifier"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductPizzaIngredients" ADD CONSTRAINT "_ProductPizzaIngredients_A_fkey" FOREIGN KEY ("A") REFERENCES "PizzaIngredient"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductPizzaIngredients" ADD CONSTRAINT "_ProductPizzaIngredients_B_fkey" FOREIGN KEY ("B") REFERENCES "Product"("id") ON DELETE CASCADE ON UPDATE CASCADE;

================
File: backend/prisma/migrations/20250619223940_add_preorder_fields/migration.sql
================
/*
  Warnings:

  - You are about to drop the column `dailyOrderNumber` on the `Order` table. All the data in the column will be lost.
  - You are about to drop the column `finishedAt` on the `Order` table. All the data in the column will be lost.
  - You are about to drop the column `scheduledDeliveryTime` on the `Order` table. All the data in the column will be lost.
  - You are about to drop the column `status` on the `Order` table. All the data in the column will be lost.
  - You are about to drop the column `customerId` on the `PreOrder` table. All the data in the column will be lost.
  - You are about to drop the column `scheduledDeliveryTime` on the `PreOrder` table. All the data in the column will be lost.
  - Added the required column `dailyNumber` to the `Order` table without a default value. This is not possible if the table is not empty.
  - Added the required column `whatsappPhoneNumber` to the `PreOrder` table without a default value. This is not possible if the table is not empty.

*/
-- DropForeignKey
ALTER TABLE "PreOrder" DROP CONSTRAINT "PreOrder_customerId_fkey";

-- AlterTable
ALTER TABLE "Order" DROP COLUMN "dailyOrderNumber",
DROP COLUMN "finishedAt",
DROP COLUMN "scheduledDeliveryTime",
DROP COLUMN "status",
ADD COLUMN     "dailyNumber" INTEGER NOT NULL,
ADD COLUMN     "isFromWhatsApp" BOOLEAN NOT NULL DEFAULT true,
ADD COLUMN     "orderStatus" "OrderStatus" NOT NULL DEFAULT 'PENDING',
ADD COLUMN     "scheduledAt" TIMESTAMP(3);

-- AlterTable
ALTER TABLE "PreOrder" DROP COLUMN "customerId",
DROP COLUMN "scheduledDeliveryTime",
ADD COLUMN     "scheduledAt" TIMESTAMP(3),
ADD COLUMN     "whatsappPhoneNumber" TEXT NOT NULL;

-- CreateIndex
CREATE INDEX "PreOrder_whatsappPhoneNumber_idx" ON "PreOrder"("whatsappPhoneNumber");

================
File: backend/prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

================
File: backend/src/common/types/order.types.ts
================
export interface NewOrder {
  id: number;
  telefono: string;
  informacion_entrega: string;
  precio_total: number;
  fecha_creacion: string;
  horario_entrega_programado: string | null;
  tiempoEstimado: number;
  productos: OrderProduct[];
}

export interface OrderProduct {
  nombre: string;
  cantidad: number;
  precio: number;
  modificadores: { nombre: string; precio: number }[];
  ingredientes_pizza?: { mitad: string; nombre: string }[];
  comments?: string;
}

export interface OrderSummaryResult {
  newOrder: NewOrder;
  orderSummary: string;
}

================
File: backend/src/common/types/otp.types.ts
================
export interface OTPRecord {
  otp: string;
  expiresAt: number;
}

export interface OTPGenerateResponse {
  otp: string;
  expirationTime: number;
}

export interface OTPVerifyRequest {
  customerId: string;
  otp: string;
}

================
File: backend/src/common/types/restaurant.ts
================
/**
 * Tipo para la información del restaurante
 * Usado en predefinedMessages.ts
 */
export interface RestaurantInfo {
  restaurantName: string;
  phoneMain: string;
  phoneSecondary: string;
  address: string;
  city: string;
  state: string;
  postalCode: string;
}

================
File: backend/src/common/utils/messageSplitter.ts
================
/**
 * Utilidad unificada para dividir mensajes largos de WhatsApp
 * Consolida la lógica duplicada de división de mensajes
 */

interface SplitOptions {
  maxLength?: number;
  preserveFormatting?: boolean;
  intelligentSplit?: boolean;
}

const DEFAULT_MAX_LENGTH = 4000; // Límite de WhatsApp con margen de seguridad

export class MessageSplitter {
  /**
   * Dividir un mensaje largo en partes respetando el límite de caracteres
   */
  static split(text: string, options: SplitOptions = {}): string[] {
    const {
      maxLength = DEFAULT_MAX_LENGTH,
      preserveFormatting = true,
      intelligentSplit = true
    } = options;
    
    // Si el mensaje cabe en una parte, devolverlo tal cual
    if (text.length <= maxLength) {
      return [text];
    }
    
    // Usar división inteligente si está habilitada
    if (intelligentSplit) {
      return this.intelligentSplit(text, maxLength, preserveFormatting);
    }
    
    // División simple por longitud
    return this.simpleSplit(text, maxLength);
  }
  
  /**
   * División inteligente que respeta estructura del contenido
   */
  private static intelligentSplit(
    text: string, 
    maxLength: number, 
    preserveFormatting: boolean
  ): string[] {
    const parts: string[] = [];
    const lines = text.split('\n');
    let currentPart = '';
    let currentSection = '';
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Detectar encabezados de sección
      const isSectionHeader = this.isSectionHeader(line);
      
      // Si encontramos un nuevo encabezado y la parte actual + sección excede el límite
      if (isSectionHeader && currentSection && 
          (currentPart.length + currentSection.length > maxLength)) {
        // Guardar la parte actual si tiene contenido
        if (currentPart.trim()) {
          parts.push(currentPart.trim());
        }
        currentPart = currentSection;
        currentSection = line + '\n';
      } else if (currentPart.length + line.length + 1 > maxLength) {
        // Si agregar la línea actual excedería el límite
        
        if (!currentPart.trim() && line.length > maxLength) {
          // Si la línea es muy larga, dividirla por palabras
          const splitLine = this.splitLongLine(line, maxLength);
          parts.push(...splitLine.slice(0, -1));
          currentPart = splitLine[splitLine.length - 1] + '\n';
        } else {
          // Guardar la parte actual y empezar una nueva
          parts.push(currentPart.trim());
          currentPart = currentSection + line + '\n';
          currentSection = '';
        }
      } else {
        // Agregar línea a la sección actual
        currentSection += line + '\n';
      }
    }
    
    // Agregar cualquier contenido restante
    if (currentSection) {
      currentPart += currentSection;
    }
    if (currentPart.trim()) {
      parts.push(currentPart.trim());
    }
    
    // Agregar indicadores de continuación si se preserva el formato
    if (preserveFormatting && parts.length > 1) {
      return this.addContinuationIndicators(parts);
    }
    
    return parts;
  }
  
  /**
   * División simple por longitud máxima
   */
  private static simpleSplit(text: string, maxLength: number): string[] {
    const parts: string[] = [];
    let currentPart = '';
    
    const words = text.split(/\s+/);
    
    for (const word of words) {
      if (currentPart.length + word.length + 1 > maxLength) {
        if (currentPart) {
          parts.push(currentPart.trim());
          currentPart = word;
        } else {
          // La palabra es más larga que el límite, cortarla
          const chunks = this.chunkString(word, maxLength);
          parts.push(...chunks.slice(0, -1));
          currentPart = chunks[chunks.length - 1];
        }
      } else {
        currentPart += (currentPart ? ' ' : '') + word;
      }
    }
    
    if (currentPart) {
      parts.push(currentPart.trim());
    }
    
    return parts;
  }
  
  /**
   * Dividir una línea larga por palabras
   */
  private static splitLongLine(line: string, maxLength: number): string[] {
    const parts: string[] = [];
    const words = line.split(' ');
    let tempLine = '';
    
    for (const word of words) {
      if (tempLine.length + word.length + 1 <= maxLength) {
        tempLine += (tempLine ? ' ' : '') + word;
      } else {
        if (tempLine) parts.push(tempLine);
        
        // Si una sola palabra excede el límite, cortarla
        if (word.length > maxLength) {
          const chunks = this.chunkString(word, maxLength);
          parts.push(...chunks.slice(0, -1));
          tempLine = chunks[chunks.length - 1];
        } else {
          tempLine = word;
        }
      }
    }
    
    if (tempLine) {
      parts.push(tempLine);
    }
    
    return parts;
  }
  
  /**
   * Verificar si una línea es un encabezado de sección
   */
  private static isSectionHeader(line: string): boolean {
    // Patrones comunes de encabezados
    const patterns = [
      /^[🍕🍔🥤🍗🥗🍝🍰🌮🥟🍛📋🛒💰📍👤📅⏰]/,  // Emojis al inicio
      /^[A-Z\s]{3,}:/,                                  // MAYÚSCULAS:
      /^\*\*.*\*\*$/,                                   // **Negrita**
      /^#+\s/,                                          // # Markdown headers
      /^[-=]{3,}$/,                                     // Líneas divisorias
    ];
    
    return patterns.some(pattern => pattern.test(line));
  }
  
  /**
   * Dividir una cadena en chunks de tamaño fijo
   */
  private static chunkString(str: string, size: number): string[] {
    const chunks: string[] = [];
    for (let i = 0; i < str.length; i += size) {
      chunks.push(str.slice(i, i + size));
    }
    return chunks;
  }
  
  /**
   * Agregar indicadores de continuación a las partes
   */
  private static addContinuationIndicators(parts: string[]): string[] {
    return parts.map((part, index) => {
      if (index === 0) {
        return part + '\n\n_(Continúa...)_';
      } else if (index === parts.length - 1) {
        return `_(Continuación ${index + 1}/${parts.length})_\n\n` + part;
      } else {
        return `_(Continuación ${index + 1}/${parts.length})_\n\n` + 
               part + '\n\n_(Continúa...)_';
      }
    });
  }
  
  /**
   * Dividir un menú preservando categorías completas
   */
  static splitMenu(menuText: string, maxLength: number = DEFAULT_MAX_LENGTH): string[] {
    return this.split(menuText, {
      maxLength,
      preserveFormatting: false, // No agregar indicadores de continuación
      intelligentSplit: true
    });
  }
  
  /**
   * Dividir un mensaje de chat normal
   */
  static splitMessage(message: string, maxLength: number = DEFAULT_MAX_LENGTH): string[] {
    return this.split(message, {
      maxLength,
      preserveFormatting: true,
      intelligentSplit: true
    });
  }
}

================
File: backend/src/services/ai/index.ts
================
export * from './GeminiService';
export * from './AgentService';

================
File: backend/src/services/messaging/middlewares/RestaurantHoursMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { RestaurantService } from '../../restaurant/RestaurantService';
import { sendWhatsAppMessage } from '../../whatsapp';
import { RESTAURANT_CLOSED_MESSAGE } from '../../../common/config/predefinedMessages';
import logger from '../../../common/utils/logger';
import { getCurrentMexicoTime } from '../../../common/utils/timeUtils';

export class RestaurantHoursMiddleware implements MessageMiddleware {
  name = 'RestaurantHoursMiddleware';

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      // Get restaurant configuration
      const config = await RestaurantService.getConfig();
      
      // Check if restaurant is accepting orders
      if (!config.acceptingOrders) {
        const closedMessage = await RESTAURANT_CLOSED_MESSAGE();
        await sendWhatsAppMessage(context.message.from, closedMessage);
        context.stop();
        return context;
      }

      // Get current restaurant time
      const currentTime = await getCurrentMexicoTime();
      const dayOfWeek = currentTime.day();
      const currentMinutes = currentTime.hours() * 60 + currentTime.minutes();

      // Get business hours for today
      const businessHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
      
      if (!businessHours || businessHours.isClosed || !businessHours.openingTime || !businessHours.closingTime) {
        logger.info(`Restaurant is closed on day ${dayOfWeek}`);
        const closedMessage = await RESTAURANT_CLOSED_MESSAGE();
        await sendWhatsAppMessage(context.message.from, closedMessage);
        context.stop();
        return context;
      }

      // Parse opening and closing times
      const [openHour, openMinute] = businessHours.openingTime.split(':').map(Number);
      const [closeHour, closeMinute] = businessHours.closingTime.split(':').map(Number);
      
      const openTime = openHour * 60 + openMinute;
      const closeTime = closeHour * 60 + closeMinute;
      
      // Apply grace periods
      const effectiveOpenTime = openTime + (config.openingGracePeriod || 0);
      const effectiveCloseTime = closeTime - (config.closingGracePeriod || 0);

      // Check if current time is within operating hours (with grace periods)
      if (currentMinutes < effectiveOpenTime || currentMinutes > effectiveCloseTime) {
        logger.info(`Restaurant hours check failed: current=${currentMinutes}, open=${effectiveOpenTime}, close=${effectiveCloseTime}`);
        
        // Check if we're in a grace period
        let message: string;
        if (currentMinutes >= openTime && currentMinutes < effectiveOpenTime) {
          // In opening grace period
          const minutesUntilOpen = effectiveOpenTime - currentMinutes;
          message = `⏰ ¡Buenos días! Aunque nuestro restaurante ya abrió, todavía no estamos recibiendo pedidos.

🕐 Comenzaremos a tomar pedidos en ${minutesUntilOpen} minutos.

📍 *Horario de hoy:*
Apertura: ${businessHours.openingTime}
Inicio de pedidos: ${Math.floor(effectiveOpenTime / 60)}:${(effectiveOpenTime % 60).toString().padStart(2, '0')}
Cierre de pedidos: ${Math.floor(effectiveCloseTime / 60)}:${(effectiveCloseTime % 60).toString().padStart(2, '0')}
Cierre: ${businessHours.closingTime}

¡Gracias por tu paciencia! 🙏`;
        } else if (currentMinutes > effectiveCloseTime && currentMinutes <= closeTime) {
          // In closing grace period
          message = `⏰ Lo sentimos, ya no estamos recibiendo nuevos pedidos por hoy.

🕐 Dejamos de tomar pedidos ${config.closingGracePeriod} minutos antes del cierre para garantizar la calidad del servicio.

📍 *Horario de hoy:*
Último pedido: ${Math.floor(effectiveCloseTime / 60)}:${(effectiveCloseTime % 60).toString().padStart(2, '0')}
Cierre: ${businessHours.closingTime}

¡Te esperamos mañana! 😊`;
        } else {
          // Outside business hours completely
          const closedMessage = await RESTAURANT_CLOSED_MESSAGE();
          message = closedMessage;
        }
        
        await sendWhatsAppMessage(context.message.from, message);
        context.stop();
        return context;
      }

      // Restaurant is open, continue processing
      return context;
    } catch (error) {
      logger.error('Error in RestaurantHoursMiddleware:', error);
      // In case of error, allow message to continue (fail open)
      return context;
    }
  }
}

================
File: backend/src/services/messaging/strategies/AudioMessageStrategy.ts
================
import { MessageStrategy } from './MessageStrategy';
import { MessageContext } from '../MessageContext';
import { GeminiService } from '../../ai';
import { sendWhatsAppMessage, getWhatsAppMediaUrl } from '../../whatsapp';
import { AUDIO_TRANSCRIPTION_ERROR } from '../../../common/config/predefinedMessages';
import logger from '../../../common/utils/logger';
import { env } from '../../../common/config/envValidator';
import axios from 'axios';
import { ValidationError, ErrorCode } from '../../../common/services/errors';

export class AudioMessageStrategy extends MessageStrategy {
  name = 'AudioMessageStrategy';
  
  canHandle(context: MessageContext): boolean {
    return context.message.type === 'audio';
  }
  
  async execute(context: MessageContext): Promise<void> {
    if (!context.message.audio) return;
    
    try {
      logger.info(`Processing audio message from ${context.message.from}`);
      
      // Notificar al usuario que estamos procesando
      await sendWhatsAppMessage(
        context.message.from,
        "🎤 Recibí tu mensaje de voz. Dame un momento mientras lo proceso..."
      );
      
      // Obtener URL del audio
      const audioUrl = await getWhatsAppMediaUrl(context.message.audio.id);
      if (!audioUrl) {
        throw new ValidationError(
          ErrorCode.WHATSAPP_API_ERROR,
          'Could not get audio URL',
          { metadata: { audioId: context.message.audio.id } }
        );
      }
      
      // Descargar audio
      const audioResponse = await axios.get(audioUrl, {
        responseType: 'arraybuffer',
        headers: {
          'Authorization': `Bearer ${env.WHATSAPP_ACCESS_TOKEN}`
        },
        timeout: 30000
      });
      
      // Determinar tipo MIME
      const mimeType = context.message.audio.mime_type || 'audio/ogg';
      const validMimeTypes = ['audio/ogg', 'audio/mpeg', 'audio/mp4', 'audio/wav'];
      
      if (!validMimeTypes.includes(mimeType)) {
        throw new ValidationError(
          ErrorCode.TRANSCRIPTION_ERROR,
          `Unsupported audio format: ${mimeType}`,
          { metadata: { mimeType, validMimeTypes } }
        );
      }
      
      // Convertir a base64
      const audioBase64 = Buffer.from(audioResponse.data).toString('base64');
      
      // Transcribir con el servicio centralizado de Gemini
      const transcription = await GeminiService.transcribeAudio(audioBase64, mimeType);
      
      logger.info(`Audio transcribed successfully: "${transcription}"`);
      
      // Notificar al usuario de la transcripción
      await sendWhatsAppMessage(
        context.message.from,
        `🎤 Entendí: "${transcription}"\n\nProcesando tu mensaje...`
      );
      
      // Convertir a mensaje de texto y procesar
      context.message.type = 'text';
      context.message.text = { body: transcription };
      
      // Dejar que la estrategia de mensajes de texto lo maneje
      // Esto se hará cuando el pipeline continúe al siguiente middleware
      
    } catch (error) {
      logger.error('Error processing audio message:', error);
      await sendWhatsAppMessage(context.message.from, AUDIO_TRANSCRIPTION_ERROR);
      context.stop();
    }
  }
}

================
File: backend/src/services/messaging/strategies/InteractiveMessageStrategy.ts
================
import { MessageStrategy } from './MessageStrategy';
import { MessageContext } from '../MessageContext';
import { handleInteractiveMessage } from '../../../whatsapp/handlers/interactiveMessageHandler';
import logger from '../../../common/utils/logger';

export class InteractiveMessageStrategy extends MessageStrategy {
  name = 'InteractiveMessageStrategy';
  
  canHandle(context: MessageContext): boolean {
    return context.message.type === 'interactive';
  }
  
  async execute(context: MessageContext): Promise<void> {
    try {
      // Delegar al manejador de mensajes interactivos existente
      await handleInteractiveMessage(context.message.from, context.message);
      
      // Detener procesamiento adicional ya que los mensajes interactivos se manejan completamente
      context.stop();
    } catch (error) {
      logger.error('Error handling interactive message:', error);
      // El manejo de errores ya se hace en handleInteractiveMessage
      context.stop();
    }
  }
}

================
File: backend/src/services/messaging/strategies/MessageStrategy.ts
================
import { MessageContext } from '../MessageContext';
import { MessageResponse } from '../types';

export abstract class MessageStrategy {
  abstract name: string;
  
  abstract canHandle(context: MessageContext): boolean;
  
  abstract execute(context: MessageContext): Promise<void>;
  
  protected addResponse(context: MessageContext, response: MessageResponse): void {
    context.addResponse(response);
  }
}

================
File: backend/src/services/messaging/index.ts
================
export * from './types';
export { MessageContext } from './MessageContext';
export * from './pipeline/MessagePipeline';
export * from './MessageProcessor';

// Export middlewares
export * from './middlewares/RateLimitMiddleware';
export * from './middlewares/CustomerValidationMiddleware';
export * from './middlewares/MessageTypeMiddleware';

================
File: backend/src/services/messaging/MessageContext.ts
================
import { IncomingMessage, MessageResponse } from './types';
import { Customer } from '../../common/types';

export class MessageContext {
  public message: IncomingMessage;
  public customer?: Customer;
  public chatHistory: any[] = [];
  public responses: MessageResponse[] = [];
  public metadata: Map<string, any> = new Map();
  public shouldStop: boolean = false;
  public error?: Error;

  constructor(message: IncomingMessage) {
    this.message = message;
  }

  addResponse(response: MessageResponse) {
    this.responses.push(response);
  }

  setCustomer(customer: Customer) {
    this.customer = customer;
  }

  setChatHistory(history: any[]) {
    this.chatHistory = history;
  }

  stop() {
    this.shouldStop = true;
  }

  setError(error: Error) {
    this.error = error;
    this.stop();
  }

  get(key: string): any {
    return this.metadata.get(key);
  }

  set(key: string, value: any): void {
    this.metadata.set(key, value);
  }
}

================
File: backend/src/services/messaging/MessageProcessor.ts
================
import { MessagePipeline } from './pipeline/MessagePipeline';
import { IncomingMessage } from './types';
import logger from '../../common/utils/logger';

// Esta clase proporciona una interfaz simple para procesar mensajes de WhatsApp
// a través de nuestro pipeline de procesamiento de mensajes

export class MessageProcessor {
  private static pipeline: MessagePipeline | null = null;
  
  static getPipeline(): MessagePipeline {
    if (!this.pipeline) {
      this.pipeline = new MessagePipeline();
    }
    return this.pipeline;
  }
  
  // Este método procesa los mensajes entrantes a través del pipeline
  static async processWithPipeline(message: any): Promise<void> {
    try {
      // Convertir el formato del mensaje al formato del pipeline
      const incomingMessage: IncomingMessage = {
        id: message.id,
        from: message.from,
        type: message.type,
        timestamp: message.timestamp,
        text: message.text,
        interactive: message.interactive,
        audio: message.audio
      };
      
      // Procesar con el pipeline
      await this.getPipeline().process(incomingMessage);
    } catch (error) {
      logger.error('Error in MessageProcessor:', error);
      throw error; // Dejar que el llamador maneje el error
    }
  }
}

================
File: backend/src/services/messaging/README.md
================
# Pipeline de Procesamiento de Mensajes

Este sistema de pipeline permite un procesamiento de mensajes modular y mantenible para el bot de WhatsApp.

## Arquitectura

### Pipeline Principal
- `MessagePipeline`: Orquesta el flujo de procesamiento de mensajes
- `MessageContext`: Contiene toda la información del mensaje y su procesamiento
- `MessageProcessor`: Interfaz principal para procesar mensajes de WhatsApp

### Middlewares
Los middlewares se ejecutan en orden y cada uno puede:
- Modificar el contexto
- Detener el procesamiento (`context.stop()`)
- Agregar respuestas
- Manejar errores

#### Middlewares Actuales:
1. **RateLimitMiddleware**: Controla el límite de mensajes por usuario
2. **CustomerValidationMiddleware**: Valida y carga información del cliente
3. **MessageTypeMiddleware**: Maneja diferentes tipos de mensajes y mensajes de bienvenida

## Uso

### Flujo de Procesamiento

1. **Webhook de WhatsApp** → `messageProcessor.ts`
2. **MessageProcessor** convierte el mensaje al formato del pipeline
3. **Pipeline** ejecuta los middlewares en orden:
   - Crea un `MessageContext`
   - Ejecuta cada middleware
   - Procesa el mensaje según su tipo
   - Envía respuestas
   - Actualiza el historial del chat

### Agregar Nuevos Middlewares

```typescript
// Crear el middleware
export class MyMiddleware implements MessageMiddleware {
  name = 'MyMiddleware';
  
  async process(context: MessageContext): Promise<MessageContext> {
    // Tu lógica aquí
    return context;
  }
}

// Agregarlo al pipeline
pipeline.addMiddleware(new MyMiddleware());
```

## Estructura de Estrategias

### Estrategias de Procesamiento
- **TextMessageStrategy**: Procesa mensajes de texto con AI
- **InteractiveMessageStrategy**: Maneja botones y listas interactivas
- **AudioMessageStrategy**: Transcribe audio a texto usando Gemini

### Extensibilidad
Para agregar soporte a nuevos tipos de mensajes, simplemente crea una nueva estrategia que extienda `MessageStrategy`.

## Ventajas del Sistema

1. **Modularidad**: Cada responsabilidad en su propio middleware
2. **Testabilidad**: Fácil testear cada componente por separado
3. **Mantenibilidad**: Código más limpio y organizado
4. **Extensibilidad**: Fácil agregar nuevas funcionalidades
5. **Escalabilidad**: Diseñado para crecer con nuevos requerimientos

## Debugging

El pipeline incluye logs detallados:
```
DEBUG: Running middleware: RateLimitMiddleware
DEBUG: Running middleware: CustomerValidationMiddleware
DEBUG: Pipeline stopped by middleware: RateLimitMiddleware
```

Esto facilita identificar dónde ocurren problemas.

================
File: frontend-app/public/delivery-address.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" fill="none">
  <!-- Background circle with gradient -->
  <defs>
    <linearGradient id="bgGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#f97316;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#ec4899;stop-opacity:1" />
    </linearGradient>
  </defs>
  <circle cx="16" cy="16" r="15" fill="url(#bgGradient)" stroke="#ea580c" stroke-width="2"/>
  
  <!-- Location pin -->
  <path d="M16 6c-4 0-7.5 3.5-7.5 7.5c0 5.25 7.5 13 7.5 13s7.5-7.75 7.5-13c0-4-3.5-7.5-7.5-7.5z" fill="white" opacity="0.95"/>
  
  <!-- Inner circle -->
  <circle cx="16" cy="13.5" r="3" fill="#f97316"/>
  
  <!-- House icon inside pin -->
  <path d="M16 11.5l-2 1.5v2.5h1.5v-1.5h1v1.5h1.5v-2.5l-2-1.5z" fill="white"/>
  <path d="M14.5 11l1.5-1l1.5 1" fill="none" stroke="white" stroke-width="0.5"/>
</svg>

================
File: frontend-app/public/restaurant.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" fill="none">
  <!-- Background circle -->
  <circle cx="16" cy="16" r="15" fill="#dc2626" stroke="#7f1d1d" stroke-width="2"/>
  
  <!-- Flame icon for "La Leña" (The Firewood) -->
  <path d="M16 8c-1.5 2-3 3-3 5.5c0 1.5.5 2.5 1.5 3.5c-.5-1.5 0-2.5 1-3.5c.5 1 1 1.5 1.5 2.5c.5-1 1.5-2 1.5-3.5c0-2.5-1.5-3.5-3-4.5z" fill="#fbbf24"/>
  <path d="M13 14c0 3.5 2 6 3 6s3-2.5 3-6c0-.5-.1-1-.2-1.5c-.3 1-.8 1.5-1.3 1.5c-.5-1-1-1.5-1.5-2c-.5.5-1 1-1.5 2c-.5 0-1-.5-1.3-1.5c-.1.5-.2 1-.2 1.5z" fill="#f59e0b"/>
  
  <!-- Grill lines -->
  <rect x="11" y="21" width="10" height="1" rx="0.5" fill="white"/>
  <rect x="11" y="23" width="10" height="1" rx="0.5" fill="white"/>
</svg>

================
File: frontend-app/src/components/AddressForm/index.ts
================
export { AddressForm } from './AddressForm';

================
File: frontend-app/src/components/AddressManager/AddressManager2.tsx
================
import { useState } from 'react';
import toast from 'react-hot-toast';
import customerService from '@/services/customer.service';

interface Address {
  id: number;
  street: string;
  number: string;
  interiorNumber?: string | null;
  neighborhood?: string | null;
  city?: string | null;
  state?: string | null;
  references?: string | null;
  isDefault: boolean;
}

interface AddressManagerProps {
  addresses: Address[];
  customerId: string;
  otp: string;
  onAddressClick: (address: Address) => void;
  onAddNew: () => void;
  onAddressesChange: () => void;
}

export function AddressManager2({
  addresses,
  customerId,
  otp,
  onAddressClick,
  onAddNew,
  onAddressesChange,
}: AddressManagerProps) {
  const [isDeleting, setIsDeleting] = useState<string | null>(null);
  const [isSettingDefault, setIsSettingDefault] = useState<string | null>(null);

  const handleDelete = async (e: React.MouseEvent, addressId: number) => {
    e.stopPropagation();
    
    if (!confirm('¿Estás seguro de que deseas eliminar esta dirección?')) {
      return;
    }

    setIsDeleting(addressId.toString());
    
    try {
      await customerService.deleteAddress(addressId, customerId, otp);
      toast.success('Dirección eliminada exitosamente');
      onAddressesChange();
    } catch (error: any) {
      console.error('Error deleting address:', error);
      toast.error(error.response?.data?.error || 'Error al eliminar la dirección');
    } finally {
      setIsDeleting(null);
    }
  };

  const handleSetDefault = async (e: React.MouseEvent, addressId: number) => {
    e.stopPropagation();
    
    setIsSettingDefault(addressId.toString());
    
    try {
      await customerService.setDefaultAddress(addressId, customerId, otp);
      toast.success('Dirección principal actualizada');
      onAddressesChange();
    } catch (error: any) {
      console.error('Error setting default address:', error);
      toast.error(error.response?.data?.error || 'Error al establecer dirección principal');
    } finally {
      setIsSettingDefault(null);
    }
  };

  if (addresses.length === 0) {
    return (
      <div className="text-center py-8 bg-gray-50 rounded-lg">
        <svg className="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
        </svg>
        <p className="text-gray-600 mb-4">No tienes direcciones guardadas</p>
        <button
          onClick={onAddNew}
          className="bg-gradient-to-r from-orange-500 to-pink-600 text-white font-semibold px-6 py-3 rounded-lg hover:from-orange-600 hover:to-pink-700 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:scale-105"
        >
          <svg className="w-5 h-5 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
          </svg>
          Agregar mi primera dirección
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center mb-6">
        <h3 className="text-lg font-semibold text-gray-800">📍 Mis direcciones</h3>
        <button
          onClick={onAddNew}
          className="bg-gradient-to-r from-orange-500 to-pink-600 text-white font-semibold px-4 py-2 rounded-lg hover:from-orange-600 hover:to-pink-700 transition-all duration-200 shadow-md hover:shadow-lg flex items-center text-sm transform hover:scale-105"
        >
          <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
          </svg>
          Agregar nueva dirección
        </button>
      </div>

      <div className="space-y-3">
        {addresses.map((address) => (
          <div
            key={address.id}
            className="bg-white border-2 border-gray-200 rounded-lg p-4 hover:border-blue-400 hover:shadow-md transition-all cursor-pointer"
            onClick={() => onAddressClick(address)}
          >
            <div className="flex justify-between items-start">
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-2 mb-1">
                  <h4 className="font-semibold text-gray-800 truncate">
                    {address.street} {address.number}
                    {address.interiorNumber && ` Int. ${address.interiorNumber}`}
                  </h4>
                  {address.isDefault && (
                    <span className="text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full font-medium">
                      Principal
                    </span>
                  )}
                </div>
                <p className="text-sm text-gray-600">
                  {address.neighborhood && `${address.neighborhood}, `}
                  {address.city}, {address.state}
                </p>
                {address.references && (
                  <p className="text-xs text-gray-500 mt-1 truncate">
                    Ref: {address.references}
                  </p>
                )}
              </div>
              
              <div className="flex items-center gap-2 ml-4">
                {!address.isDefault && (
                  <button
                    onClick={(e) => handleSetDefault(e, address.id)}
                    disabled={isSettingDefault === address.id.toString()}
                    className="text-gray-500 hover:text-green-600 hover:bg-green-50 transition-all p-3 rounded-lg border-2 border-transparent hover:border-green-200"
                    title="Establecer como principal"
                  >
                    {isSettingDefault === address.id.toString() ? (
                      <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-green-600"></div>
                    ) : (
                      <div className="flex flex-col items-center">
                        <svg className="w-6 h-6 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span className="text-xs font-medium">Principal</span>
                      </div>
                    )}
                  </button>
                )}
                
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    onAddressClick(address);
                  }}
                  className="text-gray-500 hover:text-blue-600 hover:bg-blue-50 transition-all p-3 rounded-lg"
                  title="Editar"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                  </svg>
                </button>
                
                <button
                  onClick={(e) => handleDelete(e, address.id)}
                  disabled={isDeleting === address.id.toString()}
                  className="text-gray-500 hover:text-red-600 hover:bg-red-50 transition-all p-3 rounded-lg"
                  title="Eliminar"
                >
                  {isDeleting === address.id.toString() ? (
                    <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-red-600"></div>
                  ) : (
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                  )}
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

================
File: frontend-app/src/components/AddressManager/index.ts
================
export { AddressManager2 as AddressManager } from './AddressManager2';

================
File: frontend-app/src/components/AddressSelector/AddressSelector.tsx
================
import { useState } from 'react';
import type { Address } from '@/types/customer.types';

interface AddressSelectorProps {
  addresses: Address[];
  selectedAddressId: string | null;
  onAddressSelect: (addressId: string) => void;
  onAddNewAddress?: () => void;
}

export function AddressSelector({
  addresses,
  selectedAddressId,
  onAddressSelect,
  onAddNewAddress,
}: AddressSelectorProps) {
  if (addresses.length === 0) {
    return (
      <div className="text-center py-6 bg-gray-50 rounded-lg">
        <p className="text-gray-600 mb-4">No tienes direcciones guardadas</p>
        {onAddNewAddress && (
          <button
            onClick={onAddNewAddress}
            className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors"
          >
            Agregar dirección
          </button>
        )}
      </div>
    );
  }

  return (
    <div className="space-y-3">
      <h3 className="text-lg font-semibold text-gray-800 mb-4">Selecciona una dirección de entrega</h3>
      
      {addresses.map((address) => (
        <label
          key={address.id}
          className={`block p-4 border-2 rounded-lg cursor-pointer transition-all ${
            selectedAddressId === address.id.toString()
              ? 'border-blue-500 bg-blue-50'
              : 'border-gray-200 hover:border-gray-300'
          }`}
        >
          <div className="flex items-start">
            <input
              type="radio"
              name="address"
              value={address.id}
              checked={selectedAddressId === address.id.toString()}
              onChange={() => onAddressSelect(address.id.toString())}
              className="mt-1 mr-3 text-blue-600 focus:ring-blue-500"
            />
            <div className="flex-1">
              <div className="flex items-center gap-2 mb-1">
                <p className="font-semibold text-gray-800">
                  {address.street} {address.number}
                  {address.interiorNumber && ` Int. ${address.interiorNumber}`}
                </p>
                {address.isDefault && (
                  <span className="text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full font-medium">
                    Principal
                  </span>
                )}
              </div>
              <p className="text-sm text-gray-600">
                {address.neighborhood && `${address.neighborhood}, `}
                {address.city}, {address.state}
              </p>
              {address.references && (
                <p className="text-xs text-gray-500 mt-1">
                  Ref: {address.references}
                </p>
              )}
            </div>
          </div>
        </label>
      ))}
      
      {onAddNewAddress && (
        <button
          onClick={onAddNewAddress}
          className="w-full py-3 border-2 border-dashed border-gray-300 rounded-lg text-gray-600 hover:border-blue-400 hover:text-blue-600 transition-colors flex items-center justify-center"
        >
          <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
          </svg>
          Agregar nueva dirección
        </button>
      )}
    </div>
  );
}

================
File: frontend-app/src/components/AddressSelector/index.ts
================
export { AddressSelector } from './AddressSelector';

================
File: frontend-app/src/components/BasicMap/index.ts
================
export { BasicMap } from './BasicMap';

================
File: frontend-app/src/components/ui/Button.tsx
================
import { forwardRef } from 'react';
import { clsx } from 'clsx';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  isLoading?: boolean;
  fullWidth?: boolean;
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ 
    children, 
    className, 
    variant = 'primary', 
    size = 'md', 
    isLoading = false, 
    fullWidth = false,
    disabled,
    ...props 
  }, ref) => {
    const baseStyles = 'font-semibold rounded-md transition duration-300 inline-flex items-center justify-center';
    
    const variants = {
      primary: 'bg-blue-600 text-white hover:bg-blue-700 disabled:bg-gray-400',
      secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300 disabled:bg-gray-100',
      danger: 'bg-red-600 text-white hover:bg-red-700 disabled:bg-gray-400',
    };

    const sizes = {
      sm: 'px-3 py-1.5 text-sm',
      md: 'px-4 py-2 text-base',
      lg: 'px-6 py-3 text-lg',
    };

    return (
      <button
        ref={ref}
        className={clsx(
          baseStyles,
          variants[variant],
          sizes[size],
          fullWidth && 'w-full',
          'disabled:cursor-not-allowed',
          className
        )}
        disabled={disabled || isLoading}
        {...props}
      >
        {isLoading && (
          <svg
            className="animate-spin -ml-1 mr-2 h-4 w-4"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            />
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            />
          </svg>
        )}
        {children}
      </button>
    );
  }
);

Button.displayName = 'Button';

================
File: frontend-app/src/components/ui/WhatsAppButton.tsx
================
import { Button } from './Button';

interface WhatsAppButtonProps {
  phoneNumber?: string;
  message?: string;
  className?: string;
  children?: React.ReactNode;
}

export function WhatsAppButton({ 
  phoneNumber = import.meta.env.VITE_BOT_WHATSAPP_NUMBER,
  message = '',
  className = '',
  children = 'Abrir WhatsApp'
}: WhatsAppButtonProps) {
  const handleClick = () => {
    const encodedMessage = encodeURIComponent(message);
    const whatsappUrl = `https://wa.me/${phoneNumber}${message ? `?text=${encodedMessage}` : ''}`;
    window.open(whatsappUrl, '_blank');
  };

  return (
    <Button
      onClick={handleClick}
      className={`bg-green-600 hover:bg-green-700 text-white ${className}`}
    >
      <svg 
        className="w-5 h-5 mr-2" 
        fill="currentColor" 
        viewBox="0 0 24 24"
      >
        <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z"/>
      </svg>
      {children}
    </Button>
  );
}

================
File: frontend-app/src/i18n/index.ts
================
import { translations, type Locale } from './translations';
import { config } from '@/config';

class I18n {
  private locale: Locale;

  constructor() {
    this.locale = (config.regional.locale || 'es-MX') as Locale;
  }

  /**
   * Get translated text
   */
  t(path: string, params?: Record<string, string>): string {
    const keys = path.split('.');
    let value: any = translations[this.locale];

    for (const key of keys) {
      value = value?.[key];
      if (!value) {
        console.warn(`Translation not found for key: ${path}`);
        return path;
      }
    }

    if (typeof value !== 'string') {
      console.warn(`Translation value is not a string for key: ${path}`);
      return path;
    }

    // Replace parameters
    if (params) {
      return value.replace(/{(\w+)}/g, (match, key) => params[key] || match);
    }

    return value;
  }

  /**
   * Change locale
   */
  setLocale(locale: Locale): void {
    if (translations[locale]) {
      this.locale = locale;
    } else {
      console.warn(`Locale ${locale} not found`);
    }
  }

  /**
   * Get current locale
   */
  getLocale(): Locale {
    return this.locale;
  }
}

export const i18n = new I18n();
export const t = i18n.t.bind(i18n);

================
File: frontend-app/src/i18n/translations.ts
================
export const translations = {
  'es-MX': {
    common: {
      loading: 'Cargando...',
      error: 'Error',
      success: 'Éxito',
      save: 'Guardar',
      cancel: 'Cancelar',
      continue: 'Continuar',
      back: 'Atrás',
      close: 'Cerrar',
    },
    otp: {
      verifying: 'Verificando enlace...',
      invalidLink: 'Enlace inválido',
      expiredLink: 'Este enlace ha expirado o no es válido. Por favor, solicita un nuevo enlace desde WhatsApp.',
      continueWhatsApp: 'Continuar en WhatsApp',
    },
    address: {
      title: 'Registrar Dirección de Entrega',
      updateTitle: 'Actualizar Dirección',
      welcome: '¡Hola{name}! Por favor completa tu información de entrega.',
      yourNumber: 'Tu número: {number}',
      useMyLocation: 'Usar mi ubicación actual',
      searchPlaceholder: 'Busca tu dirección en México...',
      mapError: 'Error al cargar el mapa. Por favor, recarga la página.',
      locationError: 'No se pudo obtener tu ubicación',
      addressDetails: 'Detalles de la dirección',
      
      // Form fields
      street: 'Calle y número',
      neighborhood: 'Colonia',
      zipCode: 'Código postal',
      city: 'Ciudad',
      state: 'Estado',
      country: 'País',
      references: 'Referencias para encontrar tu domicilio',
      referencesPlaceholder: 'Entre calles, color de casa, puntos de referencia...',
      
      // Messages
      selectLocation: 'Por favor, selecciona una ubicación en el mapa',
      completeFields: 'Por favor completa todos los campos requeridos',
      outOfDeliveryArea: 'La dirección está fuera del área de entrega',
      savingAddress: 'Guardando dirección...',
      updatingAddress: 'Actualizando dirección...',
      addressSaved: 'Dirección guardada exitosamente',
      addressUpdated: 'Dirección actualizada exitosamente',
      redirecting: 'Redirigiendo a WhatsApp...',
      errorSaving: 'Error al guardar la dirección',
      errorUpdating: 'Error al actualizar la dirección',
    },
    geolocation: {
      notSupported: 'Tu navegador no soporta geolocalización',
      permissionDenied: 'Permiso de ubicación denegado',
      positionUnavailable: 'Ubicación no disponible',
      timeout: 'Tiempo de espera agotado',
      unknownError: 'Error desconocido al obtener ubicación',
    },
  },
  'en-US': {
    common: {
      loading: 'Loading...',
      error: 'Error',
      success: 'Success',
      save: 'Save',
      cancel: 'Cancel',
      continue: 'Continue',
      back: 'Back',
      close: 'Close',
    },
    otp: {
      verifying: 'Verifying link...',
      invalidLink: 'Invalid link',
      expiredLink: 'This link has expired or is invalid. Please request a new link from WhatsApp.',
      continueWhatsApp: 'Continue on WhatsApp',
    },
    address: {
      title: 'Register Delivery Address',
      updateTitle: 'Update Address',
      welcome: 'Hello{name}! Please complete your delivery information.',
      yourNumber: 'Your number: {number}',
      useMyLocation: 'Use my current location',
      searchPlaceholder: 'Search for your address...',
      mapError: 'Error loading map. Please reload the page.',
      locationError: 'Could not get your location',
      addressDetails: 'Address details',
      
      // Form fields
      street: 'Street and number',
      neighborhood: 'Neighborhood',
      zipCode: 'ZIP code',
      city: 'City',
      state: 'State',
      country: 'Country',
      references: 'References to find your address',
      referencesPlaceholder: 'Between streets, house color, landmarks...',
      
      // Messages
      selectLocation: 'Please select a location on the map',
      completeFields: 'Please complete all required fields',
      outOfDeliveryArea: 'Address is outside delivery area',
      savingAddress: 'Saving address...',
      updatingAddress: 'Updating address...',
      addressSaved: 'Address saved successfully',
      addressUpdated: 'Address updated successfully',
      redirecting: 'Redirecting to WhatsApp...',
      errorSaving: 'Error saving address',
      errorUpdating: 'Error updating address',
    },
    geolocation: {
      notSupported: 'Your browser does not support geolocation',
      permissionDenied: 'Location permission denied',
      positionUnavailable: 'Location unavailable',
      timeout: 'Request timeout',
      unknownError: 'Unknown error getting location',
    },
  },
};

export type TranslationKey = keyof typeof translations['es-MX'];
export type Locale = keyof typeof translations;

================
File: frontend-app/src/styles/toast-animations.css
================
/* Custom toast animations */
@keyframes toast-enter {
  0% {
    transform: translateY(-100px) scale(0.8);
    opacity: 0;
  }
  100% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
}

@keyframes toast-exit {
  0% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translateY(-20px) scale(0.9);
    opacity: 0;
  }
}

/* Apply animations to react-hot-toast */
[data-hot-toast] {
  animation: toast-enter 0.35s cubic-bezier(0.21, 1.02, 0.73, 1) forwards;
}

[data-hot-toast][data-visible="false"] {
  animation: toast-exit 0.4s forwards;
}

/* Add a subtle pulse effect for success toasts */
[data-hot-toast][data-type="success"] {
  animation: toast-enter 0.35s cubic-bezier(0.21, 1.02, 0.73, 1) forwards, pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.02);
  }
}

/* Bounce effect for error toasts */
[data-hot-toast][data-type="error"] {
  animation: toast-enter 0.35s cubic-bezier(0.21, 1.02, 0.73, 1) forwards, shake 0.5s ease-in-out;
}

@keyframes shake {
  0%, 100% {
    transform: translateX(0);
  }
  10%, 30%, 50%, 70%, 90% {
    transform: translateX(-2px);
  }
  20%, 40%, 60%, 80% {
    transform: translateX(2px);
  }
}

/* Loading toast animation */
[data-hot-toast][data-type="loading"] svg {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

================
File: frontend-app/src/types/api.types.ts
================
export interface ApiResponse<T> {
  data: T;
  success?: boolean;
  message?: string;
  error?: string;
}

export interface ApiError {
  message: string;
  statusCode: number;
  error?: any;
}

================
File: frontend-app/src/utils/loadGoogleMaps.ts
================
let isLoading = false;
let isLoaded = false;

export const loadGoogleMaps = (): Promise<void> => {
  return new Promise((resolve, reject) => {
    console.log('loadGoogleMaps called');
    console.log('API Key:', import.meta.env.VITE_GOOGLE_MAPS_API_KEY);
    
    // If already loaded, resolve immediately
    if (isLoaded && window.google && window.google.maps) {
      console.log('Google Maps already loaded');
      resolve();
      return;
    }

    // If already loading, wait for it
    if (isLoading) {
      const checkInterval = setInterval(() => {
        if (isLoaded && window.google && window.google.maps) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
      return;
    }

    isLoading = true;

    // Check if script already exists
    const existingScript = document.querySelector('script[src*="maps.googleapis.com"]');
    if (existingScript) {
      existingScript.addEventListener('load', () => {
        isLoaded = true;
        isLoading = false;
        resolve();
      });
      return;
    }

    // Create and load script
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${import.meta.env.VITE_GOOGLE_MAPS_API_KEY}&libraries=places`;
    script.async = true;
    script.defer = true;

    script.onload = () => {
      isLoaded = true;
      isLoading = false;
      resolve();
    };

    script.onerror = (error) => {
      console.error('Failed to load Google Maps script:', error);
      isLoading = false;
      reject(new Error('Failed to load Google Maps - Check API key and enabled APIs'));
    };
    
    // Add global callback to check for auth errors
    (window as any).gm_authFailure = () => {
      console.error('Google Maps authentication failed - Check API key permissions');
      reject(new Error('Google Maps authentication failed'));
    };

    document.head.appendChild(script);
  });
};

================
File: frontend-app/src/utils/polygonUtils.ts
================
/**
 * Check if a point is inside a polygon using the ray casting algorithm
 * @param point The point to check
 * @param polygon The polygon vertices
 * @returns true if the point is inside the polygon
 */
export function isPointInPolygon(
  point: { lat: number; lng: number },
  polygon: { lat: number; lng: number }[]
): boolean {
  if (polygon.length < 3) return false;

  let inside = false;
  const x = point.lat;
  const y = point.lng;

  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].lat;
    const yi = polygon[i].lng;
    const xj = polygon[j].lat;
    const yj = polygon[j].lng;

    const intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    
    if (intersect) inside = !inside;
  }

  return inside;
}

/**
 * Get the center point of a polygon
 * @param polygon The polygon vertices
 * @returns The center point
 */
export function getPolygonCenter(polygon: { lat: number; lng: number }[]): { lat: number; lng: number } {
  if (polygon.length === 0) {
    return { lat: 0, lng: 0 };
  }

  let totalLat = 0;
  let totalLng = 0;

  polygon.forEach(point => {
    totalLat += point.lat;
    totalLng += point.lng;
  });

  return {
    lat: totalLat / polygon.length,
    lng: totalLng / polygon.length
  };
}

================
File: frontend-app/src/app.css
================
@import "tailwindcss";

/* Custom styles if needed */

================
File: frontend-app/src/Router.tsx
================
import { Routes, Route } from 'react-router-dom';
import AddressRegistration from './AddressRegistration';

function Router() {
  return (
    <Routes>
      <Route path="/" element={<div>Welcome</div>} />
      <Route path="/address-registration/:customerId" element={<AddressRegistration />} />
    </Routes>
  );
}

export default Router;

================
File: frontend-app/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: frontend-app/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Environment variables
.env
.env.local
.env.production

================
File: frontend-app/eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: frontend-app/README.md
================
# Frontend - Formulario de Dirección de Entrega

Aplicación frontend construida con Vite + React + TypeScript para el registro de direcciones de entrega.

## 🚀 Tecnologías

- **Vite** - Build tool ultra-rápido
- **React 18** - Biblioteca UI
- **TypeScript** - Type safety
- **Tailwind CSS** - Estilos utility-first
- **React Hook Form + Yup** - Manejo de formularios y validación
- **React Google Maps** - Integración con Google Maps
- **Axios** - Cliente HTTP
- **React Hot Toast** - Notificaciones

## 📦 Instalación

```bash
npm install
```

## 🔧 Configuración

1. Copia el archivo `.env.example` a `.env`:
```bash
cp .env.example .env
```

2. Configura las variables de entorno:
```env
VITE_API_URL=http://localhost:3001
VITE_GOOGLE_MAPS_API_KEY=tu-api-key
VITE_BOT_WHATSAPP_NUMBER=521234567890
VITE_POLYGON_COORDS='[{"lat": 20.54, "lng": -102.79}]'
```

## 🛠️ Scripts

```bash
# Desarrollo
npm run dev

# Build para producción
npm run build

# Preview de producción
npm run preview

# Type checking
npm run type-check

# Linting
npm run lint
```

## 📁 Estructura

```
src/
├── components/       # Componentes React
│   ├── AddressForm/  # Formulario de dirección
│   ├── Map/          # Componente de mapa
│   └── ui/           # Componentes UI reutilizables
├── services/         # Servicios API
├── types/            # Tipos TypeScript
├── hooks/            # Custom hooks
└── utils/            # Utilidades
```

## 🌐 Características

- ✅ Formulario de dirección con validación
- ✅ Integración con Google Maps
- ✅ Autocompletado de direcciones
- ✅ Geolocalización
- ✅ Validación de área de entrega
- ✅ Soporte para actualización de direcciones
- ✅ Notificaciones via WhatsApp
- ✅ Diseño responsive

## 🔗 URLs

La aplicación espera los siguientes parámetros en la URL:
- `from`: ID del cliente
- `otp`: Token de verificación
- `preOrderId`: (opcional) ID de preorden para actualizar

Ejemplo:
```
http://localhost:3000/?from=521234567890@c.us&otp=123456
```

## 🚀 Despliegue

1. Build de producción:
```bash
npm run build
```

2. Los archivos de producción estarán en `dist/`

3. Puedes servir los archivos estáticos con cualquier servidor web (Nginx, Apache, etc.)

================
File: frontend-app/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: frontend-app/tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    
    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"]
}

================
File: frontend-app/tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: frontend-app/tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: .gitignore
================
node_modules
.next/
.package-lock.json.swp
package.json.save
.env
.env.local
backend/dist/

================
File: docker-compose.yml
================
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: bot_db
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:

================
File: package.json
================
{
  "name": "bot_app",
  "version": "1.0.0",
  "scripts": {
    "dev": "concurrently \"npm run dev:backend\" \"npm run dev:frontend\"",
    "dev:backend": "cd backend && npm run dev",
    "dev:frontend": "cd frontend-app && npm run dev",
    "build": "cd backend && npm run build && cd ../frontend-app && npm run build",
    "start": "npm run build && concurrently \"npm run start:backend\" \"npm run start:frontend\"",
    "start:backend": "cd backend && npm start",
    "start:frontend": "cd frontend-app && npm run dev",
    "install:all": "npm install && npm --prefix backend install && npm --prefix frontend-app install"
  },
  "devDependencies": {
    "concurrently": "^7.0.0"
  },
  "dependencies": {
    "winston": "^3.15.0"
  }
}

================
File: backend/src/common/services/errors/CustomErrors.ts
================
import { ErrorCode, ErrorType, ErrorContext } from './types';

export class BaseError extends Error {
  constructor(
    public code: ErrorCode,
    public type: ErrorType,
    message: string,
    public context?: ErrorContext
  ) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
}

export class BusinessLogicError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.BUSINESS_LOGIC, message, context);
    this.name = 'BusinessLogicError';
  }
}

export class ValidationError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.VALIDATION, message, context);
    this.name = 'ValidationError';
  }
}

export class TechnicalError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.TECHNICAL, message, context);
    this.name = 'TechnicalError';
  }
}

export class ExternalServiceError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.EXTERNAL_SERVICE, message, context);
    this.name = 'ExternalServiceError';
  }
}

export class NotFoundError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.BUSINESS_LOGIC, message, context);
    this.name = 'NotFoundError';
  }
}

export class RateLimitError extends BaseError {
  constructor(message: string, context?: ErrorContext) {
    super(ErrorCode.RATE_LIMIT_EXCEEDED, ErrorType.RATE_LIMIT, message, context);
    this.name = 'RateLimitError';
  }
}

================
File: backend/src/common/types/menu.ts
================
export interface ProductoInfo {
  productId: string;
  name: string;
  productVariants?: Array<{
    productVariantId: string;
    name: string;
  }>;
  modifierGroups?: Array<{
    modifierGroupId: string;
    name: string;
    minSelections: number;
    maxSelections: number;
    isRequired: boolean;
    allowMultipleSelections: boolean;
    productModifiers?: Array<{
      productModifierId: string;
      name: string;
    }>;
  }>;
  pizzaIngredients?: Array<{
    pizzaIngredientId: string;
    name: string;
  }>;
}

================
File: backend/src/common/types/webhook.types.ts
================
// Interfaz para mensajes entrantes de WhatsApp (desde webhook)
export interface IncomingWhatsAppMessage {
    from: string;
    type: string;
    id: string;
    text?: { body: string };
    timestamp: string;
    interactive?: {
      type: string;
      button_reply?: {
        id: string;
        title: string;
      };
      list_reply?: {
        id: string;
        title: string;
        description?: string;
      };
    };
    audio?: {
      id: string;
      mime_type: string;
    };
  }
  
  export interface WebhookEntry {
    changes: Array<{
      value: {
        messages?: IncomingWhatsAppMessage[];
        messaging_product?: string;
        metadata?: {
          display_phone_number: string;
          phone_number_id: string;
        };
      };
    }>;
  }
  
  export interface WebhookBody {
    object: string;
    entry: WebhookEntry[];
  }

================
File: backend/src/common/types/whatsapp.types.ts
================
// Interfaz para mensajes salientes de WhatsApp
export interface OutgoingWhatsAppMessage {
  messaging_product: string;
  to: string;
  type: string;
  text: { body: string };
}

// Interfaz para el contenido interactivo
export interface WhatsAppInteractiveContent {
  header?: {
    type: string;
    text?: string;
    image?: {
      link: string;
    };
  };
  body: {
    text: string;
  };
  footer?: {
    text: string;
  };
  action: {
    button?: string;
    buttons?: Array<{
      type: string;
      reply: {
        id: string;
        title: string;
      };
    }>;
    sections?: Array<{
      title?: string;
      rows: Array<{
        id: string;
        title: string;
        description?: string;
      }>;
    }>;
  };
}

// Interfaz para mensajes interactivos salientes
export interface OutgoingWhatsAppInteractiveMessage {
  messaging_product: string;
  recipient_type: string;
  to: string;
  type: string;
  interactive: WhatsAppInteractiveContent;
}

// Interfaz para la respuesta de la API
export interface WhatsAppApiResponse {
  messages: [{
    id: string;
  }];
}

================
File: backend/src/common/utils/textUtils.ts
================
/**
 * Utilidades de procesamiento de texto
 * Extraídas del antiguo messageProcessUtils.ts
 */

export const SIMILARITY_THRESHOLDS = {
  PRODUCT_NAME: 0.8,
  VARIANT_NAME: 0.85,
  MODIFIER_NAME: 0.85,
  PIZZA_INGREDIENT_NAME: 0.85,
  WORD: 0.7,
  PRODUCT: 0.8,
  VARIANT: 0.85,
  MODIFIER: 0.85,
  INGREDIENT: 0.85,
};

export function normalizeText(text: string): string[] {
  const normalized = text
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9\s]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  const wordsToFilter = [
    "pizza", "con", "de", "y", "la", "el", "los", "las", "un", "una",
    "para", "por", "sin", "mas", "menos", "extra", "doble", "triple",
    "grande", "mediana", "chica", "pequeña", "familiar", "personal"
  ];

  const words = normalized.split(/\s+/);
  const filteredWords = words
    .filter((word) => !wordsToFilter.includes(word))
    .map((word) => mapSynonym(word) || word);

  return filteredWords;
}

export function normalizeTextForIngredients(text: string): string[] {
  const normalized = text
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z\s]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  const words = normalized.split(/\s+/);
  const filteredWords = words.map((word) => mapSynonym(word) || word);

  return filteredWords;
}

export function generateNGrams(words: string[], maxN: number): string[] {
  const ngrams = [];
  const len = words.length;
  for (let n = 1; n <= maxN; n++) {
    for (let i = 0; i <= len - n; i++) {
      ngrams.push(words.slice(i, i + n).join(" "));
    }
  }
  return ngrams;
}

function mapSynonym(word: string): string | null {
  const synonymMap: { [key: string]: string } = {
    // Sinónimos generales
    "chica": "pequeña",
    "grande": "grande",
    "mediana": "mediana",
    
    // Ingredientes
    "champinones": "champiñones",
    "champinon": "champiñones",
    "hongos": "champiñones",
    "setas": "champiñones",
    
    "pina": "piña",
    "anana": "piña",
    
    "pepperoni": "pepperoni",
    "peperoni": "pepperoni",
    "salami": "pepperoni",
    
    "queso": "queso",
    "mozzarella": "queso",
    "mozarela": "queso",
    
    "jamon": "jamón",
    "ham": "jamón",
    
    "tocino": "tocino",
    "bacon": "tocino",
    "panceta": "tocino",
    
    "salchicha": "salchicha",
    "chorizo": "salchicha",
    
    "pimiento": "pimiento",
    "morron": "pimiento",
    "bell pepper": "pimiento",
    
    "cebolla": "cebolla",
    "onion": "cebolla",
    
    "aceitunas": "aceitunas",
    "olivas": "aceitunas",
    
    "tomate": "tomate",
    "jitomate": "tomate",
    
    // Bebidas
    "coca": "coca cola",
    "cocacola": "coca cola",
    "coke": "coca cola",
    
    "sprite": "sprite",
    "seven": "sprite",
    "7up": "sprite",
    
    // Otros
    "ranch": "ranch",
    "ranchero": "ranch",
  };

  return synonymMap[word] || null;
}

export function getErrorsAndWarnings(
  orderSummary: any,
  textSummary: string
): { errors: string[]; warnings: string[] } {
  const errors: string[] = [];
  const warnings: string[] = [];

  orderSummary.forEach((producto: any) => {
    if (producto.errors && producto.errors.length > 0) {
      errors.push(...producto.errors);
    }
    if (producto.warnings && producto.warnings.length > 0) {
      warnings.push(...producto.warnings);
    }
  });

  return { errors, warnings };
}

export function removeScoreField(obj: any): any {
  if (Array.isArray(obj)) {
    return obj.map(item => removeScoreField(item));
  } else if (obj !== null && typeof obj === 'object') {
    const newObj: any = {};
    for (const key in obj) {
      if (key !== 'score') {
        newObj[key] = removeScoreField(obj[key]);
      }
    }
    return newObj;
  }
  return obj;
}

export function detectUnknownWords(
  productMessage: string,
  bestProduct: any,
  warnings: string[]
): void {
  // Normalizar el mensaje del producto
  const messageWords = new Set(normalizeText(productMessage));
  
  // Crear conjunto de palabras conocidas del producto
  const knownWords = new Set<string>();
  
  // Agregar palabras del nombre del producto
  normalizeText(bestProduct.name).forEach(word => knownWords.add(word));
  
  // Agregar palabras de la variante seleccionada
  if (bestProduct.productVariant) {
    normalizeText(bestProduct.productVariant.name).forEach(word => knownWords.add(word));
  }
  
  // Agregar palabras de los modificadores seleccionados
  if (bestProduct.selectedModifiers) {
    bestProduct.selectedModifiers.forEach((modifier: any) => {
      normalizeText(modifier.name).forEach(word => knownWords.add(word));
    });
  }
  
  // Agregar palabras de los ingredientes de pizza seleccionados
  if (bestProduct.selectedPizzaIngredients) {
    bestProduct.selectedPizzaIngredients.forEach((ingredient: any) => {
      normalizeText(ingredient.name).forEach(word => knownWords.add(word));
    });
  }
  
  // Encontrar palabras desconocidas
  const unknownWords = Array.from(messageWords).filter(word => !knownWords.has(word));
  
  // Si hay palabras desconocidas, agregar advertencia
  if (unknownWords.length > 0) {
    warnings.push(`Algunas palabras no fueron reconocidas: ${unknownWords.join(', ')}`);
  }
}

================
File: backend/src/routes/address-selection.ts
================
import { Router, Request, Response } from 'express';
import { prisma } from '../server';
import logger from '../common/utils/logger';
import { sendWhatsAppInteractiveMessage } from '../services/whatsapp';

const router = Router();

/**
 * Send address selection message to customer
 * POST /backend/address-selection/send
 */
router.post('/send', async (req: Request, res: Response): Promise<void> => {
  try {
    const { customerId, preOrderId } = req.body;
    
    if (!customerId) {
      res.status(400).json({ 
        error: 'customerId is required' 
      });
      return;
    }
    
    // Get customer with addresses
    const customer = await prisma.customer.findUnique({
      where: { id: customerId },
      include: {
        addresses: {
          where: { deletedAt: null },
          orderBy: [
            { isDefault: 'desc' },
            { createdAt: 'desc' }
          ],
          take: 5 // Limit to 5 addresses for WhatsApp list
        }
      }
    });
    
    if (!customer) {
      res.status(404).json({ error: 'Customer not found' });
      return;
    }
    
    if (customer.addresses.length === 0) {
      // No addresses, send link to add one
      const { OTPService } = await import('../services/security/OTPService');
      const otp = OTPService.generateOTP();
      OTPService.storeOTP(customer.whatsappPhoneNumber, otp, true);
      
      const updateLink = `${process.env.FRONTEND_BASE_URL}/address-registration/${customer.whatsappPhoneNumber}?otp=${otp}${preOrderId ? `&preOrderId=${preOrderId}` : ''}`;
      
      const { sendMessageWithUrlButton } = await import('../services/whatsapp');
      await sendMessageWithUrlButton(
        customer.whatsappPhoneNumber,
        "📍 Registrar Dirección",
        "No tienes direcciones guardadas. Por favor, registra una dirección de entrega haciendo clic en el botón de abajo.",
        "Agregar Dirección",
        updateLink
      );
      
      res.json({ 
        success: true,
        message: 'Address registration link sent',
        hasAddresses: false
      });
      return;
    }
    
    if (customer.addresses.length === 1) {
      // Only one address, use it automatically
      if (preOrderId) {
        await updatePreOrderAddress(parseInt(preOrderId), customer.addresses[0].id);
      }
      
      await sendWhatsAppInteractiveMessage(
        customer.whatsappPhoneNumber,
        {
          type: "button",
          body: {
            text: `📍 *Dirección de entrega:*\n${formatAddress(customer.addresses[0])}\n\n¿Deseas usar esta dirección o cambiarla?`
          },
          action: {
            buttons: [
              {
                type: "reply",
                reply: {
                  id: `confirm_address_${customer.addresses[0].id}`,
                  title: "✅ Usar esta dirección"
                }
              },
              {
                type: "reply", 
                reply: {
                  id: "change_address",
                  title: "🔄 Cambiar dirección"
                }
              }
            ]
          }
        }
      );
      
      res.json({ 
        success: true,
        message: 'Single address confirmation sent',
        hasAddresses: true,
        addressCount: 1
      });
      return;
    }
    
    // Multiple addresses, send selection list
    const sections = [
      {
        title: "Mis direcciones",
        rows: customer.addresses.map((address, index) => ({
          id: `select_address_${address.id}`,
          title: truncateText(`${address.street} ${address.number}`, 24),
          description: truncateText(
            `${address.neighborhood ? address.neighborhood + ', ' : ''}${address.city}${address.isDefault ? ' (Principal)' : ''}`,
            72
          )
        }))
      }
    ];
    
    // Add option to add new address
    sections[0].rows.push({
      id: "add_new_address",
      title: "➕ Agregar nueva dirección",
      description: "Registrar una nueva dirección de entrega"
    });
    
    await sendWhatsAppInteractiveMessage(
      customer.whatsappPhoneNumber,
      {
        type: "list",
        header: {
          type: "text",
          text: "📍 Seleccionar Dirección"
        },
        body: {
          text: "Por favor selecciona la dirección de entrega para tu pedido:"
        },
        footer: {
          text: "Elige una opción de la lista"
        },
        action: {
          button: "Ver direcciones",
          sections
        }
      }
    );
    
    res.json({ 
      success: true,
      message: 'Address selection list sent',
      hasAddresses: true,
      addressCount: customer.addresses.length
    });
    
  } catch (error: any) {
    logger.error('Error sending address selection:', error);
    res.status(500).json({ 
      error: 'Failed to send address selection',
      message: error.message 
    });
  }
});

/**
 * Update selected address for preorder
 * POST /backend/address-selection/update
 */
router.post('/update', async (req: Request, res: Response): Promise<void> => {
  try {
    const { preOrderId, addressId, customerId } = req.body;
    
    if (!preOrderId || !addressId || !customerId) {
      res.status(400).json({ 
        error: 'preOrderId, addressId, and customerId are required' 
      });
      return;
    }
    
    // Verify address belongs to customer
    const address = await prisma.address.findFirst({
      where: { 
        id: addressId,
        customerId,
        deletedAt: null
      }
    });
    
    if (!address) {
      res.status(404).json({ 
        error: 'Address not found or does not belong to customer' 
      });
      return;
    }
    
    // Update preorder with selected address
    await updatePreOrderAddress(preOrderId, addressId);
    
    res.json({ 
      success: true,
      message: 'PreOrder address updated successfully'
    });
    
  } catch (error: any) {
    logger.error('Error updating preorder address:', error);
    res.status(500).json({ 
      error: 'Failed to update address',
      message: error.message 
    });
  }
});

// Helper functions
function formatAddress(address: any): string {
  const parts = [];
  
  if (address.street && address.number) {
    let streetLine = `${address.street} ${address.number}`;
    if (address.interiorNumber) {
      streetLine += ` Int. ${address.interiorNumber}`;
    }
    parts.push(streetLine);
  }
  
  if (address.neighborhood) parts.push(address.neighborhood);
  if (address.city && address.state) {
    parts.push(`${address.city}, ${address.state}`);
  }
  
  if (address.references) {
    parts.push(`Referencias: ${address.references}`);
  }
  
  return parts.join('\n');
}

function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength - 3) + '...';
}

async function updatePreOrderAddress(preOrderId: number, addressId: string): Promise<void> {
  // Get the address details
  const address = await prisma.address.findUnique({
    where: { id: addressId }
  });
  
  if (!address) {
    throw new Error('Address not found');
  }
  
  // Get existing preorder delivery info
  const preOrder = await prisma.preOrder.findUnique({
    where: { id: preOrderId },
    include: { deliveryInfo: true }
  });
  
  if (!preOrder) {
    throw new Error('PreOrder not found');
  }
  
  const deliveryInfoData = {
    street: address.street,
    number: address.number,
    interiorNumber: address.interiorNumber,
    neighborhood: address.neighborhood,
    city: address.city,
    state: address.state,
    zipCode: address.zipCode,
    country: address.country,
    references: address.references,
    latitude: address.latitude?.toNumber(),
    longitude: address.longitude?.toNumber(),
    preOrderId: preOrderId
  };
  
  if (preOrder.deliveryInfo && preOrder.deliveryInfo.length > 0) {
    // Update existing delivery info
    await prisma.orderDeliveryInfo.update({
      where: { id: preOrder.deliveryInfo[0].id },
      data: deliveryInfoData
    });
  } else {
    // Create new delivery info
    await prisma.orderDeliveryInfo.create({
      data: deliveryInfoData
    });
  }
  
  logger.info(`Updated preorder ${preOrderId} with address ${addressId}`);
}

export default router;

================
File: backend/src/routes/sync.ts
================
import { Router, Request, Response } from 'express';
import { SyncService } from '../services/sync/SyncService';
import logger from '../common/utils/logger';
import { prisma } from '../server';

const router = Router();

/**
 * Sync customer from local backend
 * POST /backend/sync/customer
 */
router.post('/customer', async (req: Request, res: Response): Promise<void> => {
  try {
    const localCustomer = req.body;
    
    // Validate required fields
    if (!localCustomer.id || !localCustomer.phoneNumber) {
      res.status(400).json({ 
        error: 'Missing required fields: id and phoneNumber' 
      });
      return;
    }
    
    const customer = await SyncService.syncCustomerFromLocal(localCustomer);
    res.json({ 
      success: true, 
      customer: {
        id: customer.id,
        whatsappPhoneNumber: customer.whatsappPhoneNumber,
        syncVersion: customer.syncVersion
      }
    });
    
  } catch (error: any) {
    logger.error('Error syncing customer from local:', error);
    res.status(500).json({ 
      error: 'Failed to sync customer',
      message: error.message 
    });
  }
});

/**
 * Get customer by ID
 * GET /backend/sync/customer/:id
 */
router.get('/customer/:id', async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    // Search by UUID
    const customer = await prisma.customer.findUnique({
      where: { id },
      include: { addresses: true }
    });
    
    if (!customer) {
      res.status(404).json({ error: 'Customer not found' });
      return;
    }
    
    res.json({ customer });
    
  } catch (error: any) {
    logger.error('Error fetching customer by ID:', error);
    res.status(500).json({ error: 'Failed to fetch customer' });
  }
});

/**
 * Batch sync customers
 * POST /backend/sync/customers/batch
 */
router.post('/customers/batch', async (req: Request, res: Response): Promise<void> => {
  try {
    const { customers } = req.body;
    
    if (!Array.isArray(customers)) {
      res.status(400).json({ error: 'customers must be an array' });
      return;
    }
    
    const results = [];
    const errors = [];
    
    for (const localCustomer of customers) {
      try {
        const customer = await SyncService.syncCustomerFromLocal(localCustomer);
        results.push({
          id: customer.id,
          whatsappPhoneNumber: customer.whatsappPhoneNumber,
          success: true
        });
      } catch (error: any) {
        errors.push({
          id: localCustomer.id,
          error: error.message
        });
      }
    }
    
    res.json({
      success: true,
      synced: results.length,
      failed: errors.length,
      results,
      errors
    });
    
  } catch (error: any) {
    logger.error('Error in batch sync:', error);
    res.status(500).json({ error: 'Batch sync failed' });
  }
});

/**
 * Get sync status
 * GET /backend/sync/status
 */
router.get('/status', async (req: Request, res: Response) => {
  try {
    const { since, entityType } = req.query;
    
    const where: any = {};
    if (since) {
      where.createdAt = { gte: new Date(since as string) };
    }
    if (entityType) {
      where.entityType = entityType;
    }
    
    const syncLogs = await prisma.syncLog.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      take: 100
    });
    
    const stats = await prisma.syncLog.groupBy({
      by: ['syncStatus', 'entityType'],
      _count: true,
      where
    });
    
    res.json({
      logs: syncLogs,
      stats
    });
    
  } catch (error: any) {
    logger.error('Error fetching sync status:', error);
    res.status(500).json({ error: 'Failed to fetch sync status' });
  }
});

/**
 * Manual sync trigger
 * POST /backend/sync/trigger
 */
router.post('/trigger', async (req: Request, res: Response) => {
  try {
    const { direction = 'bidirectional', entityType = 'customer' } = req.body;
    
    if (entityType === 'customer') {
      const customers = await SyncService.getCustomersToSync();
      
      // TODO: Implement actual sync logic
      // This would call your local backend API
      
      res.json({
        message: 'Sync triggered',
        direction,
        entityType,
        itemsToSync: customers.length
      });
    } else {
      res.status(400).json({ error: 'Unsupported entity type' });
    }
    
  } catch (error: any) {
    logger.error('Error triggering sync:', error);
    res.status(500).json({ error: 'Failed to trigger sync' });
  }
});

export default router;

================
File: backend/src/services/messaging/middlewares/AddressRequiredMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { sendMessageWithUrlButton } from '../../whatsapp';
import { OTPService } from '../../security/OTPService';
import { env } from '../../../common/config/envValidator';
import logger from '../../../common/utils/logger';

export class AddressRequiredMiddleware implements MessageMiddleware {
  name = 'AddressRequiredMiddleware';

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      const hasNoAddress = context.get('hasNoAddress');
      const customerId = context.message.from;
      
      // Si el cliente no tiene dirección, bloquear la conversación
      if (hasNoAddress) {
        logger.info(`Blocking conversation for customer ${customerId} - no address on file`);
        
        // Generar OTP con expiración extendida para registro de dirección
        const otp = OTPService.generateOTP();
        OTPService.storeOTP(customerId, otp, true); // true = address registration
        
        // Crear enlace de registro
        const registrationLink = `${env.FRONTEND_BASE_URL}/address-registration/${customerId}?otp=${otp}`;
        
        // Enviar mensaje con botón URL
        await sendMessageWithUrlButton(
          customerId,
          "🏠 ¡Bienvenido!",
          "Para poder tomar tu pedido, necesitamos que registres tu dirección de entrega.\n\nEs muy fácil y rápido:\n• Haz clic en el botón de abajo\n• Completa tu información\n• ¡Listo para ordenar!",
          "Registrar Dirección",
          registrationLink
        );
        
        // Detener el procesamiento - no procesar ningún mensaje hasta que tenga dirección
        context.stop();
        return context;
      }
      
      return context;
    } catch (error) {
      logger.error('Error in AddressRequiredMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/middlewares/MessageProcessingMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { MessageStrategy } from '../strategies/MessageStrategy';
import { TextMessageStrategy } from '../strategies/TextMessageStrategy';
import { InteractiveMessageStrategy } from '../strategies/InteractiveMessageStrategy';
import { AudioMessageStrategy } from '../strategies/AudioMessageStrategy';
import logger from '../../../common/utils/logger';

export class MessageProcessingMiddleware implements MessageMiddleware {
  name = 'MessageProcessingMiddleware';
  
  private strategies: MessageStrategy[] = [
    new AudioMessageStrategy(),      // Audio primero para convertir a texto
    new InteractiveMessageStrategy(), // Mensajes interactivos
    new TextMessageStrategy(),        // Mensajes de texto
  ];
  
  async process(context: MessageContext): Promise<MessageContext> {
    try {
      // Encontrar la estrategia apropiada
      for (const strategy of this.strategies) {
        if (strategy.canHandle(context)) {
          await strategy.execute(context);
          
          // Si el audio se convirtió a texto, continuar procesando
          if (strategy.name === 'AudioMessageStrategy' && context.message.type === 'text') {
            continue;
          }
          
          break;
        }
      }
      
      return context;
    } catch (error) {
      logger.error('Error in MessageProcessingMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/types/responses.ts
================
/**
 * Tipo unificado para todas las respuestas del sistema
 * Reemplaza AIResponse, MessageResponse, ResponseItem, etc.
 */
export interface UnifiedResponse {
  // Contenido principal
  content?: {
    text?: string;
    interactive?: any;
  };
  
  // Metadatos
  metadata: {
    // Control de envío
    shouldSend: boolean;
    
    // Relevancia para el historial
    isRelevant: boolean;
    
    // Tipo de respuesta
    type: ResponseType;
    
    // IDs relacionados
    preOrderId?: number;
    orderId?: number;
    messageId?: string;
  };
  
  // Datos procesados (para pedidos)
  processedData?: {
    orderItems?: any[];
    orderType?: 'delivery' | 'pickup';
    warnings?: string[];
    scheduledAt?: Date;
  };
  
  // Errores
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

/**
 * Tipos de respuesta
 */
export enum ResponseType {
  // Mensajes simples
  TEXT = 'TEXT',
  INTERACTIVE = 'INTERACTIVE',
  
  // Respuestas de procesamiento
  ORDER_CONFIRMATION = 'ORDER_CONFIRMATION',
  ORDER_PROCESSING = 'ORDER_PROCESSING',
  
  // Respuestas de consulta
  MENU_INFO = 'MENU_INFO',
  WAIT_TIME_INFO = 'WAIT_TIME_INFO',
  RESTAURANT_INFO = 'RESTAURANT_INFO',
  
  // Errores
  ERROR = 'ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
}

/**
 * Builder para crear respuestas de forma consistente
 */
export class ResponseBuilder {
  static text(message: string, isRelevant = true): UnifiedResponse {
    return {
      content: { text: message },
      metadata: {
        shouldSend: true,
        isRelevant,
        type: ResponseType.TEXT,
      },
    };
  }
  
  static interactive(message: any, preOrderId?: number): UnifiedResponse {
    return {
      content: { interactive: message },
      metadata: {
        shouldSend: true,
        isRelevant: false,
        type: ResponseType.INTERACTIVE,
        preOrderId,
      },
    };
  }
  
  static orderProcessing(data: any): UnifiedResponse {
    return {
      processedData: data,
      metadata: {
        shouldSend: false,
        isRelevant: true,
        type: ResponseType.ORDER_PROCESSING,
      },
    };
  }
  
  static error(code: string, message: string): UnifiedResponse {
    return {
      content: { text: message },
      error: { code, message },
      metadata: {
        shouldSend: true,
        isRelevant: true,
        type: ResponseType.ERROR,
      },
    };
  }
}

================
File: backend/src/services/messaging/types.ts
================
import { Customer } from '@prisma/client';

export * from './types/responses';

export interface IncomingMessage {
  id: string;
  from: string;
  type: 'text' | 'interactive' | 'audio' | 'image' | 'document' | 'location';
  timestamp: string;
  text?: {
    body: string;
  };
  interactive?: {
    type: 'button_reply' | 'list_reply';
    button_reply?: {
      id: string;
      title: string;
    };
    list_reply?: {
      id: string;
      title: string;
      description?: string;
    };
  };
  audio?: {
    id: string;
    mime_type: string;
  };
}

export interface MessageContext {
  message: IncomingMessage;
  customer?: Customer;
  chatHistory?: any[];
  response?: MessageResponse;
  metadata: Map<string, any>;
  shouldStop: boolean;
  error?: Error;
}

export interface MessageResponse {
  text?: string;
  interactiveMessage?: any;
  sendToWhatsApp: boolean;
  isRelevant: boolean;
  preOrderId?: number;
  confirmationMessage?: string;
  historyMarker?: string; // Texto alternativo para guardar en el historial
}

export interface MessageMiddleware {
  name: string;
  process(context: MessageContext): Promise<MessageContext>;
}

export interface MessageStrategy {
  execute(message: IncomingMessage, customer: Customer): Promise<MessageResponse[]>;
}

================
File: backend/src/services/orders/OrderService.ts
================
import { prisma } from '../../server';
import { PizzaHalf, IngredientAction } from '@prisma/client';
import { CreateOrderDto } from './dto/create-order.dto';
import logger from '../../common/utils/logger';
import { NotFoundError, ErrorCode } from '../../common/services/errors';

export class OrderService {
  async create(createOrderDto: CreateOrderDto) {
    try {
      // Generar el número de orden diario
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const lastOrder = await prisma.order.findFirst({
        where: {
          createdAt: {
            gte: today
          }
        },
        orderBy: {
          dailyNumber: 'desc'
        }
      });
      
      const dailyNumber = lastOrder ? lastOrder.dailyNumber + 1 : 1;
      
      // Get restaurant config for estimated times
      const config = await prisma.restaurantConfig.findFirst();
      const estimatedTime = createOrderDto.orderType === 'DELIVERY' 
        ? (config?.estimatedDeliveryTime || 40)
        : (config?.estimatedPickupTime || 20);
      
      // Initialize total cost - will be calculated after creating items
      let totalCost = 0;
      
      // Use Prisma transaction for atomic operations
      const order = await prisma.$transaction(async (tx) => {
        // Create the order
        const newOrder = await tx.order.create({
          data: {
            orderType: createOrderDto.orderType as "DINE_IN" | "TAKE_AWAY" | "DELIVERY",
            customerId: createOrderDto.customerId,
            scheduledAt: createOrderDto.scheduledAt ? new Date(createOrderDto.scheduledAt) : null,
            orderStatus: 'PENDING',
            dailyNumber,
            totalCost,
            estimatedTime,
            isFromWhatsApp: true,
            createdAt: new Date(),
            updatedAt: new Date()
          }
        });
        
        // Create order items if provided
        if (createOrderDto.orderItems && createOrderDto.orderItems.length > 0) {
          const orderItemsWithPrices = await Promise.all(
            createOrderDto.orderItems.map(async (item) => {
              // Get product and variant info to calculate price
              const product = await tx.product.findUnique({
                where: { id: item.productId },
                include: { variants: true }
              });
              
              if (!product) {
                throw new NotFoundError(
                  ErrorCode.INVALID_PRODUCT,
                  `Product ${item.productId} not found`,
                  { metadata: { productId: item.productId } }
                );
              }
              
              // Calculate base price
              let itemPrice = 0;
              if (item.productVariantId) {
                const variant = product.variants.find(v => v.id === item.productVariantId);
                if (variant) {
                  itemPrice = variant.price;
                }
              } else if (product.price !== null) {
                itemPrice = product.price;
              }
              
              // First calculate total price including modifiers
              let modifierIds: string[] = [];
              if (item.selectedModifiers && item.selectedModifiers.length > 0) {
                modifierIds = item.selectedModifiers.map(sm => sm.modifierId);
                
                // Get modifier prices
                const modifiers = await tx.productModifier.findMany({
                  where: { id: { in: modifierIds } }
                });
                
                // Add modifier prices to item price
                for (const modifier of modifiers) {
                  itemPrice += modifier.price || 0;
                }
              }
              
              // Crear items individuales según la cantidad
              const quantity = item.quantity || 1;
              const orderItems = [];
              
              for (let i = 0; i < quantity; i++) {
                const orderItem = await tx.orderItem.create({
                  data: {
                    orderId: newOrder.id,
                    productId: item.productId,
                    productVariantId: item.productVariantId,
                    basePrice: itemPrice,
                    finalPrice: itemPrice,
                    productModifiers: modifierIds.length > 0 ? {
                      connect: modifierIds.map(id => ({ id }))
                    } : undefined
                  }
                });
                orderItems.push(orderItem);
              }
              
              // Create selected pizza ingredients for each order item if provided
              if (item.selectedPizzaIngredients && item.selectedPizzaIngredients.length > 0) {
                for (const orderItem of orderItems) {
                  await Promise.all(
                    item.selectedPizzaIngredients.map(ingredient =>
                      tx.selectedPizzaIngredient.create({
                        data: {
                          orderItemId: orderItem.id,
                          pizzaIngredientId: ingredient.pizzaIngredientId,
                          half: ingredient.half as PizzaHalf,
                          action: ingredient.action as IngredientAction
                        }
                      })
                    )
                  );
                }
              }
              
              // Calculate total price for all items of this type
              const itemTotal = itemPrice * quantity;
              totalCost += itemTotal;
              
              return orderItems;
            })
          );
        }
        
        // Create delivery info if provided
        if (createOrderDto.orderDeliveryInfo) {
          await tx.orderDeliveryInfo.create({
            data: {
              ...createOrderDto.orderDeliveryInfo,
              orderId: newOrder.id,
            }
          });
        }
        
        // Update order with calculated total cost
        const updatedOrder = await tx.order.update({
          where: { id: newOrder.id },
          data: { totalCost }
        });
        
        return updatedOrder;
      });
      
      return order;
    } catch (error) {
      logger.error('Error creating order:', error);
      throw error;
    }
  }

  async findOne(id: string) {
    return prisma.order.findUnique({
      where: { id },
      include: {
        orderItems: {
          include: {
            product: true,
            productVariant: true,
            productModifiers: true,
            selectedPizzaIngredients: {
              include: {
                pizzaIngredient: true
              }
            }
          }
        },
        deliveryInfo: true
      }
    });
  }

  async update(id: string, updateData: any) {
    try {
      const order = await prisma.order.update({
        where: { id },
        data: {
          ...updateData,
          updatedAt: new Date()
        }
      });
      return order;
    } catch (error) {
      // If the order doesn't exist, Prisma will throw an error
      return null;
    }
  }

  async cancel(id: string) {
    return this.update(id, { orderStatus: 'CANCELLED' });
  }

}

================
File: backend/src/services/whatsapp/index.ts
================
/**
 * Central export file for WhatsApp functionality
 * Re-exports commonly used functions for easier imports
 */

// Re-export from WhatsAppService
export { 
  WhatsAppService,
  WhatsAppService as default 
} from './WhatsAppService';

// Re-export specific WhatsApp functions
import { WhatsAppService } from './WhatsAppService';

export const sendWhatsAppMessage = WhatsAppService.sendWhatsAppMessage.bind(WhatsAppService);
export const sendWhatsAppInteractiveMessage = WhatsAppService.sendInteractiveMessage.bind(WhatsAppService);
export const sendMessageWithUrlButton = WhatsAppService.sendMessageWithUrlButton.bind(WhatsAppService);
export const getWhatsAppMediaUrl = WhatsAppService.getMediaUrl.bind(WhatsAppService);
export const downloadWhatsAppMedia = WhatsAppService.downloadMedia.bind(WhatsAppService);
export const verifyWhatsAppWebhook = WhatsAppService.verifyWebhook.bind(WhatsAppService);
export const handleWhatsAppWebhook = WhatsAppService.handleWebhook.bind(WhatsAppService);

================
File: backend/src/whatsapp/handlers/orders/index.ts
================
/**
 * Order handlers index
 * Exports all order-related handlers
 */

export { 
  handlePreOrderConfirmation,
  sendOrderConfirmation 
} from './confirmationHandler';

export { 
  handleOrderCancellation 
} from './cancellationHandler';

export {
  createPreOrderAndSendSummary,
  handlePreOrderDiscard
} from './preOrderHandler';

export {
  generateProductSummary,
  generatePizzaIngredientsSummary,
  generateOrderSummary
} from './orderFormatters';

================
File: backend/railway.json
================
{
  "build": {
    "builder": "NIXPACKS",
    "buildCommand": "npm install && npm run generate && npm run build"
  },
  "deploy": {
    "startCommand": "npm run migrate && npm run start:prod",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}

================
File: frontend-app/src/components/ui/index.ts
================
export { Button } from './Button';
export { Input } from './Input';
export { WhatsAppButton } from './WhatsAppButton';

================
File: frontend-app/src/components/ui/Input.tsx
================
import { forwardRef } from 'react';
import { clsx } from 'clsx';

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement | HTMLTextAreaElement> {
  label?: string;
  error?: string;
  hint?: string;
  as?: 'input' | 'textarea';
  rows?: number;
  required?: boolean;
}

export const Input = forwardRef<HTMLInputElement | HTMLTextAreaElement, InputProps>(
  ({ label, error, hint, className, as = 'input', required, ...props }, ref) => {
    const Component = as;
    
    return (
      <div className="mb-4">
        {label && (
          <label className="block text-sm font-medium text-gray-700 mb-2">
            {label}
            {required && <span className="text-red-500 ml-1">*</span>}
          </label>
        )}
        {hint && (
          <p className="text-xs text-gray-500 mb-2">{hint}</p>
        )}
        <Component
          ref={ref as any}
          className={clsx(
            'w-full px-4 py-3 text-sm border rounded-lg transition duration-200',
            'focus:outline-none focus:ring-2 focus:ring-offset-0',
            error
              ? 'border-red-300 focus:ring-red-500 focus:border-red-500 bg-red-50'
              : 'border-gray-300 focus:ring-blue-500 focus:border-blue-500 hover:border-gray-400',
            className
          )}
          {...props}
        />
        {error && (
          <p className="text-red-600 text-xs mt-2 flex items-center">
            <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
            {error}
          </p>
        )}
      </div>
    );
  }
);

Input.displayName = 'Input';

================
File: frontend-app/src/config/index.ts
================
export const config = {
  // API Configuration
  api: {
    baseUrl: import.meta.env.VITE_BACKEND_BASE_URL || 'http://localhost:5000',
    prefix: import.meta.env.VITE_API_PREFIX || '/backend',
  },
  
  // WhatsApp Configuration
  whatsapp: {
    botNumber: import.meta.env.VITE_BOT_WHATSAPP_NUMBER || '521234567890',
    baseUrl: 'https://wa.me',
  },
  
  // Regional Configuration
  regional: {
    countryCode: import.meta.env.VITE_COUNTRY_CODE || 'mx',
    locale: import.meta.env.VITE_LOCALE || 'es-MX',
    timezone: import.meta.env.VITE_TIMEZONE || 'America/Mexico_City',
  },
  
  // Google Maps Configuration
  maps: {
    apiKey: import.meta.env.VITE_GOOGLE_MAPS_API_KEY,
    libraries: ['places', 'geometry'] as ('places' | 'geometry')[],
    defaultZoom: {
      initial: 14,
      search: 17,
      selected: 16,
    },
    padding: { top: 50, right: 50, bottom: 50, left: 50 },
  },
  
  // UI Configuration
  ui: {
    mapHeight: {
      mobile: 'h-[300px]',
      desktop: 'sm:h-[400px]',
    },
    colors: {
      primary: '#3B82F6',
      marker: {
        fill: '#3B82F6',
        stroke: '#ffffff',
      },
      polygon: {
        fill: '#3B82F6',
        fillOpacity: 0.2,
        stroke: '#3B82F6',
        strokeOpacity: 0.8,
        strokeWeight: 2,
      },
    },
  },
};

// API Endpoints
export const endpoints = {
  addressRegistration: {
    verifyOtp: `${config.api.prefix}/address-registration/verify-otp`,
    create: `${config.api.prefix}/address-registration/create`,
    update: (addressId: string) => `${config.api.prefix}/address-registration/${addressId}`,
    delete: (addressId: string) => `${config.api.prefix}/address-registration/${addressId}`,
    setDefault: (addressId: string) => `${config.api.prefix}/address-registration/${addressId}/default`,
    getAddresses: (customerId: string) => `${config.api.prefix}/address-registration/${customerId}/addresses`,
    getDeliveryArea: `${config.api.prefix}/address-registration/delivery-area`,
  },
};

================
File: frontend-app/src/services/api.ts
================
import axios from 'axios';
import type { AxiosInstance, AxiosError } from 'axios';
import type { ApiError } from '@/types/api.types';

class ApiService {
  private api: AxiosInstance;

  constructor() {
    this.api = axios.create({
      baseURL: import.meta.env.VITE_API_URL || '',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Response interceptor for error handling
    this.api.interceptors.response.use(
      (response) => response,
      (error: AxiosError<ApiError>) => {
        const apiError: ApiError = {
          message: error.response?.data?.message || error.message || 'An error occurred',
          statusCode: error.response?.status || 500,
          error: error.response?.data?.error,
        };
        return Promise.reject(apiError);
      }
    );
  }

  get instance() {
    return this.api;
  }
}

const apiService = new ApiService();
export default apiService.instance;

================
File: frontend-app/src/index.css
================
@import "tailwindcss";

================
File: frontend-app/package.json
================
{
  "name": "frontend-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@googlemaps/js-api-loader": "^1.16.8",
    "@hookform/resolvers": "^5.1.1",
    "@react-google-maps/api": "^2.20.6",
    "axios": "^1.9.0",
    "clsx": "^2.1.1",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.57.0",
    "react-hot-toast": "^2.5.2",
    "react-router-dom": "^7.6.2",
    "yup": "^1.6.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@tailwindcss/postcss": "^4.1.10",
    "@types/google.maps": "^3.58.1",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.4.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "postcss": "^8.5.5",
    "tailwindcss": "^4.1.10",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5"
  }
}

================
File: frontend-app/postcss.config.js
================
export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}

================
File: frontend-app/vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/backend': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
  },
})

================
File: CLAUDE.md
================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Commands

### Development
```bash
# Start local development (both backend and frontend)
./start-local.sh

# Or run separately:
npm run dev          # Runs both backend and frontend concurrently
cd backend && npm run dev    # Backend only (port 3001)
cd frontend-app && npm run dev   # Frontend only (port 3000)

# Other development scripts
./dev.sh             # Full dev with hot-reload
./dev-backend.sh     # Backend only development
./dev-frontend.sh    # Frontend only development
```

### Database Management
```bash
cd backend
npm run generate      # Generate Prisma client after schema changes
npm run migrate:dev   # Create and apply migrations in development
npm run migrate       # Apply migrations in production
npm run studio        # Open Prisma Studio to view/edit database
npm run seed          # Seed database with initial restaurant data
```

### Build & Production
```bash
npm run build         # Build both backend and frontend
npm run start         # Build and start both services

# Backend only
cd backend && npm run build && npm run start

# Frontend only  
cd frontend-app && npm run build && npm run preview
```

### Linting
```bash
cd frontend-app && npm run lint    # ESLint for frontend
# Note: No linting configured for backend
```

### Testing WhatsApp Locally
```bash
# 1. Start the backend
./start-local.sh

# 2. In another terminal, expose webhook with ngrok
ngrok http 3001

# 3. Update webhook URL in Meta Business dashboard to:
# https://[your-ngrok-id].ngrok.io/backend/webhook
```

## Architecture Overview

This is a WhatsApp restaurant ordering bot with AI-powered natural language processing.

### Message Processing Pipeline

WhatsApp messages flow through a sophisticated middleware pipeline:

```
Webhook Entry (/backend/webhook)
    ↓
WhatsAppService.handleWebhook()
    ↓
MessageProcessor.processWithPipeline()
    ↓
Middleware Pipeline:
    1. RateLimitMiddleware (configurable limits)
    2. CustomerValidationMiddleware (creates/validates customers, loads chat history)
    3. RestaurantHoursMiddleware (checks if restaurant is open)
    4. AddressRequiredMiddleware (blocks until address registered)
    5. MessageTypeMiddleware (routes to appropriate strategy)
    6. MessageProcessingMiddleware (strategy pattern):
        - AudioMessageStrategy (transcribes with Gemini)
        - InteractiveMessageStrategy (button/list responses)
        - TextMessageStrategy (AI agent processing)
```

### AI Agent Architecture

**Two-Agent System**:

1. **General Agent** (`AgentService.processMessage`)
   - Detects user intent and routes appropriately
   - Function tools available:
     - `send_menu`: Display full restaurant menu
     - `get_business_hours`: Restaurant info and hours
     - `prepare_order_context`: Initiate order processing
     - `generate_address_update_link`: OTP-secured address update
     - `send_bot_instructions`: Help messages
     - `reset_conversation`: Clear chat history
   - Always asks for order type (delivery/takeaway) before processing

2. **Order Agent** (`AgentService.processOrderMapping`)
   - Specialized for mapping natural language to menu items
   - Uses semantic similarity matching
   - Executes `map_order_items` function
   - Creates structured order data from conversational input

### Service Architecture

**Stateless Services Pattern**: All services use static methods
- Import `prisma` from server.ts for database access
- Services organized by domain in `/backend/src/services/[domain]/`
- Examples:
  ```typescript
  export class OrderService {
    static async createOrder(data: CreateOrderData): Promise<Order> {
      // Implementation
    }
  }
  ```

### Key Business Logic

1. **Address Requirement**: Customers MUST have a registered address before any conversation
   - Enforced by `AddressRequiredMiddleware`
   - Generates OTP and sends registration link
   - Blocks all other interactions until completed

2. **Order Flow**:
   - User message → AI extracts items → Creates PreOrder
   - Shows summary with confirm/cancel buttons
   - Confirmation converts PreOrder to Order
   - Generates unique daily order number

3. **Message History Management**:
   - Full history stored for context
   - Relevant history (last 20 messages) for AI processing
   - Automatic cleanup of duplicate consecutive messages
   - History markers for important events (resets, orders)

4. **Security**:
   - OTP-based authentication for sensitive operations
   - Message deduplication prevents replay attacks
   - WhatsApp phone number as primary identifier

### Error Handling

Centralized error service with WhatsApp-friendly messages:
```typescript
throw new BusinessLogicError(
  ErrorCode.CUSTOMER_NOT_FOUND,
  'Customer not found',
  { customerId: data.customerId }
);
```

### Type System

- Centralized types in `/backend/src/common/types/`
- Always import from the central index.ts
- Never import directly from Prisma client
- Moving towards unified response types

### Important Implementation Details

1. **Message Splitting**: Automatic splitting at 4000 chars
2. **WhatsApp Message Types**:
   - Text: Processed through AI agents
   - Audio: Transcribed then processed as text
   - Interactive: Direct action handlers (bypasses AI)
3. **Response Accumulation**: Context collects all responses during pipeline
4. **Idempotency**: Message log prevents duplicate processing

## Environment Variables

Required (see `.env.example` for full list):
- `DATABASE_URL`: PostgreSQL connection (local uses port 5433 to avoid conflicts)
- `GOOGLE_AI_API_KEY`: Google AI API key for Gemini
- `GEMINI_MODEL`: Model version (default: gemini-2.5-pro)
- `WHATSAPP_PHONE_NUMBER_MESSAGING_ID`: Meta phone number ID
- `WHATSAPP_ACCESS_TOKEN`: WhatsApp API access token
- `WHATSAPP_VERIFY_TOKEN`: Webhook verification token
- `FRONTEND_BASE_URL`: Frontend URL for address collection
- `RATE_LIMIT_MAX_MESSAGES`: Message limit per window (default: 30)
- `RATE_LIMIT_TIME_WINDOW_MINUTES`: Time window for rate limiting (default: 5)

## Database Schema

### Core Business Models

**Customer** - WhatsApp users
- `id`: UUID primary key
- `whatsappPhoneNumber`: Unique WhatsApp identifier (used for all messaging)
- `firstName/lastName`: Optional customer name
- `email`: Optional email
- `fullChatHistory/relevantChatHistory`: JSON fields storing conversation history
- `stripeCustomerId`: For payment processing
- `isBanned/banReason`: For blocking abusive users
- `totalOrders/totalSpent`: Customer metrics
- Relations: has many `addresses` and `orders`

**Address** - Customer delivery addresses (1:N with Customer)
- `id`: UUID primary key
- `customerId`: Foreign key to Customer
- `street/number/interiorNumber`: Address components
- `neighborhood/city/state/zipCode/country`: Location details
- `latitude/longitude`: GPS coordinates (Decimal precision)
- `references`: Additional delivery instructions
- `isDefault`: Marks primary address

**Order** - Confirmed customer orders
- `id`: UUID primary key
- `dailyNumber`: Sequential number reset daily
- `orderType`: DINE_IN, TAKE_AWAY, or DELIVERY
- `orderStatus`: PENDING → IN_PROGRESS → IN_PREPARATION → READY → IN_DELIVERY → DELIVERED/COMPLETED/CANCELLED
- `paymentStatus`: PENDING or PAID
- `totalCost`: Order total
- `customerId`: Foreign key to Customer
- `scheduledAt`: For future orders
- `messageId`: WhatsApp message tracking
- `stripeSessionId`: Payment tracking
- Relations: has many `orderItems`, has one `deliveryInfo`

**PreOrder** - Temporary orders before confirmation
- `id`: Auto-increment integer
- `orderItems`: JSON containing order details
- `orderType`: Same as Order
- `whatsappPhoneNumber`: Customer phone (not UUID)
- `messageId`: For tracking confirmation buttons
- Relations: can have `deliveryInfo`

**OrderDeliveryInfo** - Snapshot of delivery address at order time
- Preserves historical delivery data
- Contains all address fields (street, number, city, etc.)
- `pickupName`: For TAKE_AWAY orders
- Can belong to either `Order` or `PreOrder`

### Product Catalog Models

**Category** - Top-level product categories
- `id`: String primary key
- `name`: Unique category name
- `photoId`: Optional image reference
- Relations: has many `subcategories`

**Subcategory** - Product subcategories
- Belongs to a `Category`
- Relations: has many `products`

**Product** - Menu items
- `id`: String primary key
- `name/description`: Product details
- `price`: Base price (nullable if has variants)
- `hasVariants`: Boolean flag
- `isPizza`: Special handling for pizzas
- `estimatedPrepTime`: Minutes to prepare
- Relations: has many `variants`, `modifierGroups`, `pizzaIngredients`

**ProductVariant** - Size/type variations (e.g., small, medium, large)
- `price`: Variant-specific price
- Belongs to a `Product`

**ModifierGroup** - Groups of optional modifications
- `minSelections/maxSelections`: Selection constraints
- `isRequired`: Must select at least min
- `allowMultipleSelections`: Can select multiple modifiers
- Relations: has many `productModifiers`

**ProductModifier** - Individual modifications (e.g., extra cheese, no onions)
- `price`: Additional cost (nullable)
- `isDefault`: Pre-selected option
- Belongs to a `ModifierGroup`

**PizzaIngredient** - Special ingredients for pizzas
- `ingredientValue`: Quantity/portion
- `productIds`: Array of applicable pizza products
- Can be added/removed per pizza half

### Order Detail Models

**OrderItem** - Individual items within an order
- Links to `Product` and optionally `ProductVariant`
- `basePrice/finalPrice`: Pricing before/after modifiers
- `preparationStatus`: Independent tracking per item
- Relations: many-to-many with `productModifiers` and `selectedPizzaIngredients`

**SelectedPizzaIngredient** - Pizza customizations per order item
- `half`: LEFT, RIGHT, or FULL pizza
- `action`: ADD or REMOVE ingredient
- Links `OrderItem` to `PizzaIngredient`

### Restaurant Configuration Models

**RestaurantConfig** - Global restaurant settings
- Restaurant name, phones, address
- `acceptingOrders`: Master on/off switch
- `estimatedPickupTime/estimatedDeliveryTime`: Default wait times
- `openingGracePeriod/closingGracePeriod`: Buffer times
- `deliveryCoverageArea`: JSON polygon for delivery zone
- Relations: has many `businessHours`

**BusinessHours** - Operating hours per day
- `dayOfWeek`: 0-6 (Sunday-Saturday)
- `openingTime/closingTime`: HH:mm format
- `isClosed`: Override for holidays

### System Models

**MessageLog** - WhatsApp message deduplication
- `messageId`: Unique WhatsApp message ID
- `processed`: Boolean flag to prevent reprocessing

**MessageRateLimit** - Rate limiting per customer
- `whatsappPhoneNumber`: Customer identifier
- `messageCount`: Messages in current window
- `lastMessageTime`: For sliding window calculation

**SyncLog** - Tracks sync between local and cloud systems
- `entityType/entityId`: What was synced
- `syncDirection`: local_to_cloud or cloud_to_local
- `syncStatus`: pending, success, or failed

**SeederControl** - Prevents duplicate seed runs
- `lastRun`: Timestamp of last seed execution

## Deployment

Railway deployment:
```bash
# Build command
cd backend && npm install && npm run build

# Start command  
cd backend && npm run migrate && npm run seed && npm start
```

Auto-deploys on push to connected repository.

## Frontend Integration

- React app at `/frontend-app` for address collection
- OTP-secured registration flow
- Google Maps integration for address selection
- Communicates with backend via REST API

================
File: DEPLOY_RAILWAY.md
================
# Guía de Despliegue en Railway

Esta guía te ayudará a desplegar el backend del bot de WhatsApp y su base de datos PostgreSQL en Railway.

## Requisitos Previos

1. Cuenta en [Railway](https://railway.app)
2. Cuenta de GitHub con este repositorio
3. Credenciales de WhatsApp Business API
4. API Key de Google AI (Gemini) o OpenAI
5. Credenciales de Stripe (si usas pagos)

## Paso 1: Crear un Nuevo Proyecto en Railway

1. Inicia sesión en [Railway](https://railway.app)
2. Click en **"New Project"**
3. Selecciona **"Empty Project"**

## Paso 2: Agregar PostgreSQL

1. Dentro de tu proyecto, click en **"New"**
2. Selecciona **"Database"** → **"Add PostgreSQL"**
3. Railway creará automáticamente la base de datos con todas las credenciales

## Paso 3: Desplegar el Backend

1. En el mismo proyecto, click en **"New"** → **"GitHub Repo"**
2. Autoriza Railway para acceder a tu GitHub si es necesario
3. Selecciona tu repositorio `bot_backend`
4. En la configuración del servicio:
   - **Root Directory**: `/backend`
   - **Start Command**: Se detectará automáticamente del `railway.json`

## Paso 4: Conectar la Base de Datos

1. Click en tu servicio de backend
2. Ve a la pestaña **"Variables"**
3. Click en **"Add Variable Reference"**
4. Selecciona **"DATABASE_URL"** del servicio PostgreSQL
5. Railway conectará automáticamente los servicios

## Paso 5: Configurar Variables de Entorno

En la pestaña **"Variables"** del servicio backend, agrega las siguientes variables:

### Variables Obligatorias

```env
# WhatsApp Business API
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=tu_phone_number_id
WHATSAPP_ACCESS_TOKEN=tu_token_de_meta
WHATSAPP_VERIFY_TOKEN=un_token_secreto_que_tu_elijas

# API de IA (elige una)
GOOGLE_AI_API_KEY=AIza...tu_api_key_de_gemini

# Entorno
NODE_ENV=production

# Rate Limiting
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5
```

### Variables para Pagos (si las usas)

```env
STRIPE_SECRET_KEY=sk_live_...
STRIPE_WEBHOOK_SECRET=whsec_...
```

### Variables de URL (se actualizan después del deploy)

```env
NEXT_PUBLIC_BACKEND_BASE_URL=https://tu-servicio.railway.app
FRONTEND_BASE_URL=https://tu-frontend.railway.app
```

## Paso 6: Configurar el Dominio

1. Una vez desplegado, Railway te asignará un dominio automático
2. Ve a **"Settings"** → **"Networking"** → **"Generate Domain"**
3. Copia la URL generada (ejemplo: `https://bot-backend-production.up.railway.app`)
4. Actualiza la variable `NEXT_PUBLIC_BACKEND_BASE_URL` con esta URL

## Paso 7: Ejecutar Migraciones

Las migraciones se ejecutan automáticamente gracias al `railway.json`, pero si necesitas ejecutarlas manualmente:

1. Ve a la pestaña **"Deployments"**
2. Click en los tres puntos del deployment activo
3. Selecciona **"Run command"**
4. Ejecuta: `npm run migrate`

## Paso 8: Configurar Webhook en Meta

1. Ve a tu app en [Meta for Developers](https://developers.facebook.com)
2. En WhatsApp → Configuration → Webhook
3. Configura:
   - **Callback URL**: `https://tu-dominio-railway.app/backend/webhooks/whatsapp`
   - **Verify Token**: El mismo valor que pusiste en `WHATSAPP_VERIFY_TOKEN`
4. Suscríbete a los campos: `messages`, `messaging_postbacks`

## Paso 9: Verificar el Despliegue

1. Visita `https://tu-dominio-railway.app/backend` - Deberías ver un mensaje de bienvenida
2. Revisa los logs en Railway para asegurarte de que no hay errores
3. Envía un mensaje de prueba a tu número de WhatsApp Business

## Solución de Problemas

### Error de Conexión a Base de Datos

- Verifica que `DATABASE_URL` esté vinculada correctamente
- Los logs deberían mostrar: "Conexión a la base de datos establecida con éxito"

### Webhook no Responde

- Verifica que la URL del webhook sea correcta
- Asegúrate de que `WHATSAPP_VERIFY_TOKEN` coincida en Railway y Meta
- Revisa los logs para ver si llegan las peticiones

### Error 500 en las Peticiones

- Revisa que todas las variables de entorno obligatorias estén configuradas
- Verifica los logs del servicio en Railway
- Asegúrate de que las migraciones se ejecutaron correctamente

### El Bot no Responde

- Verifica que `GOOGLE_AI_API_KEY` sea válida
- Revisa que el número de WhatsApp esté en el formato correcto (con código de país)
- Verifica los logs para ver si se procesan los mensajes

## Comandos Útiles

Para ejecutar comandos en Railway:

```bash
# Ver logs en tiempo real
railway logs

# Ejecutar migraciones manualmente
railway run npm run migrate

# Ejecutar seeders
railway run npm run seed
```

## Monitoreo

1. **Logs**: Disponibles en la pestaña "Deployments" de cada servicio
2. **Métricas**: Railway muestra uso de CPU, memoria y red
3. **Base de Datos**: Puedes conectarte usando cualquier cliente PostgreSQL con las credenciales de Railway

## Costos

- Railway ofrece $5 USD gratis al mes
- PostgreSQL y el backend consumen aproximadamente $5-10 USD/mes en uso normal
- Monitorea tu uso en la sección "Usage" del proyecto

## Siguiente Paso

Una vez que el backend esté funcionando, puedes:
1. Configurar un dominio personalizado
2. Implementar CI/CD con GitHub Actions
3. Configurar backups automáticos de la base de datos
4. Agregar monitoreo con servicios externos

¿Necesitas ayuda con algún paso específico? ¡El bot ya debería estar funcionando!

================
File: LOCAL_DEVELOPMENT.md
================
# Guía de Desarrollo Local con Docker

Esta guía te ayudará a ejecutar el backend del bot de WhatsApp en tu máquina local usando Docker.

## Requisitos Previos

- Docker y Docker Compose instalados
- Git
- Node.js 18+ (para ejecutar comandos npm)
- Una API Key de Google AI (Gemini)

## Paso 1: Clonar el Repositorio

```bash
git clone <tu-repositorio>
cd bot_backend
```

## Paso 2: Crear Docker Compose

Crea un archivo `docker-compose.yml` en la raíz del proyecto:

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: bot_postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres123
      POSTGRES_DB: bot_restaurant_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    container_name: bot_backend
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - "5000:5000"
    environment:
      DATABASE_URL: postgresql://postgres:postgres123@postgres:5432/bot_restaurant_db
      NODE_ENV: development
      PORT: 5000
    env_file:
      - ./backend/.env
    volumes:
      - ./backend:/app
      - /app/node_modules
    command: npm run dev

volumes:
  postgres_data:
```

## Paso 3: Crear Dockerfile para el Backend

Crea el archivo `backend/Dockerfile`:

```dockerfile
FROM node:18-alpine

WORKDIR /app

# Copiar archivos de dependencias
COPY package*.json ./
COPY tsconfig.json ./

# Instalar dependencias
RUN npm ci

# Copiar prisma schema
COPY prisma ./prisma

# Generar Prisma Client
RUN npx prisma generate

# Copiar el resto del código
COPY . .

# Exponer puerto
EXPOSE 5000

# Comando por defecto
CMD ["npm", "run", "dev"]
```

## Paso 4: Configurar Variables de Entorno

Crea el archivo `backend/.env` basado en `.env.example`:

```bash
cd backend
cp .env.example .env
```

Edita `backend/.env` con tus valores:

```env
# Base de datos (Docker Compose la configura automáticamente)
DATABASE_URL=postgresql://postgres:postgres123@localhost:5432/bot_restaurant_db

# WhatsApp Business API (usa valores de prueba para desarrollo)
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=123456789
WHATSAPP_ACCESS_TOKEN=desarrollo_token_123
WHATSAPP_VERIFY_TOKEN=mi_token_verificacion_local

# API de IA - NECESITAS UNA REAL
GOOGLE_AI_API_KEY=AIza... # Obtén una en https://makersuite.google.com/app/apikey

# Stripe (opcional para desarrollo)
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Configuración de URLs
NEXT_PUBLIC_BACKEND_BASE_URL=http://localhost:5000
FRONTEND_BASE_URL=http://localhost:3000

# Rate Limiting
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5

# Entorno
NODE_ENV=development
```

## Paso 5: Iniciar los Servicios

```bash
# Desde la raíz del proyecto
docker-compose up -d

# Ver logs
docker-compose logs -f

# Ver solo logs del backend
docker-compose logs -f backend
```

## Paso 6: Ejecutar Migraciones y Seed

```bash
# Ejecutar migraciones
docker-compose exec backend npx prisma migrate dev

# Ejecutar seed (datos iniciales)
docker-compose exec backend npm run seed
```

## Paso 7: Verificar que Todo Funciona

### 1. Health Check
```bash
curl http://localhost:5000/backend
```

Deberías ver:
```json
{
  "message": "Bot Backend API is running",
  "version": "2.0.0",
  "timestamp": "2024-01-15T..."
}
```

### 2. Prisma Studio (Visualizar Base de Datos)
```bash
docker-compose exec backend npx prisma studio
```
Abre http://localhost:5555 en tu navegador

### 3. Probar Webhook
```bash
# Verificación GET
curl "http://localhost:5000/backend/webhook?hub.mode=subscribe&hub.verify_token=mi_token_verificacion_local&hub.challenge=test123"
```

### 4. Simular Mensaje de WhatsApp
```bash
curl -X POST http://localhost:5000/backend/webhook \
  -H "Content-Type: application/json" \
  -d '{
    "entry": [{
      "id": "ENTRY_ID",
      "changes": [{
        "value": {
          "messaging_product": "whatsapp",
          "metadata": {
            "display_phone_number": "15551234567",
            "phone_number_id": "123456789"
          },
          "messages": [{
            "from": "521234567890",
            "id": "MESSAGE_ID",
            "timestamp": "1234567890",
            "type": "text",
            "text": {
              "body": "Hola, quiero ver el menú"
            }
          }]
        }
      }]
    }]
  }'
```

## Comandos Útiles de Docker

```bash
# Detener servicios
docker-compose down

# Detener y eliminar volúmenes (BORRA LA BD)
docker-compose down -v

# Reconstruir imagen del backend
docker-compose build backend

# Ejecutar comandos en el contenedor
docker-compose exec backend npm run migrate
docker-compose exec backend npm run seed
docker-compose exec backend npm run studio

# Ver logs
docker-compose logs -f backend
docker-compose logs -f postgres

# Reiniciar un servicio
docker-compose restart backend
```

## Desarrollo con Hot Reload

El backend está configurado con `ts-node` en modo watch, por lo que:
- Los cambios en el código se reflejan automáticamente
- No necesitas reiniciar el contenedor
- Solo guarda los archivos y el servidor se recargará

## Solución de Problemas

### Error: "Cannot connect to database"
```bash
# Verifica que PostgreSQL esté corriendo
docker-compose ps

# Revisa los logs de PostgreSQL
docker-compose logs postgres
```

### Error: "Google AI API key not valid"
- Asegúrate de tener una API key válida de Google AI
- Obtén una en: https://makersuite.google.com/app/apikey

### Error: "Port 5000 already in use"
```bash
# Encuentra qué proceso usa el puerto
lsof -i :5000

# O cambia el puerto en docker-compose.yml
ports:
  - "5001:5000"
```

### Limpiar y empezar de nuevo
```bash
# Detener todo y eliminar volúmenes
docker-compose down -v

# Eliminar node_modules
rm -rf backend/node_modules

# Reconstruir todo
docker-compose build --no-cache
docker-compose up -d
```

## Testing Local

### Script de Pruebas Automatizadas

Crea `test-local.sh`:

```bash
#!/bin/bash

echo "🧪 Ejecutando pruebas del backend..."

# Colores
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

# URL base
BASE_URL="http://localhost:5000/backend"

# 1. Health check
echo -e "\n1. Health Check:"
response=$(curl -s -w "\n%{http_code}" $BASE_URL)
http_code=$(echo "$response" | tail -n1)
body=$(echo "$response" | head -n-1)

if [ "$http_code" == "200" ]; then
    echo -e "${GREEN}✓ Health check pasó${NC}"
    echo "$body" | jq '.'
else
    echo -e "${RED}✗ Health check falló (HTTP $http_code)${NC}"
fi

# 2. Webhook verification
echo -e "\n2. Verificación de Webhook:"
response=$(curl -s -w "\n%{http_code}" "$BASE_URL/webhook?hub.mode=subscribe&hub.verify_token=mi_token_verificacion_local&hub.challenge=test123")
http_code=$(echo "$response" | tail -n1)
body=$(echo "$response" | head -n-1)

if [ "$http_code" == "200" ] && [ "$body" == "test123" ]; then
    echo -e "${GREEN}✓ Verificación de webhook pasó${NC}"
else
    echo -e "${RED}✗ Verificación de webhook falló${NC}"
fi

# 3. Test OTP
echo -e "\n3. Test de OTP:"
response=$(curl -s -w "\n%{http_code}" -X POST $BASE_URL/otp/verify \
  -H "Content-Type: application/json" \
  -d '{"customerId":"test123","otp":"123456"}')
http_code=$(echo "$response" | tail -n1)

if [ "$http_code" == "200" ]; then
    echo -e "${GREEN}✓ Endpoint OTP funcionando${NC}"
else
    echo -e "${RED}✗ Endpoint OTP falló${NC}"
fi

echo -e "\n✅ Pruebas completadas"
```

Hazlo ejecutable:
```bash
chmod +x test-local.sh
./test-local.sh
```

## Integración con ngrok (para webhooks reales)

Si quieres probar con webhooks reales de WhatsApp:

```bash
# Instalar ngrok
brew install ngrok  # macOS
# o descarga de https://ngrok.com

# Exponer tu backend local
ngrok http 5000

# Obtendrás una URL como: https://abc123.ngrok.io
# Usa esta URL en Meta Developers como webhook:
# https://abc123.ngrok.io/backend/webhook
```

## Próximos Pasos

1. **Desarrollo**: Modifica el código en `backend/src`
2. **Pruebas**: Usa los scripts de prueba
3. **Depuración**: Revisa logs con `docker-compose logs -f backend`
4. **Base de datos**: Usa Prisma Studio para ver/editar datos
5. **Deployment**: Cuando estés listo, despliega a Railway

¡Feliz desarrollo! 🚀

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: backend/src/common/services/errors/errorMessages.ts
================
import { ErrorCode } from './types';

interface ErrorMessageConfig {
  user: string;
  log: string;
}

export const ERROR_MESSAGES: Record<ErrorCode, ErrorMessageConfig> = {
  // Business Logic Errors
  [ErrorCode.ORDER_NOT_FOUND]: {
    user: "❌ Lo siento, no se pudo encontrar tu orden. 🔍",
    log: "Order not found"
  },
  [ErrorCode.ORDER_CANNOT_CANCEL]: {
    user: "⚠️ Lo siento, esta orden ya no se puede cancelar.",
    log: "Cannot cancel order - invalid status"
  },
  [ErrorCode.RESTAURANT_CLOSED]: {
    user: "🚫 Lo sentimos, estamos cerrados en este momento. 😴",
    log: "Restaurant is closed"
  },
  [ErrorCode.NOT_ACCEPTING_ORDERS]: {
    user: "🚫🍽️ Lo sentimos, no estamos aceptando pedidos en este momento. 😔",
    log: "Restaurant not accepting orders"
  },
  [ErrorCode.PAYMENT_LINK_EXISTS]: {
    user: "⚠️ Ya existe un enlace de pago activo para esta orden.",
    log: "Payment link already exists"
  },
  [ErrorCode.CUSTOMER_NOT_FOUND]: {
    user: "❌ No se encontró información del cliente.",
    log: "Customer not found"
  },
  
  // Validation Errors
  [ErrorCode.INVALID_PRODUCT]: {
    user: "❌ Uno o más productos no son válidos. Por favor, verifica tu pedido.",
    log: "Invalid product ID or configuration"
  },
  [ErrorCode.MISSING_DELIVERY_INFO]: {
    user: "📍 No encontramos tu información de entrega. Por favor, regístrala primero.",
    log: "Missing delivery information"
  },
  [ErrorCode.INVALID_SCHEDULE_TIME]: {
    user: "⏰ El horario seleccionado no es válido. Por favor, elige otro horario.",
    log: "Invalid scheduled delivery time"
  },
  [ErrorCode.MISSING_REQUIRED_FIELD]: {
    user: "❌ Falta información requerida. Por favor, completa todos los campos.",
    log: "Missing required field"
  },
  [ErrorCode.INVALID_ORDER_TYPE]: {
    user: "❌ Tipo de orden no válido. Por favor, selecciona entrega a domicilio o recolección.",
    log: "Invalid order type"
  },
  
  // Technical Errors
  [ErrorCode.DATABASE_ERROR]: {
    user: "🔧 Hubo un problema técnico. Por favor, intenta de nuevo más tarde.",
    log: "Database operation failed"
  },
  [ErrorCode.WHATSAPP_API_ERROR]: {
    user: "📱 Hubo un problema al enviar el mensaje. Por favor, intenta de nuevo.",
    log: "WhatsApp API error"
  },
  [ErrorCode.PAYMENT_PROCESSING_ERROR]: {
    user: "💳 Hubo un problema al procesar el pago. Por favor, intenta de nuevo.",
    log: "Payment processing error"
  },
  [ErrorCode.AI_SERVICE_ERROR]: {
    user: "🤖 Hubo un problema al procesar tu solicitud. Por favor, intenta de nuevo.",
    log: "AI service error"
  },
  [ErrorCode.TRANSCRIPTION_ERROR]: {
    user: "🎤 Hubo un problema al procesar tu mensaje de audio. Por favor, intenta nuevamente o envía un mensaje de texto.",
    log: "Audio transcription failed"
  },
  
  // External Service Errors
  [ErrorCode.STRIPE_ERROR]: {
    user: "💳 El servicio de pagos no está disponible temporalmente. Por favor, intenta más tarde.",
    log: "Stripe service error"
  },
  [ErrorCode.GEMINI_ERROR]: {
    user: "🤖 El asistente no está disponible temporalmente. Por favor, intenta más tarde.",
    log: "Gemini AI service error"
  },
  [ErrorCode.WHATSAPP_ERROR]: {
    user: "📱 Error en el servicio de WhatsApp. Por favor, intenta más tarde.",
    log: "WhatsApp service error"
  },
  
  // Rate Limit
  [ErrorCode.RATE_LIMIT_EXCEEDED]: {
    user: "⏳ Has alcanzado el límite de mensajes. Por favor espera unos minutos antes de enviar más mensajes.",
    log: "Rate limit exceeded"
  }
};

================
File: backend/src/common/services/errors/ErrorService.ts
================
import logger from '../../utils/logger';
import { sendWhatsAppMessage } from '../../../services/whatsapp';
import { ErrorCode, ErrorType, ErrorContext, ErrorResponse } from './types';
import { ERROR_MESSAGES } from './errorMessages';
import { BaseError } from './CustomErrors';

export class ErrorService {
  /**
   * Manejador principal de errores que procesa todos los errores de manera estandarizada
   */
  static async handleError(
    error: unknown,
    context: ErrorContext
  ): Promise<ErrorResponse> {
    // Si ya es nuestro error personalizado, usar sus propiedades
    if (error instanceof BaseError) {
      return this.createErrorResponse(error.code, error.type, context);
    }

    // Intentar identificar el tipo y código del error
    const { errorCode, errorType } = this.identifyError(error);
    
    // Registrar el error con contexto
    this.logError(error, errorCode, context);
    
    return this.createErrorResponse(errorCode, errorType, context);
  }

  /**
   * Enviar mensaje de error al usuario vía WhatsApp
   */
  static async sendErrorToUser(
    userId: string,
    errorResponse: ErrorResponse
  ): Promise<void> {
    if (errorResponse.shouldNotifyUser) {
      try {
        await sendWhatsAppMessage(userId, errorResponse.userMessage);
      } catch (sendError) {
        logger.error('Failed to send error message to user:', {
          userId,
          errorCode: errorResponse.errorCode,
          sendError
        });
      }
    }
  }

  /**
   * Crear una respuesta de error estandarizada
   */
  private static createErrorResponse(
    errorCode: ErrorCode,
    errorType: ErrorType,
    context?: ErrorContext
  ): ErrorResponse {
    const errorConfig = ERROR_MESSAGES[errorCode];
    
    return {
      userMessage: errorConfig.user,
      logMessage: errorConfig.log,
      errorCode,
      errorType,
      shouldNotifyUser: this.shouldNotifyUser(errorType),
      context
    };
  }

  /**
   * Identificar tipo y código de error desde un error desconocido
   */
  private static identifyError(error: unknown): {
    errorCode: ErrorCode;
    errorType: ErrorType;
  } {
    const errorMessage = error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();

    // Verificar patrones de error específicos
    if (errorMessage.includes('order not found') || errorMessage.includes('orden no encontrada')) {
      return { errorCode: ErrorCode.ORDER_NOT_FOUND, errorType: ErrorType.BUSINESS_LOGIC };
    }
    
    if (errorMessage.includes('rate limit') || errorMessage.includes('límite')) {
      return { errorCode: ErrorCode.RATE_LIMIT_EXCEEDED, errorType: ErrorType.RATE_LIMIT };
    }
    
    if (errorMessage.includes('stripe')) {
      return { errorCode: ErrorCode.STRIPE_ERROR, errorType: ErrorType.EXTERNAL_SERVICE };
    }
    
    if (errorMessage.includes('whatsapp')) {
      return { errorCode: ErrorCode.WHATSAPP_ERROR, errorType: ErrorType.EXTERNAL_SERVICE };
    }
    
    if (errorMessage.includes('database') || errorMessage.includes('prisma')) {
      return { errorCode: ErrorCode.DATABASE_ERROR, errorType: ErrorType.TECHNICAL };
    }
    
    if (errorMessage.includes('validation') || errorMessage.includes('invalid')) {
      return { errorCode: ErrorCode.MISSING_REQUIRED_FIELD, errorType: ErrorType.VALIDATION };
    }
    
    if (errorMessage.includes('transcription') || errorMessage.includes('audio')) {
      return { errorCode: ErrorCode.TRANSCRIPTION_ERROR, errorType: ErrorType.TECHNICAL };
    }
    
    if (errorMessage.includes('ai') || errorMessage.includes('gemini')) {
      return { errorCode: ErrorCode.AI_SERVICE_ERROR, errorType: ErrorType.EXTERNAL_SERVICE };
    }

    // Por defecto a error técnico
    return { errorCode: ErrorCode.DATABASE_ERROR, errorType: ErrorType.TECHNICAL };
  }

  /**
   * Registro mejorado de errores con contexto
   */
  private static logError(
    error: unknown,
    errorCode: ErrorCode,
    context: ErrorContext
  ): void {
    const errorDetails = {
      errorCode,
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      context,
      timestamp: new Date().toISOString()
    };

    logger.error('Error occurred:', errorDetails);
  }

  /**
   * Determinar si el usuario debe ser notificado basado en el tipo de error
   */
  private static shouldNotifyUser(errorType: ErrorType): boolean {
    // Siempre notificar para errores de lógica de negocio, validación y límite de tasa
    // A veces notificar para errores técnicos (depende del contexto)
    // Raramente notificar para errores de servicio externo (usualmente reintentar primero)
    return [
      ErrorType.BUSINESS_LOGIC,
      ErrorType.VALIDATION,
      ErrorType.RATE_LIMIT
    ].includes(errorType);
  }

  /**
   * Manejar error y enviar al usuario en una operación
   */
  static async handleAndSendError(
    error: unknown,
    userId: string,
    context: ErrorContext
  ): Promise<void> {
    const errorResponse = await this.handleError(error, context);
    await this.sendErrorToUser(userId, errorResponse);
  }
}

================
File: backend/src/common/services/errors/index.ts
================
export * from './types';
export * from './CustomErrors';
export * from './errorMessages';
export { ErrorService } from './ErrorService';

================
File: backend/src/common/services/errors/types.ts
================
export enum ErrorType {
  BUSINESS_LOGIC = 'BUSINESS_LOGIC',
  VALIDATION = 'VALIDATION',
  TECHNICAL = 'TECHNICAL',
  EXTERNAL_SERVICE = 'EXTERNAL_SERVICE',
  RATE_LIMIT = 'RATE_LIMIT'
}

export enum ErrorCode {
  // Business Logic
  ORDER_NOT_FOUND = 'BL001',
  ORDER_CANNOT_CANCEL = 'BL003',
  RESTAURANT_CLOSED = 'BL004',
  NOT_ACCEPTING_ORDERS = 'BL005',
  PAYMENT_LINK_EXISTS = 'BL006',
  CUSTOMER_NOT_FOUND = 'BL007',
  
  // Validation
  INVALID_PRODUCT = 'VAL001',
  MISSING_DELIVERY_INFO = 'VAL002',
  INVALID_SCHEDULE_TIME = 'VAL003',
  MISSING_REQUIRED_FIELD = 'VAL004',
  INVALID_ORDER_TYPE = 'VAL005',
  
  // Technical
  DATABASE_ERROR = 'TECH001',
  WHATSAPP_API_ERROR = 'TECH002',
  PAYMENT_PROCESSING_ERROR = 'TECH003',
  AI_SERVICE_ERROR = 'TECH004',
  TRANSCRIPTION_ERROR = 'TECH005',
  
  // External Service
  STRIPE_ERROR = 'EXT001',
  GEMINI_ERROR = 'EXT002',
  WHATSAPP_ERROR = 'EXT003',
  
  // Rate Limit
  RATE_LIMIT_EXCEEDED = 'RL001'
}

export interface ErrorContext {
  userId?: string;
  customerId?: string;
  orderId?: number;
  operation?: string;
  metadata?: Record<string, any>;
}

export interface ErrorResponse {
  userMessage: string;
  logMessage: string;
  errorCode: ErrorCode;
  errorType: ErrorType;
  shouldNotifyUser: boolean;
  context?: ErrorContext;
}

================
File: backend/src/common/types/index.ts
================
/**
 * Central type export file
 * All common types should be imported from here
 */

// Order types
export * from './order.types';
export * from './otp.types';

// Menu types
export * from './menu';

// Restaurant types
export * from './restaurant';

// WhatsApp & Webhook types
export * from './whatsapp.types';
export * from './webhook.types';

// Response types are now in messaging/types/responses

// Agent types removed - using unified agent now

// Service types
export * from './services.types';

// Re-export commonly used Prisma types
export type {
  Customer,
  Order,
  OrderType,
  OrderStatus,
  PaymentStatus,
  Product,
  ProductVariant,
  Category,
  Subcategory,
  ProductModifier,
  ModifierGroup,
  PizzaIngredient,
  PizzaHalf,
  IngredientAction,
  PreOrder,
  RestaurantConfig,
  BusinessHours
} from '@prisma/client';

================
File: backend/src/common/types/services.types.ts
================
/**
 * Service-specific types that are used across multiple services
 */

// Delivery Info types (compatible with Address model)
export interface DeliveryInfoInput {
  street?: string | null;
  number?: string | null;
  interiorNumber?: string | null;
  neighborhood?: string | null;
  city?: string | null;
  state?: string | null;
  zipCode?: string | null;
  country?: string | null;
  references?: string | null;
  latitude?: number | null;
  longitude?: number | null;
  isDefault?: boolean;
}

// Product Calculation types
export interface OrderItemInput {
  productId?: string;
  productVariantId?: string;
  quantity: number;
  comments?: string;
  selectedModifiers?: string[];
  selectedPizzaIngredients?: Array<{
    pizzaIngredientId: string;
    half: string;
    action: string;
  }>;
}

export interface CalculatedItem {
  product: any;
  productVariant: any;
  quantity: number;
  itemPrice: number;
  comments?: string;
  modifiers: any[];
  pizzaIngredients: any[];
}

// AI Context types
export enum ContextType {
  NEW_ORDER = "nuevo_pedido",
  CUSTOMER_SERVICE = "servicio_cliente",
  GENERAL_INQUIRY = "consulta_general",
  MENU_INQUIRY = "consulta_menu",
  COMPLAINT = "queja",
  UNKNOWN = "desconocido"
}

// Order Management types
export interface OrderCreationResult {
  order: any;
  formattedOrder: any;
  message: string;
}

export interface PreOrderCreationResult {
  preOrderId: number;
  products: any[];
  totalCost: number;
  estimatedTime: number;
}

================
File: backend/src/services/messaging/middlewares/RateLimitMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { prisma } from '../../../server';
import { sendWhatsAppMessage } from '../../whatsapp';
import { RATE_LIMIT_MESSAGE } from '../../../common/config/predefinedMessages';
import logger from '../../../common/utils/logger';
import { env } from '../../../common/config/envValidator';

export class RateLimitMiddleware implements MessageMiddleware {
  name = 'RateLimitMiddleware';
  
  private readonly RATE_LIMIT_MESSAGES = parseInt(env.RATE_LIMIT_MAX_MESSAGES);
  private readonly RATE_LIMIT_WINDOW_MINUTES = parseInt(env.RATE_LIMIT_TIME_WINDOW_MINUTES);

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      const whatsappPhoneNumber = context.message.from;
      const now = new Date();
      const windowStart = new Date(now.getTime() - this.RATE_LIMIT_WINDOW_MINUTES * 60 * 1000);

      // Verificar límite de tasa existente
      const rateLimit = await prisma.messageRateLimit.findUnique({
        where: { whatsappPhoneNumber }
      });

      if (rateLimit && rateLimit.lastMessageTime > windowStart) {
        // Dentro de la ventana de límite de tasa
        if (rateLimit.messageCount >= this.RATE_LIMIT_MESSAGES) {
          // Límite de tasa excedido
          logger.warn(`Rate limit exceeded for customer ${whatsappPhoneNumber}`);
          await sendWhatsAppMessage(whatsappPhoneNumber, RATE_LIMIT_MESSAGE);
          context.stop();
          return context;
        }

        // Incrementar contador de mensajes
        await prisma.messageRateLimit.update({
          where: { whatsappPhoneNumber },
          data: {
            messageCount: rateLimit.messageCount + 1,
            lastMessageTime: now
          }
        });
      } else {
        // Fuera de la ventana de límite o sin registro de límite
        await prisma.messageRateLimit.upsert({
          where: { whatsappPhoneNumber },
          update: {
            messageCount: 1,
            lastMessageTime: now
          },
          create: {
            whatsappPhoneNumber,
            messageCount: 1,
            lastMessageTime: now
          }
        });
      }

      return context;
    } catch (error) {
      logger.error('Error in RateLimitMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/orders/services/ProductCalculationService.ts
================
import { prisma } from "../../../server";
import { ValidationError, ErrorCode } from "../../../common/services/errors";
import logger from "../../../common/utils/logger";
import { OrderItemInput, CalculatedItem } from "../../../common/types";

export class ProductCalculationService {
  /**
   * Calculate items and prices for an order
   */
  static async calculateOrderItems(orderItems: OrderItemInput[]): Promise<{
    items: CalculatedItem[];
    totalCost: number;
  }> {
    const calculatedItems = await Promise.all(
      orderItems.map(async (item) => await this.calculateSingleItem(item))
    );

    const totalCost = calculatedItems.reduce((sum, item) => sum + item.itemPrice, 0);

    return {
      items: calculatedItems,
      totalCost
    };
  }

  /**
   * Calculate a single order item
   */
  private static async calculateSingleItem(item: OrderItemInput): Promise<CalculatedItem> {
    logger.info("Processing item:", JSON.stringify(item, null, 2));

    let product, productVariant;
    let itemPrice = 0;
    
    logger.info(`Starting calculation for item with productId: ${item.productId}, variantId: ${item.productVariantId}`);

    // Get product and variant
    if (item.productId) {
      product = await prisma.product.findUnique({
        where: { id: item.productId }
      });

      if (!product) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Product not found: ${item.productId}`, { metadata: { productId: item.productId } });
      }
    }

    if (item.productVariantId) {
      productVariant = await prisma.productVariant.findUnique({
        where: { id: item.productVariantId },
        include: { product: true }
      });

      if (!productVariant) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Product variant not found: ${item.productVariantId}`, { metadata: { productVariantId: item.productVariantId } });
      }

      product = productVariant.product;
      itemPrice = productVariant.price;
      logger.info(`Found variant ${productVariant.name} with price: ${productVariant.price}`);
    } else if (product && product.price !== null) {
      // If no variant but product has price, use product price
      itemPrice = product.price;
      logger.info(`Using product price: ${product.price}`);
    }

    if (!product && !productVariant) {
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        'Either productId or productVariantId must be provided',
        { metadata: { item } }
      );
    }

    // Calculate modifiers
    const modifiers = await this.calculateModifiers(item.selectedModifiers || [], product?.id);
    itemPrice += modifiers.totalPrice;

    // Calculate pizza ingredients
    const pizzaIngredients = await this.calculatePizzaIngredients(
      item.selectedPizzaIngredients || [],
      product?.id
    );

    // Total item price
    itemPrice = itemPrice * item.quantity;
    
    logger.info(`Final item price after quantity (${item.quantity}): ${itemPrice}`);

    return {
      product,
      productVariant,
      quantity: item.quantity,
      itemPrice,
      subtotal: itemPrice, // Add subtotal for compatibility
      productName: product?.name,
      variantName: productVariant?.name,
      comments: item.comments,
      modifiers: modifiers.items,
      pizzaIngredients
    };
  }

  /**
   * Calculate modifiers for a product
   */
  private static async calculateModifiers(
    selectedModifierIds: string[],
    productId?: string
  ): Promise<{ items: any[]; totalPrice: number }> {
    if (!selectedModifierIds.length) {
      return { items: [], totalPrice: 0 };
    }

    const modifiers = await prisma.productModifier.findMany({
      where: { 
        id: { in: selectedModifierIds }
      },
      include: { modifierGroup: true }
    });

    // Validate all modifiers were found
    if (modifiers.length !== selectedModifierIds.length) {
      const foundIds = modifiers.map((m: any) => m.id);
      const notFoundIds = selectedModifierIds.filter(id => !foundIds.includes(id));
      
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        `Modifiers not found: ${notFoundIds.join(', ')}`,
        { metadata: { notFoundIds, productId } }
      );
    }

    // Group by modifier group and validate
    const modifiersByGroup = modifiers.reduce((acc: any, mod: any) => {
      const groupId = mod.modifierGroup.id;
      if (!acc[groupId]) {
        acc[groupId] = {
          group: mod.modifierGroup,
          modifiers: []
        };
      }
      acc[groupId].modifiers.push(mod);
      return acc;
    }, {} as Record<string, { group: any; modifiers: any[] }>);

    // Validate modifier selection rules
    for (const groupData of Object.values(modifiersByGroup)) {
      const { group, modifiers: groupModifiers } = groupData as { group: any; modifiers: any[] };
      if (group.required && groupModifiers.length === 0) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Required modifier group ${group.name} must have at least one selection`, { metadata: { modifierGroupName: group.name } });
      }

      if (!group.acceptsMultiple && groupModifiers.length > 1) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Modifier group ${group.name} only accepts one selection`, { metadata: { modifierGroupName: group.name, selectedCount: groupModifiers.length } });
      }
    }

    const totalPrice = modifiers.reduce((sum: number, mod: any) => sum + mod.price, 0);

    return {
      items: modifiers,
      totalPrice
    };
  }

  /**
   * Calculate pizza ingredients
   */
  private static async calculatePizzaIngredients(
    selectedIngredients: Array<{
      pizzaIngredientId: string;
      half: string;
      action: string;
    }>,
    productId?: string
  ): Promise<any[]> {
    if (!selectedIngredients.length) {
      return [];
    }

    const ingredientIds = selectedIngredients.map(i => i.pizzaIngredientId);
    const ingredients = await prisma.pizzaIngredient.findMany({
      where: {
        id: { in: ingredientIds },
        products: productId ? { some: { id: productId } } : undefined
      }
    });

    // Validate all ingredients were found
    if (ingredients.length !== ingredientIds.length) {
      const foundIds = ingredients.map(i => i.id);
      const notFoundIds = ingredientIds.filter(id => !foundIds.includes(id));
      
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        `Pizza ingredients not found: ${notFoundIds.join(', ')}`,
        { metadata: { notFoundIds, productId } }
      );
    }

    // Map ingredients with their selection details
    return selectedIngredients.map(selected => {
      const ingredient = ingredients.find(i => i.id === selected.pizzaIngredientId);
      return {
        ...ingredient,
        half: selected.half,
        action: selected.action
      };
    });
  }
}

================
File: backend/src/services/payment/StripeService.ts
================
import { Request, Response } from 'express';
import Stripe from 'stripe';
import logger from '../../common/utils/logger';
import { env } from '../../common/config/envValidator';
import { ExternalServiceError, ErrorCode } from '../../common/services/errors';
import { prisma } from '../../server';

/**
 * Service for handling Stripe payment operations
 */
export class StripeService {
  private static stripe: Stripe | null = null;
  private static webhookSecret: string = '';
  private static initialized = false;

  /**
   * Initialize Stripe client (lazy initialization)
   */
  private static initialize(): void {
    if (this.initialized) {
      return;
    }

    try {
      const stripeKey = env.STRIPE_SECRET_KEY;
      if (stripeKey) {
        this.stripe = new Stripe(stripeKey, {
          apiVersion: '2024-10-28.acacia'
        });
        this.webhookSecret = env.STRIPE_WEBHOOK_SECRET || '';
        logger.info('Stripe service initialized');
      } else {
        logger.warn('Stripe service not configured - missing STRIPE_SECRET_KEY');
      }
    } catch (error) {
      logger.error('Failed to initialize Stripe service:', error);
    } finally {
      this.initialized = true;
    }
  }

  /**
   * Check if Stripe is configured
   */
  static isConfigured(): boolean {
    this.initialize();
    return this.stripe !== null;
  }

  /**
   * Handle Stripe webhook
   */
  static async handleWebhook(req: Request, res: Response): Promise<void> {
    this.initialize();
    
    if (!this.stripe) {
      logger.warn('Stripe webhook called but Stripe is not configured');
      res.status(503).json({ error: 'Stripe service unavailable' });
      return;
    }
    
    try {
      const sig = req.headers['stripe-signature'] as string;
      
      let event: Stripe.Event;
      
      try {
        event = this.stripe.webhooks.constructEvent(req.body, sig, this.webhookSecret);
      } catch (err: any) {
        logger.error('Webhook signature verification failed:', err.message);
        res.status(400).send(`Webhook Error: ${err.message}`);
        return;
      }
      
      // Handle the event
      switch (event.type) {
        case 'checkout.session.completed':
          const session = event.data.object as Stripe.Checkout.Session;
          await this.handleCompletedCheckout(session);
          break;
          
        case 'payment_intent.succeeded':
          const paymentIntent = event.data.object as Stripe.PaymentIntent;
          logger.info('Payment succeeded:', paymentIntent.id);
          break;
          
        default:
          logger.info(`Unhandled event type ${event.type}`);
      }
      
      res.json({ received: true });
    } catch (error) {
      logger.error('Error handling Stripe webhook:', error);
      res.status(500).send('Internal Server Error');
    }
  }

  /**
   * Handle completed checkout session
   */
  private static async handleCompletedCheckout(session: Stripe.Checkout.Session): Promise<void> {
    try {
      logger.info('Checkout session completed:', session.id);
      
      // Update order payment status
      if (session.metadata?.orderId) {
        await prisma.order.update({
          where: { id: session.metadata.orderId },
          data: {
            paymentStatus: 'PAID',
            stripeSessionId: session.id
          }
        });
        
        logger.info(`Order ${session.metadata.orderId} marked as paid`);
      }
    } catch (error) {
      logger.error('Error handling completed checkout:', error);
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Failed to handle completed checkout',
        { metadata: { sessionId: session.id } }
      );
    }
  }

  /**
   * Create a checkout session for an order
   */
  static async createCheckoutSession(
    orderId: number, 
    amount: number, 
    customerPhone: string
  ): Promise<Stripe.Checkout.Session> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured',
        { metadata: { orderId } }
      );
    }

    try {
      const session = await this.stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [{
          price_data: {
            currency: 'mxn',
            product_data: {
              name: `Orden #${orderId}`,
              description: 'Pedido de establecimiento'
            },
            unit_amount: Math.round(amount * 100) // Convert to cents
          },
          quantity: 1
        }],
        mode: 'payment',
        success_url: `${env.FRONTEND_BASE_URL}/success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${env.FRONTEND_BASE_URL}/cancel`,
        metadata: {
          orderId: orderId.toString(),
          customerPhone
        }
      });
      
      logger.info(`Created checkout session ${session.id} for order ${orderId}`);
      return session;
    } catch (error) {
      logger.error('Error creating checkout session:', error);
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Failed to create checkout session',
        { metadata: { orderId, amount } }
      );
    }
  }

  /**
   * Get checkout session by ID
   */
  static async getCheckoutSession(sessionId: string): Promise<Stripe.Checkout.Session | null> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured',
        { metadata: { sessionId } }
      );
    }

    try {
      const session = await this.stripe.checkout.sessions.retrieve(sessionId);
      return session;
    } catch (error) {
      logger.error('Error retrieving checkout session:', error);
      return null;
    }
  }

  /**
   * Cancel payment intent
   */
  static async cancelPaymentIntent(paymentIntentId: string): Promise<void> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured',
        { metadata: { paymentIntentId } }
      );
    }

    try {
      await this.stripe.paymentIntents.cancel(paymentIntentId);
      logger.info(`Cancelled payment intent ${paymentIntentId}`);
    } catch (error) {
      logger.error('Error cancelling payment intent:', error);
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Failed to cancel payment intent',
        { metadata: { paymentIntentId } }
      );
    }
  }
}

================
File: backend/src/services/restaurant/RestaurantService.ts
================
import { prisma } from '../../server';
import { RestaurantConfig, BusinessHours } from '../../common/types';
import logger from '../../common/utils/logger';
import { BusinessLogicError, ErrorCode } from '../../common/services/errors';

/**
 * Service for managing restaurant configuration and business hours
 */
export class RestaurantService {
  private static configCache: RestaurantConfig | null = null;
  private static businessHoursCache: BusinessHours[] | null = null;

  /**
   * Get restaurant configuration (with caching)
   */
  static async getConfig(): Promise<RestaurantConfig> {
    try {
      // Return cached config if available
      if (this.configCache) {
        return this.configCache;
      }

      // Get or create config
      let config = await prisma.restaurantConfig.findFirst();
      
      if (!config) {
        config = await prisma.restaurantConfig.create({
          data: {
            acceptingOrders: true,
            estimatedPickupTime: 20,
            estimatedDeliveryTime: 40
          }
        });
        logger.info('Created default restaurant configuration');
      }

      this.configCache = config;
      return config;
    } catch (error) {
      logger.error('Error getting restaurant config:', error);
      // Return default config if error
      return {
        id: 1,
        acceptingOrders: true,
        estimatedPickupTime: 20,
        estimatedDeliveryTime: 40
      } as RestaurantConfig;
    }
  }

  /**
   * Update restaurant configuration
   */
  static async updateConfig(data: Partial<RestaurantConfig>): Promise<RestaurantConfig> {
    try {
      const config = await prisma.restaurantConfig.findFirst();
      
      if (!config) {
        throw new BusinessLogicError(
          ErrorCode.ORDER_NOT_FOUND,
          'Restaurant configuration not found'
        );
      }

      const { id, ...updateData } = data;
      const updated = await prisma.restaurantConfig.update({
        where: { id: config.id },
        data: updateData as any
      });

      // Clear caches
      this.clearCache();
      
      // Clear timezone cache if timezone was updated
      if (data.timeZone) {
        const { clearTimeZoneCache } = await import('../../common/utils/timeUtils');
        clearTimeZoneCache();
      }

      logger.info('Restaurant configuration updated:', data);
      return updated;
    } catch (error) {
      logger.error('Error updating restaurant config:', error);
      throw error;
    }
  }

  /**
   * Toggle accepting orders
   */
  static async toggleAcceptingOrders(accepting: boolean): Promise<RestaurantConfig> {
    return this.updateConfig({ acceptingOrders: accepting });
  }

  /**
   * Get business hours for a specific day
   */
  static async getBusinessHoursForDay(dayOfWeek: number): Promise<BusinessHours | null> {
    try {
      const config = await this.getConfig();
      
      const businessHours = await prisma.businessHours.findUnique({
        where: {
          restaurantConfigId_dayOfWeek: {
            restaurantConfigId: config.id,
            dayOfWeek: dayOfWeek
          }
        }
      });

      return businessHours;
    } catch (error) {
      logger.error(`Error getting business hours for day ${dayOfWeek}:`, error);
      return null;
    }
  }

  /**
   * Get all business hours
   */
  static async getAllBusinessHours(): Promise<BusinessHours[]> {
    try {
      if (this.businessHoursCache) {
        return this.businessHoursCache;
      }

      const config = await this.getConfig();
      const businessHours = await prisma.businessHours.findMany({
        where: { restaurantConfigId: config.id },
        orderBy: { dayOfWeek: 'asc' }
      });

      this.businessHoursCache = businessHours;
      return businessHours;
    } catch (error) {
      logger.error('Error getting all business hours:', error);
      return [];
    }
  }

  /**
   * Update business hours for a specific day
   */
  static async updateBusinessHours(
    dayOfWeek: number, 
    data: { openingTime?: string; closingTime?: string; isClosed?: boolean }
  ): Promise<BusinessHours> {
    try {
      const config = await this.getConfig();

      const businessHours = await prisma.businessHours.upsert({
        where: {
          restaurantConfigId_dayOfWeek: {
            restaurantConfigId: config.id,
            dayOfWeek
          }
        },
        update: data,
        create: {
          restaurantConfigId: config.id,
          dayOfWeek,
          ...data
        }
      });

      // Clear cache
      this.businessHoursCache = null;
      
      logger.info(`Updated business hours for day ${dayOfWeek}:`, data);
      return businessHours;
    } catch (error) {
      logger.error('Error updating business hours:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to update business hours',
        { metadata: { dayOfWeek, data } }
      );
    }
  }

  /**
   * Check if restaurant is currently open
   */
  static async isOpen(date: Date = new Date()): Promise<boolean> {
    try {
      const dayOfWeek = date.getDay();
      const businessHours = await this.getBusinessHoursForDay(dayOfWeek);

      if (!businessHours || businessHours.isClosed || !businessHours.openingTime || !businessHours.closingTime) {
        return false;
      }

      const currentTime = date.getHours() * 60 + date.getMinutes();
      const [openHour, openMinute] = businessHours.openingTime.split(':').map(Number);
      const [closeHour, closeMinute] = businessHours.closingTime.split(':').map(Number);
      
      const openTime = openHour * 60 + openMinute;
      const closeTime = closeHour * 60 + closeMinute;

      return currentTime >= openTime && currentTime <= closeTime;
    } catch (error) {
      logger.error('Error checking if restaurant is open:', error);
      return false;
    }
  }

  /**
   * Clear all caches
   */
  static clearCache(): void {
    this.configCache = null;
    this.businessHoursCache = null;
    logger.debug('Restaurant service caches cleared');
  }

  /**
   * Get delivery coverage area
   */
  static async getDeliveryCoverageArea(): Promise<any> {
    const config = await this.getConfig();
    return config.deliveryCoverageArea;
  }

  /**
   * Update delivery coverage area
   */
  static async updateDeliveryCoverageArea(coverageArea: any): Promise<RestaurantConfig> {
    return this.updateConfig({ deliveryCoverageArea: coverageArea });
  }
}

================
File: backend/src/services/sync/SyncService.ts
================
import { prisma } from '../../server';
import logger from '../../common/utils/logger';
import { Customer, SyncLog } from '@prisma/client';

export interface LocalCustomer {
  id: string; // UUID
  firstName: string | null;
  lastName: string | null;
  phoneNumber: string;
  email: string | null;
  birthDate: Date | null;
  totalOrders: number;
  totalSpent: number;
  isActive: boolean;
  isBanned: boolean;
  banReason: string | null;
  updatedAt: Date;
  addresses?: LocalAddress[];
}

export interface LocalAddress {
  id: string; // UUID
  street: string;
  number: string;
  interiorNumber?: string | null;
  neighborhood?: string | null;
  city?: string | null;
  state?: string | null;
  zipCode?: string | null;
  country?: string | null;
  references?: string | null;
  latitude?: number | null;
  longitude?: number | null;
  isDefault: boolean;
}

export class SyncService {
  /**
   * Sincronizar un cliente desde el backend local al backend de WhatsApp
   */
  static async syncCustomerFromLocal(localCustomer: LocalCustomer): Promise<Customer> {
    try {
      // Mapear número de teléfono al formato de WhatsApp (agregar código de país si es necesario)
      const whatsappPhoneNumber = this.formatPhoneNumberForWhatsApp(localCustomer.phoneNumber);
      
      // Verificar si el cliente existe por número de teléfono
      const existingCustomer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber }
      });

      let customer: Customer;
      
      if (existingCustomer) {
        // Actualizar cliente existente
        customer = await prisma.customer.update({
          where: { whatsappPhoneNumber },
          data: {
            firstName: localCustomer.firstName,
            lastName: localCustomer.lastName,
            email: localCustomer.email,
            birthDate: localCustomer.birthDate,
            totalOrders: localCustomer.totalOrders,
            totalSpent: localCustomer.totalSpent,
            isActive: localCustomer.isActive,
            isBanned: localCustomer.isBanned,
            banReason: localCustomer.banReason,
            lastSyncAt: new Date(),
            syncVersion: { increment: 1 }
          }
        });
        
        await this.logSync('customer', customer.id, 'update', 'local_to_cloud', 'success');
      } else {
        // Crear nuevo cliente con el mismo UUID que el local
        customer = await prisma.customer.create({
          data: {
            id: localCustomer.id, // Usar el mismo UUID que el backend local
            whatsappPhoneNumber,
            firstName: localCustomer.firstName,
            lastName: localCustomer.lastName,
            email: localCustomer.email,
            birthDate: localCustomer.birthDate,
            totalOrders: localCustomer.totalOrders,
            totalSpent: localCustomer.totalSpent,
            isActive: localCustomer.isActive,
            isBanned: localCustomer.isBanned,
            banReason: localCustomer.banReason,
            lastSyncAt: new Date(),
            fullChatHistory: [],
            relevantChatHistory: []
          }
        });
        
        await this.logSync('customer', customer.id, 'create', 'local_to_cloud', 'success');
      }
      
      logger.info(`Synced customer ${customer.id} with phone ${whatsappPhoneNumber} from local backend`);
      
      // Sincronizar direcciones si se proporcionan
      if (localCustomer.addresses && localCustomer.addresses.length > 0) {
        await this.syncAddressesFromLocal(customer.id, localCustomer.addresses);
      }
      
      return customer;
      
    } catch (error) {
      const whatsappPhoneNumber = this.formatPhoneNumberForWhatsApp(localCustomer.phoneNumber);
      await this.logSync('customer', localCustomer.id, 'update', 'local_to_cloud', 'failed', error instanceof Error ? error.message : 'Unknown error');
      logger.error('Error syncing customer from local:', error);
      throw error;
    }
  }

  /**
   * Sincronizar direcciones desde el backend local
   */
  static async syncAddressesFromLocal(
    customerId: string,
    localAddresses: LocalAddress[]
  ): Promise<void> {
    try {
      for (const localAddress of localAddresses) {
        const existingAddress = await prisma.address.findUnique({
          where: { id: localAddress.id }
        });
        
        const addressData = {
          id: localAddress.id, // Usar el mismo UUID que el backend local
          customerId,
          street: localAddress.street,
          number: localAddress.number,
          interiorNumber: localAddress.interiorNumber,
          neighborhood: localAddress.neighborhood,
          city: localAddress.city,
          state: localAddress.state,
          zipCode: localAddress.zipCode,
          country: localAddress.country,
          references: localAddress.references,
          latitude: localAddress.latitude,
          longitude: localAddress.longitude,
          isDefault: localAddress.isDefault
        };
        
        if (existingAddress) {
          await prisma.address.update({
            where: { id: localAddress.id },
            data: addressData
          });
        } else {
          // Si se establece como predeterminada, desmarcar otras predeterminadas
          if (localAddress.isDefault) {
            await prisma.address.updateMany({
              where: { customerId, isDefault: true },
              data: { isDefault: false }
            });
          }
          
          await prisma.address.create({
            data: addressData
          });
        }
        
        await this.logSync('address', localAddress.id, 
          existingAddress ? 'update' : 'create', 'local_to_cloud', 'success');
      }
      
      logger.info(`Synced ${localAddresses.length} addresses for customer ${customerId}`);
    } catch (error) {
      logger.error('Error syncing addresses from local:', error);
      throw error;
    }
  }

  /**
   * Sincronizar un cliente desde el backend de WhatsApp al backend local
   * Esto llamaría a tu API del backend local
   */
  static async syncCustomerToLocal(customer: Customer & { addresses?: any[] }): Promise<void> {
    try {
      // Obtener direcciones del cliente
      const addresses = await prisma.address.findMany({
        where: { 
          customerId: customer.id,
          deletedAt: null
        }
      });
      
      // Esto haría una llamada API a tu backend local
      // Por ahora, solo registrar la sincronización
      const syncData = {
        id: customer.id,
        phoneNumber: this.formatPhoneNumberForLocal(customer.whatsappPhoneNumber),
        firstName: customer.firstName,
        lastName: customer.lastName,
        email: customer.email,
        birthDate: customer.birthDate,
        totalOrders: customer.totalOrders,
        totalSpent: customer.totalSpent?.toNumber() || 0,
        isActive: customer.isActive,
        isBanned: customer.isBanned,
        banReason: customer.banReason,
        fullChatHistory: customer.fullChatHistory,
        relevantChatHistory: customer.relevantChatHistory,
        lastInteraction: customer.lastInteraction,
        addresses: addresses.map(addr => ({
          id: addr.id,
          street: addr.street,
          number: addr.number,
          interiorNumber: addr.interiorNumber,
          neighborhood: addr.neighborhood,
          city: addr.city,
          state: addr.state,
          zipCode: addr.zipCode,
          country: addr.country,
          references: addr.references,
          latitude: addr.latitude?.toNumber() || null,
          longitude: addr.longitude?.toNumber() || null,
          isDefault: addr.isDefault
        }))
      };
      
      // TODO: Hacer llamada API al backend local
      // const response = await axios.post(LOCAL_BACKEND_URL + '/sync/customer', syncData);
      
      await this.logSync('customer', customer.id, 'update', 'cloud_to_local', 'success');
      logger.info(`Synced customer ${customer.id} to local backend with ${addresses.length} addresses`);
      
    } catch (error) {
      await this.logSync('customer', customer.id, 'update', 'cloud_to_local', 'failed', error instanceof Error ? error.message : 'Unknown error');
      logger.error('Error syncing customer to local:', error);
      throw error;
    }
  }

  /**
   * Obtener clientes que necesitan sincronización
   */
  static async getCustomersToSync(since?: Date): Promise<Customer[]> {
    return await prisma.customer.findMany({
      where: {
        OR: [
          { lastSyncAt: null },
          { lastSyncAt: { lt: since || new Date(Date.now() - 24 * 60 * 60 * 1000) } }
        ]
      }
    });
  }

  /**
   * Formatear número de teléfono para WhatsApp (asegurar código de país)
   */
  private static formatPhoneNumberForWhatsApp(phoneNumber: string): string {
    // Eliminar cualquier carácter no numérico
    let cleaned = phoneNumber.replace(/\D/g, '');
    
    // Agregar código de país de México si no está presente
    if (!cleaned.startsWith('52')) {
      cleaned = '52' + cleaned;
    }
    
    return cleaned;
  }

  /**
   * Formatear número de teléfono para backend local (eliminar código de país si es necesario)
   */
  private static formatPhoneNumberForLocal(whatsappPhoneNumber: string): string {
    // Eliminar código de país para almacenamiento local si es necesario
    if (whatsappPhoneNumber.startsWith('52')) {
      return whatsappPhoneNumber.substring(2);
    }
    return whatsappPhoneNumber;
  }

  /**
   * Registrar operación de sincronización
   */
  private static async logSync(
    entityType: string,
    entityId: string,
    action: string,
    syncDirection: string,
    syncStatus: string,
    errorMessage?: string
  ): Promise<SyncLog> {
    return await prisma.syncLog.create({
      data: {
        entityType,
        entityId,
        action,
        syncDirection,
        syncStatus,
        errorMessage,
        completedAt: syncStatus === 'success' ? new Date() : null
      }
    });
  }

  /**
   * Manejar resolución de conflictos entre local y nube
   */
  static async resolveConflict(localCustomer: LocalCustomer, cloudCustomer: Customer): Promise<Customer> {
    // Estrategia simple: el más recientemente actualizado gana
    const localUpdatedAt = new Date(localCustomer.updatedAt);
    const cloudUpdatedAt = new Date(cloudCustomer.updatedAt);
    
    if (localUpdatedAt > cloudUpdatedAt) {
      // Local es más nuevo, actualizar nube
      return await this.syncCustomerFromLocal(localCustomer);
    } else {
      // Nube es más nueva, actualizar local
      await this.syncCustomerToLocal(cloudCustomer);
      return cloudCustomer;
    }
  }
}

================
File: backend/README.md
================
# Backend - WhatsApp Restaurant Bot

Backend service for a WhatsApp restaurant bot using Express, Prisma, and PostgreSQL.

## Quick Start

See the main README.md in the parent directory for setup instructions.

## Environment Variables

Required environment variables:

```bash
# Database
DATABASE_URL=postgresql://postgres:postgres@localhost:5433/bot_db

# Google AI
GOOGLE_AI_API_KEY=your_api_key  # Get from https://makersuite.google.com/app/apikey
GEMINI_MODEL=gemini-2.5-pro

# WhatsApp Business API
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=your_phone_id
WHATSAPP_ACCESS_TOKEN=your_access_token
WHATSAPP_VERIFY_TOKEN=your_verify_token

# Application
FRONTEND_BASE_URL=http://localhost:3000
NODE_ENV=development
PORT=5000

# Rate Limiting
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5

# Optional - Stripe Payments
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=
```

## Database Schema

The database uses Prisma ORM with the following main tables:
- Customer: WhatsApp customer information
- Product: Restaurant menu items
- Order: Customer orders
- PreOrder: Temporary cart items
- Address: Customer addresses

## API Endpoints

- `GET /backend` - Health check
- `POST /backend/webhook` - WhatsApp webhook
- `POST /backend/otp/verify` - Verify OTP
- `POST /backend/customer-delivery-info` - Create delivery info
- `PUT /backend/customer-delivery-info/:customerId` - Update delivery info
- `GET /backend/customer-delivery-info/:customerId` - Get delivery info
- `POST /backend/pre-orders/select-products` - Add products to cart

## Development

```bash
npm run dev         # Start development server
npm run build       # Build for production
npm run studio      # Open Prisma Studio
npm run migrate:dev # Run migrations
npm run seed        # Seed database
```

================
File: frontend-app/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/delivery-address.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Registro de Dirección</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: QUICK_START.md
================
# 🚀 Inicio Rápido - Bot WhatsApp Local

## Requisitos Previos
1. **Docker** instalado
2. **Node.js 18+** instalado
3. **ngrok** (para WhatsApp real) - ver configuración abajo
4. **API Key de Google AI** (gratis en https://makersuite.google.com/app/apikey)
5. **Cuenta Meta Developer** con app WhatsApp Business configurada

## 🔧 Configuración Inicial (solo la primera vez)

### 1️⃣ Obtener Credenciales de WhatsApp

1. Ve a [Meta for Developers](https://developers.facebook.com)
2. Crea o selecciona tu app
3. En WhatsApp > API Setup, obtén:
   - `Phone number ID` (WHATSAPP_PHONE_NUMBER_MESSAGING_ID)
   - `WhatsApp Business Account ID`
   - `Permanent Access Token` (WHATSAPP_ACCESS_TOKEN)
4. Anota tu número de WhatsApp Business
5. **IMPORTANTE para desarrollo**: En la sección "To" o "Recipients", agrega tu número personal:
   - Click en "Add phone number" o "Manage phone number list"
   - Agrega el número desde el cual enviarás mensajes de prueba
   - Verifica con el código que recibirás por WhatsApp

### 2️⃣ Configurar Variables de Entorno

Edita `backend/.env.local` (NO `.env`) y actualiza:

```env
# Google AI - REQUERIDO
GOOGLE_AI_API_KEY=tu_api_key_real_aqui

# WhatsApp Business API - REQUERIDO
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=tu_phone_number_id
WHATSAPP_ACCESS_TOKEN=tu_access_token_permanente
WHATSAPP_VERIFY_TOKEN=un_token_secreto_que_tu_elijas
```

### 3️⃣ Configurar Ngrok

Ngrok ahora requiere autenticación (cuenta gratuita):

1. **Crea una cuenta** en https://dashboard.ngrok.com/signup
2. **Obtén tu authtoken** en https://dashboard.ngrok.com/get-started/your-authtoken
3. **Configura ngrok** con tu token:
   ```bash
   ngrok config add-authtoken TU_TOKEN_AQUI
   ```

## 🚀 Iniciar el Bot

### 1️⃣ Iniciar Backend y Base de Datos
```bash
./start-local.sh
```

Esto automáticamente:
- ✅ Inicia PostgreSQL con Docker
- ✅ Instala dependencias
- ✅ Crea las tablas y carga el menú
- ✅ Inicia el servidor en http://localhost:5000/backend

### 2️⃣ Exponer el Servidor con Ngrok

En otra terminal:
```bash
ngrok http 5000
```

Verás algo como:
```
Forwarding  https://abc123.ngrok-free.app -> http://localhost:5000
```

**IMPORTANTE**: 
- Copia la URL HTTPS (cambia cada vez que reinicias ngrok)
- Si no configuraste ngrok anteriormente, ver la sección 3️⃣ arriba

### 3️⃣ Configurar Webhook en Meta

1. Ve a tu app en [Meta for Developers](https://developers.facebook.com)
2. WhatsApp > Configuration > Webhook
3. Configura:
   - **Callback URL**: `https://abc123.ngrok-free.app/backend/webhook`
   - **Verify token**: El mismo que pusiste en WHATSAPP_VERIFY_TOKEN
4. Click en "Verify and save"
5. Suscríbete a los campos: `messages`

## ✅ ¡Listo para Probar!

1. **Envía un mensaje** a tu número de WhatsApp Business
2. **Verás los logs** en la terminal donde ejecutaste `./start-local.sh`
3. **El bot responderá** directamente por WhatsApp

### Mensajes de Prueba:
- "Hola" - Saludo inicial
- "Quiero ver el menú" - Muestra el menú
- "Quiero 2 pizzas hawaianas grandes" - Inicia un pedido

## 🛠️ Comandos Útiles

```bash
# Ver y editar datos en la base de datos (en otra terminal)
cd backend && npx prisma studio
# Esto abre una interfaz web en http://localhost:5555

# Ver logs de Docker
docker compose logs -f

# Reiniciar todo
docker compose down && ./start-local.sh
```

## 🛑 Para Detener Todo

1. `Ctrl+C` en la terminal del servidor
2. `Ctrl+C` en la terminal de ngrok
3. `docker-compose down` para detener PostgreSQL

## ⚠️ Solución de Problemas

### "Webhook no se verifica"
- Asegúrate que el verify token coincida exactamente
- La URL debe ser HTTPS (ngrok lo proporciona)
- El servidor debe estar corriendo antes de verificar

### "No recibo mensajes"
- Verifica que estés suscrito a "messages" en el webhook
- Revisa los logs del servidor
- En Meta > Webhooks > Recent errors

### "Error: Recipient phone number not in allowed list"
- Tu app está en modo desarrollo
- Ve a WhatsApp > API Setup > sección "To" o "Recipients"
- Agrega el número desde el cual envías mensajes
- Verifica con el código que recibes por WhatsApp

### "El bot no responde"
- Verifica que tengas tu Google AI API key configurada
- Revisa los logs para ver errores
- Asegúrate que el número que envía está en formato internacional

## 📝 Notas Importantes

- **Ngrok gratis**: La URL cambia cada vez, debes actualizar el webhook
- **Rate limits**: WhatsApp tiene límites de mensajes por minuto
- **Desarrollo**: Usa un número de prueba para no afectar el principal
- **Logs**: Todos los mensajes y respuestas aparecen en la terminal

================
File: README.md
================
# 🤖 Bot Backend - WhatsApp Restaurant Bot

Backend para un bot de WhatsApp para restaurante, usando Express, Prisma y PostgreSQL.

## 🚀 Inicio Rápido

Ver la guía completa en: **[QUICK_START.md](QUICK_START.md)**

### Resumen:
1. Configura credenciales de WhatsApp y Google AI
2. Ejecuta `./start-local.sh`
3. Usa ngrok para exponer el webhook
4. ¡Listo! El bot responde por WhatsApp

### Requisitos:
- Docker y Docker Compose
- Node.js 18+
- ngrok
- API Key de Google AI
- Cuenta Meta Developer con WhatsApp Business

## 📁 Estructura del Proyecto

```
backend/
├── prisma/
│   ├── schema.prisma    # Esquema de la base de datos
│   └── seed.ts          # Datos iniciales (menú)
├── src/
│   ├── config/          # Configuraciones y mensajes predefinidos
│   ├── services/        # Lógica de negocio
│   ├── utils/           # Utilidades y procesador de IA
│   ├── whatsapp/        # Handlers de WhatsApp
│   └── server.ts        # Servidor Express principal
└── .env.local           # Variables de entorno para desarrollo
```

## 🚀 Deploy en Railway

### 1. Preparar el Proyecto

Asegúrate de que todo funciona localmente primero.

### 2. Crear Proyecto en Railway

1. Ve a [Railway.app](https://railway.app)
2. Crea un nuevo proyecto
3. Agrega un servicio PostgreSQL
4. Agrega tu repositorio de GitHub

### 3. Configurar Variables de Entorno

En Railway, agrega estas variables:

```env
# WhatsApp Business API
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=tu_numero_id
WHATSAPP_ACCESS_TOKEN=tu_access_token
WHATSAPP_VERIFY_TOKEN=tu_verify_token

# Google AI
GOOGLE_AI_API_KEY=tu_api_key

# URLs
FRONTEND_BASE_URL=https://tu-dominio.com

# Límites de mensajes
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5

# Stripe (opcional)
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=
```

### 4. Configurar el Build

En Railway, configura:
- **Build Command**: `cd backend && npm install && npm run build`
- **Start Command**: `cd backend && npm run migrate && npm run seed && npm start`

### 5. Deploy

Railway desplegará automáticamente cuando hagas push a tu repositorio.

## 🔧 Scripts de Desarrollo

### Scripts Principales

```bash
# Iniciar todo (backend + frontend + PostgreSQL)
./start-local.sh

# Iniciar solo el frontend (requiere backend corriendo)
./start-frontend.sh

# Desarrollo completo con hot-reload (backend + frontend)
./dev.sh

# Solo backend
./dev-backend.sh

# Solo frontend
./dev-frontend.sh
```

### Comandos NPM

```bash
# Desarrollo local
npm run dev

# Generar cliente de Prisma
npm run generate

# Ejecutar migraciones
npm run migrate:dev

# Ver base de datos
npm run studio

# Ejecutar seed
npm run seed
```

## 📝 Notas Importantes

- El bot usa Google Gemini AI para procesar mensajes
- La base de datos PostgreSQL se configura automáticamente en Railway
- Los webhooks de WhatsApp deben apuntar a: `https://tu-app.railway.app/backend/webhook`
- El puerto 5433 se usa localmente para evitar conflictos con PostgreSQL existente
- Para probar con WhatsApp real en local, usa ngrok o similar

================
File: start-local.sh
================
#!/bin/bash

echo "🚀 Iniciando backend localmente..."

# Colores
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

# Verificar si el puerto 5433 está en uso
if lsof -Pi :5433 -sTCP:LISTEN -t >/dev/null 2>&1 ; then
    echo -e "\n${YELLOW}⚠️  El puerto 5433 está en uso. Intentando detener contenedores previos...${NC}"
    docker compose down
    sleep 2
fi

# Paso 1: Iniciar PostgreSQL con Docker
echo -e "\n${YELLOW}1. Iniciando PostgreSQL...${NC}"
docker compose up -d

# Esperar a que PostgreSQL esté listo
echo -e "${YELLOW}   Esperando a que PostgreSQL esté listo...${NC}"
max_attempts=30
attempt=0
until docker compose exec -T postgres pg_isready -U postgres >/dev/null 2>&1 || [ $attempt -eq $max_attempts ]; do
    attempt=$((attempt + 1))
    printf "\r   Esperando... intento $attempt/$max_attempts"
    sleep 1
done

if [ $attempt -eq $max_attempts ]; then
    echo -e "\n${RED}❌ PostgreSQL no pudo iniciar después de $max_attempts intentos${NC}"
    echo "   Intenta ejecutar: docker compose logs postgres"
    exit 1
fi
echo -e "\n${GREEN}   ✅ PostgreSQL está listo!${NC}"

# Paso 2: Verificar configuración antes de copiar
echo -e "\n${YELLOW}2. Verificando configuración...${NC}"
cd backend

# Verificar configuración en .env.local
echo -e "${YELLOW}Verificando .env.local...${NC}"

# Verificar API Key de Google
if grep -q "TU_API_KEY_AQUI" .env.local || grep -q "tu_api_key_real_aqui" .env.local; then
    echo -e "\n${RED}❌ FALTA: Google AI API Key${NC}"
    echo "   Edita backend/.env.local y configura GOOGLE_AI_API_KEY"
    echo "   Obtén una en: https://makersuite.google.com/app/apikey"
    missing_config=true
else
    echo -e "${GREEN}✅ Google AI API Key configurada${NC}"
fi

# Verificar credenciales de WhatsApp
if grep -q "tu_phone_number_id" .env.local || grep -q "tu_access_token_permanente" .env.local || grep -q "un_token_secreto_que_tu_elijas" .env.local; then
    echo -e "\n${RED}❌ FALTA: Credenciales de WhatsApp${NC}"
    echo "   Edita backend/.env.local y configura:"
    echo "   - WHATSAPP_PHONE_NUMBER_MESSAGING_ID"
    echo "   - WHATSAPP_ACCESS_TOKEN"
    echo "   - WHATSAPP_VERIFY_TOKEN"
    echo "   - BOT_WHATSAPP_NUMBER"
    echo "   Obtén las credenciales en: https://developers.facebook.com"
    missing_config=true
else
    echo -e "${GREEN}✅ Credenciales de WhatsApp configuradas${NC}"
fi

if [ "$missing_config" = true ]; then
    echo -e "\n${YELLOW}Ver QUICK_START.md para instrucciones detalladas${NC}"
    echo ""
    read -p "Presiona ENTER cuando hayas configurado todo..."
fi

# Copiar archivo de entorno
echo -e "\n${YELLOW}Copiando .env.local a .env...${NC}"
cp .env.local .env
echo -e "${GREEN}✅ Archivo .env creado${NC}"

# Paso 3: Instalar dependencias
echo -e "\n${YELLOW}3. Instalando dependencias...${NC}"
npm install

# Paso 4: Generar Prisma Client
echo -e "\n${YELLOW}4. Generando Prisma Client...${NC}"
npm run generate

# Paso 5: Ejecutar migraciones
echo -e "\n${YELLOW}5. Creando tablas en la base de datos...${NC}"
npx prisma migrate deploy 2>/dev/null || npx prisma migrate dev --name init

# Paso 6: Ejecutar seed
echo -e "\n${YELLOW}6. Agregando datos iniciales (menú)...${NC}"
npm run seed

# Paso 7: Verificar e instalar dependencias del frontend si existe
if [ -d "../frontend-app" ] && [ -f "../frontend-app/package.json" ]; then
    echo -e "\n${YELLOW}7. Verificando frontend...${NC}"
    cd ../frontend-app
    if [ ! -d "node_modules" ]; then
        echo -e "${YELLOW}   Instalando dependencias del frontend...${NC}"
        npm install
    fi
    cd ../backend
fi

# Función para limpiar al salir
cleanup() {
    echo -e "\n${YELLOW}⏹️  Deteniendo servicios...${NC}"
    pkill -P $$
    exit 0
}

# Capturar Ctrl+C
trap cleanup INT

# Paso 8: Iniciar servicios
echo -e "\n${GREEN}✅ Todo listo! Iniciando servicios...${NC}"

# Iniciar backend
echo -e "${YELLOW}🖥️  Iniciando Backend...${NC}"
npm run dev 2>&1 | sed 's/^/[Backend] /' &
BACKEND_PID=$!

# Esperar un poco para que el backend inicie
sleep 3

# Iniciar frontend si existe
if [ -d "../frontend-app" ] && [ -f "../frontend-app/package.json" ]; then
    echo -e "${YELLOW}🌐 Iniciando Frontend...${NC}"
    cd ../frontend-app && npm run dev 2>&1 | sed 's/^/[Frontend] /' &
    FRONTEND_PID=$!
    cd ../backend
fi

echo -e "\n${GREEN}✅ Servicios iniciados:${NC}"
echo -e "   Backend:  ${BLUE}http://localhost:5000${NC}"
if [ ! -z "$FRONTEND_PID" ]; then
    echo -e "   Frontend: ${BLUE}http://localhost:3000${NC}"
fi
echo -e "   Prisma Studio: ${YELLOW}npx prisma studio${NC}"
echo -e "   Logs de Docker: ${YELLOW}docker compose logs -f${NC}"
echo -e "\n${BLUE}📱 Para conectar WhatsApp:${NC}"
echo -e "   1. En otra terminal ejecuta: ${YELLOW}ngrok http 5000${NC}"
echo -e "   2. Copia la URL HTTPS que te da ngrok"
echo -e "   3. Configura el webhook en Meta Developers"
echo -e "   4. ¡Envía mensajes a tu número de WhatsApp!"
echo -e "\n${YELLOW}Para detener todo: Ctrl+C y luego: docker compose down${NC}"
echo ""

# Esperar a los procesos
wait $BACKEND_PID

================
File: backend/src/common/config/envValidator.ts
================
import dotenv from 'dotenv';
import logger from '../utils/logger';
import { ValidationError, ErrorCode } from '../services/errors';

dotenv.config();

interface EnvironmentVariables {
  // Required variables
  DATABASE_URL: string;
  GOOGLE_AI_API_KEY: string;
  WHATSAPP_PHONE_NUMBER_MESSAGING_ID: string;
  WHATSAPP_ACCESS_TOKEN: string;
  WHATSAPP_VERIFY_TOKEN: string;
  FRONTEND_BASE_URL: string;
  GEMINI_MODEL: string;
  
  // Optional variables
  STRIPE_SECRET_KEY?: string;
  STRIPE_WEBHOOK_SECRET?: string;
  NODE_ENV: string;
  PORT: string;
  RATE_LIMIT_MAX_MESSAGES: string;
  RATE_LIMIT_TIME_WINDOW_MINUTES: string;
  DEFAULT_TIMEZONE: string;
  DEFAULT_LOCALE: string;
}

class EnvironmentValidator {
  private requiredVars: (keyof EnvironmentVariables)[] = [
    'DATABASE_URL',
    'GOOGLE_AI_API_KEY',
    'WHATSAPP_PHONE_NUMBER_MESSAGING_ID',
    'WHATSAPP_ACCESS_TOKEN',
    'WHATSAPP_VERIFY_TOKEN',
    'FRONTEND_BASE_URL',
    'GEMINI_MODEL',
    'NODE_ENV',
    'PORT',
    'RATE_LIMIT_MAX_MESSAGES',
    'RATE_LIMIT_TIME_WINDOW_MINUTES',
    'DEFAULT_TIMEZONE',
    'DEFAULT_LOCALE'
  ];

  validate(): void {
    logger.info('Starting environment validation...');
    const missingVars: string[] = [];
    
    for (const varName of this.requiredVars) {
      if (!process.env[varName]) {
        missingVars.push(varName);
      } else {
        logger.debug(`Environment variable ${varName}: ${varName.includes('KEY') || varName.includes('TOKEN') ? '[REDACTED]' : process.env[varName]}`);
      }
    }
    
    if (missingVars.length > 0) {
      const errorMessage = `Missing required environment variables: ${missingVars.join(', ')}`;
      logger.error(errorMessage);
      throw new ValidationError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        errorMessage,
        { metadata: { missingVars } }
      );
    }
    
    // Validate specific formats
    this.validateDatabaseUrl();
    this.validateUrl('FRONTEND_BASE_URL');
    
    // Log optional variables status
    if (process.env.STRIPE_SECRET_KEY) {
      logger.info('Stripe payment integration is enabled');
    } else {
      logger.warn('Stripe payment integration is disabled (STRIPE_SECRET_KEY not set)');
    }
    
    logger.info('Environment variables validated successfully');
  }
  
  private validateDatabaseUrl(): void {
    const dbUrl = process.env.DATABASE_URL;
    if (!dbUrl?.startsWith('postgresql://')) {
      throw new ValidationError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        'DATABASE_URL must be a valid PostgreSQL connection string',
        { metadata: { providedUrl: dbUrl } }
      );
    }
  }
  
  
  private validateUrl(varName: string): void {
    const url = process.env[varName];
    try {
      if (url) {
        new URL(url);
      }
    } catch {
      throw new ValidationError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        `${varName} must be a valid URL`,
        { metadata: { varName, providedUrl: url } }
      );
    }
  }
  
  getEnv(): EnvironmentVariables {
    return {
      DATABASE_URL: process.env.DATABASE_URL!,
      GOOGLE_AI_API_KEY: process.env.GOOGLE_AI_API_KEY!,
      WHATSAPP_PHONE_NUMBER_MESSAGING_ID: process.env.WHATSAPP_PHONE_NUMBER_MESSAGING_ID!,
      WHATSAPP_ACCESS_TOKEN: process.env.WHATSAPP_ACCESS_TOKEN!,
      WHATSAPP_VERIFY_TOKEN: process.env.WHATSAPP_VERIFY_TOKEN!,
      FRONTEND_BASE_URL: process.env.FRONTEND_BASE_URL!,
      GEMINI_MODEL: process.env.GEMINI_MODEL!,
      STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
      STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
      NODE_ENV: process.env.NODE_ENV!,
      PORT: process.env.PORT!,
      RATE_LIMIT_MAX_MESSAGES: process.env.RATE_LIMIT_MAX_MESSAGES!,
      RATE_LIMIT_TIME_WINDOW_MINUTES: process.env.RATE_LIMIT_TIME_WINDOW_MINUTES!,
      DEFAULT_TIMEZONE: process.env.DEFAULT_TIMEZONE!,
      DEFAULT_LOCALE: process.env.DEFAULT_LOCALE!
    };
  }
}

export const envValidator = new EnvironmentValidator();
export const env = envValidator.getEnv();

================
File: backend/src/common/utils/geoUtils.ts
================
import { RestaurantService } from '../../services/restaurant/RestaurantService';
import logger from './logger';

/**
 * Verifica si un punto está dentro de un polígono usando el algoritmo ray-casting
 * @param point [latitude, longitude]
 * @param polygon Array de coordenadas [[lat1, lng1], [lat2, lng2], ...]
 * @returns true si el punto está dentro del polígono
 */
export function isPointInPolygon(point: [number, number], polygon: [number, number][]): boolean {
  const [lat, lng] = point;
  let inside = false;

  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const [lat1, lng1] = polygon[i];
    const [lat2, lng2] = polygon[j];

    const intersect = ((lat1 > lat) !== (lat2 > lat)) &&
      (lng < (lng2 - lng1) * (lat - lat1) / (lat2 - lat1) + lng1);

    if (intersect) inside = !inside;
  }

  return inside;
}


/**
 * Verifica si una ubicación está dentro del área de cobertura del restaurante
 * @param latitude Latitud de la ubicación
 * @param longitude Longitud de la ubicación
 * @returns true si está dentro del área de cobertura
 */
export async function isWithinDeliveryArea(latitude: number, longitude: number): Promise<boolean> {
  try {
    const config = await RestaurantService.getConfig();
    
    // Si hay un polígono definido, usarlo
    if (config.deliveryCoverageArea && Array.isArray(config.deliveryCoverageArea)) {
      const polygon = config.deliveryCoverageArea as [number, number][];
      return isPointInPolygon([latitude, longitude], polygon);
    }
    
    
    // Si no hay configuración de área, aceptar todas las direcciones
    logger.warn('No delivery area configuration found, accepting all addresses');
    return true;
  } catch (error) {
    logger.error('Error checking delivery area:', error);
    // En caso de error, aceptar la dirección para no bloquear el servicio
    return true;
  }
}

/**
 * Obtiene información sobre el área de cobertura
 */
export async function getDeliveryAreaInfo(): Promise<{
  hasPolygon: boolean;
  polygon?: [number, number][];
}> {
  try {
    const config = await RestaurantService.getConfig();
    
    return {
      hasPolygon: !!config.deliveryCoverageArea,
      polygon: config.deliveryCoverageArea as [number, number][] | undefined
    };
  } catch (error) {
    logger.error('Error getting delivery area info:', error);
    return { hasPolygon: false };
  }
}

================
File: backend/src/common/utils/logger.ts
================
import * as winston from 'winston';
import { env } from '../config/envValidator';

// Helper function to format JSON for better readability
const formatJSON = (obj: any, indent = 2): string => {
  try {
    if (typeof obj === 'string') {
      // Try to parse if it's a JSON string
      try {
        const parsed = JSON.parse(obj);
        return JSON.stringify(parsed, null, indent);
      } catch {
        return obj;
      }
    }
    return JSON.stringify(obj, null, indent);
  } catch (error) {
    return String(obj);
  }
};

const logger = winston.createLogger({
  level: env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message, ...meta }) => {
      // Helper function to safely stringify objects with circular references
      const safeStringify = (obj: any, indent = 0): string => {
        const seen = new WeakSet();
        return JSON.stringify(obj, (key, value) => {
          if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
              return '[Circular Reference]';
            }
            seen.add(value);
          }
          return value;
        }, indent);
      };
      
      // Si el mensaje es un objeto, convertirlo a string
      const formattedMessage = typeof message === 'object' 
        ? safeStringify(message, 2)
        : String(message);
      
      // Si hay metadata adicional, incluirla en el log
      const metadata = Object.keys(meta).length ? `\n${safeStringify(meta, 2)}` : '';
      
      return `${timestamp} [${level}]: ${formattedMessage}${metadata}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
});

// Add helper methods for JSON logging
(logger as any).json = function(message: string, data: any) {
  this.debug(`${message}\n${formatJSON(data)}`);
};

(logger as any).jsonInfo = function(message: string, data: any) {
  this.info(`${message}\n${formatJSON(data)}`);
};

export default logger;

================
File: backend/src/common/utils/timeUtils.ts
================
import moment from "moment-timezone";
import { prisma } from "../../server";
import logger from "./logger";
import { RestaurantService } from "../../services/restaurant/RestaurantService";

// Cache for timezone
let cachedTimeZone: string | null = null;

async function getTimeZone(): Promise<string> {
  try {
    if (cachedTimeZone) {
      return cachedTimeZone;
    }
    
    const config = await RestaurantService.getConfig();
    cachedTimeZone = config.timeZone || "America/Mexico_City";
    return cachedTimeZone;
  } catch (error) {
    logger.error("Error getting timezone from config:", error);
    // Fallback to default timezone
    return "America/Mexico_City";
  }
}

const parseTime = (timeString: string): number => {
  const [hours, minutes] = timeString.split(":").map(Number);
  return hours * 60 + minutes;
};

const getCurrentMexicoTime = async (): Promise<moment.Moment> => {
  const timeZone = await getTimeZone();
  return moment().tz(timeZone);
};

const getUTCTime = (): moment.Moment => {
  return moment().utc();
};

// Helper function to clear timezone cache when config changes
export function clearTimeZoneCache(): void {
  cachedTimeZone = null;
}

const isBusinessOpen = async (): Promise<boolean> => {
  try {
    const now = await getCurrentMexicoTime();
    const dayOfWeek = now.day();
    const currentMinutes = now.hours() * 60 + now.minutes();

    // Get business hours for current day
    const todayHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
    
    if (!todayHours || todayHours.isClosed || !todayHours.openingTime || !todayHours.closingTime) {
      return false;
    }

    const openingMinutes = parseTime(todayHours.openingTime);
    const closingMinutes = parseTime(todayHours.closingTime);

    // Get restaurant config for grace periods
    const config = await RestaurantService.getConfig();
    
    // Apply grace periods
    const effectiveOpeningTime = openingMinutes + (config.openingGracePeriod || 0);
    const effectiveClosingTime = closingMinutes - (config.closingGracePeriod || 0);

    return currentMinutes >= effectiveOpeningTime && currentMinutes < effectiveClosingTime;
  } catch (error) {
    logger.error("Error checking if business is open:", error);
    // Fallback to closed if database fails
    return false;
  }
};

export { getCurrentMexicoTime, isBusinessOpen, getUTCTime };

export async function getFormattedBusinessHours(): Promise<string> {
  try {
    const hours = await RestaurantService.getAllBusinessHours();
    
    const dayNames = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
    
    const formattedHours = hours.map(h => {
      if (h.isClosed || !h.openingTime || !h.closingTime) {
        return `${dayNames[h.dayOfWeek]}: Cerrado`;
      }
      return `${dayNames[h.dayOfWeek]}: ${h.openingTime} - ${h.closingTime}`;
    });
    
    return formattedHours.join('\n');
  } catch (error) {
    logger.error("Error getting formatted business hours:", error);
    return "Horarios no disponibles";
  }
}

export async function getBusinessStatus(): Promise<{
  isOpen: boolean;
  message: string;
  nextOpeningTime?: string;
}> {
  try {
    const now = await getCurrentMexicoTime();
    const dayOfWeek = now.day();
    const currentMinutes = now.hours() * 60 + now.minutes();
    
    const todayHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
    const config = await RestaurantService.getConfig();
    
    if (!todayHours || todayHours.isClosed || !todayHours.openingTime || !todayHours.closingTime) {
      // Find next opening day
      let nextDay = (dayOfWeek + 1) % 7;
      let daysChecked = 0;
      
      while (daysChecked < 7) {
        const nextDayHours = await RestaurantService.getBusinessHoursForDay(nextDay);
        if (nextDayHours && !nextDayHours.isClosed && nextDayHours.openingTime) {
          const dayName = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'][nextDay];
          return {
            isOpen: false,
            message: `⏰ Estamos cerrados hoy. Abrimos el ${dayName} a las ${nextDayHours.openingTime} hrs. 🍕`,
            nextOpeningTime: nextDayHours.openingTime
          };
        }
        nextDay = (nextDay + 1) % 7;
        daysChecked++;
      }
      
      return {
        isOpen: false,
        message: "⏰ Estamos cerrados. Por favor, contacta al restaurante para más información. 📞"
      };
    }
    
    const openingMinutes = parseTime(todayHours.openingTime);
    const closingMinutes = parseTime(todayHours.closingTime);
    const effectiveOpeningTime = openingMinutes + (config.openingGracePeriod || 0);
    const effectiveClosingTime = closingMinutes - (config.closingGracePeriod || 0);
    
    // Before opening (including grace period)
    if (currentMinutes < effectiveOpeningTime) {
      const minutesUntilOpen = effectiveOpeningTime - currentMinutes;
      if (minutesUntilOpen <= 60) {
        return {
          isOpen: false,
          message: `⏰ Abrimos en ${minutesUntilOpen} minutos. Por favor, espera un momento. 🍕`,
          nextOpeningTime: todayHours.openingTime
        };
      }
      return {
        isOpen: false,
        message: `⏰ Abrimos a las ${todayHours.openingTime} hrs. ¡Te esperamos! 🍕`,
        nextOpeningTime: todayHours.openingTime
      };
    }
    
    // Near closing time (within grace period)
    if (currentMinutes >= effectiveClosingTime && currentMinutes < closingMinutes) {
      const minutesUntilClose = closingMinutes - currentMinutes;
      return {
        isOpen: false,
        message: `⏰ Ya no estamos tomando pedidos. Cerramos en ${minutesUntilClose} minutos. ¡Vuelve mañana! 🍕`
      };
    }
    
    // After closing
    if (currentMinutes >= closingMinutes) {
      // Find next opening (tomorrow or next available day)
      let nextDay = (dayOfWeek + 1) % 7;
      let daysChecked = 0;
      
      while (daysChecked < 7) {
        const nextDayHours = await RestaurantService.getBusinessHoursForDay(nextDay);
        if (nextDayHours && !nextDayHours.isClosed && nextDayHours.openingTime) {
          const dayName = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'][nextDay];
          return {
            isOpen: false,
            message: `⏰ Ya cerramos por hoy. Abrimos el ${dayName} a las ${nextDayHours.openingTime} hrs. ¡Te esperamos! 🍕`,
            nextOpeningTime: nextDayHours.openingTime
          };
        }
        nextDay = (nextDay + 1) % 7;
        daysChecked++;
      }
    }
    
    // Restaurant is open
    const minutesUntilEffectiveClose = effectiveClosingTime - currentMinutes;
    if (minutesUntilEffectiveClose <= 30) {
      return {
        isOpen: true,
        message: `✅ Estamos abiertos. ⚠️ Último momento para ordenar, cerramos pronto (en ${minutesUntilEffectiveClose} minutos).`
      };
    }
    
    return {
      isOpen: true,
      message: "✅ Estamos abiertos y listos para tomar tu pedido. 🍕"
    };
  } catch (error) {
    logger.error("Error getting business status:", error);
    return {
      isOpen: false,
      message: "❌ Error al verificar el horario. Por favor, contacta al restaurante."
    };
  }
}

export async function getNextDailyOrderNumber(): Promise<number> {
  try {
    // Obtener la fecha actual en la zona horaria del restaurante
    const timeZone = await getTimeZone();
    const todayInMexico = moment.tz(timeZone);

    // Definir el inicio y fin del día en UTC
    const startOfDayUTC = todayInMexico.clone().startOf("day").utc();
    const endOfDayUTC = todayInMexico.clone().endOf("day").utc();

    const lastOrder = await prisma.order.findFirst({
      where: {
        createdAt: {
          gte: startOfDayUTC.toDate(),
          lt: endOfDayUTC.toDate(),
        },
      },
      orderBy: {
        dailyNumber: "desc"
      },
    });

    return lastOrder ? lastOrder.dailyNumber + 1 : 1;
  } catch (error) {
    logger.error(
      "Error al obtener el siguiente número de orden diaria:",
      error
    );
    throw error;
  }
}

export async function getMexicoDayRange(dateString: string): Promise<{
  startDate: Date;
  endDate: Date;
}> {
  const timeZone = await getTimeZone();
  const mexicoDate = moment.tz(dateString, timeZone).startOf("day");

  const startDate = mexicoDate.clone().utc().toDate();
  const endDate = mexicoDate.clone().endOf("day").utc().toDate();

  return { startDate, endDate };
}

================
File: backend/src/routes/webhook.ts
================
import { Router } from 'express';
import express from 'express';
import { WhatsAppService } from '../services/whatsapp';
import { StripeService } from '../services/payment/StripeService';
import logger from '../common/utils/logger';

const router = Router();

// Webhook verification (GET)
router.get('/', (req, res) => {
  try {
    const result = WhatsAppService.verifyWebhook(req.query);
    if (result.verified) {
      res.status(200).send(result.challenge);
    } else {
      res.status(403).send('Forbidden');
    }
  } catch (error) {
    logger.error('Webhook verification error:', error);
    res.status(500).send('Internal Server Error');
  }
});

// Webhook handler (POST)
router.post('/', express.raw({ type: '*/*' }), async (req, res) => {
  try {
    // Check if it's a Stripe webhook
    const stripeSignature = req.headers['stripe-signature'];
    
    if (stripeSignature) {
      // Handle Stripe webhook
      await StripeService.handleWebhook(req, res);
    } else {
      // Handle WhatsApp webhook
      await WhatsAppService.handleWebhook(req, res);
    }
  } catch (error) {
    logger.error('Webhook processing error:', error);
    res.status(500).send('Internal Server Error');
  }
});

export default router;

================
File: backend/src/services/ai/GeminiService.ts
================
import { GoogleGenAI } from '@google/genai';
import { env } from '../../common/config/envValidator';
import logger from '../../common/utils/logger';
import { ValidationError, ErrorCode } from '../../common/services/errors';

/**
 * Servicio centralizado para todas las interacciones con Gemini AI
 * Maneja la configuración, el cliente y las operaciones comunes
 */
export class GeminiService {
  private static instance: GoogleGenAI | null = null;

  /**
   * Obtiene la instancia singleton del cliente de Gemini
   */
  static getClient(): GoogleGenAI {
    if (!this.instance) {
      this.instance = new GoogleGenAI({ apiKey: env.GOOGLE_AI_API_KEY });
      logger.info('GeminiService: Cliente inicializado');
      logger.info(`GeminiService: Using model ${env.GEMINI_MODEL}`);
    }
    return this.instance;
  }

  /**
   * Genera una respuesta simple de texto
   */
  static async generateText(prompt: string, systemInstruction?: string): Promise<string> {
    try {
      logger.debug('=== GeminiService.generateText DEBUG ===');
      logger.debug(`Prompt: ${prompt}`);
      logger.debug(`System Instruction: ${systemInstruction || 'None'}`);
      
      const client = this.getClient();
      const response = await client.models.generateContent({
        model: env.GEMINI_MODEL,
        contents: prompt,
        config: systemInstruction ? { systemInstruction } : undefined,
      });
      
      logger.debug('Response:', JSON.stringify(response, null, 2));
      logger.debug(`Extracted text: ${response.text || 'No text in response'}`);
      logger.debug('=== End DEBUG ===');
      
      return response.text || '';
    } catch (error) {
      logger.error('GeminiService: Error generando texto', error);
      throw error;
    }
  }

  /**
   * Genera contenido con historial de conversación
   */
  static async generateContentWithHistory(
    messages: any[],
    systemInstruction?: string,
    tools?: any[],
    toolConfig?: any
  ): Promise<any> {
    try {
      const client = this.getClient();
      
      // Construir la configuración
      const config: any = {
        systemInstruction,
        tools: tools ? [{ functionDeclarations: tools }] : undefined,
      };
      
      // Agregar toolConfig si se proporciona
      if (toolConfig) {
        config.toolConfig = toolConfig;
        logger.debug(`Tool Config: ${JSON.stringify(toolConfig, null, 2)}`);
      }
      
      const response = await client.models.generateContent({
        model: env.GEMINI_MODEL,
        contents: messages,
        config,
      });
      
      return response;
    } catch (error) {
      logger.error('GeminiService: Error generando contenido con historial', error);
      throw error;
    }
  }

  /**
   * Transcribe audio a texto
   */
  static async transcribeAudio(
    audioData: string,
    mimeType: string
  ): Promise<string> {
    try {
      logger.debug('=== GeminiService.transcribeAudio DEBUG ===');
      logger.debug(`MimeType: ${mimeType}`);
      logger.debug(`Audio data length: ${audioData.length}`);
      
      const client = this.getClient();
      
      const prompt = `Transcribe el siguiente audio a texto. 
      Si el audio no es claro o no se puede entender, responde con "ERROR_TRANSCRIPTION".
      Si el audio está en otro idioma que no sea español, tradúcelo al español.
      Solo devuelve el texto transcrito, sin explicaciones adicionales.`;

      const contents = [
        {
          role: "user",
          parts: [
            { text: prompt },
            {
              inlineData: {
                mimeType,
                data: audioData,
              },
            },
          ],
        },
      ];
      
      logger.debug('Contents structure:', JSON.stringify({
        role: contents[0].role,
        parts: contents[0].parts.map(p => p.text ? 'text' : 'inlineData')
      }, null, 2));

      const response = await client.models.generateContent({
        model: env.GEMINI_MODEL,
        contents,
      });

      const transcription = response.text?.trim() || '';
      logger.debug(`Transcription result: ${transcription}`);
      logger.debug('=== End DEBUG ===');
      
      if (!transcription || transcription === 'ERROR_TRANSCRIPTION' || transcription.length < 2) {
        throw new ValidationError(
          ErrorCode.TRANSCRIPTION_ERROR,
          'No se pudo transcribir el audio',
          { metadata: { transcriptionResult: transcription } }
        );
      }

      return transcription;
    } catch (error) {
      logger.error('GeminiService: Error transcribiendo audio', error);
      throw error;
    }
  }

  /**
   * Crea una sesión de chat con historial
   */
  static createChat(config?: {
    history?: any[];
    systemInstruction?: string;
    tools?: any[];
  }) {
    const client = this.getClient();
    return client.chats.create({
      model: env.GEMINI_MODEL,
      history: config?.history || [],
      config: {
        systemInstruction: config?.systemInstruction,
        tools: config?.tools ? [{ functionDeclarations: config.tools }] : undefined,
      },
    });
  }
}

================
File: backend/src/services/customer/CustomerService.ts
================
import { prisma } from '../../server';
import { Prisma } from '@prisma/client';
import logger from '../../common/utils/logger';
import { Customer } from '../../common/types';
import { BusinessLogicError, ErrorCode } from '../../common/services/errors';

/**
 * Service for managing customer-related operations
 */
export class CustomerService {
  /**
   * Check if a customer is banned by WhatsApp phone number
   */
  static async isCustomerBanned(whatsappPhoneNumber: string): Promise<boolean> {
    try {
      const customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber },
        select: { isBanned: true }
      });
      
      return customer?.isBanned ?? false;
    } catch (error) {
      logger.error('Error checking if customer is banned:', error);
      return false;
    }
  }

  /**
   * Get customer by WhatsApp phone number
   */
  static async getCustomerByPhone(whatsappPhoneNumber: string): Promise<Customer | null> {
    try {
      return await prisma.customer.findUnique({
        where: { whatsappPhoneNumber }
      });
    } catch (error) {
      logger.error('Error getting customer by phone:', error);
      return null;
    }
  }

  /**
   * Get customer by ID
   */
  static async getCustomerById(customerId: string): Promise<Customer | null> {
    try {
      return await prisma.customer.findUnique({
        where: { id: customerId }
      });
    } catch (error) {
      logger.error('Error getting customer by ID:', error);
      return null;
    }
  }

  /**
   * Get or create a customer by WhatsApp phone number
   */
  static async getOrCreateCustomer(whatsappPhoneNumber: string): Promise<Customer> {
    try {
      let customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber }
      });

      if (!customer) {
        customer = await prisma.customer.create({
          data: { whatsappPhoneNumber }
        });
        logger.info(`Created new customer with phone: ${whatsappPhoneNumber}`);
      }

      return customer;
    } catch (error) {
      logger.error('Error getting or creating customer:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to get or create customer',
        { metadata: { whatsappPhoneNumber } }
      );
    }
  }

  /**
   * Update customer information by ID
   */
  static async updateCustomer(
    customerId: string, 
    data: Prisma.CustomerUpdateInput
  ): Promise<Customer> {
    try {
      const customer = await prisma.customer.update({
        where: { id: customerId },
        data
      });

      logger.info(`Updated customer ${customerId}:`, data);
      return customer;
    } catch (error) {
      logger.error('Error updating customer:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to update customer',
        { metadata: { customerId, data } }
      );
    }
  }

  /**
   * Update customer information by WhatsApp phone number
   */
  static async updateCustomerByPhone(
    whatsappPhoneNumber: string, 
    data: Prisma.CustomerUpdateInput
  ): Promise<Customer> {
    try {
      const customer = await prisma.customer.update({
        where: { whatsappPhoneNumber },
        data
      });

      logger.info(`Updated customer with phone ${whatsappPhoneNumber}:`, data);
      return customer;
    } catch (error) {
      logger.error('Error updating customer by phone:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to update customer',
        { metadata: { whatsappPhoneNumber, data } }
      );
    }
  }

  /**
   * Ban a customer by WhatsApp phone number
   */
  static async banCustomer(whatsappPhoneNumber: string, reason?: string): Promise<void> {
    try {
      await prisma.customer.update({
        where: { whatsappPhoneNumber },
        data: { 
          isBanned: true,
          bannedAt: new Date(),
          banReason: reason,
          updatedAt: new Date()
        }
      });

      logger.warn(`Customer with phone ${whatsappPhoneNumber} has been banned. Reason: ${reason || 'Not specified'}`);
    } catch (error) {
      logger.error('Error banning customer:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to ban customer',
        { metadata: { whatsappPhoneNumber, reason } }
      );
    }
  }

  /**
   * Unban a customer by WhatsApp phone number
   */
  static async unbanCustomer(whatsappPhoneNumber: string): Promise<void> {
    try {
      await prisma.customer.update({
        where: { whatsappPhoneNumber },
        data: { 
          isBanned: false,
          bannedAt: null,
          banReason: null,
          updatedAt: new Date()
        }
      });

      logger.info(`Customer with phone ${whatsappPhoneNumber} has been unbanned`);
    } catch (error) {
      logger.error('Error unbanning customer:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to unban customer',
        { metadata: { whatsappPhoneNumber } }
      );
    }
  }

  /**
   * Get customer with delivery info by WhatsApp phone number
   */
  static async getCustomerWithDeliveryInfo(whatsappPhoneNumber: string): Promise<any> {
    try {
      const customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber },
        include: {
          addresses: true
        }
      });

      if (!customer) {
        throw new BusinessLogicError(
          ErrorCode.CUSTOMER_NOT_FOUND,
          'Customer not found',
          { metadata: { whatsappPhoneNumber } }
        );
      }

      return customer;
    } catch (error) {
      if (error instanceof BusinessLogicError) throw error;
      
      logger.error('Error getting customer with delivery info:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to get customer information',
        { metadata: { whatsappPhoneNumber } }
      );
    }
  }

  /**
   * Get customer with delivery info by ID
   */
  static async getCustomerWithDeliveryInfoById(customerId: string): Promise<any> {
    try {
      const customer = await prisma.customer.findUnique({
        where: { id: customerId },
        include: {
          addresses: true
        }
      });

      if (!customer) {
        throw new BusinessLogicError(
          ErrorCode.CUSTOMER_NOT_FOUND,
          'Customer not found',
          { metadata: { customerId } }
        );
      }

      return customer;
    } catch (error) {
      if (error instanceof BusinessLogicError) throw error;
      
      logger.error('Error getting customer with delivery info by ID:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to get customer information',
        { metadata: { customerId } }
      );
    }
  }
}

================
File: backend/src/services/messaging/middlewares/CustomerValidationMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { prisma } from '../../../server';
import { sendWhatsAppMessage } from '../../whatsapp';
import { BANNED_USER_MESSAGE } from '../../../common/config/predefinedMessages';
import logger from '../../../common/utils/logger';

export class CustomerValidationMiddleware implements MessageMiddleware {
  name = 'CustomerValidationMiddleware';

  private removeDuplicateMessages(messages: any[]): any[] {
    if (messages.length === 0) return messages;
    
    const cleaned: any[] = [messages[0]];
    
    for (let i = 1; i < messages.length; i++) {
      const current = messages[i];
      const previous = messages[i - 1];
      
      // Si el mensaje actual es diferente al anterior, lo agregamos
      if (current.role !== previous.role || current.content !== previous.content) {
        cleaned.push(current);
      }
    }
    
    return cleaned;
  }

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      const whatsappPhoneNumber = context.message.from;
      
      // Obtener o crear cliente con sus direcciones
      let customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber },
        include: { addresses: true }
      });

      if (!customer) {
        // Crear nuevo cliente
        customer = await prisma.customer.create({
          data: {
            whatsappPhoneNumber,
            lastInteraction: new Date(),
            fullChatHistory: [],
            relevantChatHistory: []
          },
          include: { addresses: true }
        });
        
        // Marcar como cliente nuevo para mensaje de bienvenida
        context.set('isNewCustomer', true);
        context.set('hasNoAddress', true);
      } else {
        // Verificar si el cliente está baneado
        if (customer.isBanned) {
          logger.warn(`Banned customer ${whatsappPhoneNumber} tried to send a message`);
          const bannedMessage = await BANNED_USER_MESSAGE();
          await sendWhatsAppMessage(whatsappPhoneNumber, bannedMessage);
          context.stop();
          return context;
        }
        
        // Verificar si el cliente tiene direcciones activas
        const activeAddresses = customer.addresses.filter(addr => !addr.deletedAt);
        if (activeAddresses.length === 0) {
          context.set('hasNoAddress', true);
          logger.info(`Customer ${whatsappPhoneNumber} has no active addresses`);
        }
      }

      context.setCustomer(customer);
      
      // Cargar historial de chat
      const fullChatHistory = Array.isArray(customer.fullChatHistory)
        ? customer.fullChatHistory
        : JSON.parse((customer.fullChatHistory as string) || "[]");
      
      let relevantChatHistory = Array.isArray(customer.relevantChatHistory)
        ? customer.relevantChatHistory
        : JSON.parse((customer.relevantChatHistory as string) || "[]");
      
      // Limpiar duplicados consecutivos en el historial relevante
      relevantChatHistory = this.removeDuplicateMessages(relevantChatHistory);
      
      // Limitar el historial relevante a los últimos 20 mensajes
      if (relevantChatHistory.length > 20) {
        relevantChatHistory = relevantChatHistory.slice(-20);
        logger.debug(`Historial relevante limitado a los últimos 20 mensajes (de ${relevantChatHistory.length} total)`);
      }
      
      context.set('fullChatHistory', fullChatHistory);
      context.set('relevantChatHistory', relevantChatHistory);
      
      // Verificar si es una conversación nueva (más de 1 hora desde la última interacción)
      const isNewConversation = customer.lastInteraction && 
        (new Date().getTime() - new Date(customer.lastInteraction).getTime() > 60 * 60 * 1000) ||
        relevantChatHistory.length === 0;
      
      if (isNewConversation && !context.get('isNewCustomer')) {
        context.set('isNewConversation', true);
      }

      return context;
    } catch (error) {
      logger.error('Error in CustomerValidationMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/middlewares/MessageTypeMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } from '../../whatsapp';
import { WELCOME_MESSAGE_INTERACTIVE, UNSUPPORTED_MESSAGE_TYPE } from '../../../common/config/predefinedMessages';
import logger from '../../../common/utils/logger';

export class MessageTypeMiddleware implements MessageMiddleware {
  name = 'MessageTypeMiddleware';

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      // Verificar si es un cliente nuevo o conversación nueva que necesita mensaje de bienvenida
      const customer = context.customer;
      const isVeryNewCustomer = customer && customer.createdAt && 
        (new Date().getTime() - new Date(customer.createdAt).getTime() < 5 * 60 * 1000); // Created less than 5 minutes ago
      
      // Only send welcome if it's a new conversation (not a brand new customer who just registered)
      if (context.get('isNewConversation') && !isVeryNewCustomer) {
        const welcomeMessage = await WELCOME_MESSAGE_INTERACTIVE();
        await sendWhatsAppInteractiveMessage(context.message.from, welcomeMessage);
      }
      
      // La detección de reinicio ahora se maneja a través del agente general
      
      // Validar tipo de mensaje
      const supportedTypes = ['text', 'interactive', 'audio'];
      if (!supportedTypes.includes(context.message.type)) {
        await sendWhatsAppMessage(context.message.from, UNSUPPORTED_MESSAGE_TYPE);
        context.stop();
        return context;
      }
      
      // Establecer tipo de mensaje para procesamiento
      context.set('messageType', context.message.type);
      
      // Para mensajes de audio, necesitaremos manejar la transcripción
      if (context.message.type === 'audio') {
        context.set('needsTranscription', true);
      }
      
      return context;
    } catch (error) {
      logger.error('Error in MessageTypeMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/orders/dto/create-order.dto.ts
================
import {
  IsString,
  IsArray,
  IsOptional,
  IsDateString,
  ValidateNested,
  IsNotEmpty,
  IsNumber,
} from "class-validator";
import { Type } from "class-transformer";

class OrderItemDto {
  @IsString()
  productId: string;

  @IsOptional()
  @IsString()
  productVariantId?: string;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => SelectedPizzaIngredientDto)
  selectedPizzaIngredients: SelectedPizzaIngredientDto[];

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => SelectedModifierDto)
  selectedModifiers: SelectedModifierDto[];

  @IsNotEmpty()
  quantity: number;

  @IsOptional()
  @IsString()
  comments?: string;
}

class SelectedPizzaIngredientDto {
  @IsString()
  pizzaIngredientId: string;

  @IsString()
  half: string;

  @IsString()
  action: string;
}

class SelectedModifierDto {
  @IsString()
  modifierId: string;
}

class OrderDeliveryInfoDto {
  @IsNumber()
  @IsOptional()
  id?: number;

  @IsString()
  @IsOptional()
  street?: string;

  @IsString()
  @IsOptional()
  number?: string;

  @IsString()
  @IsOptional()
  interiorNumber?: string;

  @IsString()
  @IsOptional()
  neighborhood?: string;

  @IsString()
  @IsOptional()
  zipCode?: string;

  @IsString()
  @IsOptional()
  city?: string;

  @IsString()
  @IsOptional()
  state?: string;

  @IsString()
  @IsOptional()
  country?: string;

  @IsNumber()
  @IsOptional()
  latitude?: number;

  @IsNumber()
  @IsOptional()
  longitude?: number;

  @IsString()
  @IsOptional()
  pickupName?: string;


  @IsString()
  @IsOptional()
  references?: string;

  @IsNumber()
  @IsOptional()
  preOrderId?: number;

  @IsNumber()
  @IsOptional()
  orderId?: number;
}

export class CreateOrderDto {
  @IsString()
  orderType: string;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => OrderItemDto)
  orderItems: OrderItemDto[];

  @IsOptional()
  @ValidateNested()
  @Type(() => OrderDeliveryInfoDto)
  orderDeliveryInfo?: OrderDeliveryInfoDto;

  @IsString()
  customerId: string;

  @IsOptional()
  @IsDateString()
  scheduledAt?: string;
}

================
File: backend/src/services/orders/services/DeliveryInfoService.ts
================
import { prisma } from "../../../server";
import { ValidationError, ErrorCode, NotFoundError } from "../../../common/services/errors";
import logger from "../../../common/utils/logger";
import { DeliveryInfoInput } from "../../../common/types";
import { Address, Prisma } from "@prisma/client";

export class DeliveryInfoService {
  /**
   * Obtener o crear información de entrega para una orden
   */
  static async getOrCreateDeliveryInfo(
    orderType: 'delivery' | 'pickup',
    customerId: string,
    deliveryInfoInput?: DeliveryInfoInput
  ): Promise<any> {
    // Obtener la dirección predeterminada del cliente o la primera dirección activa
    const customerAddress = await prisma.address.findFirst({
      where: { 
        customerId,
        deletedAt: null
      },
      orderBy: [
        { isDefault: 'desc' },
        { createdAt: 'desc' }
      ]
    });

    if (!customerAddress) {
      throw new ValidationError(
        ErrorCode.MISSING_DELIVERY_INFO,
        'Customer has no active addresses',
        { metadata: { customerId } }
      );
    }

    // Construir datos de información de entrega basados en el tipo de orden
    let deliveryInfoData: any = {};

    if (orderType === "delivery") {
      // Copiar todos los campos de dirección desde la dirección del cliente
      // Esto crea una instantánea de la dirección en el momento de la orden
      deliveryInfoData = {
        street: deliveryInfoInput?.street || customerAddress.street,
        number: customerAddress.number,
        interiorNumber: customerAddress.interiorNumber,
        neighborhood: deliveryInfoInput?.neighborhood || customerAddress.neighborhood,
        zipCode: deliveryInfoInput?.zipCode || customerAddress.zipCode,
        city: deliveryInfoInput?.city || customerAddress.city,
        state: deliveryInfoInput?.state || customerAddress.state,
        country: deliveryInfoInput?.country || customerAddress.country,
        latitude: deliveryInfoInput?.latitude || customerAddress.latitude?.toNumber(),
        longitude: deliveryInfoInput?.longitude || customerAddress.longitude?.toNumber(),
        references: deliveryInfoInput?.references || customerAddress.references,
      };

      // Validar campos requeridos para entrega
      if (!deliveryInfoData.street || !deliveryInfoData.number) {
        throw new ValidationError(
          ErrorCode.MISSING_DELIVERY_INFO,
          'Street address and number are required for delivery orders',
          { metadata: { customerId, orderType } }
        );
      }
    } else if (orderType === "pickup") {
      // Para órdenes de recogida, quizás solo necesitemos información básica
      deliveryInfoData = {
        pickupName: customerId, // Usar ID del cliente como referencia de recogida
      };
    }

    // Crear una copia de información de entrega para esta orden específica
    // Esto preserva la dirección en el momento de creación de la orden
    const orderDeliveryInfo = await prisma.orderDeliveryInfo.create({
      data: deliveryInfoData
    });

    logger.info(`Created order delivery info ${orderDeliveryInfo.id} from customer address`);
    return orderDeliveryInfo;
  }

  /**
   * Actualizar información de entrega para una preorden
   */
  static async updatePreOrderDeliveryInfo(
    preOrderId: number,
    deliveryInfo: DeliveryInfoInput
  ): Promise<void> {
    const preOrder = await prisma.preOrder.findUnique({
      where: { id: preOrderId },
      include: { deliveryInfo: true }
    });

    if (!preOrder) {
      throw new ValidationError(
        ErrorCode.ORDER_NOT_FOUND,
        'PreOrder not found',
        { metadata: { preOrderId } }
      );
    }

    if (preOrder.deliveryInfo && preOrder.deliveryInfo.length > 0 && preOrder.deliveryInfo[0].id) {
      // Actualizar información de entrega existente
      await prisma.orderDeliveryInfo.update({
        where: { id: preOrder.deliveryInfo[0].id },
        data: deliveryInfo
      });
    } else {
      // Crear nueva información de entrega y vincularla
      const newDeliveryInfo = await prisma.orderDeliveryInfo.create({
        data: deliveryInfo
      });

      await prisma.preOrder.update({
        where: { id: preOrderId },
        data: {
          deliveryInfo: {
            connect: { id: newDeliveryInfo.id }
          }
        }
      });
    }

    logger.info(`Updated delivery info for preorder ${preOrderId}`);
  }

  /**
   * Validar que la dirección de entrega esté dentro del área de cobertura
   */
  static async validateDeliveryArea(
    latitude: number,
    longitude: number
  ): Promise<boolean> {
    const config = await prisma.restaurantConfig.findFirst();
    
    if (!config || !config.deliveryCoverageArea) {
      // Si no se define área de cobertura, aceptar todas las entregas
      return true;
    }

    // TODO: Implementar verificación real de polígono/radio
    // Por ahora, retornar true
    logger.warn('Delivery area validation not implemented yet');
    return true;
  }

  /**
   * Crear dirección del cliente
   */
  static async createCustomerAddress(
    data: Prisma.AddressCreateInput
  ): Promise<Address> {
    try {
      // Si esta es la primera dirección, hacerla predeterminada
      const existingAddresses = await prisma.address.count({
        where: { 
          customerId: data.customer.connect?.id || data.customer.connectOrCreate?.where.id,
          deletedAt: null
        }
      });
      
      const addressData = {
        ...data,
        isDefault: existingAddresses === 0 ? true : (data.isDefault || false)
      };
      
      // Si se establece como predeterminada, desmarcar otras predeterminadas
      if (addressData.isDefault) {
        await prisma.address.updateMany({
          where: { 
            customerId: data.customer.connect?.id || data.customer.connectOrCreate?.where.id,
            isDefault: true
          },
          data: { isDefault: false }
        });
      }
      
      const address = await prisma.address.create({
        data: addressData
      });
      
      logger.info(`Created customer address ${address.id} for customer ${address.customerId}`);
      return address;
    } catch (error) {
      logger.error('Error creating customer address:', error);
      throw new ValidationError(ErrorCode.DATABASE_ERROR, 'Failed to create customer address', { metadata: { error: error instanceof Error ? error.message : 'Unknown error' } });
    }
  }

  /**
   * Actualizar dirección del cliente
   */
  static async updateCustomerAddress(
    addressId: string,
    data: Prisma.AddressUpdateInput
  ): Promise<Address> {
    try {
      const deliveryInfo = await prisma.address.update({
        where: { id: addressId },
        data
      });
      
      logger.info(`Updated address ${addressId}`);
      return deliveryInfo;
    } catch (error: any) {
      if (error.code === 'P2025') {
        throw new NotFoundError(
          ErrorCode.ORDER_NOT_FOUND,
          'Address not found',
          { metadata: { addressId } }
        );
      }
      
      logger.error('Error updating customer address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to update customer address',
        { metadata: { addressId } }
      );
    }
  }

  /**
   * Copiar dirección del cliente a información de entrega de orden
   * Este es un método de conveniencia para crear OrderDeliveryInfo desde la Address del cliente
   */
  static async copyCustomerAddressToOrder(
    customerId: string,
    orderType: 'delivery' | 'pickup',
    customDeliveryInfo?: DeliveryInfoInput
  ): Promise<any> {
    return this.getOrCreateDeliveryInfo(orderType, customerId, customDeliveryInfo);
  }

  /**
   * Obtener todas las direcciones del cliente
   */
  static async getCustomerAddresses(
    customerId: string,
    includeInactive: boolean = false
  ): Promise<Address[]> {
    try {
      const addresses = await prisma.address.findMany({
        where: { 
          customerId,
          ...(includeInactive ? {} : { deletedAt: null })
        },
        orderBy: [
          { isDefault: 'desc' },
          { createdAt: 'desc' }
        ]
      });
      
      return addresses;
    } catch (error) {
      logger.error('Error fetching customer addresses:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to fetch customer addresses',
        { metadata: { customerId } }
      );
    }
  }

  /**
   * Obtener la dirección predeterminada del cliente
   */
  static async getCustomerDefaultAddress(
    customerId: string
  ): Promise<Address | null> {
    try {
      const address = await prisma.address.findFirst({
        where: { 
          customerId,
          isDefault: true,
          deletedAt: null
        }
      });
      
      if (!address) {
        // Si no hay predeterminada, obtener la primera dirección activa
        const firstAddress = await prisma.address.findFirst({
          where: { 
            customerId,
            deletedAt: null
          },
          orderBy: { createdAt: 'desc' }
        });
        
        return firstAddress;
      }
      
      return address;
    } catch (error) {
      logger.error('Error fetching default address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to fetch default address',
        { metadata: { customerId } }
      );
    }
  }

  /**
   * Establecer dirección como predeterminada
   */
  static async setDefaultAddress(
    addressId: string,
    customerId: string
  ): Promise<Address> {
    try {
      // Desmarcar otras predeterminadas
      await prisma.address.updateMany({
        where: { 
          customerId,
          isDefault: true
        },
        data: { isDefault: false }
      });
      
      // Establecer esta como predeterminada
      const address = await prisma.address.update({
        where: { id: addressId },
        data: { isDefault: true }
      });
      
      logger.info(`Set address ${addressId} as default for customer ${customerId}`);
      return address;
    } catch (error) {
      logger.error('Error setting default address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to set default address',
        { metadata: { addressId, customerId } }
      );
    }
  }

  /**
   * Eliminación suave de dirección
   */
  static async deleteCustomerAddress(
    addressId: string,
    customerId: string
  ): Promise<void> {
    try {
      const address = await prisma.address.findFirst({
        where: { id: addressId, customerId }
      });
      
      if (!address) {
        throw new NotFoundError(
          ErrorCode.ORDER_NOT_FOUND,
          'Address not found',
          { metadata: { addressId, customerId } }
        );
      }
      
      // Eliminación suave
      await prisma.address.update({
        where: { id: addressId },
        data: { 
          deletedAt: new Date()
        }
      });
      
      // Si era predeterminada, establecer otra como predeterminada
      if (address.isDefault) {
        const nextDefault = await prisma.address.findFirst({
          where: { 
            customerId,
            deletedAt: null,
            id: { not: addressId }
          },
          orderBy: { createdAt: 'desc' }
        });
        
        if (nextDefault) {
          await this.setDefaultAddress(nextDefault.id, customerId);
        }
      }
      
      logger.info(`Soft deleted address ${addressId} for customer ${customerId}`);
    } catch (error) {
      if (error instanceof NotFoundError) {
        throw error;
      }
      
      logger.error('Error deleting address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to delete address',
        { metadata: { addressId, customerId } }
      );
    }
  }
}

================
File: backend/src/services/orders/services/OrderManagementService.ts
================
import { prisma } from "../../../server";
import { Order, OrderStatus, PreOrder } from "@prisma/client";
import logger from "../../../common/utils/logger";
import { BusinessLogicError, ErrorCode } from "../../../common/services/errors";
import { OrderService } from "../OrderService";
import { CreateOrderDto } from "../dto/create-order.dto";

export class OrderManagementService {
  private orderService: OrderService;

  constructor() {
    this.orderService = new OrderService();
  }

  /**
   * Convert a preorder to a confirmed order
   */
  async confirmPreOrder(preOrderId: number): Promise<Order> {
    const preOrder = await prisma.preOrder.findUnique({
      where: { id: preOrderId },
      include: {
        deliveryInfo: true,
      },
    });

    if (!preOrder) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'PreOrder not found',
        { metadata: { preOrderId } }
      );
    }

    // Build order items from preOrder.orderItems JSON
    const orderItems = (preOrder.orderItems as any[]).map((item) => ({
      productId: item.productId,
      productVariantId: item.productVariantId,
      quantity: item.quantity,
      comments: item.comments,
      selectedModifiers: item.selectedModifiers || [],
      selectedPizzaIngredients: item.selectedPizzaIngredients || [],
    }));

    // Build delivery info if exists
    let deliveryInfo = undefined;
    if (preOrder.deliveryInfo && preOrder.deliveryInfo.length > 0) {
      const info = preOrder.deliveryInfo[0];
      deliveryInfo = {
        street: info.street || undefined,
        number: info.number || undefined,
        interiorNumber: info.interiorNumber || undefined,
        neighborhood: info.neighborhood || undefined,
        zipCode: info.zipCode || undefined,
        city: info.city || undefined,
        state: info.state || undefined,
        country: info.country || undefined,
        latitude: info.latitude ? info.latitude.toNumber() : undefined,
        longitude: info.longitude ? info.longitude.toNumber() : undefined,
        pickupName: info.pickupName || undefined,
        references: info.references || undefined,
      };
    }

    // Get customer by WhatsApp phone number
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: preOrder.whatsappPhoneNumber }
    });

    if (!customer) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer not found for this phone number',
        { metadata: { whatsappPhoneNumber: preOrder.whatsappPhoneNumber } }
      );
    }

    const orderData: CreateOrderDto = {
      orderItems,
      customerId: customer.id,
      orderType: preOrder.orderType,
      scheduledAt: preOrder.scheduledAt ? preOrder.scheduledAt.toISOString() : undefined,
      ...(deliveryInfo ? { orderDeliveryInfo: deliveryInfo } : {}),
    };

    // Create the order
    const order = await this.orderService.create(orderData);

    // Delete the preorder after successful confirmation
    await prisma.preOrder.delete({ where: { id: preOrderId } });

    logger.info(`PreOrder ${preOrderId} converted to Order ${order.id}`);
    return order;
  }

  /**
   * Cancel an order if it's in a cancellable state
   */
  async cancelOrder(orderId: string): Promise<Order> {
    const order = await prisma.order.findUnique({
      where: { id: orderId },
    });

    if (!order) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'Order not found',
        { metadata: { orderId } }
      );
    }

    const cancellableStatuses: OrderStatus[] = ["PENDING", "IN_PROGRESS"];
    if (!cancellableStatuses.includes(order.orderStatus)) {
      throw new BusinessLogicError(ErrorCode.ORDER_CANNOT_CANCEL, 'Cannot cancel order with status: ${order.orderStatus}', { metadata: { orderId, currentStatus: order.orderStatus } });
    }

    const cancelledOrder = await prisma.order.update({
      where: { id: orderId },
      data: { orderStatus: 'CANCELLED' },
    });

    logger.info(`Order ${orderId} cancelled successfully`);
    return cancelledOrder;
  }

  /**
   * Get order by message ID
   */
  async getOrderByMessageId(messageId: string): Promise<Order | null> {
    return await prisma.order.findFirst({
      where: { messageId },
      include: {
        orderItems: {
          include: {
            product: true,
            productVariant: true,
            productModifiers: true,
            selectedPizzaIngredients: {
              include: { pizzaIngredient: true },
            },
          },
        },
        deliveryInfo: true,
      },
    });
  }

  /**
   * Get preorder by message ID
   */
  async getPreOrderByMessageId(messageId: string): Promise<PreOrder | null> {
    return await prisma.preOrder.findFirst({
      where: { messageId },
      include: {
        deliveryInfo: true,
      },
    });
  }

  /**
   * Update order message ID for tracking
   */
  async updateOrderMessageId(orderId: string, messageId: string): Promise<void> {
    await prisma.order.update({
      where: { id: orderId },
      data: { messageId },
    });
  }

  /**
   * Discard a preorder
   */
  async discardPreOrder(preOrderId: number): Promise<void> {
    const preOrder = await prisma.preOrder.findUnique({
      where: { id: preOrderId },
    });

    if (!preOrder) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'PreOrder not found',
        { metadata: { preOrderId } }
      );
    }

    await prisma.preOrder.delete({
      where: { id: preOrderId },
    });

    logger.info(`PreOrder ${preOrderId} discarded successfully`);
  }
}

================
File: backend/src/services/orders/services/SchedulingService.ts
================
import { RestaurantService } from "../../restaurant/RestaurantService";
import { ValidationError, ErrorCode } from "../../../common/services/errors";
import { env } from "../../../common/config/envValidator";

export class SchedulingService {
  /**
   * Validate and process scheduled delivery time
   */
  static async validateScheduledTime(
    scheduledAt: string | Date | undefined,
    orderType: 'delivery' | 'pickup'
  ): Promise<Date | null> {
    if (!scheduledAt || scheduledAt === "null") {
      return null;
    }

    const now = new Date();
    let fullScheduledDeliveryTime: Date;

    if (scheduledAt instanceof Date) {
      fullScheduledDeliveryTime = scheduledAt;
    } else {
      const timeParts = scheduledAt.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
      if (!timeParts) {
        throw new ValidationError(
          ErrorCode.INVALID_SCHEDULE_TIME,
          'Invalid time format',
          { metadata: { scheduledAt } }
        );
      }

      let hours = parseInt(timeParts[1]);
      const minutes = parseInt(timeParts[2]);
      const meridiem = timeParts[3];

      if (meridiem) {
        if (meridiem.toUpperCase() === "PM" && hours !== 12) {
          hours += 12;
        } else if (meridiem.toUpperCase() === "AM" && hours === 12) {
          hours = 0;
        }
      }

      fullScheduledDeliveryTime = new Date(now);
      fullScheduledDeliveryTime.setHours(hours, minutes, 0, 0);

      if (fullScheduledDeliveryTime <= now) {
        fullScheduledDeliveryTime.setDate(fullScheduledDeliveryTime.getDate() + 1);
      }
    }

    // Validate against business hours
    await this.validateAgainstBusinessHours(fullScheduledDeliveryTime, orderType);

    return fullScheduledDeliveryTime;
  }

  /**
   * Validate scheduled time against business hours
   */
  private static async validateAgainstBusinessHours(
    scheduledTime: Date,
    orderType: 'delivery' | 'pickup'
  ): Promise<void> {
    const config = await RestaurantService.getConfig();
    
    // Convert to Mexico time
    const mexicoTime = new Date(
      scheduledTime.toLocaleString("en-US", {
        timeZone: config.timeZone || env.DEFAULT_TIMEZONE,
      })
    );

    const dayOfWeek = mexicoTime.getDay();
    const scheduledHour = mexicoTime.getHours();
    const scheduledMinute = mexicoTime.getMinutes();

    // Get business hours for the day
    const businessHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
    
    if (!businessHours || businessHours.isClosed || !businessHours.openingTime || !businessHours.closingTime) {
      throw new ValidationError(
        ErrorCode.RESTAURANT_CLOSED,
        'Restaurant is closed on this day',
        { metadata: { dayOfWeek } }
      );
    }

    // Parse opening and closing times
    const [openingHour, openingMinute] = businessHours.openingTime.split(":").map(Number);
    const [closingHour, closingMinute] = businessHours.closingTime.split(":").map(Number);
    const openingMinutes = openingHour * 60 + openingMinute;
    const closingMinutes = closingHour * 60 + closingMinute;

    // Apply grace periods
    const openingGracePeriod = config.openingGracePeriod || 0;
    const closingGracePeriod = config.closingGracePeriod || 0;
    const adjustedOpeningMinutes = openingMinutes - openingGracePeriod;
    const adjustedClosingMinutes = closingMinutes + closingGracePeriod;

    // Convert scheduled time to minutes
    const scheduledMinutes = scheduledHour * 60 + scheduledMinute;

    // Check if within hours
    if (scheduledMinutes < adjustedOpeningMinutes || scheduledMinutes > adjustedClosingMinutes) {
      const adjustedOpeningTime = new Date(mexicoTime);
      adjustedOpeningTime.setHours(openingHour, openingMinute - openingGracePeriod);
      
      const adjustedClosingTime = new Date(mexicoTime);
      adjustedClosingTime.setHours(closingHour, closingMinute + closingGracePeriod);

      const openingFormatted = adjustedOpeningTime.toLocaleTimeString("es-MX", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: true,
      });
      const closingFormatted = adjustedClosingTime.toLocaleTimeString("es-MX", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: true,
      });

      throw new ValidationError(
        ErrorCode.INVALID_SCHEDULE_TIME,
        `Scheduled time is outside business hours. Please schedule between ${openingFormatted} and ${closingFormatted}`,
        { metadata: { scheduledMinutes, adjustedOpeningMinutes, adjustedClosingMinutes } }
      );
    }

    // Check minimum time requirement
    const minTimeRequired = orderType === "pickup" 
      ? config.estimatedPickupTime 
      : config.estimatedDeliveryTime;
    
    const now = new Date();
    const timeDifference = (scheduledTime.getTime() - now.getTime()) / (1000 * 60);

    if (timeDifference < minTimeRequired) {
      throw new ValidationError(
        ErrorCode.INVALID_SCHEDULE_TIME,
        `Scheduled time must be at least ${minTimeRequired} minutes from now`,
        { metadata: { timeDifference, minTimeRequired } }
      );
    }
  }
}

================
File: backend/src/services/products/ProductService.ts
================
import { prisma } from '../../server';
import { Product, Category, ProductVariant } from '@prisma/client';
import logger from '../../common/utils/logger';
import { NotFoundError, ErrorCode } from '../../common/services/errors';

/**
 * Service for managing products and menu
 */
export class ProductService {
  /**
   * Get all active products with their relations
   */
  static async getActiveProducts(options?: {
    includeRelations?: boolean;
    formatForAI?: boolean;
    restaurantName?: string;
  }): Promise<Product[] | string> {
    try {
      const products = await prisma.product.findMany({
        where: { isActive: true },
        include: options?.includeRelations !== false ? {
          subcategory: {
            include: {
              category: true
            }
          },
          variants: {
            where: { isActive: true }
          },
          modifierGroups: {
            include: {
              productModifiers: {
                where: { isActive: true }
              }
            }
          },
          pizzaIngredients: {
            where: { isActive: true }
          }
        } : undefined
      });

      // Si se solicita formato para AI, formatear el menú
      if (options?.formatForAI) {
        // Obtener nombre del restaurante si no se proporciona
        let restaurantName = options.restaurantName;
        if (!restaurantName) {
          try {
            const { RestaurantService } = await import('../restaurant/RestaurantService');
            const config = await RestaurantService.getConfig();
            restaurantName = config.restaurantName;
          } catch (error) {
            restaurantName = "Nuestro Restaurante";
          }
        }
        return this.formatMenuForAI(products, restaurantName);
      }

      return products;
    } catch (error) {
      logger.error('Error fetching active products:', error);
      throw error;
    }
  }

  /**
   * Format menu for AI consumption
   */
  private static formatMenuForAI(products: any[], restaurantName: string = "Nuestro Restaurante"): string {
    let menuText = `🍽️ **MENÚ DE ${restaurantName.toUpperCase()}** 🍽️\n`;
    menuText += "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n";

    // Agrupar por categoría y subcategoría
    const productsByCategory = products.reduce((acc, product) => {
      const categoryName = product.subcategory?.category?.name || 'Sin categoría';
      const subcategoryName = product.subcategory?.name || 'Sin subcategoría';
      
      if (!acc[categoryName]) acc[categoryName] = {};
      if (!acc[categoryName][subcategoryName]) {
        acc[categoryName][subcategoryName] = {
          description: product.subcategory?.description,
          products: []
        };
      }
      acc[categoryName][subcategoryName].products.push(product);
      return acc;
    }, {} as Record<string, Record<string, { description: string | null; products: any[] }>>);

    // Mapeo de emojis por tipo de categoría (genérico)
    const categoryEmojis: Record<string, string> = {
      'pizza': '🍕',
      'pizzas': '🍕',
      'hamburguesa': '🍔',
      'hamburguesas': '🍔',
      'bebida': '🥤',
      'bebidas': '🥤',
      'postre': '🍰',
      'postres': '🍰',
      'ensalada': '🥗',
      'ensaladas': '🥗',
      'pasta': '🍝',
      'pastas': '🍝',
      'sandwich': '🥪',
      'sandwiches': '🥪',
      'sushi': '🍱',
      'comida china': '🥡',
      'tacos': '🌮',
      'mexicana': '🌮',
      'desayuno': '🍳',
      'desayunos': '🍳',
      'café': '☕',
      'cafés': '☕',
      'sopa': '🍲',
      'sopas': '🍲',
      'mariscos': '🦐',
      'pescados': '🐟',
      'pollo': '🍗',
      'carne': '🥩',
      'carnes': '🥩',
      'vegano': '🌱',
      'vegetariano': '🥦',
      'combo': '🍱',
      'combos': '🍱',
      'promoción': '⭐',
      'promociones': '⭐'
    };

    // Función para obtener emoji apropiado
    const getEmoji = (categoryName: string): string => {
      const lowerName = categoryName.toLowerCase();
      for (const [key, emoji] of Object.entries(categoryEmojis)) {
        if (lowerName.includes(key)) {
          return emoji;
        }
      }
      return '🍽️'; // Emoji por defecto
    };

    // Formatear por categoría y subcategoría
    for (const [category, subcategories] of Object.entries(productsByCategory)) {
      const emoji = getEmoji(category);
      
      menuText += `\n${emoji} **${category.toUpperCase()}** ${emoji}\n`;
      menuText += `${'─'.repeat(30)}\n\n`;
      
      for (const [subcategory, data] of Object.entries(subcategories as Record<string, any>)) {
        if (subcategory !== 'Sin subcategoría') {
          menuText += `▸ _${subcategory}_\n\n`;
        }
        
        const categoryProducts = data.products;
        
        for (const product of categoryProducts) {
          // Nombre del producto
          menuText += `  **${product.name}**`;
          
          // Precio si no tiene variantes
          if (!product.hasVariants && product.price) {
            menuText += ` ─ $${product.price.toFixed(2)}`;
          }
          
          menuText += '\n';
          
          // Variantes con precios
          if (product.variants?.length > 0 && product.hasVariants) {
            for (const variant of product.variants) {
              menuText += `    • ${variant.name}: **$${variant.price.toFixed(2)}**\n`;
            }
          }
          
          // Ingredientes de pizza (si aplica)
          if (product.pizzaIngredients?.length > 0 && product.isPizza) {
            const ingredients = product.pizzaIngredients.map(i => i.name).join(', ');
            menuText += `    _Ingredientes: ${ingredients}_\n`;
          }
          
          // Modificadores disponibles
          if (product.modifierGroups?.length > 0) {
            for (const modGroup of product.modifierGroups) {
              if (modGroup.productModifiers?.length > 0) {
                menuText += `\n    **${modGroup.name}**\n`;
                for (const mod of modGroup.productModifiers) {
                  const price = mod.price ? `+$${mod.price.toFixed(2)}` : 'Sin costo';
                  menuText += `      ○ ${mod.name} (${price})\n`;
                }
              }
            }
          }
          
          menuText += "\n";
        }
      }
    }

    // Agregar información adicional
    menuText += "\n━━━━━━━━━━━━━━━━━━━━━━\n";
    menuText += "💡 **Cómo ordenar:**\n";
    menuText += "• Menciona el nombre del producto\n";
    menuText += "• Especifica el tamaño si hay variantes\n";
    menuText += "• Indica modificadores si deseas\n";
    menuText += "━━━━━━━━━━━━━━━━━━━━━━\n";

    return menuText;
  }

  /**
   * Get all active categories
   */
  static async getActiveCategories(): Promise<Category[]> {
    try {
      return await prisma.category.findMany({
        where: { isActive: true },
        include: {
          subcategories: {
            where: { isActive: true }
          }
        }
      });
    } catch (error) {
      logger.error('Error fetching active categories:', error);
      throw error;
    }
  }

  /**
   * Get product by ID
   */
  static async getProductById(productId: string): Promise<Product | null> {
    try {
      return await prisma.product.findUnique({
        where: { id: productId },
        include: {
          variants: true,
          modifierGroups: {
            include: {
              productModifiers: true
            }
          },
          pizzaIngredients: true
        }
      });
    } catch (error) {
      logger.error('Error fetching product by ID:', error);
      throw error;
    }
  }

  /**
   * Get variant by ID
   */
  static async getVariantById(variantId: string): Promise<ProductVariant | null> {
    try {
      return await prisma.productVariant.findUnique({
        where: { id: variantId },
        include: {
          product: true
        }
      });
    } catch (error) {
      logger.error('Error fetching variant by ID:', error);
      throw error;
    }
  }

  /**
   * Toggle product availability
   */
  static async toggleProductAvailability(productId: string, isActive: boolean): Promise<Product> {
    try {
      const product = await prisma.product.update({
        where: { id: productId },
        data: { isActive }
      });

      logger.info(`Product ${productId} availability set to ${isActive}`);
      return product;
    } catch (error) {
      logger.error('Error toggling product availability:', error);
      throw new NotFoundError(
        ErrorCode.INVALID_PRODUCT,
        'Product not found',
        { metadata: { productId } }
      );
    }
  }

  /**
   * Toggle variant availability
   */
  static async toggleVariantAvailability(variantId: string, isActive: boolean): Promise<ProductVariant> {
    try {
      const variant = await prisma.productVariant.update({
        where: { id: variantId },
        data: { isActive }
      });

      logger.info(`Variant ${variantId} availability set to ${isActive}`);
      return variant;
    } catch (error) {
      logger.error('Error toggling variant availability:', error);
      throw new NotFoundError(
        ErrorCode.INVALID_PRODUCT,
        'Product variant not found',
        { metadata: { variantId } }
      );
    }
  }

  /**
   * Get menu structure for AI context (without IDs or prices)
   */
  static async getMenuStructureForAI(): Promise<any> {
    try {
      const products = await prisma.product.findMany({
        where: { isActive: true },
        include: {
          subcategory: {
            include: {
              category: true
            }
          },
          variants: {
            where: { isActive: true },
            orderBy: { name: 'asc' }
          },
          modifierGroups: {
            include: {
              productModifiers: {
                where: { isActive: true },
                orderBy: { sortOrder: 'asc' }
              }
            }
          },
          pizzaIngredients: {
            where: { isActive: true }
          }
        },
        orderBy: { name: 'asc' }
      });

      // Agrupar por categorías
      const menuStructure: Record<string, any> = {};

      for (const product of products) {
        const categoryName = product.subcategory.category.name;
        const subcategoryName = product.subcategory.name;

        // Crear estructura de categoría si no existe
        if (!menuStructure[categoryName]) {
          menuStructure[categoryName] = {};
        }

        // Crear estructura de subcategoría si no existe
        if (!menuStructure[categoryName][subcategoryName]) {
          menuStructure[categoryName][subcategoryName] = [];
        }

        // Crear estructura del producto
        const productStructure: any = {
          nombre: product.name,
          descripcion: product.description
        };

        // Agregar variantes si existen
        if (product.variants.length > 0) {
          productStructure.variantes = product.variants.map(v => v.name);
        }

        // Agregar modificadores si existen
        if (product.modifierGroups.length > 0) {
          productStructure.modificadores = {};
          
          for (const group of product.modifierGroups) {
            if (group.productModifiers.length > 0) {
              productStructure.modificadores[group.name] = group.productModifiers.map(m => m.name);
            }
          }
        }

        // Agregar ingredientes de pizza si es una pizza
        if (product.isPizza && product.pizzaIngredients.length > 0) {
          productStructure.ingredientesPizza = product.pizzaIngredients.map(i => i.name);
        }

        menuStructure[categoryName][subcategoryName].push(productStructure);
      }

      return menuStructure;
    } catch (error) {
      logger.error('Error getting menu structure for AI:', error);
      throw error;
    }
  }

}

================
File: backend/src/services/security/OTPService.ts
================
import logger from '../../common/utils/logger';
import crypto from 'crypto';

/**
 * Service for managing One-Time Passwords (OTP)
 */
export class OTPService {
  private static otpStore = new Map<string, { code: string; expires: Date }>();
  private static cleanupInterval: NodeJS.Timeout | null = null;
  private static readonly MAX_OTP_ENTRIES = 10000;
  private static readonly OTP_EXPIRY_MINUTES = 10;

  /**
   * Generate a new OTP code
   */
  static generateOTP(): string {
    return crypto.randomInt(100000, 999999).toString();
  }

  /**
   * Store an OTP for a customer
   */
  static storeOTP(customerId: string, otp: string, isAddressRegistration: boolean = false): void {
    // Check store size limit
    if (this.otpStore.size >= this.MAX_OTP_ENTRIES) {
      this.cleanupOldestEntries();
    }

    const expires = new Date(Date.now() + this.OTP_EXPIRY_MINUTES * 60 * 1000);
    this.otpStore.set(customerId, { code: otp, expires });
    
    logger.info(`OTP stored for customer ${customerId} (expires at ${expires.toISOString()})`);
  }

  /**
   * Generate and store OTP for a customer
   */
  static async generateAndSendOTP(customerId: string): Promise<boolean> {
    try {
      const otp = this.generateOTP();
      this.storeOTP(customerId, otp);

      // In production, send via SMS/WhatsApp
      // For development, just log it
      logger.info(`OTP for customer ${customerId}: ${otp}`);

      return true;
    } catch (error) {
      logger.error('Error generating OTP:', error);
      return false;
    }
  }

  /**
   * Verify an OTP
   */
  static async verifyOTP(customerId: string, code: string): Promise<boolean> {
    try {
      logger.info(`Verifying OTP for customer ${customerId}, code: ${code}`);
      
      // Log all stored OTPs for debugging
      logger.debug(`Current OTP store size: ${this.otpStore.size}`);
      for (const [key, value] of this.otpStore.entries()) {
        logger.debug(`Stored OTP - Customer: ${key}, Code: ${value.code}, Expires: ${value.expires.toISOString()}`);
      }
      
      const storedOTP = this.otpStore.get(customerId);
      
      if (!storedOTP) {
        logger.warn(`No OTP found for customer ${customerId}`);
        return false;
      }

      // Check if expired
      if (new Date() > storedOTP.expires) {
        this.otpStore.delete(customerId);
        logger.warn(`OTP expired for customer ${customerId} - Expired at: ${storedOTP.expires.toISOString()}, Current time: ${new Date().toISOString()}`);
        return false;
      }

      // Verify code
      if (storedOTP.code === code) {
        // Don't delete immediately for address registration - allow multiple verifications
        logger.info(`OTP verified successfully for customer ${customerId}`);
        return true;
      }

      logger.warn(`Invalid OTP attempt for customer ${customerId} - Expected: ${storedOTP.code}, Received: ${code}`);
      return false;
    } catch (error) {
      logger.error('Error verifying OTP:', error);
      return false;
    }
  }

  /**
   * Invalidate an OTP
   */
  static async invalidateOTP(customerId: string): Promise<void> {
    this.otpStore.delete(customerId);
    logger.info(`OTP invalidated for customer ${customerId}`);
  }

  /**
   * Clean up oldest OTP entries when limit is reached
   */
  private static cleanupOldestEntries(): void {
    logger.warn('OTP store limit reached, cleaning up oldest entries');
    
    const entries = Array.from(this.otpStore.entries())
      .sort((a, b) => a[1].expires.getTime() - b[1].expires.getTime())
      .slice(0, Math.floor(this.MAX_OTP_ENTRIES * 0.1)); // Remove 10% of oldest
    
    entries.forEach(([key]) => this.otpStore.delete(key));
    logger.info(`Cleaned up ${entries.length} OTP entries`);
  }

  /**
   * Clean up expired OTPs
   */
  private static cleanupExpiredOTPs(): void {
    const now = new Date();
    let cleanedCount = 0;
    
    for (const [customerId, otp] of this.otpStore.entries()) {
      if (now > otp.expires) {
        this.otpStore.delete(customerId);
        cleanedCount++;
      }
    }
    
    if (cleanedCount > 0) {
      logger.debug(`Cleaned up ${cleanedCount} expired OTPs`);
    }
  }

  /**
   * Start periodic cleanup of expired OTPs
   */
  static startOTPCleanup(): void {
    if (this.cleanupInterval) return; // Already running
    
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredOTPs();
    }, 60000); // Run every minute
    
    logger.info('OTP cleanup interval started');
  }

  /**
   * Stop periodic cleanup
   */
  static stopOTPCleanup(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
      logger.info('OTP cleanup interval stopped');
    }
  }

  /**
   * Get OTP statistics (for monitoring)
   */
  static getStats(): { total: number; expired: number } {
    const now = new Date();
    let expired = 0;

    for (const [, otp] of this.otpStore.entries()) {
      if (now > otp.expires) {
        expired++;
      }
    }

    return {
      total: this.otpStore.size,
      expired
    };
  }
}

================
File: backend/src/whatsapp/handlers/orders/cancellationHandler.ts
================
import { sendWhatsAppMessage } from "../../../services/whatsapp";
import { ErrorService, BusinessLogicError, ErrorCode } from "../../../common/services/errors";
import { OrderManagementService } from "../../../services/orders/services/OrderManagementService";
import {
  ORDER_NOT_FOUND_MESSAGE,
  ORDER_CANNOT_BE_CANCELLED_MESSAGE,
  ORDER_CANCELLED_MESSAGE
} from "../../../common/config/predefinedMessages";

export async function handleOrderCancellation(
  from: string,
  messageId: string
): Promise<void> {
  try {
    const orderManagementService = new OrderManagementService();
    const order = await orderManagementService.getOrderByMessageId(messageId);

    if (!order) {
      await sendWhatsAppMessage(from, ORDER_NOT_FOUND_MESSAGE);
      return;
    }

    try {
      await orderManagementService.cancelOrder(order.id);
      await sendWhatsAppMessage(from, ORDER_CANCELLED_MESSAGE);
    } catch (error) {
      // If it's a business logic error about status, send the appropriate message
      if (error instanceof BusinessLogicError && error.code === ErrorCode.ORDER_CANNOT_CANCEL) {
        const message = ORDER_CANNOT_BE_CANCELLED_MESSAGE(order.orderStatus);
        await sendWhatsAppMessage(from, message);
        return;
      }
      throw error;
    }
  } catch (error) {
    await ErrorService.handleAndSendError(error, from, {
      userId: from,
      operation: 'handleOrderCancellation',
      metadata: { messageId }
    });
  }
}

================
File: backend/src/whatsapp/handlers/orderHandlers.ts
================
/**
 * Order handlers
 * This file now serves as a compatibility layer that re-exports
 * all order-related handlers from their new modular locations
 */

export {
  handlePreOrderConfirmation,
  sendOrderConfirmation,
  handleOrderCancellation,
  createPreOrderAndSendSummary,
  handlePreOrderDiscard
} from './orders';

================
File: backend/.gitignore
================
# Dependencies
node_modules/

# Build output
dist

# Environment files
.env
.env.local
.env.production

# IDE
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Testing
coverage/
.nyc_output/

# Temporary files
*.tmp
*.temp
.cache/

# repomix
.repomix/

/generated/prisma

================
File: frontend-app/src/types/customer.types.ts
================
export interface Customer {
  customerId: string;
  firstName?: string | null;
  lastName?: string | null;
  hasAddresses: boolean;
  addresses: Address[];
}

export interface Address {
  id: number;
  localId?: string | null;
  customerId: string;
  street: string;
  number: string;
  interiorNumber?: string | null;
  neighborhood?: string | null;
  city?: string | null;
  state?: string | null;
  zipCode?: string | null;
  country?: string | null;
  references?: string | null;
  latitude?: number | null;
  longitude?: number | null;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
  deletedAt?: string | null;
}

export interface AddressFormData {
  street: string;
  number: string;
  interiorNumber?: string;
  neighborhood?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
  references?: string;
  latitude: number;
  longitude: number;
  isDefault?: boolean;
}

export interface OTPVerificationResponse {
  valid: boolean;
  customer?: Customer;
}

export interface AddressRegistrationResponse {
  success: boolean;
  address: Address;
}

// Legacy types for backward compatibility
export interface CustomerDeliveryInfo {
  customerId?: string;
  pickupName?: string;
  streetAddress?: string;
  neighborhood?: string | null;
  postalCode?: string | null;
  city?: string | null;
  state?: string | null;
  country?: string | null;
  latitude?: string | number;
  longitude?: string | number;
  additionalDetails?: string | null;
}

// Location type
export interface Location {
  lat: number;
  lng: number;
}

================
File: frontend-app/src/App.tsx
================
import { useState, useEffect } from 'react';
import { useSearchParams } from 'react-router-dom';
import { useLoadScript, Autocomplete } from '@react-google-maps/api';
import toast, { Toaster } from 'react-hot-toast';
import { AddressForm } from '@/components/AddressForm';
import { BasicMap as Map } from '@/components/BasicMap';
import { Button } from '@/components/ui';
import customerService from '@/services/customer.service';
import type { AddressFormData, Customer, Address } from '@/types';

const libraries: ('places' | 'geometry')[] = ['places', 'geometry'];

interface Location {
  lat: number;
  lng: number;
}

function App() {
  const [searchParams] = useSearchParams();
  const customerId = searchParams.get('from') || '';
  const otp = searchParams.get('otp') || '';
  const preOrderId = searchParams.get('preOrderId');

  const [isValidOtp, setIsValidOtp] = useState(false);
  const [loading, setLoading] = useState(true);
  const [customer, setCustomer] = useState<Customer | null>(null);
  const [selectedAddress, setSelectedAddress] = useState<Address | null>(null);
  const [selectedLocation, setSelectedLocation] = useState<Location | null>(null);
  const [formData, setFormData] = useState<AddressFormData>({
    street: '',
    number: '',
    interiorNumber: '',
    neighborhood: '',
    zipCode: '',
    city: '',
    state: '',
    country: '',
    references: '',
    latitude: 0,
    longitude: 0,
  });
  const [isUpdating, setIsUpdating] = useState(false);
  const [locationError, setLocationError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [autocomplete, setAutocomplete] = useState<google.maps.places.Autocomplete | null>(null);

  const { isLoaded, loadError } = useLoadScript({
    googleMapsApiKey: import.meta.env.VITE_GOOGLE_MAPS_API_KEY,
    libraries,
  });

  const polygonCoords: Location[] = import.meta.env.VITE_POLYGON_COORDS 
    ? JSON.parse(import.meta.env.VITE_POLYGON_COORDS)
    : [];

  useEffect(() => {
    if (customerId && otp) {
      verifyOtp();
    } else {
      setLoading(false);
      toast.error('El enlace no es válido. Falta información necesaria.');
    }
  }, [customerId, otp]);

  const verifyOtp = async () => {
    try {
      const response = await customerService.verifyOTP(customerId, otp);
      
      if (response.valid && response.customer) {
        setIsValidOtp(true);
        setCustomer(response.customer);
        
        // If customer has addresses, load the default one
        if (response.customer.addresses.length > 0) {
          const defaultAddress = response.customer.addresses.find(addr => addr.isDefault) || response.customer.addresses[0];
          loadExistingAddress(defaultAddress);
        }
      } else {
        toast.error('El enlace ha expirado o no es válido.');
      }
    } catch (error) {
      console.error('Error al verificar el OTP:', error);
      toast.error('Hubo un error al verificar el enlace.');
    } finally {
      setLoading(false);
    }
  };

  const loadExistingAddress = (address: Address) => {
    setSelectedAddress(address);
    setIsUpdating(true);
    
    const formattedData: AddressFormData = {
      street: address.street,
      number: address.number,
      interiorNumber: address.interiorNumber || '',
      neighborhood: address.neighborhood || '',
      zipCode: address.zipCode || '',
      city: address.city || '',
      state: address.state || '',
      country: address.country || '',
      references: address.references || '',
      latitude: address.latitude || 0,
      longitude: address.longitude || 0,
    };

    setFormData(formattedData);
    
    if (address.latitude && address.longitude) {
      setSelectedLocation({
        lat: Number(address.latitude),
        lng: Number(address.longitude),
      });
    }
  };

  const handleLocationSelect = (location: Location) => {
    setSelectedLocation(location);
    setLocationError(null);
    
    // Reverse geocoding to get address details
    const geocoder = new google.maps.Geocoder();
    geocoder.geocode({ location }, (results, status) => {
      if (status === 'OK' && results && results[0]) {
        const addressComponents = results[0].address_components;
        const formattedAddress = results[0].formatted_address;
        
        const newFormData: Partial<AddressFormData> = {
          latitude: location.lat,
          longitude: location.lng,
        };

        addressComponents.forEach((component) => {
          const types = component.types;
          if (types.includes('route')) {
            newFormData.street = component.long_name;
          } else if (types.includes('street_number')) {
            newFormData.number = component.long_name;
          } else if (types.includes('sublocality_level_1') || types.includes('neighborhood')) {
            newFormData.neighborhood = component.long_name;
          } else if (types.includes('postal_code')) {
            newFormData.zipCode = component.long_name;
          } else if (types.includes('locality')) {
            newFormData.city = component.long_name;
          } else if (types.includes('administrative_area_level_1')) {
            newFormData.state = component.long_name;
          } else if (types.includes('country')) {
            newFormData.country = component.long_name;
          }
        });

        setFormData((prev) => ({ ...prev, ...newFormData }));
      }
    });
  };

  const handlePlaceSelect = () => {
    if (autocomplete) {
      const place = autocomplete.getPlace();
      if (place.geometry && place.geometry.location) {
        const location = {
          lat: place.geometry.location.lat(),
          lng: place.geometry.location.lng(),
        };
        handleLocationSelect(location);
      }
    }
  };

  const handleSubmit = async (data: AddressFormData) => {
    if (!selectedLocation) {
      toast.error('Por favor selecciona una ubicación en el mapa');
      return;
    }

    setIsSubmitting(true);
    
    try {
      if (isUpdating && selectedAddress) {
        // Update existing address
        await customerService.updateAddress(
          selectedAddress.id,
          customerId,
          otp,
          data
        );
        toast.success('¡Dirección actualizada exitosamente!');
      } else {
        // Create new address
        await customerService.createAddress(customerId, otp, data);
        toast.success('¡Dirección registrada exitosamente!');
      }

      // Success feedback
      setTimeout(() => {
        toast.success('Ahora puedes cerrar esta ventana y continuar con tu pedido en WhatsApp', {
          duration: 6000,
        });
      }, 1000);

      // If updating for a pre-order, notify backend
      if (preOrderId) {
        // The backend will handle the pre-order update
        toast.success('Tu pedido ha sido actualizado con la nueva dirección');
      }
    } catch (error: any) {
      console.error('Error al guardar la dirección:', error);
      const errorMessage = error.response?.data?.error || 'Hubo un error al guardar la dirección';
      toast.error(errorMessage);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleUseMyLocation = () => {
    if ('geolocation' in navigator) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const location = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          };
          handleLocationSelect(location);
        },
        (error) => {
          console.error('Error getting location:', error);
          toast.error('No se pudo obtener tu ubicación actual');
        }
      );
    } else {
      toast.error('Tu navegador no soporta geolocalización');
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Verificando enlace...</p>
        </div>
      </div>
    );
  }

  if (!isValidOtp) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
        <div className="max-w-md w-full bg-white p-8 rounded-lg shadow-lg text-center">
          <svg className="mx-auto h-12 w-12 text-red-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <h2 className="text-2xl font-bold text-gray-900 mb-2">Enlace inválido</h2>
          <p className="text-gray-600">
            Este enlace ha expirado o no es válido. Por favor, solicita un nuevo enlace desde WhatsApp.
          </p>
          <div className="mt-6">
            <a
              href={`https://wa.me/${import.meta.env.VITE_WHATSAPP_NUMBER}`}
              className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700"
            >
              Abrir WhatsApp
            </a>
          </div>
        </div>
        <Toaster position="top-center" />
      </div>
    );
  }

  if (loadError) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
        <div className="text-center text-red-600">
          Error al cargar Google Maps. Por favor, recarga la página.
        </div>
      </div>
    );
  }

  if (!isLoaded) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Cargando mapa...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-4xl mx-auto p-2">
        <div className="bg-white rounded-lg shadow-lg p-4 mb-4">
          <h1 className="text-2xl font-bold text-gray-900 mb-2">
            {isUpdating ? 'Actualizar dirección de entrega' : 'Registrar dirección de entrega'}
          </h1>
          
          {customer && (
            <p className="text-gray-600 mb-4">
              Hola {customer.firstName || 'Cliente'}, por favor completa tu información de entrega.
            </p>
          )}

          {/* Address Search */}
          <div className="mb-4">
            <Autocomplete
              onLoad={setAutocomplete}
              onPlaceChanged={handlePlaceSelect}
              options={{
                componentRestrictions: { country: 'mx' },
                fields: ['address_components', 'geometry', 'formatted_address'],
              }}
            >
              <input
                type="text"
                placeholder="Buscar dirección..."
                className="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
              />
            </Autocomplete>
          </div>

          {/* Use my location button */}
          <div className="mb-4">
            <Button
              type="button"
              variant="outline"
              onClick={handleUseMyLocation}
              className="w-full sm:w-auto"
            >
              <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
              Usar mi ubicación actual
            </Button>
          </div>

          {/* Map */}
          <div className="mb-4">
            <Map
              center={selectedLocation || { lat: 20.6597, lng: -103.3496 }}
              onLocationSelect={handleLocationSelect}
              selectedLocation={selectedLocation}
              polygonCoords={polygonCoords}
              onLocationError={setLocationError}
            />
            {locationError && (
              <p className="mt-2 text-sm text-red-600">{locationError}</p>
            )}
          </div>

          {/* Address Form */}
          <AddressForm
            formData={formData}
            onSubmit={handleSubmit}
            isUpdating={isUpdating}
          />

          {/* Submit Button */}
          <div className="mt-4">
            <Button
              type="submit"
              onClick={() => handleSubmit(formData)}
              disabled={isSubmitting || !selectedLocation}
              loading={isSubmitting}
              className="w-full"
            >
              {isSubmitting 
                ? 'Guardando...' 
                : isUpdating 
                  ? 'Actualizar dirección' 
                  : 'Registrar dirección'
              }
            </Button>
          </div>

          {/* List existing addresses if any */}
          {customer && customer.addresses.length > 0 && !isUpdating && (
            <div className="mt-6 border-t pt-4">
              <h3 className="text-lg font-semibold mb-2">Mis direcciones guardadas</h3>
              <div className="space-y-2">
                {customer.addresses.map((address) => (
                  <div 
                    key={address.id} 
                    className="p-3 border rounded-md hover:bg-gray-50 cursor-pointer"
                    onClick={() => loadExistingAddress(address)}
                  >
                    <div className="flex justify-between items-start">
                      <div>
                        <p className="font-medium">
                          {address.street} {address.number}
                          {address.interiorNumber && ` Int. ${address.interiorNumber}`}
                        </p>
                        <p className="text-sm text-gray-600">
                          {address.neighborhood && `${address.neighborhood}, `}
                          {address.city}, {address.state}
                        </p>
                      </div>
                      {address.isDefault && (
                        <span className="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">
                          Principal
                        </span>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      </div>
      <Toaster position="top-center" />
    </div>
  );
}

export default App;

================
File: frontend-app/src/main.tsx
================
import { createRoot } from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import './index.css'
import './styles/toast-animations.css'
import Router from './Router.tsx'

createRoot(document.getElementById('root')!).render(
  <BrowserRouter>
    <Router />
  </BrowserRouter>
)

================
File: frontend-app/.env.example
================
# Google Maps - REQUERIDO
# El frontend usa Google Maps para seleccionar direcciones
# Usa la misma API Key que el backend si es posible
# 
# IMPORTANTE: En Google Cloud Console, activa estas APIs:
# - Maps JavaScript API
# - Places API
# - Geocoding API
#
VITE_GOOGLE_MAPS_API_KEY=tu_google_maps_api_key

# Backend URL
VITE_BACKEND_BASE_URL=http://localhost:5000

# WhatsApp Bot Configuration
# Número de WhatsApp del bot (con código de país, sin + ni espacios)
# Ejemplo: 521234567890 para México
VITE_BOT_WHATSAPP_NUMBER=521234567890

# Regional Configuration
# Código de país ISO 3166-1 alpha-2 (mx = México, us = Estados Unidos, etc.)
VITE_COUNTRY_CODE=mx
# Locale para formato de fecha/hora y textos
VITE_LOCALE=es-MX
# Zona horaria IANA
VITE_TIMEZONE=America/Mexico_City

# API Configuration
# Prefijo para las rutas del API backend
VITE_API_PREFIX=/backend

================
File: backend/src/routes/address-registration.ts
================
import { Router, Request, Response } from 'express';
import { OTPService } from '../services/security/OTPService';
import { DeliveryInfoService } from '../services/orders/services/DeliveryInfoService';
import { prisma } from '../server';
import logger from '../common/utils/logger';

const router = Router();

/**
 * Verificar OTP para registro de dirección
 * POST /backend/address-registration/verify-otp
 */
router.post('/verify-otp', async (req: Request, res: Response): Promise<void> => {
  try {
    const { customerId, otp } = req.body;
    
    if (!customerId || !otp) {
      res.status(400).json({ 
        error: 'customerId and otp are required' 
      });
      return;
    }
    
    const isValid = await OTPService.verifyOTP(customerId, otp);
    
    if (!isValid) {
      res.status(401).json({ 
        error: 'Invalid or expired OTP' 
      });
      return;
    }
    
    // Obtener información del cliente
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: customerId },
      select: {
        id: true,
        whatsappPhoneNumber: true,
        firstName: true,
        lastName: true,
        addresses: {
          where: { deletedAt: null },
          orderBy: { isDefault: 'desc' }
        }
      }
    });
    
    if (!customer) {
      res.status(404).json({ error: 'Customer not found' });
      return;
    }
    
    res.json({ 
      valid: true,
      customer: {
        customerId: customer.whatsappPhoneNumber,
        firstName: customer.firstName,
        lastName: customer.lastName,
        hasAddresses: customer.addresses.length > 0,
        addresses: customer.addresses
      }
    });
    
  } catch (error: any) {
    logger.error('Error verifying OTP for address registration:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * Crear nueva dirección para el cliente
 * POST /backend/address-registration/create
 */
router.post('/create', async (req: Request, res: Response): Promise<void> => {
  try {
    const { customerId, otp, address } = req.body;
    
    // Validar campos requeridos
    if (!customerId || !otp || !address) {
      res.status(400).json({ 
        error: 'customerId, otp, and address are required' 
      });
      return;
    }
    
    // Verificar OTP primero
    const isValid = await OTPService.verifyOTP(customerId, otp);
    
    if (!isValid) {
      res.status(401).json({ 
        error: 'Invalid or expired OTP' 
      });
      return;
    }
    
    // Validar campos de dirección
    const requiredFields = ['street', 'number', 'city', 'state', 'country', 'latitude', 'longitude'];
    const missingFields = requiredFields.filter(field => !address[field]);
    
    if (missingFields.length > 0) {
      res.status(400).json({ 
        error: `Missing required address fields: ${missingFields.join(', ')}` 
      });
      return;
    }
    
    // Obtener primero el UUID real del cliente
    const customerRecord = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: customerId },
      select: { id: true }
    });
    
    if (!customerRecord) {
      res.status(404).json({ error: 'Customer not found' });
      return;
    }
    
    // Crear dirección
    const addressData = {
      ...address,
      customer: { connect: { id: customerRecord.id } }
    };
    
    const newAddress = await DeliveryInfoService.createCustomerAddress(addressData);
    
    // Enviar mensaje de confirmación a WhatsApp
    try {
      const { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } = await import('../services/whatsapp');
      const { ADDRESS_REGISTRATION_SUCCESS, WELCOME_MESSAGE_INTERACTIVE } = await import('../common/config/predefinedMessages');
      
      // Obtener el número de WhatsApp del cliente
      const customer = await prisma.customer.findUnique({
        where: { id: customerId },
        select: { whatsappPhoneNumber: true }
      });
      
      // Enviar mensaje de confirmación
      if (customer?.whatsappPhoneNumber) {
        await sendWhatsAppMessage(
          customer.whatsappPhoneNumber,
          ADDRESS_REGISTRATION_SUCCESS(newAddress)
        );
      }
      
      // Pequeño retraso para asegurar el orden correcto de mensajes
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Enviar mensaje de bienvenida inmediatamente después
      const welcomeMessage = await WELCOME_MESSAGE_INTERACTIVE();
      if (customer?.whatsappPhoneNumber) {
        await sendWhatsAppInteractiveMessage(customer.whatsappPhoneNumber, welcomeMessage);
      }
      
      // Marcar que el mensaje de bienvenida fue enviado para evitar duplicados
      // Actualizar lastInteraction a la hora actual para prevenir la detección de isNewConversation
      await prisma.customer.update({
        where: { id: customerRecord.id },
        data: { 
          lastInteraction: new Date()
        }
      });
      
    } catch (msgError) {
      logger.error('Error sending confirmation message:', msgError);
    }
    
    res.json({ 
      success: true,
      address: newAddress
    });
    
  } catch (error: any) {
    logger.error('Error creating address:', error);
    res.status(500).json({ 
      error: 'Failed to create address',
      message: error.message 
    });
  }
});

/**
 * Actualizar dirección existente
 * PUT /backend/address-registration/:addressId
 */
router.put('/:addressId', async (req: Request, res: Response): Promise<void> => {
  try {
    const { addressId } = req.params;
    const { customerId, otp, address } = req.body;
    
    if (!customerId || !otp || !address) {
      res.status(400).json({ 
        error: 'customerId, otp, and address are required' 
      });
      return;
    }
    
    // Verificar OTP
    const isValid = await OTPService.verifyOTP(customerId, otp);
    
    if (!isValid) {
      res.status(401).json({ 
        error: 'Invalid or expired OTP' 
      });
      return;
    }
    
    // Obtener cliente por número de teléfono
    const customerRecord = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: customerId },
      select: { id: true }
    });
    
    if (!customerRecord) {
      res.status(404).json({ error: 'Customer not found' });
      return;
    }
    
    // Verificar que la dirección pertenece al cliente
    const existingAddress = await prisma.address.findFirst({
      where: { 
        id: addressId,
        customerId: customerRecord.id
      }
    });
    
    if (!existingAddress) {
      res.status(404).json({ 
        error: 'Address not found or does not belong to customer' 
      });
      return;
    }
    
    // Actualizar dirección
    const updatedAddress = await DeliveryInfoService.updateCustomerAddress(
      addressId,
      address
    );
    
    // Enviar notificación de WhatsApp sobre actualización de dirección
    try {
      const { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } = await import('../services/whatsapp');
      const { ADDRESS_UPDATE_SUCCESS, WELCOME_MESSAGE_INTERACTIVE } = await import('../common/config/predefinedMessages');
      
      // Obtener el número de WhatsApp del cliente
      const customer = await prisma.customer.findUnique({
        where: { id: customerId },
        select: { whatsappPhoneNumber: true }
      });
      
      // Enviar confirmación de actualización
      if (customer?.whatsappPhoneNumber) {
        await sendWhatsAppMessage(
          customer.whatsappPhoneNumber,
          ADDRESS_UPDATE_SUCCESS(updatedAddress)
        );
      }
      
      // Pequeño retraso para asegurar el orden correcto de mensajes
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Enviar mensaje de bienvenida inmediatamente después
      const welcomeMessage = await WELCOME_MESSAGE_INTERACTIVE();
      if (customer?.whatsappPhoneNumber) {
        await sendWhatsAppInteractiveMessage(customer.whatsappPhoneNumber, welcomeMessage);
      }
      
      // Marcar que hubo interacción para evitar mensaje de bienvenida duplicado
      await prisma.customer.update({
        where: { id: customerRecord.id },
        data: { 
          lastInteraction: new Date()
        }
      });
      
    } catch (sendError) {
      logger.error('Failed to send WhatsApp notification:', sendError);
      // Continuar aunque WhatsApp falle
    }
    
    res.json({ 
      success: true,
      address: updatedAddress
    });
    
  } catch (error: any) {
    logger.error('Error updating address:', error);
    res.status(500).json({ 
      error: 'Failed to update address',
      message: error.message 
    });
  }
});

/**
 * Obtener direcciones del cliente
 * GET /backend/address-registration/:customerId/addresses
 */
router.get('/:customerId/addresses', async (req: Request, res: Response): Promise<void> => {
  try {
    const { customerId } = req.params;
    const { otp } = req.query;
    
    if (!otp) {
      res.status(400).json({ error: 'OTP is required' });
      return;
    }
    
    // Verificar OTP
    const isValid = await OTPService.verifyOTP(customerId, otp as string);
    
    if (!isValid) {
      res.status(401).json({ error: 'Invalid or expired OTP' });
      return;
    }
    
    // Obtener cliente por número de teléfono
    const customerRecord = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: customerId },
      select: { id: true }
    });
    
    if (!customerRecord) {
      res.status(404).json({ error: 'Customer not found' });
      return;
    }
    
    const addresses = await DeliveryInfoService.getCustomerAddresses(customerRecord.id);
    res.json({ addresses });
    
  } catch (error: any) {
    logger.error('Error fetching addresses:', error);
    res.status(500).json({ error: 'Failed to fetch addresses' });
  }
});

/**
 * Eliminar dirección del cliente
 * DELETE /backend/address-registration/:addressId
 */
router.delete('/:addressId', async (req: Request, res: Response): Promise<void> => {
  try {
    const { addressId } = req.params;
    const { customerId, otp } = req.body;
    
    if (!customerId || !otp) {
      res.status(400).json({ 
        error: 'customerId and otp are required' 
      });
      return;
    }
    
    // Verificar OTP
    const isValid = await OTPService.verifyOTP(customerId, otp);
    
    if (!isValid) {
      res.status(401).json({ 
        error: 'Invalid or expired OTP' 
      });
      return;
    }
    
    // Obtener cliente por número de teléfono
    const customerRecord = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: customerId },
      select: { id: true }
    });
    
    if (!customerRecord) {
      res.status(404).json({ error: 'Customer not found' });
      return;
    }
    
    // Eliminar dirección (eliminación suave)
    await DeliveryInfoService.deleteCustomerAddress(
      addressId,
      customerRecord.id
    );
    
    res.json({ 
      success: true,
      message: 'Address deleted successfully'
    });
    
  } catch (error: any) {
    logger.error('Error deleting address:', error);
    res.status(500).json({ 
      error: 'Failed to delete address',
      message: error.message 
    });
  }
});

/**
 * Establecer dirección como predeterminada
 * PUT /backend/address-registration/:addressId/default
 */
router.put('/:addressId/default', async (req: Request, res: Response): Promise<void> => {
  try {
    const { addressId } = req.params;
    const { customerId, otp } = req.body;
    
    if (!customerId || !otp) {
      res.status(400).json({ 
        error: 'customerId and otp are required' 
      });
      return;
    }
    
    // Verificar OTP
    const isValid = await OTPService.verifyOTP(customerId, otp);
    
    if (!isValid) {
      res.status(401).json({ 
        error: 'Invalid or expired OTP' 
      });
      return;
    }
    
    // Obtener cliente por número de teléfono
    const customerRecord = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: customerId },
      select: { id: true }
    });
    
    if (!customerRecord) {
      res.status(404).json({ error: 'Customer not found' });
      return;
    }
    
    // Establecer como predeterminada
    const updatedAddress = await DeliveryInfoService.setDefaultAddress(
      addressId,
      customerRecord.id
    );
    
    res.json({ 
      success: true,
      address: updatedAddress
    });
    
  } catch (error: any) {
    logger.error('Error setting default address:', error);
    res.status(500).json({ 
      error: 'Failed to set default address',
      message: error.message 
    });
  }
});

/**
 * Obtener polígono del área de entrega
 * GET /backend/address-registration/delivery-area
 */
router.get('/delivery-area', async (_req: Request, res: Response): Promise<void> => {
  try {
    // Obtener configuración del restaurante
    const restaurant = await prisma.restaurantConfig.findFirst({
      select: {
        deliveryCoverageArea: true
      }
    });

    if (!restaurant || !restaurant.deliveryCoverageArea) {
      res.json({ polygonCoords: [] });
      return;
    }

    // Devolver coordenadas del polígono
    res.json({ 
      polygonCoords: restaurant.deliveryCoverageArea
    });

  } catch (error: any) {
    logger.error('Error fetching delivery area:', error);
    res.status(500).json({ error: 'Failed to fetch delivery area' });
  }
});

/**
 * Estado de depuración del OTP (TEMPORAL - ELIMINAR EN PRODUCCIÓN)
 * GET /backend/address-registration/debug/otp-status
 */
router.get('/debug/otp-status', async (req: Request, res: Response): Promise<void> => {
  const stats = OTPService.getStats();
  res.json({ 
    otpStats: stats,
    message: 'Check server logs for detailed OTP information'
  });
});

export default router;

================
File: backend/src/services/messaging/pipeline/MessagePipeline.ts
================
import { IncomingMessage, MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { RateLimitMiddleware } from '../middlewares/RateLimitMiddleware';
import { CustomerValidationMiddleware } from '../middlewares/CustomerValidationMiddleware';
import { RestaurantHoursMiddleware } from '../middlewares/RestaurantHoursMiddleware';
import { AddressRequiredMiddleware } from '../middlewares/AddressRequiredMiddleware';
import { MessageTypeMiddleware } from '../middlewares/MessageTypeMiddleware';
import { MessageProcessingMiddleware } from '../middlewares/MessageProcessingMiddleware';
import { prisma } from '../../../server';
import logger from '../../../common/utils/logger';
import { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } from '../../whatsapp';

export class MessagePipeline {
  private middlewares: MessageMiddleware[] = [];
  
  constructor() {
    // Inicializar middlewares en orden
    this.middlewares = [
      new RateLimitMiddleware(),
      new CustomerValidationMiddleware(),
      new RestaurantHoursMiddleware(), // Verifica horarios antes de cualquier procesamiento
      new AddressRequiredMiddleware(), // Bloquea si no hay dirección
      new MessageTypeMiddleware(),
      new MessageProcessingMiddleware(), // Lógica principal de procesamiento
    ];
  }

  async process(message: IncomingMessage): Promise<void> {
    const context = new MessageContext(message);
    
    try {
      // Ejecutar todos los middlewares
      for (const middleware of this.middlewares) {
        await middleware.process(context);
        
        if (context.shouldStop) {
          break;
        }
      }
      
      // El procesamiento ahora se maneja por middlewares
      
      // Enviar respuestas
      await this.sendResponses(context);
      
      // Actualizar historial de chat del cliente
      await this.updateChatHistory(context);
      
    } catch (error) {
      logger.error('Error in MessagePipeline:', error);
      await this.handleError(context, error as Error);
    }
  }
  
  
  private async sendResponses(context: MessageContext): Promise<void> {
    for (const response of context.responses) {
      if (!response.sendToWhatsApp) continue;
      
      try {
        if (response.text) {
          // La utilidad messageSender se encarga de dividir mensajes largos automáticamente
          await sendWhatsAppMessage(context.message.from, response.text);
        }
        
        if (response.interactiveMessage) {
          const messageId = await sendWhatsAppInteractiveMessage(
            context.message.from, 
            response.interactiveMessage
          );
          
          // Actualizar preOrder con messageId si es necesario
          if (response.preOrderId && messageId) {
            logger.info(`Updating pre-order ${response.preOrderId} with WhatsApp messageId: ${messageId}`);
            await prisma.preOrder.update({
              where: { id: response.preOrderId },
              data: { messageId }
            });
            logger.info(`Pre-order ${response.preOrderId} updated successfully with messageId`);
          }
        }
        
        if (response.confirmationMessage) {
          await sendWhatsAppMessage(context.message.from, response.confirmationMessage);
        }
      } catch (error) {
        logger.error('Error sending response:', error);
      }
    }
  }
  
  private async updateChatHistory(context: MessageContext): Promise<void> {
    if (!context.customer || context.shouldStop) return;
    
    // Si se marca skipHistoryUpdate, no guardar nada en el historial
    if (context.get('skipHistoryUpdate')) {
      logger.debug('Skipping history update due to skipHistoryUpdate flag');
      return;
    }
    
    const fullChatHistory = context.get('fullChatHistory') || [];
    const relevantChatHistory = context.get('relevantChatHistory') || [];
    
    // Agregar mensaje del usuario al historial
    fullChatHistory.push({
      role: 'user',
      content: context.message.text?.body || '[Non-text message]',
      timestamp: new Date()
    });
    
    // Siempre agregar al historial relevante
    relevantChatHistory.push({
      role: 'user',
      content: context.message.text?.body || '[Non-text message]',
      timestamp: new Date()
    });
    
    // Agregar respuestas al historial
    for (const response of context.responses) {
      if (response.text || response.historyMarker) {
        // Para el historial completo, siempre usar el texto completo
        if (response.text) {
          fullChatHistory.push({
            role: 'assistant',
            content: response.text,
            timestamp: new Date()
          });
        }
        
        // Para el historial relevante
        if (response.isRelevant || response.historyMarker) {
          // Si hay marcador, usarlo siempre. Si no, usar el texto solo si es relevante
          const contentToSave = response.historyMarker || (response.isRelevant ? response.text : null);
          if (contentToSave) {
            relevantChatHistory.push({
              role: 'assistant',
              content: contentToSave,
              timestamp: new Date()
            });
          }
        }
      }
    }
    
    // Limitar el historial relevante a los últimos 20 mensajes antes de guardar
    if (relevantChatHistory.length > 20) {
      relevantChatHistory = relevantChatHistory.slice(-20);
    }
    
    // Actualizar cliente en la base de datos
    await prisma.customer.update({
      where: { id: context.customer.id },
      data: {
        fullChatHistory: JSON.stringify(fullChatHistory),
        relevantChatHistory: JSON.stringify(relevantChatHistory),
        lastInteraction: new Date()
      }
    });
  }
  
  private async handleError(context: MessageContext, error: Error): Promise<void> {
    logger.error('Pipeline error:', error);
    
    try {
      await sendWhatsAppMessage(
        context.message.from,
        'Lo siento, ocurrió un error procesando tu mensaje. Por favor intenta de nuevo.'
      );
    } catch (sendError) {
      logger.error('Error sending error message:', sendError);
    }
  }
  
  // Método para agregar middlewares personalizados
  addMiddleware(middleware: MessageMiddleware, index?: number): void {
    if (index !== undefined) {
      this.middlewares.splice(index, 0, middleware);
    } else {
      this.middlewares.push(middleware);
    }
  }
  
}

================
File: backend/src/services/orders/services/OrderFormattingService.ts
================
import { NewOrder } from "../../../common/types/order.types";
import { env } from "../../../common/config/envValidator";

export class OrderFormattingService {
  /**
   * Format an order for WhatsApp message display
   */
  static formatOrderForWhatsApp(order: any, customerId: string): NewOrder {
    const orderType = order.orderType;
    let deliveryInfo = "";

    // Format delivery information
    if (orderType === "delivery" && order.deliveryInfo) {
      const info = order.deliveryInfo;
      const parts = [];
      // Combine street, number, and interior number
      let fullAddress = info.street || "";
      if (info.number) {
        fullAddress += ` ${info.number}`;
      }
      if (info.interiorNumber) {
        fullAddress += ` Int. ${info.interiorNumber}`;
      }
      if (fullAddress.trim()) parts.push(fullAddress.trim());
      if (info.neighborhood) parts.push(info.neighborhood);
      if (info.city) parts.push(info.city);
      if (info.references) parts.push(`(${info.references})`);
      deliveryInfo = parts.join(", ");
    } else if (orderType === "pickup" && order.deliveryInfo?.pickupName) {
      deliveryInfo = order.deliveryInfo.pickupName;
    }

    // Calculate total price
    let totalPrice = 0;
    const products = order.orderItems?.map((item: any) => {
      const productName = item.product?.name || "Producto";
      const variantName = item.productVariant?.name || "";
      const name = variantName ? `${productName} ${variantName}` : productName;
      
      // Calculate base price
      let itemPrice = item.productVariant?.price || 0;
      
      // Add modifier prices
      const modifiers = item.productModifiers?.map((mod: any) => ({
        nombre: mod.name || "Modificador",
        precio: mod.price || 0,
      })) || [];
      
      modifiers.forEach((mod: any) => {
        itemPrice += mod.precio;
      });
      
      const totalItemPrice = itemPrice * item.quantity;
      totalPrice += totalItemPrice;

      // Map pizza ingredients
      const pizzaIngredients = item.selectedPizzaIngredients?.map((selectedIng: any) => ({
        mitad: selectedIng.half as string,
        nombre: selectedIng.pizzaIngredient?.name || "Ingrediente",
        action: selectedIng.action,
      })) || [];

      return {
        nombre: name,
        cantidad: item.quantity,
        precio: totalItemPrice,
        modificadores: modifiers,
        ingredientes_pizza: pizzaIngredients.length > 0 ? pizzaIngredients : undefined,
        comments: item.comments,
      };
    }) || [];

    // Format dates
    const createdAt = order.createdAt.toLocaleString(env.DEFAULT_LOCALE, {
      timeZone: env.DEFAULT_TIMEZONE,
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });

    const scheduledDelivery = order.scheduledAt
      ? order.scheduledAt.toLocaleString(env.DEFAULT_LOCALE, {
          timeZone: env.DEFAULT_TIMEZONE,
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        })
      : null;

    return {
      id: order.id,
      telefono: customerId,
      informacion_entrega: deliveryInfo,
      precio_total: totalPrice,
      fecha_creacion: createdAt,
      horario_entrega_programado: scheduledDelivery,
      tiempoEstimado: order.estimatedTime,
      productos: products,
    };
  }

  /**
   * Generate order confirmation message
   */
  static generateConfirmationMessage(order: any, formattedOrder: NewOrder): string {
    const orderTypeText = order.orderType === "DELIVERY" ? "A domicilio" : 
                         order.orderType === "TAKE_AWAY" ? "Para llevar" : "Para comer aquí";
    
    let message = `🎉 *¡Tu orden #${order.dailyNumber} ha sido creada exitosamente!* 🎉\n\n`;
    message += `📞 *Teléfono:* ${formattedOrder.telefono}\n`;
    message += `📅 *Fecha de creación:* ${formattedOrder.fecha_creacion}\n`;
    message += `🚚 *Información de entrega:* ${orderTypeText} - ${formattedOrder.informacion_entrega}\n`;
    message += `⏱️ *Tiempo estimado:* ${formattedOrder.tiempoEstimado} minutos\n`;

    if (formattedOrder.horario_entrega_programado) {
      message += `📅 *Entrega programada:* ${formattedOrder.horario_entrega_programado}\n`;
    }

    message += `\n🛒 *Productos:*\n`;
    formattedOrder.productos.forEach((producto) => {
      message += this.formatProduct(producto);
    });

    message += `\n💰 *Total: $${formattedOrder.precio_total}*\n\n`;
    message += `📩 Te notificaremos cuando tu pedido sea aceptado. ¡Gracias por tu preferencia! 🙏`;

    return message;
  }

  /**
   * Format a single product for display
   */
  private static formatProduct(producto: any): string {
    let summary = `- *${producto.cantidad}x ${producto.nombre}*: $${producto.precio}\n`;

    if (producto.ingredientes_pizza?.length > 0) {
      summary += this.formatPizzaIngredients(producto.ingredientes_pizza);
    }

    if (producto.modificadores.length > 0) {
      summary += `  🔸 Modificadores: ${producto.modificadores
        .map((mod: any) => mod.nombre)
        .join(", ")}\n`;
    }

    if (producto.comments) {
      summary += `  💬 Comentarios: ${producto.comments}\n`;
    }

    return summary;
  }

  /**
   * Format pizza ingredients for display
   */
  private static formatPizzaIngredients(ingredientes: any[]): string {
    let summary = "  🔸 Ingredientes de pizza:\n";

    const ingredientsByHalf = {
      left: ingredientes
        .filter((ing: any) => ing.mitad === "LEFT")
        .map((ing: any) => ing.nombre),
      right: ingredientes
        .filter((ing: any) => ing.mitad === "RIGHT")
        .map((ing: any) => ing.nombre),
      full: ingredientes
        .filter((ing: any) => ing.mitad === "FULL")
        .map((ing: any) => ing.nombre),
    };

    const leftIngredients = [
      ...ingredientsByHalf.left,
      ...ingredientsByHalf.full,
    ];
    const rightIngredients = [
      ...ingredientsByHalf.right,
      ...ingredientsByHalf.full,
    ];

    if (
      leftIngredients.length === rightIngredients.length &&
      leftIngredients.every((ing: string) => rightIngredients.includes(ing))
    ) {
      summary += `     • Completa: ${leftIngredients.join(", ")}\n`;
    } else {
      if (leftIngredients.length > 0) {
        summary += `     • Mitad Izquierda: ${leftIngredients.join(", ")}\n`;
      }
      if (rightIngredients.length > 0) {
        summary += `     • Mitad Derecha: ${rightIngredients.join(", ")}\n`;
      }
    }

    // Show removed ingredients
    const removedIngredients = ingredientes
      .filter((ing: any) => ing.action === "REMOVE")
      .map((ing: any) => ing.nombre);
    if (removedIngredients.length > 0) {
      summary += `     • ❌ Quitar: ${removedIngredients.join(", ")}\n`;
    }

    return summary;
  }
}

================
File: backend/src/services/orders/PreOrderService.ts
================
import { prisma } from "../../server";
import logger from "../../common/utils/logger";
import { SchedulingService } from "./services/SchedulingService";
import { ProductCalculationService } from "./services/ProductCalculationService";
import { DeliveryInfoService } from "./services/DeliveryInfoService";
import { RestaurantService } from "../restaurant/RestaurantService";
import { OrderType } from "@prisma/client";

export class PreOrderService {
  /**
   * Create a preorder with selected products
   */
  async createPreOrder(orderData: {
    orderItems: any[];
    whatsappPhoneNumber: string;
    orderType: OrderType;
    scheduledAt?: string | Date;
    deliveryInfo?: any;
  }) {
    const { orderItems, whatsappPhoneNumber, orderType, scheduledAt, deliveryInfo: inputDeliveryInfo } = orderData;

    logger.info(`Starting createPreOrder for ${whatsappPhoneNumber}`, {
      orderType,
      itemCount: orderItems.length,
      scheduledAt,
      items: JSON.stringify(orderItems)
    });

    try {
      // Get restaurant config
      const config = await RestaurantService.getConfig();

      // Convert OrderType enum to string
      const orderTypeString = orderType === 'DELIVERY' ? 'delivery' : orderType === 'TAKE_AWAY' ? 'pickup' : 'pickup';

      // Validate scheduled time if provided
      const validatedScheduledTime = await SchedulingService.validateScheduledTime(
        scheduledAt,
        orderTypeString
      );

      // Get customerId from whatsapp phone number for delivery info
      const customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber }
      });
      
      // Get or create delivery info
      if (customer) {
        await DeliveryInfoService.getOrCreateDeliveryInfo(
          orderTypeString,
          customer.id,
          inputDeliveryInfo
        );
      }

      // Calculate items and total cost
      const { items: calculatedItems, totalCost } = await ProductCalculationService.calculateOrderItems(
        orderItems
      );

      // Create pre-order data without messageId (will be added after WhatsApp message is sent)
      const preOrderData: any = {
        whatsappPhoneNumber,
        orderType,
        orderItems: JSON.parse(JSON.stringify(calculatedItems)), // Convert to JSON-compatible format
      };
      
      // Only add scheduledAt if it exists and is valid
      if (validatedScheduledTime) {
        preOrderData.scheduledAt = validatedScheduledTime;
      }
      
      logger.info('Creating pre-order with data:', {
        whatsappPhoneNumber: preOrderData.whatsappPhoneNumber,
        orderType: preOrderData.orderType,
        scheduledAt: preOrderData.scheduledAt,
        itemCount: calculatedItems.length,
        totalCost
      });
      
      // Create pre-order
      const preOrder = await prisma.preOrder.create({
        data: preOrderData,
      });

      logger.info(`Created pre-order ${preOrder.id} for phone ${whatsappPhoneNumber}`, {
        preOrderId: preOrder.id,
        createdAt: preOrder.createdAt
      });

      // Get delivery info if it's a delivery order
      let deliveryInfo = null;
      if (orderType === 'DELIVERY' && customer) {
        const customerWithAddresses = await prisma.customer.findUnique({
          where: { id: customer.id },
          include: { addresses: { where: { deletedAt: null } } }
        });
        
        if (customerWithAddresses?.addresses?.[0]) {
          deliveryInfo = customerWithAddresses.addresses[0];
        }
      }

      return {
        preOrderId: preOrder.id,
        orderType,
        items: calculatedItems,
        total: totalCost,
        deliveryInfo,
        scheduledAt: validatedScheduledTime,
        estimatedPickupTime: config.estimatedPickupTime,
        estimatedDeliveryTime: config.estimatedDeliveryTime,
      };
    } catch (error) {
      logger.error("Error in createPreOrder:", error);
      throw error;
    }
  }

  /**
   * Update delivery info for a preorder
   */
  async updateDeliveryInfo(preOrderId: number, deliveryInfo: any): Promise<void> {
    await DeliveryInfoService.updatePreOrderDeliveryInfo(preOrderId, deliveryInfo);
  }

}

================
File: backend/src/services/whatsapp/WhatsAppService.ts
================
import { Request, Response } from 'express';
import axios from 'axios';
import { prisma } from '../../server';
import logger from '../../common/utils/logger';
import { MessageProcessor } from '../messaging/MessageProcessor';
import { env } from '../../common/config/envValidator';
import { ExternalServiceError, ErrorCode } from '../../common/services/errors';
import { MessageSplitter } from '../../common/utils/messageSplitter';

/**
 * Service for WhatsApp Business API communication
 */
export class WhatsAppService {
  private static readonly WHATSAPP_API_URL = 'https://graph.facebook.com/v17.0';
  private static readonly PHONE_NUMBER_ID = env.WHATSAPP_PHONE_NUMBER_MESSAGING_ID;
  private static readonly ACCESS_TOKEN = env.WHATSAPP_ACCESS_TOKEN;
  private static readonly VERIFY_TOKEN = env.WHATSAPP_VERIFY_TOKEN;
  private static readonly MAX_MESSAGE_LENGTH = 4000; // WhatsApp message length limit with margin

  /**
   * Verify webhook for WhatsApp
   */
  static verifyWebhook(query: any): { verified: boolean; challenge?: string } {
    const mode = query['hub.mode'];
    const token = query['hub.verify_token'];
    const challenge = query['hub.challenge'];

    if (mode && token) {
      if (mode === 'subscribe' && token === this.VERIFY_TOKEN) {
        logger.info('Webhook verified');
        return { verified: true, challenge };
      }
    }
    
    return { verified: false };
  }

  /**
   * Handle incoming webhook from WhatsApp
   */
  static async handleWebhook(req: Request, res: Response): Promise<void> {
    try {
      const body = JSON.parse(req.body.toString());
      
      if (body.entry && body.entry.length > 0) {
        for (const entry of body.entry) {
          if (entry.changes && entry.changes.length > 0) {
            for (const change of entry.changes) {
              if (change.value.messages && change.value.messages.length > 0) {
                for (const message of change.value.messages) {
                  await this.processIncomingMessage(message);
                }
              }
            }
          }
        }
      }
      
      res.sendStatus(200);
    } catch (error) {
      logger.error('Error processing WhatsApp webhook:', error);
      res.sendStatus(500);
    }
  }

  /**
   * Process an incoming message
   */
  private static async processIncomingMessage(message: any): Promise<void> {
    try {
      const messageId = message.id;
      const from = message.from;
      
      // Check if message was already processed
      const existingLog = await prisma.messageLog.findUnique({
        where: { messageId }
      });
      
      if (existingLog?.processed) {
        logger.info(`Message ${messageId} already processed`);
        return;
      }
      
      // Mark message as being processed
      await prisma.messageLog.upsert({
        where: { messageId },
        update: { processed: true },
        create: { messageId, processed: true }
      });
      
      // Process the message
      await MessageProcessor.processWithPipeline({
        ...message,
        from
      });
      
    } catch (error) {
      logger.error('Error processing incoming message:', error);
    }
  }

  /**
   * Send a text message via WhatsApp
   */
  static async sendMessage(to: string, message: string): Promise<{ success: boolean; messageId?: string; error?: string }> {
    try {
      const response = await axios.post(
        `${this.WHATSAPP_API_URL}/${this.PHONE_NUMBER_ID}/messages`,
        {
          messaging_product: 'whatsapp',
          to,
          type: 'text',
          text: { body: message }
        },
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      logger.debug(`Full message sent to ${to}:`, message);
      logger.info(`Message sent to ${to} (${message.length} chars)`);
      return { success: true, messageId: response.data.messages[0].id };
    } catch (error: any) {
      logger.error('Error sending WhatsApp message:', error.response?.data || error.message);
      return { success: false, error: error.message };
    }
  }

  /**
   * Send an interactive message via WhatsApp
   */
  static async sendInteractiveMessage(to: string, interactive: any, contextMessageId?: string): Promise<string> {
    try {
      const payload: any = {
        messaging_product: 'whatsapp',
        to,
        type: 'interactive',
        interactive
      };

      // Add context if provided
      if (contextMessageId) {
        payload.context = { message_id: contextMessageId };
      }

      const response = await axios.post(
        `${this.WHATSAPP_API_URL}/${this.PHONE_NUMBER_ID}/messages`,
        payload,
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      const messageType = interactive.type || 'interactive';
      const buttonText = interactive.action?.button || interactive.action?.buttons?.[0]?.reply?.title || '';
      logger.info(`Interactive message (${messageType}) sent to ${to}${buttonText ? `: "${buttonText}"` : ''}`);
      return response.data.messages[0].id;
    } catch (error: any) {
      logger.error('Error sending interactive message:', error.response?.data || error.message);
      throw new ExternalServiceError(
        ErrorCode.WHATSAPP_ERROR,
        'Failed to send interactive message',
        { metadata: { to, error: error.message } }
      );
    }
  }

  /**
   * Get media URL from WhatsApp
   */
  static async getMediaUrl(mediaId: string): Promise<string | null> {
    try {
      const response = await axios.get(
        `${this.WHATSAPP_API_URL}/${mediaId}`,
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`
          }
        }
      );
      
      return response.data.url;
    } catch (error: any) {
      logger.error('Error getting media URL:', error.response?.data || error.message);
      return null;
    }
  }

  /**
   * Download media from WhatsApp
   */
  static async downloadMedia(mediaUrl: string): Promise<Buffer | null> {
    try {
      const response = await axios.get(mediaUrl, {
        headers: {
          'Authorization': `Bearer ${this.ACCESS_TOKEN}`
        },
        responseType: 'arraybuffer'
      });

      return Buffer.from(response.data);
    } catch (error: any) {
      logger.error('Error downloading media:', error.response?.data || error.message);
      return null;
    }
  }

  /**
   * Mark message as read
   */
  static async markMessageAsRead(messageId: string): Promise<boolean> {
    try {
      await axios.post(
        `${this.WHATSAPP_API_URL}/${this.PHONE_NUMBER_ID}/messages`,
        {
          messaging_product: 'whatsapp',
          status: 'read',
          message_id: messageId
        },
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      return true;
    } catch (error: any) {
      logger.error('Error marking message as read:', error.response?.data || error.message);
      return false;
    }
  }

  /**
   * Send a message with a URL button
   */
  static async sendMessageWithUrlButton(
    to: string, 
    headerText: string,
    bodyText: string, 
    buttonText: string, 
    url: string,
    footerText?: string
  ): Promise<boolean> {
    try {
      const interactive = {
        type: "cta_url",
        header: {
          type: "text",
          text: headerText
        },
        body: {
          text: bodyText
        },
        footer: footerText ? { text: footerText } : undefined,
        action: {
          name: "cta_url",
          parameters: {
            display_text: buttonText,
            url: url
          }
        }
      };

      await this.sendInteractiveMessage(to, interactive);
      return true;
    } catch (error) {
      logger.error('Error sending message with URL button:', error);
      return false;
    }
  }

  /**
   * Send a WhatsApp message, automatically splitting long messages
   */
  static async sendWhatsAppMessage(to: string, message: string): Promise<boolean> {
    try {
      if (message.length <= this.MAX_MESSAGE_LENGTH) {
        const result = await this.sendMessage(to, message);
        if (!result.success) {
          throw new ExternalServiceError(
            ErrorCode.WHATSAPP_ERROR,
            result.error || 'Failed to send message',
            { metadata: { to, messageLength: message.length } }
          );
        }
        return true;
      }
      
      // Split long message using unified utility
      const parts = MessageSplitter.splitMessage(message, this.MAX_MESSAGE_LENGTH);
      logger.debug(`Message split into ${parts.length} parts`);
      
      // Send each part
      for (const part of parts) {
        const result = await this.sendMessage(to, part);
        if (!result.success) {
          throw new ExternalServiceError(
            ErrorCode.WHATSAPP_ERROR,
            result.error || 'Failed to send message part',
            { metadata: { to, partLength: part.length } }
          );
        }
      }
      
      return true;
    } catch (error) {
      logger.error('Error sending WhatsApp message:', error);
      return false;
    }
  }

}

================
File: backend/src/whatsapp/handlers/orders/confirmationHandler.ts
================
import { prisma } from "../../../server";
import logger from "../../../common/utils/logger";
import { sendWhatsAppMessage, WhatsAppService } from "../../../services/whatsapp";
import { OrderManagementService } from "../../../services/orders/services/OrderManagementService";
import { OrderFormattingService } from "../../../services/orders/services/OrderFormattingService";
import { ErrorService, BusinessLogicError, ErrorCode } from "../../../common/services/errors";

// Crear la orden en el sistema
export async function handlePreOrderConfirmation(
  from: string,
  messageId: string
): Promise<void> {
  try {
    logger.info(`Starting preorder confirmation for ${from}, messageId: ${messageId}`);
    
    const orderManagementService = new OrderManagementService();
    const preOrder = await orderManagementService.getPreOrderByMessageId(messageId);

    if (!preOrder) {
      throw new BusinessLogicError(ErrorCode.ORDER_NOT_FOUND, 'PreOrder not found', { userId: from, operation: 'handlePreOrderConfirmation', metadata: { messageId } });
    }

    logger.info(`Found preorder: ${preOrder.id}`);

    // Convert preorder to order
    const order = await orderManagementService.confirmPreOrder(preOrder.id);

    logger.info(`Order created successfully: ${order.id}`);

    // Send order confirmation
    await sendOrderConfirmation(from, order.id, "confirmed");
  } catch (error) {
    await ErrorService.handleAndSendError(error, from, {
      userId: from,
      operation: 'handlePreOrderConfirmation',
      metadata: { messageId }
    });
  }
}

// Función principal para enviar la confirmación de la orden
export async function sendOrderConfirmation(
  telefono: string,
  orderId: string,
  action: "confirmed" | "cancelled" | "modified"
): Promise<void> {
  try {
    // Obtener la orden completa con todos los detalles
    const fullOrder = await prisma.order.findUnique({
      where: { id: orderId },
      include: {
        orderItems: {
          include: {
            product: true,
            productVariant: true,
            productModifiers: true,
            selectedPizzaIngredients: {
              include: { pizzaIngredient: true },
            },
          },
        },
        deliveryInfo: true,
      },
    });

    if (!fullOrder) {
      throw new BusinessLogicError(ErrorCode.ORDER_NOT_FOUND, 'Order not found for confirmation', { userId: telefono, metadata: { orderId }, operation: 'sendOrderConfirmation' });
    }

    const orderType = fullOrder.orderType;
    let informacionEntrega = "";

    if (orderType === "DELIVERY" && fullOrder.deliveryInfo) {
      const deliveryInfo = fullOrder.deliveryInfo;
      const parts = [];
      // Construir dirección completa
      if (deliveryInfo.street && deliveryInfo.number) {
        let address = `${deliveryInfo.street} ${deliveryInfo.number}`;
        if (deliveryInfo.interiorNumber) {
          address += ` Int ${deliveryInfo.interiorNumber}`;
        }
        parts.push(address);
      }
      if (deliveryInfo.neighborhood) parts.push(deliveryInfo.neighborhood);
      if (deliveryInfo.city) parts.push(deliveryInfo.city);
      if (deliveryInfo.references) parts.push(`(${deliveryInfo.references})`);
      informacionEntrega = parts.join(", ");
    } else if (orderType === "TAKE_AWAY" && fullOrder.deliveryInfo?.pickupName) {
      informacionEntrega = fullOrder.deliveryInfo.pickupName;
    }

    // Format order for display
    const formattedOrder = OrderFormattingService.formatOrderForWhatsApp(fullOrder, telefono);
    const orderSummary = OrderFormattingService.generateConfirmationMessage(fullOrder, formattedOrder);
    
    await sendWhatsAppMessage(telefono, orderSummary);

    // Update messageId for tracking
    const orderManagementService = new OrderManagementService();
    const newMessageId = `order_${fullOrder.id}_${Date.now()}`;
    await orderManagementService.updateOrderMessageId(fullOrder.id, newMessageId);

    // Enviar botones de acción
    await sendActionButtonsForOrder(
      telefono,
      fullOrder.dailyNumber,
      fullOrder.messageId || `order_${fullOrder.id}_${Date.now()}`,
      fullOrder.orderStatus
    );
  } catch (error) {
    await ErrorService.handleAndSendError(error, telefono, {
      userId: telefono,
      metadata: { orderId },
      operation: 'sendOrderConfirmation'
    });
  }
}

// Función para enviar los botones de acción
async function sendActionButtonsForOrder(
  telefono: string,
  orderId: number,
  messageId: string,
  orderStatus: string
): Promise<void> {
  try {
    if (orderStatus === "created" || orderStatus === "pending") {
      const message = {
        type: "button",
        header: {
          type: "text",
          text: "Opciones de tu orden",
        },
        body: {
          text: "¿Qué deseas hacer con tu orden?",
        },
        action: {
          buttons: [
            {
              type: "reply",
              reply: {
                id: "cancel_order",
                title: "❌ Cancelar orden",
              },
            },
            {
              type: "reply",
              reply: {
                id: "modify_order",
                title: "✏️ Modificar orden",
              },
            },
            {
              type: "reply",
              reply: {
                id: "online_payment",
                title: "💳 Generar enlace de pago",
              },
            },
          ],
        },
      };

      await WhatsAppService.sendInteractiveMessage(telefono, message, messageId);
    }
  } catch (error) {
    logger.error('Error sending action buttons:', error);
    // No need to notify user about button sending failure
  }
}

================
File: backend/.env.example
================
# Base de datos local (funciona con docker-compose)
DATABASE_URL=postgresql://postgres:postgres@localhost:5433/bot_db

# ===== CONFIGURACIÓN REQUERIDA =====
# Debes actualizar TODOS estos valores antes de ejecutar el bot

# 1. Google AI - REQUERIDO
# Obtén tu API Key gratis en: https://makersuite.google.com/app/apikey
GOOGLE_AI_API_KEY=tu_api_key_aqui
GEMINI_MODEL=gemini-2.5-pro

# 2. WhatsApp Business API - REQUERIDO
# Obtén estos valores en: https://developers.facebook.com
# Tutorial: Ver QUICK_START.md sección "Obtener Credenciales de WhatsApp"
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=tu_phone_number_id
WHATSAPP_ACCESS_TOKEN=tu_access_token
WHATSAPP_VERIFY_TOKEN=tu_verify_token

# URLs locales
FRONTEND_BASE_URL=http://localhost:3000
NODE_ENV=development
PORT=5000

# Límites de mensajes
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5

# Configuración regional
DEFAULT_TIMEZONE=America/Mexico_City
DEFAULT_LOCALE=es-MX

# Stripe (Pagos) - OPCIONAL (dejar vacío si no se usa)
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=

# =============================================
# VARIABLES MÍNIMAS REQUERIDAS:
# =============================================
# 1. DATABASE_URL - Conexión a PostgreSQL
# 2. GOOGLE_AI_API_KEY - Para Gemini AI
# 3. GEMINI_MODEL - Modelo de Gemini a usar
# 4. WHATSAPP_PHONE_NUMBER_MESSAGING_ID - ID del teléfono en Meta
# 5. WHATSAPP_ACCESS_TOKEN - Token de acceso de WhatsApp
# 6. WHATSAPP_VERIFY_TOKEN - Token de verificación del webhook
# 7. FRONTEND_BASE_URL - URL del frontend para enlaces
# 8. NODE_ENV - Entorno (development/production)
# 9. PORT - Puerto del servidor
# 10. RATE_LIMIT_MAX_MESSAGES - Límite de mensajes
# 11. RATE_LIMIT_TIME_WINDOW_MINUTES - Ventana de tiempo para el límite
# 12. DEFAULT_TIMEZONE - Zona horaria por defecto
# 13. DEFAULT_LOCALE - Configuración regional por defecto

================
File: backend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": ".",
    "strict": true,
    "strictPropertyInitialization": false,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "types": ["node"],
    "allowJs": true,
    "noEmit": false,
    "incremental": true,
    "sourceMap": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*", "prisma/seed.ts"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "transpileOnly": true,
    "files": true,
    "compilerOptions": {
      "module": "commonjs"
    }
  }
}

================
File: frontend-app/src/components/AddressForm/AddressForm.tsx
================
import React from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { Input } from '@/components/ui';
import type { AddressFormData } from '@/types';

const schema = yup.object({
  street: yup.string().required('La calle es obligatoria'),
  number: yup.string().required('El número es obligatorio'),
  interiorNumber: yup.string().nullable(),
  references: yup.string().nullable(),
  neighborhood: yup.string().nullable(),
  zipCode: yup.string().nullable(),
  city: yup.string().nullable(),
  state: yup.string().nullable(),
  country: yup.string().nullable(),
  latitude: yup.number().required('La ubicación es obligatoria'),
  longitude: yup.number().required('La ubicación es obligatoria'),
});

interface AddressFormProps {
  formData: AddressFormData;
  onSubmit: (data: AddressFormData) => Promise<void>;
  errors?: Record<string, string>;
  isUpdating?: boolean;
}

export const AddressForm: React.FC<AddressFormProps> = ({ 
  formData, 
  onSubmit,
  errors: externalErrors = {},
  isUpdating = false
}) => {
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch,
  } = useForm<AddressFormData>({
    resolver: yupResolver(schema),
    defaultValues: formData,
  });

  React.useEffect(() => {
    // Update form when formData changes
    Object.entries(formData).forEach(([key, value]) => {
      setValue(key as keyof AddressFormData, value);
    });
  }, [formData, setValue]);

  const fieldTranslations = {
    street: 'Calle',
    number: 'Número',
    interiorNumber: 'Número interior',
    neighborhood: 'Colonia',
    zipCode: 'Código postal',
    city: 'Ciudad',
    state: 'Estado',
    country: 'País',
    references: 'Referencias',
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Dirección principal */}
      <div className="space-y-4">
        <h3 className="text-sm font-semibold text-gray-700 flex items-center">
          <svg className="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
          </svg>
          Dirección Principal
        </h3>
        
        <div className="grid grid-cols-3 gap-3">
          <div className="col-span-2">
            <Input
              label={fieldTranslations.street}
              {...register('street')}
              error={errors.street?.message || externalErrors.street}
              required
              placeholder="Ej: Av. Principal"
            />
          </div>
          <div>
            <Input
              label={fieldTranslations.number}
              {...register('number')}
              error={errors.number?.message || externalErrors.number}
              required
              placeholder="123"
            />
          </div>
        </div>

        <div className="grid grid-cols-2 gap-3">
          <Input
            label={fieldTranslations.interiorNumber}
            {...register('interiorNumber')}
            error={errors.interiorNumber?.message}
            placeholder="Depto 4B (Opcional)"
          />
        </div>
      </div>

      {/* Referencias */}
      <div className="space-y-4">
        <h3 className="text-sm font-semibold text-gray-700 flex items-center">
          <svg className="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          Referencias
        </h3>
        
        <Input
          label=""
          {...register('references')}
          error={errors.references?.message}
          as="textarea"
          rows={3}
          placeholder="Entre calles, puntos de referencia, color de la casa, etc."
          className="resize-none"
        />
      </div>

      {/* Información adicional */}
      <div className="space-y-4">
        <h3 className="text-sm font-semibold text-gray-700 flex items-center justify-between">
          <span className="flex items-center">
            <svg className="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
            Información Geográfica
          </span>
          <span className="text-xs font-normal bg-gray-200 text-gray-600 px-2 py-1 rounded-full flex items-center">
            <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
            </svg>
            Campos automáticos
          </span>
        </h3>
        
        <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
          <div className="relative">
            <Input
              label={fieldTranslations.neighborhood}
              {...register('neighborhood')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
          <div className="relative">
            <Input
              label={fieldTranslations.zipCode}
              {...register('zipCode')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
          <div className="relative">
            <Input
              label={fieldTranslations.city}
              {...register('city')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
          <div className="relative">
            <Input
              label={fieldTranslations.state}
              {...register('state')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
          <div className="relative">
            <Input
              label={fieldTranslations.country}
              {...register('country')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
        </div>

        <div className="bg-amber-50 border border-amber-200 rounded-lg p-3">
          <p className="text-xs text-amber-800 flex items-start font-medium">
            <svg className="w-4 h-4 mr-1.5 flex-shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
            </svg>
            Estos campos se completan automáticamente cuando seleccionas tu ubicación en el mapa. No es necesario editarlos manualmente.
          </p>
        </div>
      </div>

      {/* Hidden fields for coordinates */}
      <input type="hidden" {...register('latitude')} />
      <input type="hidden" {...register('longitude')} />
    </form>
  );
};

================
File: frontend-app/src/components/BasicMap/BasicMap.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import { loadGoogleMaps } from '@/utils/loadGoogleMaps';
import { config } from '@/config';
import { isPointInPolygon } from '@/utils/polygonUtils';

interface Location {
  lat: number;
  lng: number;
}

interface BasicMapProps {
  center: Location;
  onLocationSelect: (location: Location) => void;
  selectedLocation: Location | null;
  polygonCoords?: Location[];
  onLocationError?: (error: string) => void;
}

export const BasicMap: React.FC<BasicMapProps> = ({
  center,
  onLocationSelect,
  selectedLocation,
  polygonCoords = [],
  onLocationError,
}) => {
  const mapRef = useRef<HTMLDivElement>(null);
  const searchBoxRef = useRef<HTMLInputElement>(null);
  const polygonCoordsRef = useRef<Location[]>(polygonCoords);
  const [map, setMap] = useState<google.maps.Map | null>(null);
  const markerRef = useRef<google.maps.Marker | null>(null);
  const [isMapLoaded, setIsMapLoaded] = useState(false);
  const [mapError, setMapError] = useState<string | null>(null);
  const [isDragging, setIsDragging] = useState(false);

  // Update polygon coords ref when prop changes
  useEffect(() => {
    polygonCoordsRef.current = polygonCoords;
  }, [polygonCoords]);

  useEffect(() => {
    loadGoogleMaps()
      .then(() => {
        console.log('Google Maps loaded successfully');
        setIsMapLoaded(true);
        
        if (mapRef.current && !map) {
          // Initialize map with custom styles
          const mapInstance = new google.maps.Map(mapRef.current, {
            center,
            zoom: config.maps.defaultZoom.initial,
            mapTypeControl: false,
            fullscreenControl: false,
            streetViewControl: false,
            zoomControl: true,
            zoomControlOptions: {
              position: google.maps.ControlPosition.RIGHT_CENTER
            },
            gestureHandling: 'greedy', // Allow one-finger pan on mobile
            clickableIcons: false, // Disable POI clicks
            disableDoubleClickZoom: false, // Allow double click zoom
            styles: [
              {
                featureType: 'poi',
                elementType: 'labels',
                stylers: [{ visibility: 'off' }]
              },
              {
                featureType: 'transit',
                elementType: 'labels',
                stylers: [{ visibility: 'off' }]
              }
            ]
          });

          // Add click listener
          mapInstance.addListener('click', (e: google.maps.MapMouseEvent) => {
            if (e.latLng) {
              const location = {
                lat: e.latLng.lat(),
                lng: e.latLng.lng(),
              };
              
              // Validate if location is inside polygon
              if (polygonCoordsRef.current.length > 0 && !isPointInPolygon(location, polygonCoordsRef.current)) {
                if (onLocationError) {
                  onLocationError('⚠️ Por favor selecciona una ubicación dentro de nuestra área de cobertura');
                }
                return;
              }
              
              // Create or update marker immediately
              if (markerRef.current) {
                markerRef.current.setPosition(location);
              } else {
                markerRef.current = new google.maps.Marker({
                  position: location,
                  map: mapInstance,
                  animation: google.maps.Animation.DROP,
                  draggable: true,
                  icon: {
                    url: 'data:image/svg+xml;charset=UTF-8;base64,' + btoa(`
                      <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                          <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                            <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity="0.3"/>
                          </filter>
                        </defs>
                        <path d="M24 4C16.27 4 10 10.27 10 18c0 10.5 14 26 14 26s14-15.5 14-26c0-7.73-6.27-14-14-14z" fill="#EF4444" filter="url(#shadow)"/>
                        <circle cx="24" cy="18" r="6" fill="#ffffff"/>
                        <circle cx="24" cy="18" r="3" fill="#EF4444"/>
                      </svg>
                    `),
                    scaledSize: new google.maps.Size(48, 48),
                    anchor: new google.maps.Point(24, 48),
                  },
                  cursor: 'move'
                });
                
                // Set up drag listeners
                markerRef.current.addListener('dragend', () => {
                  const newPosition = markerRef.current?.getPosition();
                  if (newPosition) {
                    const newLocation = {
                      lat: newPosition.lat(),
                      lng: newPosition.lng(),
                    };
                    
                    // Validate if new location is inside polygon
                    if (polygonCoordsRef.current.length > 0 && !isPointInPolygon(newLocation, polygonCoordsRef.current)) {
                      // Return marker to previous position
                      markerRef.current?.setPosition(location);
                      if (onLocationError) {
                        onLocationError('⚠️ Por favor selecciona una ubicación dentro de nuestra área de cobertura');
                      }
                      return;
                    }
                    
                    onLocationSelect(newLocation);
                  }
                });
              }
              
              // Call location select
              onLocationSelect(location);
              
              // Pan to location
              mapInstance.panTo(location);
              mapInstance.setZoom(16);
            }
          });

          // Draw polygon if provided
          if (polygonCoords.length > 0) {
            const polygon = new google.maps.Polygon({
              paths: polygonCoords,
              strokeColor: '#10B981',
              strokeOpacity: 0.9,
              strokeWeight: 3,
              fillColor: '#10B981',
              fillOpacity: 0.2,
              map: mapInstance,
              clickable: false,  // IMPORTANTE: Permite que los clicks pasen a través del polígono
              zIndex: 1  // Asegura que esté detrás de otros elementos
            });

            // No agregamos listeners de hover ya que el polígono no es clickeable

            // Fit map to polygon bounds
            const bounds = new google.maps.LatLngBounds();
            polygonCoords.forEach(coord => {
              bounds.extend(new google.maps.LatLng(coord.lat, coord.lng));
            });
            mapInstance.fitBounds(bounds);
            
            // Add some padding
            const padding = { top: 50, right: 50, bottom: 50, left: 50 };
            mapInstance.fitBounds(bounds, padding);
          }

          setMap(mapInstance);

          // Initialize autocomplete
          if (searchBoxRef.current) {
            const autocomplete = new google.maps.places.Autocomplete(searchBoxRef.current, {
              componentRestrictions: { country: config.regional.countryCode },
              fields: ['geometry', 'formatted_address', 'name'],
              types: ['geocode', 'establishment']
            });

            // Bias results to current map bounds
            autocomplete.bindTo('bounds', mapInstance);

            // Listen for place selection
            autocomplete.addListener('place_changed', () => {
              const place = autocomplete.getPlace();
              
              if (!place.geometry || !place.geometry.location) {
                console.log('No se encontró la ubicación');
                return;
              }

              const location = {
                lat: place.geometry.location.lat(),
                lng: place.geometry.location.lng(),
              };

              // Validate if location is inside polygon
              if (polygonCoords.length > 0 && !isPointInPolygon(location, polygonCoords)) {
                if (onLocationError) {
                  onLocationError('⚠️ La dirección seleccionada está fuera de nuestra área de cobertura');
                }
                // Clear the input
                if (searchBoxRef.current) {
                  searchBoxRef.current.value = '';
                }
                return;
              }

              onLocationSelect(location);
              mapInstance.panTo(location);
              mapInstance.setZoom(config.maps.defaultZoom.search);
            });
          }
        }
      })
      .catch((error) => {
        console.error('Error loading Google Maps:', error);
        setMapError('Error al cargar el mapa. Por favor, recarga la página.');
      });
  }, []);

  // Update marker when location changes (from search or other sources)
  useEffect(() => {
    if (map && selectedLocation) {
      if (markerRef.current) {
        // If we already have a marker, just update its position
        markerRef.current.setPosition(selectedLocation);
      } else {
        // Create a new marker if it doesn't exist
        const newMarker = new google.maps.Marker({
          position: selectedLocation,
          map: map,
          animation: google.maps.Animation.DROP,
          draggable: true,
          icon: {
            url: 'data:image/svg+xml;charset=UTF-8;base64,' + btoa(`
              <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
                <defs>
                  <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                    <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity="0.3"/>
                  </filter>
                </defs>
                <path d="M24 4C16.27 4 10 10.27 10 18c0 10.5 14 26 14 26s14-15.5 14-26c0-7.73-6.27-14-14-14z" fill="#EF4444" filter="url(#shadow)"/>
                <circle cx="24" cy="18" r="6" fill="#ffffff"/>
                <circle cx="24" cy="18" r="3" fill="#EF4444"/>
              </svg>
            `),
            scaledSize: new google.maps.Size(48, 48),
            anchor: new google.maps.Point(24, 48),
          },
          cursor: 'move'
        });
        
        // Set up drag listeners for the new marker
        newMarker.addListener('dragend', () => {
          const newPosition = newMarker.getPosition();
          if (newPosition) {
            const newLocation = {
              lat: newPosition.lat(),
              lng: newPosition.lng(),
            };
            
            // Validate if location is inside polygon
            if (polygonCoordsRef.current.length > 0 && !isPointInPolygon(newLocation, polygonCoordsRef.current)) {
              // Return marker to previous position
              newMarker.setPosition(selectedLocation);
              if (onLocationError) {
                onLocationError('⚠️ Por favor selecciona una ubicación dentro de nuestra área de cobertura');
              }
              return;
            }
            
            onLocationSelect(newLocation);
          }
        });
        
        markerRef.current = newMarker;
      }
      
      // Pan to location
      map.panTo(selectedLocation);
      map.setZoom(16);
    } else if (map && !selectedLocation && markerRef.current) {
      // Remove marker if selectedLocation is null
      markerRef.current.setMap(null);
      markerRef.current = null;
    }
  }, [map, selectedLocation]);

  if (mapError) {
    return (
      <div className="w-full h-[400px] flex items-center justify-center bg-gray-100 rounded-lg">
        <div className="text-center text-red-600">
          <p>{mapError}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Search Box */}
      <div className="relative">
        <input
          ref={searchBoxRef}
          type="text"
          placeholder="Busca tu dirección o haz clic en el mapa..."
          className="w-full px-4 py-3 pl-10 pr-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200"
          disabled={!isMapLoaded}
        />
        <svg className="absolute left-3 top-3.5 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
        </svg>
      </div>

      {/* Map Container */}
      <div className="relative w-full h-[300px] sm:h-[400px] rounded-lg overflow-hidden shadow-md border-2 border-gray-200">
        <div ref={mapRef} className="w-full h-full" />
        
        {!isMapLoaded && (
          <div className="absolute inset-0 flex items-center justify-center bg-gray-100">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
              <p className="mt-2 text-sm text-gray-600">Cargando mapa...</p>
            </div>
          </div>
        )}
        
        {/* Instructions overlay */}
        {isMapLoaded && !selectedLocation && (
          <div className="absolute top-2 left-2 sm:top-4 sm:left-4 bg-orange-500 bg-opacity-95 backdrop-blur-sm rounded-lg shadow-lg p-3 max-w-[220px] sm:max-w-xs z-10 animate-pulse">
            <div className="space-y-1">
              <p className="text-sm text-white font-semibold">
                👆 Toca cualquier punto del mapa para marcar tu ubicación
              </p>
            </div>
          </div>
        )}
        
        {/* Instructions for dragging - only show when marker exists */}
        {isMapLoaded && selectedLocation && markerRef.current && (
          <div className="absolute top-2 left-2 sm:top-4 sm:left-4 bg-white bg-opacity-95 backdrop-blur-sm rounded-lg shadow-lg p-2 sm:p-3 max-w-[200px] sm:max-w-xs z-10">
            <p className="text-xs text-gray-700">
              <span className="font-semibold">✋ Arrastra el marcador</span> para ajustar tu ubicación
            </p>
          </div>
        )}
        
        
        {/* Center on marker button */}
        {selectedLocation && map && (
          <button
            onClick={() => {
              map.panTo(selectedLocation);
              map.setZoom(17);
            }}
            className="absolute bottom-20 right-2 sm:bottom-24 sm:right-4 bg-white bg-opacity-95 backdrop-blur-sm rounded-full shadow-lg p-3 hover:bg-gray-100 transition-colors z-10"
            title="Centrar en mi ubicación"
          >
            <svg className="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l-4 4m0 0l-4-4m4 4V3" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </button>
        )}
        
        {/* Coordinates display */}
        {selectedLocation && !isDragging && (
          <div className="absolute bottom-2 right-2 sm:bottom-4 sm:right-4 bg-white bg-opacity-95 backdrop-blur-sm rounded-lg shadow-lg p-2 sm:p-3 z-10">
            <p className="text-xs text-gray-700 font-medium">📍 Ubicación seleccionada:</p>
            <p className="text-xs text-gray-600 font-mono">
              Lat: {selectedLocation.lat.toFixed(6)}
            </p>
            <p className="text-xs text-gray-600 font-mono">
              Lng: {selectedLocation.lng.toFixed(6)}
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

================
File: frontend-app/src/AddressRegistration.tsx
================
import { useState, useEffect } from 'react';
import { useParams, useSearchParams } from 'react-router-dom';
import toast, { Toaster } from 'react-hot-toast';
import { AddressForm } from '@/components/AddressForm';
import { BasicMap } from '@/components/BasicMap';
import { AddressManager } from '@/components/AddressManager';
import { WhatsAppButton } from '@/components/ui';
import customerService from '@/services/customer.service';
import type { AddressFormData, Customer, Address } from '@/types/customer.types';

interface Location {
  lat: number;
  lng: number;
}

function AddressRegistration() {
  const { customerId } = useParams<{ customerId: string }>();
  const [searchParams] = useSearchParams();
  const otp = searchParams.get('otp') || '';
  const preOrderId = searchParams.get('preOrderId');

  const [isValidOtp, setIsValidOtp] = useState(false);
  const [loading, setLoading] = useState(true);
  const [customer, setCustomer] = useState<Customer | null>(null);
  const [selectedAddress, setSelectedAddress] = useState<Address | null>(null);
  const [selectedLocation, setSelectedLocation] = useState<Location | null>(null);
  const [formData, setFormData] = useState<AddressFormData>({
    street: '',
    number: '',
    interiorNumber: '',
    neighborhood: '',
    zipCode: '',
    city: '',
    state: '',
    country: '',
    references: '',
    latitude: 0,
    longitude: 0,
  });
  const [isUpdating, setIsUpdating] = useState(false);
  const [locationError, setLocationError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [hasVerified, setHasVerified] = useState(false);
  const [polygonCoords, setPolygonCoords] = useState<Location[]>([]);
  const [mapCenter, setMapCenter] = useState<Location | null>(null);
  const [showAddressForm, setShowAddressForm] = useState(false);

  useEffect(() => {
    // Evitar doble verificación
    if (hasVerified) return;
    
    if (customerId && otp) {
      setHasVerified(true);
      verifyOtp();
    } else {
      setLoading(false);
      setIsValidOtp(false);
    }
  }, [customerId, otp, hasVerified]);

  // Load delivery area from backend
  useEffect(() => {
    const loadDeliveryArea = async () => {
      const { polygonCoords: coords } = await customerService.getDeliveryArea();
      if (coords && coords.length > 0) {
        setPolygonCoords(coords);
        
        // Calculate center from polygon
        const sumLat = coords.reduce((sum, coord) => sum + coord.lat, 0);
        const sumLng = coords.reduce((sum, coord) => sum + coord.lng, 0);
        setMapCenter({
          lat: sumLat / coords.length,
          lng: sumLng / coords.length
        });
      }
    };
    
    loadDeliveryArea();
  }, []);

  const verifyOtp = async () => {
    try {
      const response = await customerService.verifyOTP(customerId!, otp);
      
      if (response.valid && response.customer) {
        setIsValidOtp(true);
        setCustomer(response.customer);
        
        // If customer has addresses, show the address manager
        // Otherwise, show the form to add the first address
        if (response.customer.addresses.length === 0) {
          setShowAddressForm(true);
        }
      } else {
        toast.error('❌ El enlace ha expirado o no es válido');
      }
    } catch (error) {
      console.error('Error al verificar el OTP:', error);
      toast.error('⚠️ Hubo un error al verificar el enlace');
    } finally {
      setLoading(false);
    }
  };

  const loadExistingAddress = (address: Address) => {
    setSelectedAddress(address);
    setIsUpdating(true);
    setShowAddressForm(true);
    
    const formattedData: AddressFormData = {
      street: address.street,
      number: address.number,
      interiorNumber: address.interiorNumber || '',
      neighborhood: address.neighborhood || '',
      zipCode: address.zipCode || '',
      city: address.city || '',
      state: address.state || '',
      country: address.country || '',
      references: address.references || '',
      latitude: address.latitude || 0,
      longitude: address.longitude || 0,
    };

    setFormData(formattedData);
    
    if (address.latitude && address.longitude) {
      setSelectedLocation({
        lat: Number(address.latitude),
        lng: Number(address.longitude),
      });
    }
  };

  const handleLocationSelect = (location: Location) => {
    setSelectedLocation(location);
    setLocationError(null);
    
    // Update coordinates immediately
    setFormData(prev => ({
      ...prev,
      latitude: location.lat,
      longitude: location.lng,
    }));
    
    // Reverse geocoding using Google
    const geocoder = new google.maps.Geocoder();
    geocoder.geocode({ location }, (results, status) => {
      if (status === 'OK' && results && results[0]) {
        const addressComponents = results[0].address_components;
        const formattedAddress = results[0].formatted_address;
        
        const newFormData: Partial<AddressFormData> = {
          latitude: location.lat,
          longitude: location.lng,
        };

        addressComponents.forEach((component) => {
          const types = component.types;
          if (types.includes('route')) {
            newFormData.street = component.long_name;
          } else if (types.includes('street_number')) {
            newFormData.number = component.long_name;
          } else if (types.includes('sublocality_level_1') || types.includes('neighborhood')) {
            newFormData.neighborhood = component.long_name;
          } else if (types.includes('postal_code')) {
            newFormData.zipCode = component.long_name;
          } else if (types.includes('locality')) {
            newFormData.city = component.long_name;
          } else if (types.includes('administrative_area_level_1')) {
            newFormData.state = component.long_name;
          } else if (types.includes('country')) {
            newFormData.country = component.long_name;
          }
        });

        setFormData((prev) => ({ ...prev, ...newFormData }));
      }
    });
  };

  const handleAddNewAddress = () => {
    setShowAddressForm(true);
    setIsUpdating(false);
    setSelectedAddress(null);
    setSelectedLocation(null);
    setFormData({
      street: '',
      number: '',
      interiorNumber: '',
      neighborhood: '',
      zipCode: '',
      city: '',
      state: '',
      country: '',
      references: '',
      latitude: 0,
      longitude: 0,
    });
  };

  const loadCustomerData = async () => {
    try {
      const response = await customerService.verifyOTP(customerId!, otp);
      if (response.valid && response.customer) {
        setCustomer(response.customer);
        setShowAddressForm(false);
      }
    } catch (error) {
      console.error('Error reloading customer data:', error);
    }
  };


  const handleSubmit = async (data: AddressFormData) => {
    if (!selectedLocation) {
      toast.error('📍 Por favor selecciona una ubicación en el mapa');
      return;
    }

    setIsSubmitting(true);
    
    try {
      if (isUpdating && selectedAddress) {
        // Update existing address
        await customerService.updateAddress(
          selectedAddress.id,
          customerId!,
          otp,
          data
        );
        toast.success('✅ ¡Dirección actualizada exitosamente!');
      } else {
        // Create new address
        await customerService.createAddress(customerId!, otp, data);
        toast.success('🎉 ¡Dirección registrada exitosamente!');
      }
      
      // Reload customer data
      await loadCustomerData();

      // Success feedback and redirect to WhatsApp
      toast.success('📱 Redirigiendo a WhatsApp...', {
        duration: 2000,
      });

      // If updating for a pre-order, notify backend
      if (preOrderId) {
        // The backend will handle the pre-order update
        toast.success('🛍️ Tu pedido ha sido actualizado con la nueva dirección');
      }

      // Redirect to WhatsApp after a short delay
      setTimeout(() => {
        const phoneNumber = import.meta.env.VITE_BOT_WHATSAPP_NUMBER;
        const message = preOrderId 
          ? 'Mi dirección ha sido actualizada, por favor continúa con mi pedido.'
          : 'Hola, acabo de registrar mi dirección de entrega.';
        const encodedMessage = encodeURIComponent(message);
        const whatsappUrl = `https://wa.me/${phoneNumber}?text=${encodedMessage}`;
        
        // Try to close the window first, then redirect
        window.location.href = whatsappUrl;
        
        // Try to close the window after redirect (may not work in all browsers)
        setTimeout(() => {
          window.close();
        }, 100);
      }, 2000);
    } catch (error: any) {
      console.error('Error al guardar la dirección:', error);
      const errorMessage = error.response?.data?.error || 'Hubo un error al guardar la dirección';
      toast.error(errorMessage);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleUseMyLocation = () => {
    if ('geolocation' in navigator) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const location = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          };
          handleLocationSelect(location);
          toast.success('✨ ¡Ubicación actual capturada con éxito!');
        },
        (error) => {
          console.error('Error getting location:', error);
          let errorMessage = 'No se pudo obtener tu ubicación actual';
          
          switch(error.code) {
            case error.PERMISSION_DENIED:
              errorMessage = 'Permiso de ubicación denegado. Por favor habilita la ubicación en tu navegador.';
              break;
            case error.POSITION_UNAVAILABLE:
              errorMessage = 'La información de ubicación no está disponible.';
              break;
            case error.TIMEOUT:
              errorMessage = 'Se agotó el tiempo de espera para obtener la ubicación.';
              break;
          }
          
          toast.error(errorMessage);
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 0
        }
      );
    } else {
      toast.error('Tu navegador no soporta geolocalización');
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-orange-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Verificando enlace...</p>
        </div>
      </div>
    );
  }

  if (!isValidOtp) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
        <div className="max-w-md w-full bg-white p-8 rounded-lg shadow-lg text-center">
          <svg className="mx-auto h-12 w-12 text-red-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <h2 className="text-2xl font-bold text-gray-900 mb-2">Enlace inválido</h2>
          <p className="text-gray-600 mb-4">
            Este enlace ha expirado o no es válido. Por favor, solicita un nuevo enlace desde WhatsApp.
          </p>
          <div className="mt-6">
            <WhatsAppButton 
              className="w-full justify-center"
            >
              Continuar en WhatsApp
            </WhatsAppButton>
          </div>
        </div>
        <Toaster 
        position="top-center"
        toastOptions={{
          duration: 4000,
          style: {
            background: '#fff',
            color: '#1f2937',
            padding: '16px',
            borderRadius: '12px',
            fontSize: '14px',
            fontWeight: '500',
            boxShadow: '0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
            border: '1px solid rgba(0, 0, 0, 0.05)',
          },
          success: {
            iconTheme: {
              primary: '#10b981',
              secondary: '#fff',
            },
            style: {
              background: 'linear-gradient(135deg, #10b981 0%, #059669 100%)',
              color: '#fff',
              border: 'none',
            },
          },
          error: {
            iconTheme: {
              primary: '#ef4444',
              secondary: '#fff',
            },
            style: {
              background: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)',
              color: '#fff',
              border: 'none',
            },
          },
        }}
      />
      </div>
    );
  }


  return (
    <div className="min-h-screen bg-gradient-to-br from-orange-50 via-red-50 to-pink-50">
      <div className="max-w-4xl mx-auto p-2 sm:p-4">
        <div className="bg-white rounded-xl sm:rounded-2xl shadow-xl overflow-hidden">
          <div className="bg-gradient-to-r from-orange-500 to-pink-600 p-4 sm:p-6 text-white">
            <h1 className="text-xl sm:text-2xl md:text-3xl font-bold mb-2 drop-shadow-lg">
              {customer && customer.addresses.length > 0 && !showAddressForm 
                ? '📍 Mis Direcciones de Entrega' 
                : isUpdating 
                  ? '📍 Actualizar Dirección' 
                  : '📍 Registrar Dirección de Entrega'}
            </h1>
            <div className="space-y-1">
              <p className="text-sm sm:text-base text-white font-medium drop-shadow">
                {customer && customer.addresses.length > 0 && !showAddressForm
                  ? `¡Hola${customer?.firstName ? ` ${customer.firstName}` : ''}! Selecciona o agrega una dirección de entrega.`
                  : `¡Hola${customer?.firstName ? ` ${customer.firstName}` : ''}! Por favor completa tu información de entrega.`}
              </p>
              {customerId && (
                <div className="inline-block bg-white/20 backdrop-blur-sm rounded-lg px-3 py-1 mt-2">
                  <p className="text-xs sm:text-sm text-white font-medium">
                    📱 Tu número: {customerId}
                  </p>
                </div>
              )}
            </div>
          </div>
          
          <div className="p-4 sm:p-6">
            {/* Show AddressManager or Form based on state */}
            {customer && customer.addresses.length > 0 && !showAddressForm ? (
              <AddressManager
                addresses={customer.addresses}
                customerId={customerId!}
                otp={otp}
                onAddressClick={loadExistingAddress}
                onAddNew={handleAddNewAddress}
                onAddressesChange={loadCustomerData}
              />
            ) : (
              <>
                {/* Back button if user has addresses */}
                {customer && customer.addresses.length > 0 && (
                  <button
                    onClick={() => setShowAddressForm(false)}
                    className="mb-4 text-orange-600 hover:text-orange-700 flex items-center text-sm font-medium"
                  >
                    <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                    </svg>
                    Volver a mis direcciones
                  </button>
                )}

                {/* Use my location button */}
                <div className="mb-4 sm:mb-6">
                  <button
                    type="button"
                    onClick={handleUseMyLocation}
                    className="w-full sm:w-auto bg-white border-2 border-orange-500 text-orange-600 font-medium sm:font-semibold py-2.5 sm:py-3 px-4 sm:px-6 rounded-lg hover:bg-orange-50 transition duration-200 flex items-center justify-center text-sm sm:text-base"
                  >
                    <svg className="w-4 h-4 sm:w-5 sm:h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                    Usar mi ubicación actual
                  </button>
                </div>

                {/* Map with Search */}
                <div className="mb-4 sm:mb-6">
                  {mapCenter && (
                    <BasicMap
                      center={selectedLocation || mapCenter}
                      onLocationSelect={handleLocationSelect}
                      selectedLocation={selectedLocation}
                      polygonCoords={polygonCoords}
                      onLocationError={setLocationError}
                    />
                  )}
                  {locationError && (
                    <div className="mt-2 bg-red-50 border border-red-200 text-red-600 px-3 sm:px-4 py-2 rounded-lg text-xs sm:text-sm">
                      {locationError}
                    </div>
                  )}
                </div>

                {/* Address Form */}
                <div className="bg-gray-50 rounded-lg p-4 sm:p-6 mb-4 sm:mb-6">
                  <h2 className="text-base sm:text-lg font-semibold text-gray-800 mb-3 sm:mb-4">Detalles de la dirección</h2>
                  <AddressForm
                    formData={formData}
                    onSubmit={handleSubmit}
                    isUpdating={isUpdating}
                  />
                </div>

                {/* Submit Button */}
                <div className="mt-4 sm:mt-6">
                  <button
                    type="submit"
                    onClick={() => handleSubmit(formData)}
                    disabled={isSubmitting || !selectedLocation}
                    className={`w-full py-3 sm:py-4 px-4 sm:px-6 font-medium sm:font-semibold rounded-lg transition duration-200 text-sm sm:text-base ${
                      isSubmitting || !selectedLocation
                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                        : 'bg-gradient-to-r from-orange-500 to-pink-600 text-white hover:from-orange-600 hover:to-pink-700'
                    }`}
                  >
                    {isSubmitting ? (
                      <span className="flex items-center justify-center">
                        <svg className="animate-spin -ml-1 mr-2 sm:mr-3 h-4 w-4 sm:h-5 sm:w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Guardando...
                      </span>
                    ) : (
                      <span>
                        {isUpdating ? 'Actualizar dirección' : 'Registrar dirección'}
                      </span>
                    )}
                  </button>
                </div>
              </>
            )}
          </div>
        </div>
      </div>
      <Toaster 
        position="top-center"
        toastOptions={{
          duration: 4000,
          style: {
            background: '#fff',
            color: '#1f2937',
            padding: '16px',
            borderRadius: '12px',
            fontSize: '14px',
            fontWeight: '500',
            boxShadow: '0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
            border: '1px solid rgba(0, 0, 0, 0.05)',
          },
          success: {
            iconTheme: {
              primary: '#10b981',
              secondary: '#fff',
            },
            style: {
              background: 'linear-gradient(135deg, #10b981 0%, #059669 100%)',
              color: '#fff',
              border: 'none',
            },
          },
          error: {
            iconTheme: {
              primary: '#ef4444',
              secondary: '#fff',
            },
            style: {
              background: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)',
              color: '#fff',
              border: 'none',
            },
          },
        }}
      />
    </div>
  );
}

export default AddressRegistration;

================
File: backend/src/common/config/predefinedMessages.ts
================
import { prisma } from "../../server";
import { RestaurantInfo } from "../types/restaurant";

// Address registration messages
export const ADDRESS_REGISTRATION_SUCCESS = (address: any): string => {
  return `✅ *¡Dirección registrada exitosamente!*

📍 *Tu dirección de entrega:*
${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}
${address.neighborhood ? `Col. ${address.neighborhood}\n` : ''}${address.city}, ${address.state}

¡Perfecto! Tu dirección ha sido guardada. Ahora puedes realizar tu pedido. 🎉`;
};

export const ADDRESS_UPDATE_SUCCESS = (address: any): string => {
  return `✅ *¡Dirección actualizada correctamente!*

📍 *Tu nueva dirección de entrega:*
${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}
${address.neighborhood ? `Col. ${address.neighborhood}\n` : ''}${address.city}, ${address.state}

Tu información de entrega ha sido actualizada exitosamente. 👍`;
};

// Helper function to get restaurant config
async function getRestaurantInfo(): Promise<RestaurantInfo> {
  const config = await prisma.restaurantConfig.findFirst();
  
  // Cast explícito para resolver problemas de tipos en VS Code
  const typedConfig = config as any;
  
  if (!typedConfig) {
    return {
      restaurantName: "Establecimiento",
      phoneMain: "",
      phoneSecondary: "",
      address: "",
      city: "",
      state: "",
      postalCode: ""
    };
  }
  
  return {
    restaurantName: typedConfig.restaurantName || "Establecimiento",
    phoneMain: typedConfig.phoneMain || "",
    phoneSecondary: typedConfig.phoneSecondary || "",
    address: typedConfig.address || "",
    city: typedConfig.city || "",
    state: typedConfig.state || "",
    postalCode: typedConfig.postalCode || ""
  };
}

export const BANNED_USER_MESSAGE = async () => {
  const config = await getRestaurantInfo();
  return `Lo sentimos, tu número ha sido baneado debido a la detección de un uso inadecuado de nuestro servicio.

Si crees que es un error, por favor contacta directamente con nosotros:

${config.phoneMain ? `📞 Teléfono: ${config.phoneMain}` : ''}
${config.phoneSecondary ? `📞 Teléfono: ${config.phoneSecondary}` : ''}

Agradecemos tu comprensión y esperamos resolver cualquier malentendido.`;
};

export const WAIT_TIMES_MESSAGE = (
  pickupTime: number,
  deliveryTime: number
) => `
🕒 *Tiempos de espera estimados:*

🏠 Recolección en establecimiento: ${pickupTime} minutos
🚚 Entrega a domicilio: ${deliveryTime} minutos

Estos tiempos son aproximados y pueden variar según la demanda actual.
`;

export const RESTAURANT_INFO_MESSAGE = async () => {
  const { getFormattedBusinessHours } = await import("../utils/timeUtils");
  const config = await getRestaurantInfo();
  const formattedHours = await getFormattedBusinessHours();
  
  const fullAddress = [config.address, config.city, config.state, config.postalCode]
    .filter(Boolean)
    .join(", ");
  
  return `
📍 *Información y horarios de ${config.restaurantName}*

${fullAddress ? `📍 *Ubicación:* ${fullAddress}` : ''}

📞 *Teléfonos:*
${config.phoneMain ? `   ${config.phoneMain}` : ''}
${config.phoneSecondary ? `   ${config.phoneSecondary}` : ''}

🕒 *Horarios:*
${formattedHours.split('\n').map(line => '   ' + line).join('\n')}

¡Gracias por tu interés! Esperamos verte pronto.
`;
};

export const CHATBOT_HELP_MESSAGE = async () => {
  const config = await getRestaurantInfo();
  return `
🤖💬 *¡Bienvenido al Chatbot de ${config.restaurantName}!*

Este asistente virtual está potenciado por inteligencia artificial para brindarte una experiencia fluida y natural. Aquí te explicamos cómo usarlo:

🚀 *Iniciar una conversación:*
Envía cualquier mensaje para comenzar. Recibirás opciones para:
   📜 Consultar el menú
   ⏱️ Ver tiempos de espera
   🔄 Reordenar
   ℹ️ Información del restaurante

🍽️ *Realizar un pedido:*
Escribe o envía un audio con tu pedido. Opciones:
   🏠 Entrega a domicilio: Incluye la dirección completa
   🏃 Recolección en establecimiento: Indica el nombre para recoger
Ejemplos:
   '2 platos principales y una bebida para entrega a Morelos 66 poniente'
   'Un combo familiar y una ensalada para recoger, nombre: Juan Pérez'

Una vez generado tu pedido, recibirás un mensaje de confirmación cuando lo aceptemos o un mensaje de rechazo en caso de que no podamos procesarlo.

✏️ *Modificar un pedido:*
Usa la opción en el mensaje de confirmación, solo si aún no lo hemos aceptado.

❌ *Cancelar un pedido:*
Disponible en las opciones del mensaje de confirmación, solo se puede cancelar si aún no hemos aceptado el pedido.

💳 *Pagar:*
Genera un enlace de pago desde las opciones del mensaje de confirmación. Si no pagas en línea, el pago se realizará en efectivo al momento de la entrega.

🔁 *Reordenar:*
Selecciona 'Reordenar' en el mensaje de bienvenida para ver tus últimas 3 órdenes y poder reordenar con solo un click.

⚠️ *IMPORTANTE:*
Envía un mensaje a la vez y espera la respuesta antes del siguiente para evitar confusiones.

¡Disfruta tu experiencia con nuestro chatbot! 🍽️🤖
`;
};

export const CHANGE_DELIVERY_INFO_MESSAGE = (updateLink: string) => `
🚚 ¡Actualiza tu información de entrega! 📝

👇 *PRESIONA AQUÍ PARA ACTUALIZAR* 👇

${updateLink}`;

export const RESTAURANT_NOT_ACCEPTING_ORDERS_MESSAGE = async () => {
  const config = await getRestaurantInfo();
  return `
🚫🍽️ Lo sentimos, no estamos aceptando pedidos en este momento. 😔

⏳ Puedes intentar más tarde o llamarnos directamente:
${config.phoneMain ? `📞 Teléfono: ${config.phoneMain}` : ''}
${config.phoneSecondary ? `📞 Teléfono: ${config.phoneSecondary}` : ''}

¡Gracias por tu comprensión! 🙏
`;
};

export const RESTAURANT_CLOSED_MESSAGE = async () => {
  const { getFormattedBusinessHours } = await import("../utils/timeUtils");
  const formattedHours = await getFormattedBusinessHours();
  
  return `
🚫 Lo sentimos, estamos cerrados en este momento. 😴

🕒 Nuestro horario de atención es:
${formattedHours.split('\n').map(line => '   🗓️ ' + line).join('\n')}

🙏 Gracias por tu comprensión. ¡Esperamos atenderte pronto! 😊
`;
};

export const DELIVERY_INFO_REGISTRATION_MESSAGE = (
  registrationLink: string
) => `
¡Hola! 👋 Antes de continuar, necesitamos que registres tu información de entrega. 📝

👇 *PRESIONA AQUÍ PARA REGISTRARTE* 👇

${registrationLink}
`;

export const PAYMENT_CONFIRMATION_MESSAGE = (orderNumber: number) => `
¡Tu pago para la orden #${orderNumber} ha sido confirmado! 🎉✅ Gracias por tu compra. 🛍️😊
`;

export const WELCOME_MESSAGE_INTERACTIVE = async () => {
  const config = await getRestaurantInfo();
  return {
    type: "list",
    header: {
      type: "text",
      text: `Bienvenido a ${config.restaurantName} 🍽️`
    },
    body: {
      text: "¿Cómo podemos ayudarte hoy? 😊"
    },
    footer: {
      text: "Selecciona una opción:"
    },
    action: {
      button: "Ver opciones",
      sections: [
        {
          title: "Acciones",
          rows: [
            { id: "view_menu", title: "📜 Ver Menú" },
            { id: "wait_times", title: "⏱️ Tiempos de espera" },
            { id: "restaurant_info", title: "ℹ️ Información y horarios" },
            { id: "chatbot_help", title: "🤖 ¿Cómo usar el bot?" },
            {
              id: "change_delivery_info",
              title: "🚚 Actualizar entrega"
            }
          ]
        }
      ]
    }
  };
};

// Mensaje cuando se reinicia la conversación
export const CONVERSATION_RESET_MESSAGE = "🔄 Entendido, he olvidado el contexto anterior. ¿En qué puedo ayudarte ahora? 😊";

// Mensaje de error genérico
export const GENERIC_ERROR_MESSAGE = "Lo siento, ocurrió un error procesando tu mensaje. Por favor intenta de nuevo.";

// Mensaje para tipo de mensaje no soportado
export const UNSUPPORTED_MESSAGE_TYPE = "Lo siento, solo puedo procesar mensajes de texto por el momento.";

// Mensaje cuando falla la transcripción de audio
export const AUDIO_TRANSCRIPTION_ERROR = "🎤 Hubo un problema al procesar tu mensaje de audio. Por favor, intenta nuevamente o envía un mensaje de texto.";

// Mensaje de límite de tasa excedido
export const RATE_LIMIT_MESSAGE = "Has alcanzado el límite de mensajes. Por favor espera unos minutos antes de enviar más mensajes.";

// Mensaje cuando no se encuentra una orden
export const ORDER_NOT_FOUND_MESSAGE = "❌ Lo siento, no se pudo encontrar tu orden. 🚫🔍";

// Mensaje cuando no se puede cancelar una orden
export const ORDER_CANNOT_BE_CANCELLED_MESSAGE = (status: string) => {
  const statusMessages: Record<string, string> = {
    IN_PROGRESS: "Lo sentimos, pero esta orden ya no se puede cancelar porque ya fue aceptada. ⚠️",
    IN_PREPARATION: "Lo sentimos, pero esta orden ya está en preparación y no se puede cancelar. 👨‍🍳",
    READY: "Lo sentimos, pero esta orden ya está preparada y no se puede cancelar. 🍽️",
    IN_DELIVERY: "Lo sentimos, pero esta orden ya está en camino y no se puede cancelar. 🚚",
    DELIVERED: "Lo sentimos, pero esta orden ya fue entregada y no se puede cancelar. ✅",
    COMPLETED: "Lo sentimos, pero esta orden ya fue completada y no se puede cancelar. ✅",
  };
  return statusMessages[status] || "Lo sentimos, esta orden no se puede cancelar en su estado actual.";
};

// Mensaje de confirmación de cancelación de orden
export const ORDER_CANCELLED_MESSAGE = "Tu orden ha sido eliminada exitosamente. ✅";

// Mensaje cuando Stripe no está disponible
export const STRIPE_NOT_AVAILABLE_MESSAGE = "❌ Lo siento, los pagos en línea no están disponibles en este momento. Por favor, realiza el pago en efectivo al recibir tu pedido. 💵";

// Mensaje cuando ya existe un enlace de pago
export const PAYMENT_LINK_EXISTS_MESSAGE = "⚠️ Ya existe un enlace de pago activo para esta orden. Por favor, utiliza el enlace enviado anteriormente o contáctanos si necesitas ayuda. 🔄";

================
File: backend/src/whatsapp/handlers/orders/orderFormatters.ts
================
/**
 * Order formatting utilities
 * Handles the formatting of order summaries and product details
 */

import { env } from '../../../common/config/envValidator';

// Helper function to generate product summary
export function generateProductSummary(product: any): string {
  // Handle different product structures
  const quantity = product.quantity || product.cantidad || 1;
  
  // Use variant name if available, otherwise use product name
  const name = product.variantName || product.productName || product.nombre || 'Producto';
  
  const price = product.subtotal || product.itemPrice || product.precio || product.price || 0;
  
  let summary = `- *${quantity}x ${name}*: $${price}\n`;

  // Show modifiers if they exist
  if (product.modifiers?.length > 0 || product.modificadores?.length > 0) {
    const modifiers = product.modifiers || product.modificadores;
    summary += `  🔸 Modificadores: ${modifiers
      .map((mod: any) => mod.name || mod.nombre || mod)
      .join(", ")}\n`;
  }

  // Show pizza ingredients if they exist
  if (product.pizzaIngredients?.length > 0 || product.ingredientes_pizza?.length > 0) {
    summary += generatePizzaIngredientsSummary(product.pizzaIngredients || product.ingredientes_pizza);
  }

  // Show comments if they exist
  if (product.comments || product.comentarios) {
    summary += `  💬 Comentarios: ${product.comments || product.comentarios}\n`;
  }

  return summary;
}

// Helper function to generate pizza ingredients summary
export function generatePizzaIngredientsSummary(ingredients: any[]): string {
  let summary = "  🔸 Ingredientes de pizza:\n";

  const ingredientsByHalf = {
    left: ingredients
      .filter((ing: any) => ing.half === "left" || ing.mitad === "left")
      .map((ing: any) => ing.name || ing.nombre),
    right: ingredients
      .filter((ing: any) => ing.half === "right" || ing.mitad === "right")
      .map((ing: any) => ing.name || ing.nombre),
    full: ingredients
      .filter((ing: any) => ing.half === "full" || ing.mitad === "full")
      .map((ing: any) => ing.name || ing.nombre),
  };

  const leftIngredients = [
    ...ingredientsByHalf.left,
    ...ingredientsByHalf.full,
  ];
  const rightIngredients = [
    ...ingredientsByHalf.right,
    ...ingredientsByHalf.full,
  ];

  if (
    leftIngredients.length === rightIngredients.length &&
    leftIngredients.every((ing: string) => rightIngredients.includes(ing))
  ) {
    // Same ingredients on both halves
    summary += `     • Completa: ${leftIngredients.join(", ")}\n`;
  } else {
    // Different ingredients on each half
    if (leftIngredients.length > 0) {
      summary += `     • Mitad Izquierda: ${leftIngredients.join(", ")}\n`;
    }
    if (rightIngredients.length > 0) {
      summary += `     • Mitad Derecha: ${rightIngredients.join(", ")}\n`;
    }
  }

  // Show special actions (remove)
  const removedIngredients = ingredients
    .filter((ing: any) => ing.action === "remove")
    .map((ing: any) => ing.name || ing.nombre);
  if (removedIngredients.length > 0) {
    summary += `     • ❌ Quitar: ${removedIngredients.join(", ")}\n`;
  }

  return summary;
}

// Function to generate complete order summary
export function generateOrderSummary(order: any): string {
  // Normalize orderType to lowercase for comparison
  const orderType = (order.orderType || '').toString().toLowerCase();
  const deliveryTypeText = orderType === "delivery" ? "Entrega a domicilio" : "Recolección en establecimiento";
  
  let message = `📋 *Resumen de tu pedido:*\n\n`;
  message += `📦 *Tipo de orden:* ${deliveryTypeText}\n\n`;
  
  if (orderType === "pickup" || orderType === "take_away") {
    if (order.pickupName) {
      message += `👤 *Nombre para recoger:* ${order.pickupName}\n\n`;
    }
  }
  
  if (orderType === "delivery" && order.deliveryInfo) {
    // Combine street, number and interior number
    let fullAddress = order.deliveryInfo.street || "";
    if (order.deliveryInfo.number) {
      fullAddress += ` ${order.deliveryInfo.number}`;
    }
    if (order.deliveryInfo.interiorNumber) {
      fullAddress += ` Int. ${order.deliveryInfo.interiorNumber}`;
    }
    message += `📍 *Dirección de entrega:*\n${fullAddress}\n`;
    if (order.deliveryInfo.neighborhood) {
      message += `Colonia: ${order.deliveryInfo.neighborhood}\n`;
    }
    if (order.deliveryInfo.references) {
      message += `Referencias: ${order.deliveryInfo.references}\n`;
    }
    message += "\n";
  }
  
  message += `🛒 *Productos:*\n`;
  if (order.items && Array.isArray(order.items)) {
    order.items.forEach((item: any) => {
      message += generateProductSummary(item);
    });
  } else {
    message += `_No hay productos en el pedido_\n`;
  }
  
  message += `\n💰 *Total: $${order.total || '0.00'}*\n`;
  
  if (order.scheduledAt) {
    const date = new Date(order.scheduledAt);
    const formattedDate = date.toLocaleDateString(env.DEFAULT_LOCALE, {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });
    const formattedTime = date.toLocaleTimeString(env.DEFAULT_LOCALE, {
      hour: "2-digit",
      minute: "2-digit",
    });
    message += `\n⏰ *Programado para:* ${formattedDate} a las ${formattedTime}\n`;
  }
  
  return message;
}

================
File: backend/src/whatsapp/handlers/orders/preOrderHandler.ts
================
import { prisma } from "../../../server";
import logger from "../../../common/utils/logger";
import { sendWhatsAppMessage, WhatsAppService } from "../../../services/whatsapp";
import { PreOrderService } from "../../../services/orders/PreOrderService";
import { generateOrderSummary } from "./orderFormatters";
import { ErrorService, BusinessLogicError, ValidationError, ErrorCode } from "../../../common/services/errors";
import { OrderManagementService } from "../../../services/orders/services/OrderManagementService";

// Crear una preorden con los productos seleccionados
export async function createPreOrderAndSendSummary(
  result: any,
  phone: string
): Promise<void> {
  try {
    // Validar que el resultado tenga la estructura esperada
    if (!result.productos || result.productos.length === 0) {
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        'No products in order',
        { userId: phone, operation: 'createPreOrderAndSendSummary' }
      );
    }

    const preOrderService = new PreOrderService();

    // Construir los datos para la preorden
    const orderData = {
      orderItems: result.productos.map((producto: any) => ({
        productId: producto.productId,
        productVariantId: producto.productVariantId,
        quantity: producto.cantidad,
        comments: producto.comments,
        selectedModifiers: producto.modificadores.map((mod: any) => mod.id),
        selectedPizzaIngredients: producto.ingredientes_pizza?.map((ing: any) => ({
          pizzaIngredientId: ing.id,
          half: ing.mitad,
          action: ing.action || "add",
        })) || [],
      })),
      whatsappPhoneNumber: phone,
      orderType: result.orderType,
      scheduledAt: result.scheduledAt,
    };

    // Crear la preorden usando el servicio
    const preOrderResult = await preOrderService.createPreOrder(
      orderData
    );
    const { preOrderId, items: selectedProducts } = preOrderResult;

    // Obtener información de entrega si es necesario
    let deliveryInfoId = null;
    if (result.orderType === "delivery" && result.deliveryInfo) {
      const existingDeliveryInfo = await prisma.orderDeliveryInfo.findFirst({
        where: {
          street: result.deliveryInfo.street,
          number: result.deliveryInfo.number,
          neighborhood: result.deliveryInfo.neighborhood,
          city: result.deliveryInfo.city,
        },
      });

      if (existingDeliveryInfo) {
        deliveryInfoId = existingDeliveryInfo.id;
      } else {
        const newDeliveryInfo = await prisma.orderDeliveryInfo.create({
          data: {
            street: result.deliveryInfo.street,
            number: result.deliveryInfo.number,
            interiorNumber: result.deliveryInfo.interiorNumber,
            neighborhood: result.deliveryInfo.neighborhood,
            zipCode: result.deliveryInfo.zipCode,
            city: result.deliveryInfo.city,
            state: result.deliveryInfo.state,
            country: result.deliveryInfo.country || "México",
            latitude: result.deliveryInfo.latitude,
            longitude: result.deliveryInfo.longitude,
            references: result.deliveryInfo.references,
            preOrderId: preOrderId,
          },
        });
        deliveryInfoId = newDeliveryInfo.id;
      }
    } else if (result.orderType === "pickup" && result.pickupName) {
      const pickupInfo = await prisma.orderDeliveryInfo.create({
        data: {
          pickupName: result.pickupName,
          preOrderId: preOrderId,
        },
      });
      deliveryInfoId = pickupInfo.id;
    }

    // Actualizar la preorden con la información de entrega si existe
    if (deliveryInfoId) {
      const preOrder = await prisma.preOrder.update({
        where: { id: preOrderId },
        data: {
          deliveryInfo: {
            connect: { id: deliveryInfoId }
          }
        },
      });
    }

    // Generar y enviar el resumen
    const orderSummary = generateOrderSummary(result);
    await sendWhatsAppMessage(phone, orderSummary);

    // Enviar botones de confirmación
    await sendPreOrderConfirmationButtons(
      phone,
      `preorder_${preOrderId}`
    );
  } catch (error) {
    await ErrorService.handleAndSendError(error, phone, {
      userId: phone,
      operation: 'createPreOrderAndSendSummary',
      metadata: { orderType: result.orderType }
    });
  }
}

// Enviar botones de confirmación para la preorden
async function sendPreOrderConfirmationButtons(
  phone: string,
  messageId: string
): Promise<void> {
  const confirmationMessage = {
    type: "button",
    header: {
      type: "text",
      text: "¿Confirmar pedido?",
    },
    body: {
      text: "Por favor revisa tu pedido y confirma si todo está correcto.",
    },
    action: {
      buttons: [
        {
          type: "reply",
          reply: {
            id: "confirm_preorder",
            title: "✅ Confirmar",
          },
        },
        {
          type: "reply",
          reply: {
            id: "discard_preorder",
            title: "❌ Descartar",
          },
        },
      ],
    },
  };

  await WhatsAppService.sendInteractiveMessage(phone, confirmationMessage, messageId);
}

// Descartar una preorden
export async function handlePreOrderDiscard(
  from: string,
  messageId: string
): Promise<void> {
  try {
    logger.info(
      `Attempting to discard pre-order for customer ${from} with messageId ${messageId}`
    );
    
    const orderManagementService = new OrderManagementService();
    const preOrder = await orderManagementService.getPreOrderByMessageId(messageId);

    if (!preOrder) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'PreOrder not found for discard',
        { userId: from, operation: 'handlePreOrderDiscard', metadata: { messageId } }
      );
    }

    await orderManagementService.discardPreOrder(preOrder.id);
    logger.info(`Pre-order ${preOrder.id} discarded successfully`);

    await sendWhatsAppMessage(
      from,
      "❌ Tu pedido ha sido descartado. Si deseas realizar un nuevo pedido, puedes hacerlo cuando gustes. 🍕"
    );
  } catch (error) {
    await ErrorService.handleAndSendError(error, from, {
      userId: from,
      operation: 'handlePreOrderDiscard',
      metadata: { messageId }
    });
  }
}

================
File: frontend-app/src/services/customer.service.ts
================
import api from './api';
import { endpoints } from '@/config';
import type { 
  Customer, 
  Address, 
  AddressFormData, 
  OTPVerificationResponse, 
  AddressRegistrationResponse 
} from '@/types';

class CustomerService {
  /**
   * Verify OTP for address registration
   */
  async verifyOTP(customerId: string, otp: string): Promise<OTPVerificationResponse> {
    const response = await api.post<OTPVerificationResponse>(endpoints.addressRegistration.verifyOtp, {
      customerId,
      otp
    });
    return response.data;
  }

  /**
   * Create new address for customer
   */
  async createAddress(
    customerId: string, 
    otp: string, 
    address: AddressFormData
  ): Promise<AddressRegistrationResponse> {
    const response = await api.post<AddressRegistrationResponse>(endpoints.addressRegistration.create, {
      customerId,
      otp,
      address
    });
    return response.data;
  }

  /**
   * Update existing address
   */
  async updateAddress(
    addressId: number,
    customerId: string,
    otp: string,
    address: AddressFormData
  ): Promise<AddressRegistrationResponse> {
    const response = await api.put<AddressRegistrationResponse>(endpoints.addressRegistration.update(addressId.toString()), {
      customerId,
      otp,
      address
    });
    return response.data;
  }

  /**
   * Get customer addresses
   */
  async getCustomerAddresses(customerId: string, otp: string): Promise<{ addresses: Address[] }> {
    const response = await api.get<{ addresses: Address[] }>(
      endpoints.addressRegistration.getAddresses(customerId),
      { params: { otp } }
    );
    return response.data;
  }

  /**
   * Delete customer address
   */
  async deleteAddress(
    addressId: number,
    customerId: string,
    otp: string
  ): Promise<void> {
    const response = await api.delete(
      endpoints.addressRegistration.delete(addressId.toString()),
      {
        data: { customerId, otp }
      }
    );
    
    if (!response.data.success) {
      throw new Error('Failed to delete address');
    }
  }

  /**
   * Set address as default
   */
  async setDefaultAddress(
    addressId: number,
    customerId: string,
    otp: string
  ): Promise<Address> {
    const response = await api.put(
      endpoints.addressRegistration.setDefault(addressId.toString()),
      { customerId, otp }
    );
    return response.data.address;
  }

  /**
   * Get delivery area polygon
   */
  async getDeliveryArea(): Promise<{ polygonCoords: any[], center?: { lat: number, lng: number } }> {
    try {
      const response = await api.get(endpoints.addressRegistration.getDeliveryArea);
      return response.data;
    } catch (error) {
      console.error('Error fetching delivery area:', error);
      return { polygonCoords: [] };
    }
  }


  /**
   * Legacy methods for backward compatibility
   */
  async getCustomerByPhoneNumber(phoneNumber: string): Promise<Customer | null> {
    // This is now handled by OTP verification
    return null;
  }

  async getCustomerDeliveryInfo(customerId: string): Promise<any> {
    // Legacy method - no longer used
    return null;
  }

  async createCustomerDeliveryInfo(data: any): Promise<any> {
    // Convert legacy format to new format
    const addressData: AddressFormData = {
      street: data.streetAddress?.split(' ')[0] || '',
      number: data.streetAddress?.split(' ')[1] || '',
      neighborhood: data.neighborhood,
      city: data.city,
      state: data.state,
      zipCode: data.postalCode,
      country: data.country,
      references: data.additionalDetails,
      latitude: data.latitude,
      longitude: data.longitude
    };

    // Extract customerId from the data (assuming it's passed)
    const customerId = data.customerId || data.customer?.customerId;
    const otp = data.otp;

    if (!customerId || !otp) {
      throw new Error('Customer ID and OTP are required');
    }

    const response = await this.createAddress(customerId, otp, addressData);
    
    // Convert back to legacy format
    return {
      ...response.address,
      streetAddress: `${response.address.street} ${response.address.number}`,
      postalCode: response.address.zipCode,
      additionalDetails: response.address.references,
      pickupName: data.pickupName
    };
  }

  async updateCustomerDeliveryInfo(customerId: string, data: any): Promise<any> {
    // Convert legacy format to new format
    const addressData: AddressFormData = {
      street: data.streetAddress?.split(' ')[0] || '',
      number: data.streetAddress?.split(' ')[1] || '',
      neighborhood: data.neighborhood,
      city: data.city,
      state: data.state,
      zipCode: data.postalCode,
      country: data.country,
      references: data.additionalDetails,
      latitude: data.latitude,
      longitude: data.longitude
    };

    const otp = data.otp;
    const addressId = data.id || data.addressId;

    if (!otp || !addressId) {
      throw new Error('OTP and Address ID are required');
    }

    const response = await this.updateAddress(addressId, customerId, otp, addressData);
    
    // Convert back to legacy format
    return {
      ...response.address,
      streetAddress: `${response.address.street} ${response.address.number}`,
      postalCode: response.address.zipCode,
      additionalDetails: response.address.references
    };
  }
}

export default new CustomerService();

================
File: backend/prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum OrderType {
  DINE_IN
  TAKE_AWAY
  DELIVERY
}

enum OrderStatus {
  PENDING
  IN_PROGRESS
  IN_PREPARATION
  READY
  IN_DELIVERY
  DELIVERED
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
}

enum PizzaHalf {
  LEFT
  RIGHT
  FULL
}

enum IngredientAction {
  ADD
  REMOVE
}

enum PreparationStatus {
  PENDING
  IN_PROGRESS
  READY
  DELIVERED
  CANCELLED
}

// Models
model Category {
  id           String        @id
  name         String        @unique
  description  String?
  isActive     Boolean       @default(true)
  photoId      String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  deletedAt    DateTime?
  subcategories Subcategory[]
}

model Customer {
  id                  String               @id @default(uuid()) @db.Uuid // UUID primary key
  whatsappPhoneNumber String               @unique // WhatsApp phone number
  firstName           String?              @db.VarChar(100)
  lastName            String?              @db.VarChar(100)
  email               String?              @db.VarChar(255)
  birthDate           DateTime?            @db.Date
  fullChatHistory     Json?
  relevantChatHistory Json?
  stripeCustomerId    String?              @unique
  lastInteraction     DateTime?
  totalOrders         Int                  @default(0)
  totalSpent          Decimal              @default(0) @db.Decimal(10, 2)
  isActive            Boolean              @default(true)
  isBanned            Boolean              @default(false)
  bannedAt            DateTime?
  banReason           String?              @db.Text
  deletedAt           DateTime?            // Soft delete
  lastSyncAt          DateTime?            // Last sync timestamp
  syncVersion         Int                  @default(0) // For optimistic locking
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  addresses           Address[]            // One-to-Many relationship
  orders              Order[]              // One-to-Many relationship
  
  @@index([whatsappPhoneNumber])
  @@index([email])
  @@index([lastSyncAt])
}

// Customer addresses (1:N relationship)
// A customer can have multiple delivery addresses
model Address {
  id                String   @id @default(uuid()) @db.Uuid // UUID primary key
  customerId        String   @db.Uuid // Foreign key to Customer
  street            String   @db.VarChar(200)
  number            String   @db.VarChar(50)
  interiorNumber    String?  @db.VarChar(50)
  neighborhood      String?  @db.VarChar(150)
  city              String?  @db.VarChar(100)
  state             String?  @db.VarChar(100)
  zipCode           String?  @db.VarChar(10)
  country           String?  @db.VarChar(100)
  references        String?  @db.Text
  latitude          Decimal? @db.Decimal(10, 8)
  longitude         Decimal? @db.Decimal(11, 8)
  isDefault         Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  deletedAt         DateTime? // Soft delete
  customer          Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@index([customerId])
  @@index([zipCode])
}

model MessageLog {
  id        Int     @id @default(autoincrement())
  messageId String  @unique
  processed Boolean @default(false)
}

model MessageRateLimit {
  id              Int      @id @default(autoincrement())
  whatsappPhoneNumber String   @unique
  messageCount    Int      @default(0)
  lastMessageTime DateTime
}

model ProductModifier {
  id               String             @id
  groupId          String
  name             String
  description      String?
  price            Float?
  sortOrder        Int                @default(0)
  isDefault        Boolean            @default(false)
  isActive         Boolean            @default(true)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  deletedAt        DateTime?
  modifierGroup    ModifierGroup      @relation(fields: [groupId], references: [id])
  orderItems       OrderItem[]        @relation("OrderItemProductModifiers")
}

model ModifierGroup {
  id                      String            @id
  name                    String
  description             String?
  minSelections           Int               @default(0)
  maxSelections           Int               @default(1)
  isRequired              Boolean           @default(false)
  allowMultipleSelections Boolean           @default(false)
  isActive                Boolean           @default(true)
  productId               String
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt
  deletedAt               DateTime?
  product                 Product           @relation(fields: [productId], references: [id])
  productModifiers        ProductModifier[]
}

model Order {
  id                   String            @id @default(uuid())
  dailyNumber          Int
  orderType            OrderType
  orderStatus          OrderStatus       @default(PENDING)
  paymentStatus        PaymentStatus?
  totalCost            Float
  customerId           String            @db.Uuid
  estimatedTime        Int               @default(0)
  scheduledAt          DateTime?
  messageId            String?
  stripeSessionId      String?
  syncedWithLocal      Boolean           @default(false)
  isFromWhatsApp       Boolean           @default(true)
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  orderItems           OrderItem[]
  deliveryInfo         OrderDeliveryInfo?
  customer             Customer          @relation(fields: [customerId], references: [id])
}

// Order's delivery address (snapshot at order time)
// This is a copy of the customer's address at the time of order creation
// Preserves historical data even if customer changes their address later
model OrderDeliveryInfo {
  id                Int       @id @default(autoincrement())
  street            String?   @db.VarChar(200)
  number            String?   @db.VarChar(50)
  interiorNumber    String?   @db.VarChar(50)
  neighborhood      String?   @db.VarChar(150)
  city              String?   @db.VarChar(100)
  state             String?   @db.VarChar(100)
  zipCode           String?   @db.VarChar(10)  // Changed from postalCode
  country           String?   @db.VarChar(100)
  references        String?   @db.Text // Changed from additionalDetails
  latitude          Decimal?  @db.Decimal(10, 8) // Changed to Decimal for precision
  longitude         Decimal?  @db.Decimal(11, 8) // Changed to Decimal for precision
  pickupName        String?   // For pickup orders
  preOrderId        Int?
  orderId           String?   @unique
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  order             Order?    @relation(fields: [orderId], references: [id])
  preOrder          PreOrder? @relation(fields: [preOrderId], references: [id])
}

model OrderItem {
  id                    String                     @id @default(uuid())
  orderId               String
  productId             String
  productVariantId      String?
  basePrice             Float
  finalPrice            Float
  preparationStatus     PreparationStatus          @default(PENDING)
  statusChangedAt       DateTime                   @default(now())
  preparationNotes      String?
  createdAt             DateTime                   @default(now())
  updatedAt             DateTime                   @updatedAt
  deletedAt             DateTime?
  order                 Order                      @relation(fields: [orderId], references: [id])
  product               Product                    @relation(fields: [productId], references: [id])
  productVariant        ProductVariant?            @relation(fields: [productVariantId], references: [id])
  productModifiers      ProductModifier[]          @relation("OrderItemProductModifiers")
  selectedPizzaIngredients SelectedPizzaIngredient[]
}

model PizzaIngredient {
  id                    String                    @id
  name                  String
  ingredientValue       Int                       @default(1)
  ingredients           String?
  isActive              Boolean                   @default(true)
  sortOrder             Int                       @default(0)
  productIds            String[]                  // Array de IDs de productos relacionados
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
  deletedAt             DateTime?
  products              Product[]                 @relation("ProductPizzaIngredients")
  selectedPizzaIngredients SelectedPizzaIngredient[]
}

model PreOrder {
  id                    Int                @id @default(autoincrement())
  orderItems            Json
  orderType             OrderType
  scheduledAt          DateTime?
  whatsappPhoneNumber   String             // Store WhatsApp phone number instead of customerId
  messageId             String?
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  deliveryInfo          OrderDeliveryInfo[]
  
  @@index([whatsappPhoneNumber])
}

model Product {
  id                   String              @id
  name                 String
  description          String?
  price                Float?
  hasVariants          Boolean             @default(false)
  isActive             Boolean             @default(true)
  isPizza              Boolean             @default(false)
  subcategoryId        String
  preparationScreenId  String?
  photoId              String?
  estimatedPrepTime    Int                 @default(0)
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  deletedAt            DateTime?
  subcategory          Subcategory         @relation(fields: [subcategoryId], references: [id])
  variants             ProductVariant[]
  modifierGroups       ModifierGroup[]
  pizzaIngredients     PizzaIngredient[]   @relation("ProductPizzaIngredients")
  orderItems           OrderItem[]
}

model ProductVariant {
  id          String      @id
  productId   String
  name        String
  price       Float
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  deletedAt   DateTime?
  product     Product     @relation(fields: [productId], references: [id])
  orderItems  OrderItem[]
}

model RestaurantConfig {
  id                    Int                @id @default(autoincrement())
  // Información básica del restaurante
  restaurantName        String             @default("La Leña") // Nombre del restaurante
  phoneMain             String?            // Teléfono principal
  phoneSecondary        String?            // Teléfono secundario/móvil
  address               String?            // Dirección completa
  city                  String?            // Ciudad
  state                 String?            // Estado
  postalCode            String?            // Código postal
  country               String?            // País
  
  // Configuración de operación
  acceptingOrders       Boolean            @default(true)
  estimatedPickupTime   Int                @default(20) // Tiempo estimado de recolección en minutos
  estimatedDeliveryTime Int                @default(40) // Tiempo estimado de entrega a domicilio en minutos
  openingGracePeriod    Int                @default(30) // Minutos después de abrir antes de aceptar pedidos
  closingGracePeriod    Int                @default(30) // Minutos antes de cerrar para dejar de aceptar pedidos
  timeZone              String             @default("America/Mexico_City") // Zona horaria del restaurante
  businessHours         BusinessHours[]
  
  // Configuración de delivery
  deliveryCoverageArea  Json?              // Polígono de cobertura - Array de objetos {lat: number, lng: number}
}

model BusinessHours {
  id                 Int              @id @default(autoincrement())
  dayOfWeek          Int              // 0 = Domingo, 1 = Lunes, ... 6 = Sábado
  openingTime        String?          // Hora de apertura en formato HH:mm (null = cerrado)
  closingTime        String?          // Hora de cierre en formato HH:mm (null = cerrado)
  isClosed           Boolean          @default(false) // true si el restaurante está cerrado ese día
  restaurantConfigId Int
  restaurantConfig   RestaurantConfig @relation(fields: [restaurantConfigId], references: [id])
  
  @@unique([restaurantConfigId, dayOfWeek]) // Un solo horario por día
}

model SeederControl {
  id      String   @id
  lastRun DateTime
}

model SelectedPizzaIngredient {
  id               Int              @id @default(autoincrement())
  half             PizzaHalf        @default(FULL)
  pizzaIngredientId String
  orderItemId      String
  action           IngredientAction @default(ADD)
  orderItem        OrderItem        @relation(fields: [orderItemId], references: [id])
  pizzaIngredient  PizzaIngredient  @relation(fields: [pizzaIngredientId], references: [id])
}

model Subcategory {
  id          String    @id
  categoryId  String
  name        String    @unique
  description String?
  isActive    Boolean   @default(true)
  photoId     String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  category    Category  @relation(fields: [categoryId], references: [id])
  products    Product[]
}

// Sync tracking between local and cloud backends
model SyncLog {
  id            Int       @id @default(autoincrement())
  entityType    String    // 'customer', 'order', etc.
  entityId      String    // Entity UUID
  action        String    // 'create', 'update', 'delete'
  syncDirection String    // 'local_to_cloud' or 'cloud_to_local'
  syncStatus    String    // 'pending', 'success', 'failed'
  errorMessage  String?   @db.Text
  createdAt     DateTime  @default(now())
  completedAt   DateTime?
  
  @@index([entityType, entityId])
  @@index([syncStatus])
}

================
File: backend/src/services/ai/AgentService.ts
================
import { GeminiService } from './GeminiService';
import logger from '../../common/utils/logger';
import { ProductService } from '../products/ProductService';

// Definiciones de tipos para el nuevo SDK
interface Content {
  role: 'user' | 'model';
  parts: Array<{ text: string } | { inlineData: { mimeType: string; data: string } }>;
}

// Contexto para el agente de órdenes
interface OrderContext {
  itemsSummary: string;
  relevantMenu: string;
  orderType?: string;
}

/**
 * Servicio de AI con agentes especializados
 */
export class AgentService {
  /**
   * Procesa mensajes con el agente general
   */
  static async processMessage(
    messages: Content[]
  ): Promise<any> {
    try {
      // Usar el agente general para detectar intención
      const systemInstruction = await this.getGeneralAgentInstruction();
      const tools = this.getGeneralAgentTools();
      
      // Log completo de lo que recibe el modelo
      logger.debug('=== COMPLETE AI MODEL INPUT ===');
      logger.debug(`System Instruction:\n${systemInstruction}`);
      (logger as any).json('Messages:', messages);
      (logger as any).json('Tools:', tools.map(t => ({
        name: t.name,
        description: t.description,
        parameters: t.parameters
      })));
      logger.debug('=== END AI MODEL INPUT ===');
      
      const response = await GeminiService.generateContentWithHistory(
        messages,
        systemInstruction,
        tools
      );
      return response;
    } catch (error) {
      logger.error('AgentService: Error procesando mensaje', error);
      throw error;
    }
  }
  
  /**
   * Procesa una orden con el agente especializado
   */
  static async processOrderMapping(
    orderContext: OrderContext
  ): Promise<any> {
    try {
      const startTime = Date.now();
      logger.debug('=== AgentService.processOrderMapping (ORDER_AGENT) ===');
      logger.debug('Order Context:', {
        itemsSummary: orderContext.itemsSummary,
        menuLength: orderContext.relevantMenu.length
      });
      
      // Crear mensaje para el agente de órdenes
      const messages: Content[] = [{
        role: 'user',
        parts: [{ 
          text: `ORDEN: ${orderContext.itemsSummary}\nTIPO: ${orderContext.orderType || 'DELIVERY'}\nMENÚ: ${orderContext.relevantMenu}` 
        }]
      }];
      
      const systemInstruction = this.getOrderAgentInstruction();
      const tools = this.getOrderAgentTools();
      
      // Configurar modo ANY para forzar la ejecución de función
      const toolConfig = {
        functionCallingConfig: {
          mode: 'ANY',
          allowedFunctionNames: ['map_order_items']
        }
      };
      
      // Log completo de lo que recibe el modelo de órdenes
      logger.debug('=== COMPLETE ORDER AGENT INPUT ===');
      logger.debug(`System Instruction:\n${systemInstruction}`);
      (logger as any).json('Messages:', messages);
      (logger as any).json('Tools:', tools.map(t => ({
        name: t.name,
        description: t.description,
        parameters: t.parameters
      })));
      (logger as any).json('Tool Config:', toolConfig);
      logger.debug('=== END ORDER AGENT INPUT ===');
      
      logger.info('Calling Gemini API for order processing...');
      const geminiStartTime = Date.now();
      
      const response = await GeminiService.generateContentWithHistory(
        messages,
        systemInstruction,
        tools,
        toolConfig
      );
      
      const geminiTime = Date.now() - geminiStartTime;
      const totalTime = Date.now() - startTime;
      
      logger.info(`Order agent timing breakdown:`, {
        geminiApiTime: `${geminiTime}ms`,
        totalProcessingTime: `${totalTime}ms`,
        overheadTime: `${totalTime - geminiTime}ms`
      });
      logger.debug('=== End ORDER_AGENT Processing ===');
      return response;
    } catch (error) {
      logger.error('OrderAgent: Error procesando orden', error);
      throw error;
    }
  }
  
  /**
   * Instrucciones para el agente general
   */
  private static async getGeneralAgentInstruction(): Promise<string> {
    let menuJson = '{}';
    let restaurantName = 'nuestro restaurante';
    
    try {
      // Obtener estructura del menú
      const menuStructure = await ProductService.getMenuStructureForAI();
      menuJson = JSON.stringify(menuStructure, null, 2);
    } catch (error) {
      logger.error('Error obteniendo estructura del menú para AI:', error);
    }
    
    try {
      // Obtener configuración del restaurante
      const { RestaurantService } = await import('../restaurant/RestaurantService');
      const restaurantConfig = await RestaurantService.getConfig();
      restaurantName = restaurantConfig.restaurantName;
    } catch (error) {
      logger.error('Error obteniendo configuración del restaurante:', error);
    }
    
    return `
      Eres un asistente virtual de ${restaurantName}. Tu función es ayudar a los clientes con sus consultas y pedidos.
      
      REGLAS ESTRICTAS:
      - SOLO puedes proporcionar información que está en tu contexto o usar las herramientas disponibles
      - NO inventes información sobre productos, precios, ingredientes o disponibilidad
      - NO asumas o adivines características de productos que no están en tu contexto
      - Si no tienes información específica, indica al cliente que no dispones de esa información
      - NUNCA proporciones precios individuales, solo a través de la herramienta "send_menu"
      
      1. DETECTAR INTENCIÓN:
         - Si el cliente quiere ordenar algo, usa la herramienta "prepare_order_context"
         - Si es una consulta general, responde directamente
      
      2. CONSULTAS GENERALES:
         - Menú completo con precios: usa "send_menu" 
         - Información del restaurante: usa "get_business_hours"
         - Tiempos de espera: usa "get_wait_times"
         - Actualizar dirección: usa "generate_address_update_link"
         - Instrucciones del bot: usa "send_bot_instructions"
         - Para otras consultas: responde SOLO con información disponible en tu contexto
      
      3. DETECCIÓN DE ÓRDENES:
         Cuando detectes intención de ordenar (palabras clave: quiero, pedir, ordenar, dame, tráeme, etc.):
         
         PRIMERO: Verifica el tipo de orden
         - Si el cliente NO ha especificado si es para llevar o entrega a domicilio:
           * PREGUNTA: "¿Tu pedido es para entrega a domicilio o para recoger en el restaurante?"
           * NO ejecutes "prepare_order_context" hasta tener esta información
         
         - Detecta el tipo de orden SOLO cuando el cliente lo especifique:
           * DELIVERY: "a domicilio", "envío", "traer", "mi casa", "mi dirección", "que me lo traigan"
           * TAKE_AWAY: "para llevar", "recoger", "paso por", "voy por", "lo recojo"
         
         DESPUÉS de confirmar el tipo de orden:
         - Extrae TODOS los artículos mencionados
         - Incluye cantidades si las menciona
         - USA "prepare_order_context" con el tipo de orden confirmado
         
         NUNCA asumas el tipo de orden - SIEMPRE debe ser especificado por el cliente
      
      4. ACTUALIZACIÓN DE DIRECCIÓN:
         Si el cliente quiere actualizar su dirección o agregar una nueva dirección de entrega:
         - Usa "generate_address_update_link" para generar un enlace seguro
         - NO agregues mensajes adicionales, la herramienta ya envía el mensaje interactivo
      
      5. INSTRUCCIONES DEL BOT:
         Si el cliente pregunta cómo usar el bot, cómo funciona, qué puede hacer, o necesita ayuda:
         - Usa "send_bot_instructions" para enviar las instrucciones completas
         - Detecta preguntas como: "cómo usar", "cómo funciona", "qué puedo hacer", "ayuda", "tutorial", "instrucciones"
      
      6. RESETEAR CONVERSACIÓN:
         Si el cliente quiere reiniciar la conversación o borrar el historial:
         - Usa "reset_conversation" para limpiar el contexto
         - Detecta frases como: "olvida lo anterior", "reinicia la conversación", "borra el historial", "empecemos de nuevo", "olvida todo", "reinicia el chat"
      
      LIMITACIONES Y RESTRICCIONES:
      - Solo puedes responder sobre productos que existen en el menú
      - No puedes inventar o sugerir productos que no están disponibles
      - No puedes modificar ingredientes base de los productos
      - No puedes prometer tiempos de entrega específicos fuera de los establecidos
      - No puedes ofrecer descuentos o promociones no autorizadas
      - Si el cliente pide algo que no está en el menú, debes indicarlo claramente
      
      MANEJO DE ERRORES:
      - Si no entiendes la solicitud: pide aclaración de manera amable
      - Si el producto no existe: sugiere alternativas del menú disponible
      - Si hay ambigüedad: pregunta para confirmar antes de proceder
      
      IMPORTANTE:
      - Responde siempre en español
      - Sé cordial y profesional pero mantente dentro de tus capacidades
      - Para órdenes, NO intentes mapear productos, solo extrae lo que el cliente dice
      - NUNCA proporciones precios individuales bajo ninguna circunstancia
      - Si preguntan por precios, SIEMPRE ejecuta "send_menu"
      
      ESTRUCTURA DEL MENÚ DISPONIBLE:
      ${menuJson}
      
      Esta estructura muestra TODO lo que puedes ofrecer. Si algo no está aquí, NO lo ofrezcas.
      Úsala para validar las solicitudes del cliente y sugerir alternativas válidas.
    `;
  }
  
  /**
   * Instrucciones para el agente de órdenes
   */
  private static getOrderAgentInstruction(): string {
    return `MAPEA LA ORDEN AL MENÚ JSON.
    
ESTRUCTURA DEL MENÚ:
- id: ID del producto
- nombre: nombre del producto
- variantes: array con {id, nombre, precio}
- modificadores: grupos con opciones {id, nombre, precio}
- ingredientesPizza: para pizzas {id, nombre}

EJECUTA map_order_items con:
- productId: usa el id del producto
- variantId: usa el id de la variante correcta (si aplica)
- quantity: cantidad solicitada
- modifiers: array de IDs de modificadores (si aplica)
- pizzaIngredients: array de IDs de ingredientes (si es pizza)
- orderType: USA EL TIPO DE ORDEN QUE VIENE EN EL MENSAJE (DESPUÉS DE "TIPO:")

IMPORTANTE: NO CAMBIES EL TIPO DE ORDEN. USA EXACTAMENTE EL QUE ESTÁ EN EL MENSAJE.

NO CONVERSES. SOLO MAPEA Y EJECUTA.`;
  }
  
  /**
   * Herramientas para el agente general
   */
  private static getGeneralAgentTools(): any[] {
    return [
      {
        name: "send_menu",
        description: "Envía el menú completo al usuario cuando lo solicite",
        parameters: {
          type: "object",
          properties: {}
        }
      },
      {
        name: "get_business_hours",
        description: "Obtiene información completa del restaurante incluyendo ubicación, teléfonos y horarios",
        parameters: {
          type: "object",
          properties: {}
        }
      },
      {
        name: "get_wait_times",
        description: "Obtiene los tiempos de espera estimados para recolección y entrega a domicilio",
        parameters: {
          type: "object",
          properties: {}
        }
      },
      {
        name: "prepare_order_context",
        description: "Prepara el contexto para procesar una orden cuando el cliente quiere pedir algo",
        parameters: {
          type: "object",
          properties: {
            itemsSummary: {
              type: "string",
              description: "Lista de todos los artículos que el cliente mencionó (ej: '2 pizzas hawaianas grandes, 1 coca cola, papas fritas')"
            },
            orderType: {
              type: "string", 
              enum: ["DELIVERY", "TAKE_AWAY"],
              description: "Tipo de orden: DELIVERY (entrega a domicilio), TAKE_AWAY (para llevar/recoger)"
            }
          },
          required: ["itemsSummary", "orderType"]
        }
      },
      {
        name: "generate_address_update_link",
        description: "Genera un enlace seguro para que el cliente actualice o agregue una dirección de entrega",
        parameters: {
          type: "object",
          properties: {
            reason: {
              type: "string",
              description: "Razón por la cual el cliente quiere actualizar la dirección"
            }
          }
        }
      },
      {
        name: "send_bot_instructions",
        description: "Envía las instrucciones completas de cómo usar el bot cuando el cliente lo solicite",
        parameters: {
          type: "object",
          properties: {}
        }
      },
      {
        name: "reset_conversation",
        description: "Reinicia la conversación y borra el historial relevante cuando el cliente lo solicite",
        parameters: {
          type: "object",
          properties: {}
        }
      }
    ];
  }
  
  /**
   * Herramientas para el agente de órdenes
   */
  private static getOrderAgentTools(): any[] {
    return [
      {
        name: "map_order_items",
        description: "Mapear items del pedido",
        parameters: {
          type: "object",
          properties: {
            orderItems: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  productId: { type: "string" },
                  variantId: { type: "string" },
                  quantity: { type: "number" },
                  modifiers: { type: "array", items: { type: "string" } },
                  pizzaIngredients: { type: "array", items: { type: "string" } }
                },
                required: ["productId", "quantity"]
              }
            },
            orderType: {
              type: "string",
              enum: ["DELIVERY", "TAKE_AWAY"]
            },
            warnings: { type: "string" }
          },
          required: ["orderItems", "orderType"]
        }
      }
    ];
  }
  
  /**
   * Obtiene el menú relevante basado en las palabras clave (con IDs)
   */
  static async getRelevantMenu(itemsSummary: string): Promise<string> {
    try {
      const stringSimilarity = await import('string-similarity');
      
      logger.debug(`Getting relevant menu for: "${itemsSummary}"`);
      
      // Obtener productos con todas sus relaciones
      const products = await ProductService.getActiveProducts({ includeRelations: true }) as any[];
      
      // Normalizar texto de búsqueda
      const normalizeText = (text: string): string => {
        return text
          .toLowerCase()
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '') // Eliminar acentos
          .replace(/[^\w\s]/g, ' ') // Reemplazar caracteres no-palabra con espacio
          .replace(/\s+/g, ' ') // Múltiples espacios a uno solo
          .trim();
      };
      
      const normalizedSummary = normalizeText(itemsSummary);
      
      logger.debug(`Normalized search: "${normalizedSummary}"`);
      
      // Calificar cada producto basado en similitud
      const scoredProducts = products.map(product => {
        const productName = normalizeText(product.name || '');
        const productDesc = normalizeText(product.description || '');
        const categoryName = normalizeText(product.subcategory?.category?.name || '');
        const subcategoryName = normalizeText(product.subcategory?.name || '');
        
        // Crear combinaciones de búsqueda
        const searchTargets = [
          productName, // Mayor prioridad
          `${productName} ${categoryName}`,
          `${productName} ${subcategoryName}`,
          `${productName} ${productDesc}`,
        ];
        
        // Calcular puntuaciones de similitud para cada objetivo
        const similarities = searchTargets.map(target => 
          stringSimilarity.compareTwoStrings(normalizedSummary, target)
        );
        
        // Obtener la mejor puntuación de coincidencia
        const bestScore = Math.max(...similarities);
        
        // Puntuación adicional para coincidencias parciales
        let bonusScore = 0;
        
        // Verificar si alguna palabra del resumen aparece en el nombre del producto
        const summaryWords = normalizedSummary.split(' ').filter(w => w.length > 2);
        const productWords = productName.split(' ');
        
        summaryWords.forEach(summaryWord => {
          productWords.forEach(productWord => {
            const wordSimilarity = stringSimilarity.compareTwoStrings(summaryWord, productWord);
            if (wordSimilarity > 0.8) { // Umbral de 80% de similitud para palabras individuales
              bonusScore += 0.2;
            }
          });
        });
        
        const finalScore = bestScore + bonusScore;
        
        return { 
          product, 
          score: finalScore,
          debug: {
            productName,
            bestScore,
            bonusScore,
            finalScore
          }
        };
      });
      
      // Filtrar y ordenar por puntuación
      const relevantProducts = scoredProducts
        .filter(item => item.score > 0.3) // Umbral de 30% de similitud
        .sort((a, b) => b.score - a.score);
      
      // Registrar las mejores coincidencias para depuración
      logger.debug(`Top matches:`);
      relevantProducts.slice(0, 5).forEach((item, index) => {
        logger.debug(`${index + 1}. ${item.debug.productName} (score: ${item.score.toFixed(3)})`);
      });
      
      // Si no hay buenas coincidencias, usar un umbral más indulgente
      if (relevantProducts.length === 0) {
        logger.debug('No products found with 30% threshold, trying 20%...');
        const lenientMatches = scoredProducts
          .filter(item => item.score > 0.2)
          .sort((a, b) => b.score - a.score)
          .slice(0, 10);
          
        if (lenientMatches.length > 0) {
          relevantProducts.push(...lenientMatches);
        }
      }
      
      // Construir estructura completa del menú con todas las relaciones
      const menuStructure = relevantProducts
        .slice(0, 15)
        .map(item => item.product)
        .map(product => {
          const item: any = {
            id: product.id,
            nombre: product.name,
          };
          
          // Incluir variantes con información completa
          if (product.variants?.length > 0) {
            item.variantes = product.variants.map((v: any) => ({
              id: v.id,
              nombre: v.name,
              precio: v.price
            }));
          }
          
          // Incluir modificadores si existen
          if (product.modifierGroups?.length > 0) {
            item.modificadores = product.modifierGroups
              .filter((g: any) => g.productModifiers?.length > 0)
              .map((group: any) => ({
                grupo: group.name,
                requerido: group.required,
                multiple: group.acceptsMultiple,
                opciones: group.productModifiers.map((m: any) => ({
                  id: m.id,
                  nombre: m.name,
                  precio: m.price
                }))
              }));
          }
          
          // Incluir ingredientes de pizza si es una pizza
          if (product.isPizza && product.pizzaIngredients?.length > 0) {
            item.ingredientesPizza = product.pizzaIngredients.map((i: any) => ({
              id: i.id,
              nombre: i.name
            }));
          }
          
          return item;
        });
      
      // Registrar la estructura del menú en un formato legible
      logger.debug(`Returning ${menuStructure.length} relevant products`);
      if (menuStructure.length > 0) {
        (logger as any).json('Relevant menu structure:', menuStructure);
      }
      
      return JSON.stringify(menuStructure);
    } catch (error) {
      logger.error('Error obteniendo menú relevante:', error);
      return "[]";
    }
  }
}

================
File: backend/src/services/messaging/strategies/TextMessageStrategy.ts
================
import { MessageStrategy } from './MessageStrategy';
import { MessageContext } from '../MessageContext';
import { AgentService } from '../../ai';
import { PreOrderService } from '../../../services/orders/PreOrderService';
import { sendWhatsAppMessage } from '../../whatsapp';
import logger from '../../../common/utils/logger';
import { MessageSplitter } from '../../../common/utils/messageSplitter';

// Type definition for content
interface Content {
  role: 'user' | 'model';
  parts: Array<{ text: string }>;
}

export class TextMessageStrategy extends MessageStrategy {
  name = 'TextMessageStrategy';
  
  canHandle(context: MessageContext): boolean {
    return context.message.type === 'text';
  }
  
  async execute(context: MessageContext): Promise<void> {
    if (!context.message.text?.body || !context.customer) return;
    
    const text = context.message.text.body;
    let relevantChatHistory = context.get('relevantChatHistory') || [];
    
    // Crear una copia para trabajar que incluya el mensaje actual
    const workingHistory = [...relevantChatHistory];
    workingHistory.push({ role: "user", content: text });
    
    try {
      logger.debug('=== TextMessageStrategy.execute DEBUG ===');
      logger.debug('User message:', text);
      logger.debug('Customer:', context.customer ? `ID: ${context.customer.id}, Phone: ${context.customer.whatsappPhoneNumber}` : 'No customer');
      logger.debug('Chat history length:', relevantChatHistory.length);
      
      // Procesar con AI - usar workingHistory que incluye el mensaje actual
      const messages: Content[] = workingHistory.map(
        ({ role, content }: any) => ({
          role: role === "assistant" ? "model" : role,
          parts: [{ text: content }]
        })
      );
      
      (logger as any).json('Messages to send to AI:', messages);
      
      const response = await AgentService.processMessage(messages);
      
      // Convertir respuesta al formato esperado
      const aiResponses = await this.processGeminiResponse(response, context);
      
      (logger as any).json('Processed AI responses:', aiResponses);
      logger.debug('=== End TextMessageStrategy.execute DEBUG ===');
      
      // Procesar respuestas de AI
      for (const response of aiResponses) {
        if (response.text) {
          context.addResponse({
            text: response.text,
            sendToWhatsApp: response.sendToWhatsApp !== false,
            isRelevant: response.isRelevant !== false,
            historyMarker: response.historyMarker // Pasar el marcador de historial si existe
          });
        }
        
        if (response.urlButton) {
          // Manejar mensaje con botón URL
          const { sendMessageWithUrlButton } = await import('../../whatsapp');
          await sendMessageWithUrlButton(
            context.message.from,
            response.urlButton.title,
            response.urlButton.body,
            response.urlButton.buttonText,
            response.urlButton.url
          );
          
          // Agregar al contexto para que se guarde en el historial
          context.addResponse({
            text: `${response.urlButton.title}\n\n${response.urlButton.body}`,
            sendToWhatsApp: false, // Ya se envió con sendMessageWithUrlButton
            isRelevant: response.isRelevant !== false
          });
        }
        
        if (response.preprocessedContent) {
          await this.handlePreprocessedContent(context, response.preprocessedContent);
        }
        
        if (response.confirmationMessage) {
          context.addResponse({
            text: response.confirmationMessage,
            sendToWhatsApp: true,
            isRelevant: true
          });
        }
      }
    } catch (error) {
      logger.error("Error processing text message:", error);
      context.addResponse({
        text: "Error al procesar la solicitud: " + (error as Error).message,
        sendToWhatsApp: true,
        isRelevant: true
      });
    }
  }
  
  private async handlePreprocessedContent(context: MessageContext, preprocessedContent: any): Promise<void> {
    // Handle warnings
    if (preprocessedContent.warnings && preprocessedContent.warnings.length > 0) {
      const warningMessage = "📝 Observaciones:\n" + preprocessedContent.warnings.join("\n");
      await sendWhatsAppMessage(context.message.from, warningMessage);
    }
    
    // Create pre-order
    const preOrderService = new PreOrderService();
    const preOrderResult = await preOrderService.createPreOrder({
      orderItems: preprocessedContent.orderItems,
      whatsappPhoneNumber: context.message.from,
      orderType: preprocessedContent.orderType,
      scheduledAt: preprocessedContent.scheduledAt,
    });
    
    // Generate order summary
    const { generateOrderSummary } = await import('../../../whatsapp/handlers/orders/orderFormatters');
    const orderSummary = generateOrderSummary(preOrderResult);
    
    // Send order summary
    await sendWhatsAppMessage(context.message.from, orderSummary);
    
    // Add interactive confirmation message
    context.addResponse({
      interactiveMessage: {
        type: "button",
        body: {
          text: "¿Deseas confirmar tu pedido?"
        },
        action: {
          buttons: [
            {
              type: "reply",
              reply: {
                id: `confirm_order_${preOrderResult.preOrderId}`,
                title: "✅ Confirmar"
              }
            },
            {
              type: "reply",
              reply: {
                id: `discard_order_${preOrderResult.preOrderId}`,
                title: "❌ Cancelar"
              }
            }
          ]
        }
      },
      sendToWhatsApp: true,
      isRelevant: false,
      preOrderId: preOrderResult.preOrderId
    });
  }
  
  private async processGeminiResponse(response: any, context?: MessageContext): Promise<any[]> {
    logger.debug('=== processGeminiResponse DEBUG ===');
    const responses: any[] = [];
    
    // Verificar estructura de respuesta válida
    if (!response?.candidates?.[0]?.content?.parts) {
      logger.error('Estructura de respuesta inválida de Gemini API');
      logger.debug('Response structure:', {
        hasCandidate: !!response?.candidates?.[0],
        hasContent: !!response?.candidates?.[0]?.content,
        hasParts: !!response?.candidates?.[0]?.content?.parts
      });
      return [{
        text: "Error: Respuesta inválida del modelo",
        isRelevant: true
      }];
    }
    
    const parts = response.candidates[0].content.parts;
    logger.debug(`Processing ${parts.length} parts from response`);
    
    // Procesar cada parte de la respuesta
    for (const part of parts) {
      const partInfo = {
        hasText: !!part.text,
        hasFunctionCall: !!part.functionCall,
        functionName: part.functionCall?.name
      };
      logger.debug(`Processing part: ${JSON.stringify(partInfo)}`);
      
      if (part.text) {
        // Respuesta de texto simple
        logger.debug('Text response:', part.text);
        responses.push({
          text: part.text,
          isRelevant: true,
        });
      } else if (part.functionCall) {
        // Procesar function calls
        const functionInfo = {
          name: part.functionCall.name,
          args: part.functionCall.args
        };
        (logger as any).json('Function call:', functionInfo);
        
        const functionResponse = await this.handleFunctionCall(
          part.functionCall.name,
          part.functionCall.args,
          context
        );
        if (functionResponse) {
          // Si la función retorna un array (múltiples mensajes), agregar todos
          if (Array.isArray(functionResponse)) {
            logger.debug(`Function returned ${functionResponse.length} responses`);
            responses.push(...functionResponse);
          } else {
            logger.debug('Function returned single response');
            responses.push(functionResponse);
          }
        }
      }
    }
    
    logger.debug(`Total responses processed: ${responses.length}`);
    logger.debug('=== End processGeminiResponse DEBUG ===');
    
    return responses;
  }
  
  private async handleFunctionCall(name: string, args: any, context?: MessageContext): Promise<any | null> {
    logger.debug('=== handleFunctionCall DEBUG ===');
    logger.debug(`Function name: ${name}`);
    (logger as any).json('Function args:', args);
    
    let result: any = null;
    
    switch (name) {
      case "map_order_items":
        // Procesar mapeo de items del pedido
        // Asegurar que cada item tenga el formato correcto
        const processedItems = (args.orderItems || []).map((item: any) => ({
          productId: item.productId,
          productVariantId: item.variantId || null, // Map variantId to productVariantId
          quantity: item.quantity || 1,
          selectedModifiers: item.modifiers || [], // Map modifiers to selectedModifiers
          selectedPizzaIngredients: item.pizzaIngredients || [] // Map pizzaIngredients to selectedPizzaIngredients
        }));
        
        result = {
          preprocessedContent: {
            orderItems: processedItems,
            orderType: args.orderType || 'DELIVERY', // Use the orderType from the order agent
            warnings: args.warnings ? [args.warnings] : [],
            scheduledAt: args.scheduledAt || null
          }
        };
        break;
        
      case "send_menu":
        // Enviar menú
        try {
          const { ProductService } = await import('../../products/ProductService');
          const menu = await ProductService.getActiveProducts({ formatForAI: true });
          const menuText = String(menu);
          
          // Si el menú es muy largo, dividirlo en partes
          const maxLength = 4000; // Dejamos margen para WhatsApp
          if (menuText.length > maxLength) {
            const parts = MessageSplitter.splitMenu(menuText, maxLength);
            logger.debug(`Menú dividido en ${parts.length} partes`);
            // Retornar múltiples respuestas
            result = parts.map((part, index) => ({
              text: part,
              isRelevant: false, // No guardar el menú completo en historial relevante
              sendToWhatsApp: true,
              // Para el último mensaje, agregar marcador de historial
              ...(index === parts.length - 1 && { 
                historyMarker: "MENÚ ENVIADO" 
              })
            }));
          } else {
            result = {
              text: menuText,
              isRelevant: false, // No guardar el menú completo en historial relevante
              sendToWhatsApp: true,
              historyMarker: "MENÚ ENVIADO" // Marcador para el historial
            };
          }
        } catch (error) {
          logger.error('Error obteniendo menú:', error);
          result = {
            text: "Lo siento, no pude obtener el menú en este momento.",
            isRelevant: true
          };
        }
        break;
        
      case "get_business_hours":
        // Obtener información del restaurante y horarios
        try {
          const { RESTAURANT_INFO_MESSAGE } = await import('../../../common/config/predefinedMessages');
          const infoMessage = await RESTAURANT_INFO_MESSAGE();
          
          result = {
            text: infoMessage,
            isRelevant: true
          };
        } catch (error) {
          logger.error('Error obteniendo información del restaurante:', error);
          result = {
            text: "Lo siento, no pude obtener la información del restaurante en este momento.",
            isRelevant: true
          };
        }
        break;
        
      case "prepare_order_context":
        // Preparar contexto para el agente de órdenes
        try {
          logger.debug('Preparando contexto de orden:', args);
          
          // Obtener menú relevante basado en los items mencionados
          const relevantMenu = await AgentService.getRelevantMenu(args.itemsSummary);
          
          // Crear contexto para el agente de órdenes
          const orderContext = {
            itemsSummary: args.itemsSummary,
            relevantMenu: relevantMenu,
            orderType: args.orderType // Pass the order type from general agent
          };
          
          // Procesar con el agente de órdenes
          const orderResponse = await AgentService.processOrderMapping(orderContext);
          
          // Procesar la respuesta del agente de órdenes
          const orderResults = await this.processGeminiResponse(orderResponse, context);
          
          // El agente de órdenes siempre debe ejecutar map_order_items
          // Así que devolvemos todos los resultados
          result = orderResults;
          
        } catch (error) {
          logger.error('Error preparando contexto de orden:', error);
          result = {
            text: "Lo siento, hubo un error al procesar tu pedido. Por favor intenta de nuevo.",
            isRelevant: true
          };
        }
        break;
        
      case "generate_address_update_link":
        // Generar enlace para actualizar dirección
        try {
          logger.debug('Generando enlace de actualización de dirección:', args);
          
          // Importar servicios necesarios
          const { OTPService } = await import('../../security/OTPService');
          const { env } = await import('../../../common/config/envValidator');
          
          // Obtener el customerId del contexto
          const customerId = context?.message?.from;
          if (!customerId) {
            throw new Error('No se pudo obtener el ID del cliente');
          }
          
          // Generar OTP
          const otp = OTPService.generateOTP();
          OTPService.storeOTP(customerId, otp, true); // true = address registration
          
          // Crear enlace de registro
          const registrationLink = `${env.FRONTEND_BASE_URL}/address-registration/${customerId}?otp=${otp}`;
          
          // Retornar configuración del mensaje con URL button para que se envíe y guarde
          result = {
            urlButton: {
              title: "📍 Actualizar Dirección",
              body: "Te he generado un enlace seguro para que puedas actualizar o agregar una nueva dirección de entrega.\n\n" +
                    "Este enlace es temporal y expirará en 10 minutos por seguridad.",
              buttonText: "Actualizar Dirección",
              url: registrationLink
            },
            isRelevant: true
          };
          
        } catch (error) {
          logger.error('Error generando enlace de dirección:', error);
          result = {
            text: "Lo siento, hubo un error al generar el enlace. Por favor intenta de nuevo.",
            isRelevant: true
          };
        }
        break;
        
      case "send_bot_instructions":
        // Enviar instrucciones de cómo usar el bot
        try {
          logger.debug('Enviando instrucciones del bot');
          
          // Importar la función de instrucciones del bot
          const { CHATBOT_HELP_MESSAGE } = await import('../../../common/config/predefinedMessages');
          
          // Obtener las instrucciones
          const instructions = await CHATBOT_HELP_MESSAGE();
          
          result = {
            text: instructions,
            isRelevant: true
          };
          
        } catch (error) {
          logger.error('Error enviando instrucciones del bot:', error);
          result = {
            text: "Lo siento, hubo un error al obtener las instrucciones. Por favor intenta de nuevo.",
            isRelevant: true
          };
        }
        break;
        
      case "get_wait_times":
        // Obtener tiempos de espera
        try {
          logger.debug('Obteniendo tiempos de espera');
          
          // Importar servicios necesarios
          const { WAIT_TIMES_MESSAGE } = await import('../../../common/config/predefinedMessages');
          const { RestaurantService } = await import('../../../services/restaurant/RestaurantService');
          
          // Obtener configuración del restaurante
          const config = await RestaurantService.getConfig();
          
          // Obtener los tiempos de espera
          const waitTimesMessage = WAIT_TIMES_MESSAGE(
            config.estimatedPickupTime,
            config.estimatedDeliveryTime
          );
          
          result = {
            text: waitTimesMessage,
            isRelevant: true
          };
          
        } catch (error) {
          logger.error('Error obteniendo tiempos de espera:', error);
          result = {
            text: "Lo siento, no pude obtener los tiempos de espera en este momento.",
            isRelevant: true
          };
        }
        break;
        
      case "reset_conversation":
        // Reiniciar conversación
        try {
          logger.debug('Reiniciando conversación');
          
          // Importar servicios necesarios
          const { prisma } = await import('../../../server');
          const { CONVERSATION_RESET_MESSAGE } = await import('../../../common/config/predefinedMessages');
          
          // Obtener el customerId del contexto
          const customerId = context?.customer?.id;
          if (!customerId) {
            throw new Error('No se pudo obtener el ID del cliente');
          }
          
          // Reiniciar historial de chat relevante y completo INMEDIATAMENTE
          await prisma.customer.update({
            where: { id: customerId },
            data: { 
              relevantChatHistory: JSON.stringify([]),
              fullChatHistory: JSON.stringify([]),
              lastInteraction: new Date()
            }
          });
          
          // Limpiar el historial del contexto actual COMPLETAMENTE
          context?.set('relevantChatHistory', []);
          context?.set('fullChatHistory', []);
          
          // Marcar para que este intercambio completo NO se guarde
          context?.set('skipHistoryUpdate', true);
          
          result = {
            text: CONVERSATION_RESET_MESSAGE,
            isRelevant: false
          };
          
        } catch (error) {
          logger.error('Error reiniciando conversación:', error);
          result = {
            text: "Lo siento, hubo un error al reiniciar la conversación. Por favor intenta de nuevo.",
            isRelevant: true
          };
        }
        break;
        
      default:
        logger.warn(`Function call no reconocido: ${name}`);
    }
    
    if (result) {
      (logger as any).json('Function call result:', result);
    }
    logger.debug('=== End handleFunctionCall DEBUG ===');
    return result;
  }
  
}

================
File: backend/src/server.ts
================
import express, { Request, Response } from 'express';
import cors from 'cors';
import { PrismaClient } from '@prisma/client';
import webhookRoutes from './routes/webhook';
import syncRoutes from './routes/sync';
import addressRegistrationRoutes from './routes/address-registration';
import addressSelectionRoutes from './routes/address-selection';
import logger from './common/utils/logger';
import { OTPService } from './services/security/OTPService';
import { PreOrderService } from './services/orders/PreOrderService';
import { WhatsAppService } from './services/whatsapp';
import { DeliveryInfoService } from './services/orders/services/DeliveryInfoService';
import { envValidator, env } from './common/config/envValidator';

// Validate environment variables
try {
  envValidator.validate();
} catch (error) {
  logger.error('Environment validation failed:', error);
  process.exit(1);
}

// Initialize Express app
const app: express.Application = express();
const prisma = new PrismaClient();

// Configure CORS
app.use(cors({
  origin: [
    'https://pizzatototlan.store',
    'http://localhost:3000',
    env.FRONTEND_BASE_URL
  ].filter(Boolean),
  credentials: true,
}));

// Middleware for parsing JSON (except for webhook route)
app.use((req, res, next) => {
  if (req.path === '/backend/webhook' && req.method === 'POST') {
    // Skip JSON parsing for webhook verification
    next();
  } else {
    express.json()(req, res, next);
  }
});

// Health check endpoint
app.get('/backend', (_, res) => {
  res.json({ 
    message: 'Bot Backend API is running',
    version: '2.0.0',
    timestamp: new Date().toISOString()
  });
});

// Routes
app.use('/backend/webhook', webhookRoutes);
app.use('/backend/sync', syncRoutes);
app.use('/backend/address-registration', addressRegistrationRoutes);
app.use('/backend/address-selection', addressSelectionRoutes);

// OTP endpoints
app.post('/backend/otp/verify', async (req, res) => {
  try {
    const { customerId, otp } = req.body;
    const isValid = await OTPService.verifyOTP(customerId, otp);
    res.json({ valid: isValid });
  } catch (error) {
    logger.error('Error verifying OTP:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/backend/otp/invalidate', async (req, res) => {
  try {
    const { customerId } = req.body;
    await OTPService.invalidateOTP(customerId);
    res.json({ success: true });
  } catch (error) {
    logger.error('Error invalidating OTP:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Customer addresses endpoints
app.post('/backend/customer/:customerId/addresses', async (req: Request, res: Response) => {
  try {
    const { customerId } = req.params;
    const addressData = {
      ...req.body,
      customer: { connect: { customerId } }
    };
    const address = await DeliveryInfoService.createCustomerAddress(addressData);
    res.json(address);
  } catch (error: any) {
    logger.error('Error creating address:', error);
    if (error.code) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
});

app.get('/backend/customer/:customerId/addresses', async (req: Request, res: Response) => {
  try {
    const { customerId } = req.params;
    const includeInactive = req.query.includeInactive === 'true';
    const addresses = await DeliveryInfoService.getCustomerAddresses(customerId, includeInactive);
    res.json(addresses);
  } catch (error: any) {
    logger.error('Error fetching addresses:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/backend/customer/:customerId/addresses/default', async (req: Request, res: Response) => {
  try {
    const { customerId } = req.params;
    const address = await DeliveryInfoService.getCustomerDefaultAddress(customerId);
    if (!address) {
      res.status(404).json({ error: 'No default address found' });
    } else {
      res.json(address);
    }
  } catch (error: any) {
    logger.error('Error fetching default address:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.put('/backend/addresses/:addressId', async (req: Request, res: Response) => {
  try {
    const { addressId } = req.params;
    const address = await DeliveryInfoService.updateCustomerAddress(
      addressId,
      req.body
    );
    res.json(address);
  } catch (error: any) {
    logger.error('Error updating address:', error);
    if (error.code === 'CUSTOMER_NOT_FOUND') {
      res.status(404).json({ error: error.message });
    } else if (error.code) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
});

app.put('/backend/addresses/:addressId/set-default', async (req: Request, res: Response) => {
  try {
    const { addressId } = req.params;
    const { customerId } = req.body;
    const address = await DeliveryInfoService.setDefaultAddress(addressId, customerId);
    res.json(address);
  } catch (error: any) {
    logger.error('Error setting default address:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.delete('/backend/addresses/:addressId', async (req: Request, res: Response) => {
  try {
    const { addressId } = req.params;
    const { customerId } = req.body;
    await DeliveryInfoService.deleteCustomerAddress(addressId, customerId);
    res.json({ success: true });
  } catch (error: any) {
    logger.error('Error deleting address:', error);
    if (error.code === 'ORDER_NOT_FOUND') {
      res.status(404).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  }
});

// Pre-orders endpoint
app.post('/backend/pre-orders/create', async (req: Request, res: Response) => {
  try {
    const preOrderService = new PreOrderService();
    const result = await preOrderService.createPreOrder(req.body);
    res.status(200).json(result);
  } catch (error) {
    logger.error('Error creating pre-order:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// WhatsApp send message endpoint
app.post('/backend/whatsapp/send-message', async (req, res) => {
  try {
    const { to, message } = req.body;
    const result = await WhatsAppService.sendMessage(to, message);
    res.json(result);
  } catch (error) {
    logger.error('Error sending WhatsApp message:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Error handling middleware
app.use((err: any, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
  logger.error('Unhandled error:', err);
  res.status(500).json({ error: 'Something went wrong!' });
});

// Start server
const PORT = parseInt(env.PORT, 10);

async function startServer() {
  try {
    // Test database connection
    await prisma.$connect();
    logger.info('Database connected successfully');
    
    // Start OTP cleanup interval
    OTPService.startOTPCleanup();
    
    app.listen(PORT, () => {
      logger.info(`Server is running on port ${PORT}`);
    });
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on('SIGINT', async () => {
  logger.info('Shutting down server...');
  OTPService.stopOTPCleanup();
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('Shutting down server...');
  OTPService.stopOTPCleanup();
  await prisma.$disconnect();
  process.exit(0);
});

startServer();

export { app, prisma };

================
File: backend/src/whatsapp/handlers/interactiveMessageHandler.ts
================
import {
  handlePreOrderConfirmation,
  handlePreOrderDiscard,
  handleOrderCancellation,
} from "./orderHandlers";

import { prisma } from "../../server";
import { sendWhatsAppMessage, sendMessageWithUrlButton } from "../../services/whatsapp";
import Stripe from "stripe";
import { OTPService } from "../../services/security/OTPService";
import {
  WAIT_TIMES_MESSAGE,
  RESTAURANT_INFO_MESSAGE,
  CHATBOT_HELP_MESSAGE,
} from "../../common/config/predefinedMessages";
import { ProductService } from "../../services/products/ProductService";
import logger from "../../common/utils/logger";
import { getCurrentMexicoTime } from "../../common/utils/timeUtils";
import { env } from "../../common/config/envValidator";
import { ErrorService, BusinessLogicError, ErrorCode } from "../../common/services/errors";

const stripeClient = env.STRIPE_SECRET_KEY 
  ? new Stripe(env.STRIPE_SECRET_KEY, {
      apiVersion: "2024-10-28.acacia",
    })
  : null;

// ProductService uses static methods, no need to instantiate

const BUTTON_ACTIONS = {
  confirm_order: handlePreOrderConfirmation,
  discard_order: handlePreOrderDiscard,
} as const;

const LIST_ACTIONS = {
  cancel_order: handleOrderCancellation,
  pay_online: handleOnlinePayment,
  wait_times: handleWaitTimes,
  view_menu: sendMenu,
  restaurant_info: handleRestaurantInfo,
  chatbot_help: handleChatbotHelp,
  change_delivery_info: handleChangeDeliveryInfo,
} as const;

export async function handleInteractiveMessage(
  from: string,
  message: any
): Promise<void> {
  try {
    logger.info('Interactive message received:', JSON.stringify(message));
    
    if (!message.interactive) {
      logger.error('No interactive property in message');
      return;
    }
    
    const { type, button_reply, list_reply } = message.interactive;
    const messageId = message.context?.id || null;

    if (type === "button_reply") {
      // Check for address confirmation
      if (button_reply.id.startsWith('confirm_address_')) {
        await handleAddressConfirmation(from, button_reply.id, messageId);
      } else if (button_reply.id === 'change_address') {
        await handleChangeDeliveryInfo(from);
      } else {
        const action =
          BUTTON_ACTIONS[button_reply.id as keyof typeof BUTTON_ACTIONS];
        if (action) await action(from, messageId);
      }
    } else if (type === "list_reply") {
      // Check for address selection
      if (list_reply.id.startsWith('select_address_')) {
        await handleAddressSelection(from, list_reply.id, messageId);
      } else if (list_reply.id === 'add_new_address') {
        await handleAddNewAddress(from, messageId);
      } else {
        const action = LIST_ACTIONS[list_reply.id as keyof typeof LIST_ACTIONS];
        if (action) {
          logger.info(`Executing action: ${list_reply.id}`);
          await action(from, messageId);
        } else {
          logger.error(`No action found for: ${list_reply.id}`);
        }
      }
    }
  } catch (error) {
    await ErrorService.handleAndSendError(error, from, {
      userId: from,
      operation: 'handleInteractiveMessage'
    });
  }
}


async function handleOnlinePayment(
  customerId: string,
  messageId: string
): Promise<void> {
  try {
    if (!stripeClient) {
      throw new BusinessLogicError(
        ErrorCode.STRIPE_ERROR,
        'Stripe client not configured',
        { userId: customerId, operation: 'handleOnlinePayment' }
      );
    }
    const order = await prisma.order.findFirst({ where: { messageId } });
    if (!order) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'Order not found for payment processing',
        { userId: customerId, operation: 'handleOnlinePayment' }
      );
    }

    if (order.stripeSessionId || order.paymentStatus === "PENDING") {
      throw new BusinessLogicError(
        ErrorCode.PAYMENT_LINK_EXISTS,
        'Payment link already exists for this order',
        { userId: customerId, metadata: { orderId: order.id }, operation: 'handleOnlinePayment' }
      );
    }

    // Verificar el estado de la orden
    let mensaje: string | undefined;
    switch (order.orderStatus) {
      case "PENDING":
      case "IN_PROGRESS":
        // Continuar con el proceso de pago
        break;
      case "IN_PREPARATION":
        mensaje =
          "❌ Esta orden ya está en preparación. Por favor, contacta con el restaurante para opciones de pago.";
        break;
      case "READY":
        mensaje =
          "❌ Esta orden ya está preparada. Por favor, contacta con el restaurante para opciones de pago.";
        break;
      case "IN_DELIVERY":
        mensaje =
          "❌ Esta orden ya está en camino. Por favor, paga al repartidor o contacta con el restaurante.";
        break;
      case "CANCELLED":
        mensaje =
          "❌ Esta orden ya ha sido cancelada y no se puede procesar el pago.";
        break;
      case "COMPLETED":
        mensaje =
          "❌ Esta orden ya ha sido finalizada y no se puede procesar el pago.";
        break;
      default:
        mensaje =
          "❌ Lo sentimos, pero no se puede procesar el pago en este momento debido al estado actual de la orden.";
    }

    if (mensaje) {
      // Get customer's WhatsApp phone number
      const customerForMessage = await prisma.customer.findUnique({
        where: { id: customerId },
        select: { whatsappPhoneNumber: true }
      });
      
      if (customerForMessage?.whatsappPhoneNumber) {
        await sendWhatsAppMessage(customerForMessage.whatsappPhoneNumber, mensaje);
      }
      return;
    }

    let customer = await prisma.customer.findUnique({ where: { id: customerId } });
    
    if (!customer) {
      await sendWhatsAppMessage(customerId, "❌ Error al procesar el pago. Cliente no encontrado.");
      return;
    }
    
    let stripeCustomerId = customer.stripeCustomerId;

    if (!stripeCustomerId) {
      const stripeCustomer = await stripeClient.customers.create({
        phone: customer.whatsappPhoneNumber,
        metadata: { whatsappId: customer.whatsappPhoneNumber },
      });
      stripeCustomerId = stripeCustomer.id;
      await prisma.customer.update({
        where: { id: customer.id },
        data: { stripeCustomerId }
      });
    }

    const session = await stripeClient.checkout.sessions.create({
      payment_method_types: ["card"],
      customer: stripeCustomerId,
      line_items: [
        {
          price_data: {
            currency: "mxn",
            product_data: {
              name: `Orden #${
                order.dailyNumber
              } - ${(await getCurrentMexicoTime()).format("DD/MM/YYYY")}`,
            },
            unit_amount: Math.round(order.totalCost * 100),
          },
          quantity: 1,
        },
      ],
      mode: "payment",
      success_url: `${env.FRONTEND_BASE_URL}/payment-success`,
      cancel_url: `${env.FRONTEND_BASE_URL}/payment-cancel`,
    });

    await prisma.order.update({
      where: { id: order.id },
      data: {
        stripeSessionId: session.id,
        paymentStatus: "PENDING",
      }
    });

    const paymentLink = session.url;
    await sendWhatsAppMessage(
      customerId,
      `💳 Por favor, haz clic en el siguiente enlace para proceder con el pago: 🔗 ${paymentLink} 💰`
    );
    // await sendWhatsAppNotification("Se ha generado un link de pago");
  } catch (error) {
    await ErrorService.handleAndSendError(error, customerId, {
      userId: customerId,
      operation: 'handleOnlinePayment',
      metadata: { messageId }
    });
  }
}

async function sendMenu(phoneNumber: string): Promise<boolean> {
  try {
    const fullMenu = await ProductService.getActiveProducts({ formatForAI: true });
    // La utilidad messageSender se encarga de dividir mensajes largos automáticamente
    const success = await sendWhatsAppMessage(phoneNumber, String(fullMenu));
    return success;
  } catch (error) {
    await ErrorService.handleAndSendError(error, phoneNumber, {
      userId: phoneNumber,
      operation: 'sendMenu'
    });
    return false;
  }
}

async function handleWaitTimes(customerId: string): Promise<void> {
  try {
    const config = await prisma.restaurantConfig.findFirst();
    if (!config) {
      throw new BusinessLogicError(ErrorCode.DATABASE_ERROR, 'Restaurant configuration not found');
    }
    const message = WAIT_TIMES_MESSAGE(
      config.estimatedPickupTime,
      config.estimatedDeliveryTime
    );
    await sendWhatsAppMessage(customerId, message);
  } catch (error) {
    await ErrorService.handleAndSendError(error, customerId, {
      userId: customerId,
      operation: 'handleWaitTimes'
    });
  }
}

async function handleRestaurantInfo(customerId: string): Promise<void> {
  try {
    const message = await RESTAURANT_INFO_MESSAGE();
    await sendWhatsAppMessage(customerId, message);
  } catch (error) {
    await ErrorService.handleAndSendError(error, customerId, {
      userId: customerId,
      operation: 'handleRestaurantInfo'
    });
  }
}

async function handleChatbotHelp(customerId: string): Promise<void> {
  try {
    const message = await CHATBOT_HELP_MESSAGE();
    await sendWhatsAppMessage(customerId, message);
  } catch (error) {
    await ErrorService.handleAndSendError(error, customerId, {
      userId: customerId,
      operation: 'handleChatbotHelp'
    });
  }
}

async function handleChangeDeliveryInfo(from: string): Promise<void> {
  const otp = OTPService.generateOTP();
  OTPService.storeOTP(from, otp, true); // true for address registration
  const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${from}?otp=${otp}`;
  
  // Enviar mensaje con botón URL
  await sendMessageWithUrlButton(
    from,
    "🚚 Actualizar Dirección",
    "Puedes actualizar o agregar una nueva dirección de entrega haciendo clic en el botón de abajo.",
    "Actualizar Dirección",
    updateLink
  );
}

async function handleAddressConfirmation(from: string, confirmationId: string, messageId: string): Promise<void> {
  try {
    // Extract address ID from confirmation ID
    const addressId = confirmationId.replace('confirm_address_', '');
    
    // This is the same as selecting an address
    await handleAddressSelection(from, `select_address_${addressId}`, messageId);
    
  } catch (error) {
    await ErrorService.handleAndSendError(error, from, {
      userId: from,
      operation: 'handleAddressConfirmation'
    });
  }
}

async function handleAddressSelection(from: string, selectionId: string, messageId: string): Promise<void> {
  try {
    // Extract address ID from selection ID
    const addressId = selectionId.replace('select_address_', '');
    
    // Get customer
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: from },
      include: {
        addresses: {
          where: { id: addressId }
        }
      }
    });
    
    if (!customer || customer.addresses.length === 0) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer or address not found',
        { userId: from }
      );
    }
    
    const selectedAddress = customer.addresses[0];
    
    // Format address for confirmation
    const addressParts = [];
    if (selectedAddress.street && selectedAddress.number) {
      let streetLine = `${selectedAddress.street} ${selectedAddress.number}`;
      if (selectedAddress.interiorNumber) {
        streetLine += ` Int. ${selectedAddress.interiorNumber}`;
      }
      addressParts.push(streetLine);
    }
    if (selectedAddress.neighborhood) addressParts.push(selectedAddress.neighborhood);
    if (selectedAddress.city && selectedAddress.state) {
      addressParts.push(`${selectedAddress.city}, ${selectedAddress.state}`);
    }
    if (selectedAddress.references) {
      addressParts.push(`Referencias: ${selectedAddress.references}`);
    }
    
    const formattedAddress = addressParts.join('\n');
    
    // Check if this is for a preorder
    const preOrder = await prisma.preOrder.findFirst({
      where: { 
        whatsappPhoneNumber: customer.whatsappPhoneNumber,
        messageId: { contains: messageId }
      }
    });
    
    if (preOrder) {
      // Update preorder with selected address
      const axios = (await import('axios')).default;
      await axios.post(`${process.env.BACKEND_BASE_URL || 'http://localhost:3001'}/backend/address-selection/update`, {
        preOrderId: preOrder.id,
        addressId: selectedAddress.id,
        customerId: customer.id
      });
      
      await sendWhatsAppMessage(
        from,
        `✅ *Dirección seleccionada exitosamente*\n\n📍 *Dirección de entrega:*\n${formattedAddress}\n\nTu pedido será entregado en esta dirección.`
      );
    } else {
      // Just confirming address selection
      await sendWhatsAppMessage(
        from,
        `✅ *Dirección seleccionada*\n\n📍 *Dirección de entrega:*\n${formattedAddress}\n\nEsta dirección se usará para tu próximo pedido.`
      );
    }
    
  } catch (error) {
    await ErrorService.handleAndSendError(error, from, {
      userId: from,
      operation: 'handleAddressSelection'
    });
  }
}

async function handleAddNewAddress(from: string, messageId: string): Promise<void> {
  try {
    // Get customer
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: from }
    });
    
    if (!customer) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer not found',
        { userId: from }
      );
    }
    
    // Check if this is for a preorder
    const preOrder = await prisma.preOrder.findFirst({
      where: { 
        whatsappPhoneNumber: customer.whatsappPhoneNumber,
        messageId: { contains: messageId }
      }
    });
    
    const otp = OTPService.generateOTP();
    OTPService.storeOTP(customer.whatsappPhoneNumber, otp, true);
    
    const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${customer.whatsappPhoneNumber}?otp=${otp}${preOrder ? `&preOrderId=${preOrder.id}` : ''}`;
    
    await sendMessageWithUrlButton(
      from,
      "📍 Agregar Nueva Dirección",
      "Haz clic en el botón de abajo para registrar una nueva dirección de entrega.",
      "Agregar Dirección",
      updateLink
    );
    
  } catch (error) {
    await ErrorService.handleAndSendError(error, from, {
      userId: from,
      operation: 'handleAddNewAddress'
    });
  }
}

================
File: backend/prisma/seed.ts
================
import { PrismaClient } from '@prisma/client';
import dotenv from 'dotenv';
import path from 'path';

// Load environment variables from the correct path
dotenv.config({ path: path.resolve(__dirname, '../.env') });

const prisma = new PrismaClient();

async function main() {
  console.log('Starting complete seed...');

  // Check if already seeded
  const existingCategories = await prisma.category.count();
  if (existingCategories > 0) {
    console.log('Database already seeded. Cleaning up...');
    // Clean up existing data in reverse dependency order
    await prisma.selectedPizzaIngredient.deleteMany();
    await prisma.orderItem.deleteMany();
    await prisma.orderDeliveryInfo.deleteMany();
    await prisma.order.deleteMany();
    await prisma.preOrder.deleteMany();
    await prisma.pizzaIngredient.deleteMany();
    await prisma.productModifier.deleteMany();
    await prisma.modifierGroup.deleteMany();
    await prisma.productVariant.deleteMany();
    await prisma.product.deleteMany();
    await prisma.subcategory.deleteMany();
    await prisma.category.deleteMany();
    await prisma.businessHours.deleteMany();
    await prisma.restaurantConfig.deleteMany();
  }

  // Create restaurant config with business hours
  const restaurantConfig = await prisma.restaurantConfig.create({
    data: {
      // Información básica del restaurante
      restaurantName: "La Leña",
      phoneMain: "3919160126",
      phoneSecondary: "3338423316",
      address: "C. Ogazón Sur 36, Centro",
      city: "Tototlán",
      state: "Jalisco",
      postalCode: "47730",
      country: "México",
      
      // Configuración de operación
      acceptingOrders: true,
      estimatedPickupTime: 20,
      estimatedDeliveryTime: 40,
      openingGracePeriod: 30,
      closingGracePeriod: 30,
      timeZone: "America/Mexico_City",
      
      // Configuración de delivery
      // Formato Google Maps: {lat: number, lng: number}
      deliveryCoverageArea: [
        { lat: 20.552083014344916, lng: -102.80691765951832 },
        { lat: 20.533011128610994, lng: -102.80691765951832 },
        { lat: 20.533011128610994, lng: -102.78047795060189 },
        { lat: 20.552083014344916, lng: -102.78047795060189 },
        { lat: 20.552083014344916, lng: -102.80691765951832 }
      ]
    }
  });

  // Create business hours for each day of the week
  const businessHours = [
    { dayOfWeek: 0, openingTime: "14:00", closingTime: "21:00", isClosed: false }, // Domingo
    { dayOfWeek: 1, openingTime: null, closingTime: null, isClosed: true },       // Lunes (cerrado)
    { dayOfWeek: 2, openingTime: "14:00", closingTime: "22:00", isClosed: false }, // Martes
    { dayOfWeek: 3, openingTime: "4:00", closingTime: "23:00", isClosed: false }, // Miércoles
    { dayOfWeek: 4, openingTime: "4:00", closingTime: "22:00", isClosed: false }, // Jueves
    { dayOfWeek: 5, openingTime: "4:00", closingTime: "22:00", isClosed: false }, // Viernes
    { dayOfWeek: 6, openingTime: "14:00", closingTime: "22:00", isClosed: false }, // Sábado
  ];

  for (const hours of businessHours) {
    await prisma.businessHours.create({
      data: {
        ...hours,
        restaurantConfigId: restaurantConfig.id
      }
    });
  }

  // Create categories and subcategories
  const categories = [
    {
      id: "COM",
      name: "Comida",
      description: "Platos principales y entradas",
      subcategories: [
        { id: "COM-S1", name: "Entradas", description: "Alitas, papas y más" },
        { id: "COM-S2", name: "Pizzas", description: "Pizzas artesanales" },
        { id: "COM-S3", name: "Hamburguesas", description: "Hamburguesas gourmet" },
        { id: "COM-S4", name: "Ensaladas", description: "Ensaladas frescas" },
      ],
    },
    {
      id: "BEB",
      name: "Bebida",
      description: "Bebidas y coctelería",
      subcategories: [
        { id: "BEB-S1", name: "Frappes y Postres", description: "Bebidas frías y postres" },
        { id: "BEB-S2", name: "Jarras", description: "Bebidas para compartir" },
        { id: "BEB-S3", name: "Cocteleria", description: "Cocteles y bebidas con alcohol" },
        { id: "BEB-S4", name: "Bebidas", description: "Aguas frescas y bebidas naturales" },
        { id: "BEB-S5", name: "Cafe Caliente", description: "Café y bebidas calientes" },
        { id: "BEB-S6", name: "Refrescos", description: "Refrescos embotellados" },
      ],
    },
  ];

  for (const cat of categories) {
    await prisma.category.create({
      data: {
        id: cat.id,
        name: cat.name,
        description: cat.description,
        isActive: true,
        subcategories: {
          create: cat.subcategories.map(sub => ({
            id: sub.id,
            name: sub.name,
            description: sub.description,
            isActive: true
          }))
        }
      }
    });
  }

  // Create products
  const products = [
    // BEBIDAS
    {
      id: "AH",
      name: "Agua fresca de horchata",
      description: "Refrescante agua de horchata natural",
      price: 35,
      subcategoryId: "BEB-S4",
    },
    {
      id: "LIM",
      name: "Limonada",
      description: "Limonada natural recién preparada",
      price: 35,
      subcategoryId: "BEB-S4",
    },
    {
      id: "LIMM",
      name: "Limonada Mineral",
      description: "Limonada con agua mineral",
      price: 35,
      subcategoryId: "BEB-S4",
    },
    {
      id: "SANP",
      name: "Sangria Preparada",
      description: "Sangría sin alcohol con frutas naturales",
      price: 35,
      subcategoryId: "BEB-S4",
    },
    {
      id: "MC",
      name: "Michelada",
      description: "Michelada preparada con nuestra receta especial",
      hasVariants: true,
      subcategoryId: "BEB-S4",
      variants: [
        { id: "MCV1", name: "Michelada clara", price: 80 },
        { id: "MCV2", name: "Michelada oscura", price: 80 },
      ],
    },
    // REFRESCOS
    {
      id: "CC",
      name: "Coca Cola",
      description: "Refresco Coca Cola 355ml",
      price: 30,
      subcategoryId: "BEB-S6",
    },
    {
      id: "SAN",
      name: "Sangria",
      description: "Refresco Sangría Señorial",
      price: 30,
      subcategoryId: "BEB-S6",
    },
    {
      id: "SQU",
      name: "Squirt",
      description: "Refresco Squirt toronja",
      price: 30,
      subcategoryId: "BEB-S6",
    },
    {
      id: "MIR",
      name: "Mirinda",
      description: "Refresco Mirinda naranja",
      price: 30,
      subcategoryId: "BEB-S6",
    },
    {
      id: "MAN",
      name: "Manzanita",
      description: "Refresco Manzanita Sol",
      price: 30,
      subcategoryId: "BEB-S6",
    },
    {
      id: "7UP",
      name: "7up",
      description: "Refresco 7up lima-limón",
      price: 30,
      subcategoryId: "BEB-S6",
    },
    {
      id: "AGM",
      name: "Agua Mineral",
      description: "Agua mineral Peñafiel",
      price: 30,
      subcategoryId: "BEB-S6",
    },
    // CAFE CALIENTE
    {
      id: "CA",
      name: "Cafe Americano",
      description: "Café americano recién preparado",
      price: 45,
      subcategoryId: "BEB-S5",
    },
    {
      id: "CP",
      name: "Capuchino",
      description: "Capuchino con espuma de leche",
      price: 45,
      subcategoryId: "BEB-S5",
    },
    {
      id: "CH",
      name: "Chocolate",
      description: "Chocolate caliente cremoso",
      price: 50,
      subcategoryId: "BEB-S5",
    },
    {
      id: "LC",
      name: "Latte Capuchino",
      description: "Latte con toque de capuchino",
      price: 50,
      subcategoryId: "BEB-S5",
    },
    {
      id: "LV",
      name: "Latte Vainilla",
      description: "Latte con jarabe de vainilla",
      price: 50,
      subcategoryId: "BEB-S5",
    },
    {
      id: "MCC",
      name: "Mocaccino",
      description: "Café con chocolate y crema",
      price: 50,
      subcategoryId: "BEB-S5",
    },
    // FRAPPES Y POSTRES
    {
      id: "F",
      name: "Frappe",
      description: "Frappes preparados con ingredientes premium",
      hasVariants: true,
      subcategoryId: "BEB-S1",
      variants: [
        { id: "FV1", name: "Frappe Capuchino", price: 70 },
        { id: "FV2", name: "Frappe Coco", price: 70 },
        { id: "FV3", name: "Frappe Caramelo", price: 70 },
        { id: "FV4", name: "Frappe Cajeta", price: 70 },
        { id: "FV5", name: "Frappe Mocaccino", price: 70 },
        { id: "FV6", name: "Frappe Galleta", price: 70 },
        { id: "FV7", name: "Frappe Bombon", price: 70 },
        { id: "FV8", name: "Frappe Rompope", price: 85 },
        { id: "FV9", name: "Frappe Mazapan", price: 85 },
        { id: "FV10", name: "Frappe Magnum", price: 85 },
      ],
    },
    // COCTELERIA (sin detalles de ingredientes para simplificar)
    {
      id: "CARAJ",
      name: "Carajillo",
      description: "Café con licor 43",
      price: 90,
      subcategoryId: "BEB-S3",
    },
    {
      id: "CLERI",
      name: "Clericot",
      description: "Vino tinto con frutas",
      price: 80,
      subcategoryId: "BEB-S3",
    },
    {
      id: "MOJ",
      name: "Mojito",
      description: "Ron, hierbabuena, limón y soda",
      price: 100,
      subcategoryId: "BEB-S3",
    },
    {
      id: "MAR",
      name: "Margarita",
      description: "Tequila, triple sec y limón",
      price: 85,
      subcategoryId: "BEB-S3",
    },
    // HAMBURGUESAS
    {
      id: "H",
      name: "Hamburguesa",
      description: "Hamburguesas artesanales con carne de res premium",
      hasVariants: true,
      subcategoryId: "COM-S3",
      variants: [
        {
          id: "HV1",
          name: "Hamburguesa Tradicional",
          price: 85,
          description: "Carne de res, tocino, queso amarillo, queso asadero, vegetales frescos y aderezos",
        },
        {
          id: "HV2",
          name: "Hamburguesa Especial",
          price: 95,
          description: "Carne de res, tocino, pierna, doble queso, vegetales frescos y aderezos",
        },
        {
          id: "HV3",
          name: "Hamburguesa Hawaiana",
          price: 95,
          description: "Carne de res, tocino, piña, jamón, doble queso, vegetales y aderezos",
        },
        {
          id: "HV4",
          name: "Hamburguesa Pollo",
          price: 100,
          description: "Pollo a la plancha, tocino, doble queso, vegetales y aderezos",
        },
        {
          id: "HV5",
          name: "Hamburguesa BBQ",
          price: 100,
          description: "Carne de res, salsa BBQ, tocino, doble queso, cebolla guisada y aderezos",
        },
        {
          id: "HV6",
          name: "Hamburguesa Leñazo",
          price: 110,
          description: "Doble carne de sirloin, tocino, doble queso, cebolla guisada y aderezos",
        },
        {
          id: "HV7",
          name: "Hamburguesa Cubana",
          price: 100,
          description: "Carne de res, tocino, pierna, salchicha, jamón, doble queso y aderezos",
        },
      ],
      modifierGroups: [
        {
          id: "HM1",
          name: "Hamburguesa con papas",
          isRequired: false,
          allowMultipleSelections: false,
          modifiers: [
            { id: "HM1-1", name: "Con papas francesa", price: 10 },
            { id: "HM1-2", name: "Con papas gajo", price: 15 },
            { id: "HM1-3", name: "Con papas mixtas", price: 15 },
            { id: "HM1-4", name: "Con papas francesa gratinadas", price: 15 },
            { id: "HM1-5", name: "Con papas gajo gratinadas", price: 20 },
            { id: "HM1-6", name: "Con papas mixtas gratinadas", price: 20 },
          ],
        },
        {
          id: "HM2",
          name: "Hamburguesa extras",
          isRequired: false,
          allowMultipleSelections: true,
          modifiers: [
            { id: "HM2-1", name: "Partida", price: 0 },
            { id: "HM2-2", name: "Doble carne", price: 15 },
            { id: "HM2-3", name: "Doble pollo", price: 20 },
            { id: "HM2-4", name: "Piña", price: 5 },
            { id: "HM2-5", name: "Pollo en lugar de carne de res", price: 15 },
          ],
        },
        {
          id: "HM3",
          name: "Quitar ingredientes Hamburguesa",
          isRequired: false,
          allowMultipleSelections: true,
          modifiers: [
            { id: "HM3-1", name: "Sin aderezo", price: 0 },
            { id: "HM3-2", name: "Sin aderezos", price: 0 },
            { id: "HM3-3", name: "Sin catsup", price: 0 },
            { id: "HM3-4", name: "Sin cebolla", price: 0 },
            { id: "HM3-5", name: "Sin chile jalapeño", price: 0 },
            { id: "HM3-6", name: "Sin crema", price: 0 },
            { id: "HM3-7", name: "Sin jitomate", price: 0 },
            { id: "HM3-8", name: "Sin lechuga", price: 0 },
            { id: "HM3-9", name: "Sin mostaza", price: 0 },
            { id: "HM3-10", name: "Sin pierna", price: 0 },
            { id: "HM3-11", name: "Sin queso amarillo", price: 0 },
            { id: "HM3-12", name: "Sin queso blanco", price: 0 },
            { id: "HM3-13", name: "Sin tocino", price: 0 },
            { id: "HM3-14", name: "Sin verduras", price: 0 },
          ],
        },
      ],
    },
    {
      id: "DQ",
      name: "Dedos de queso",
      description: "Dedos de queso mozzarella empanizados",
      price: 90,
      subcategoryId: "COM-S3",
    },
    // ENTRADAS - ALITAS
    {
      id: "A",
      name: "Alitas",
      description: "Alitas de pollo preparadas al momento",
      hasVariants: true,
      subcategoryId: "COM-S1",
      variants: [
        { id: "AV1", name: "Orden de Alitas BBQ", price: 135 },
        { id: "AV2", name: "Orden de Alitas Picosas", price: 135 },
        { id: "AV3", name: "Orden de Alitas Fritas", price: 135 },
        { id: "AV4", name: "Orden de Alitas Mango Habanero", price: 140 },
        { id: "AV5", name: "Orden de Alitas Mixtas", price: 135 },
        { id: "AV6", name: "Media Orden de Alitas BBQ", price: 70 },
        { id: "AV7", name: "Media Orden de Alitas Picosas", price: 70 },
        { id: "AV8", name: "Media Orden de Alitas Fritas", price: 70 },
        { id: "AV9", name: "Media Orden de Alitas Mango Habanero", price: 75 },
      ],
      modifierGroups: [
        {
          id: "AM1",
          name: "Modificadores Alitas",
          isRequired: false,
          allowMultipleSelections: true,
          modifiers: [
            { id: "AM1-1", name: "Extra salsa", price: 10 },
            { id: "AM1-2", name: "Con aderezo ranch", price: 10 },
            { id: "AM1-3", name: "Extra chile de aceite", price: 10 },
            { id: "AM1-4", name: "Extra doradas", price: 0 },
          ],
        },
      ],
    },
    // ENTRADAS - PAPAS
    {
      id: "P",
      name: "Orden de Papas",
      description: "Papas preparadas con nuestra receta especial",
      hasVariants: true,
      subcategoryId: "COM-S1",
      variants: [
        { id: "PV1", name: "Orden de Papas a la Francesa", price: 90 },
        { id: "PV2", name: "Orden de Papas Gajo", price: 105 },
        { id: "PV3", name: "Orden de Papas Mixtas francesa y gajo", price: 105 },
        { id: "PV4", name: "Media Orden de Papas a la Francesa", price: 50 },
        { id: "PV5", name: "Media Orden de Papas Gajo", price: 65 },
      ],
      modifierGroups: [
        {
          id: "PM1",
          name: "Papas queso",
          isRequired: true,
          allowMultipleSelections: true,
          modifiers: [
            { id: "PM1-1", name: "Sin queso", price: 0 },
            { id: "PM1-2", name: "Con queso", price: 0 },
            { id: "PM1-3", name: "Extra queso", price: 10 },
          ],
        },
        {
          id: "PM2",
          name: "Papas observaciones",
          isRequired: false,
          allowMultipleSelections: true,
          modifiers: [
            { id: "PM2-1", name: "Extra aderezo", price: 0 },
          ],
        },
      ],
    },
    // ENSALADAS
    {
      id: "EN",
      name: "Ensalada",
      description: "Ensaladas frescas preparadas al momento",
      hasVariants: true,
      subcategoryId: "COM-S4",
      variants: [
        {
          id: "EV1",
          name: "Ensalada de Pollo Chica",
          price: 90,
          description: "Pollo a la plancha, vegetales frescos, queso parmesano y aderezo",
        },
        {
          id: "EV2",
          name: "Ensalada de Pollo Grande",
          price: 120,
          description: "Pollo a la plancha, vegetales frescos, queso parmesano y aderezo",
        },
        {
          id: "EV3",
          name: "Ensalada de Jamon Chica",
          price: 80,
          description: "Jamón, vegetales frescos, queso parmesano y aderezo",
        },
        {
          id: "EV4",
          name: "Ensalada de Jamon Grande",
          price: 100,
          description: "Jamón, vegetales frescos, queso parmesano y aderezo",
        },
        {
          id: "EV5",
          name: "Ensalada Vegetal Chica",
          price: 70,
          description: "Vegetales frescos, queso parmesano y aderezo",
        },
        {
          id: "EV6",
          name: "Ensalada Vegetal Grande",
          price: 90,
          description: "Vegetales frescos, queso parmesano y aderezo",
        },
      ],
      modifierGroups: [
        {
          id: "EM1",
          name: "Extras Ensaladas",
          isRequired: false,
          allowMultipleSelections: true,
          modifiers: [
            { id: "EM1-1", name: "Con vinagreta", price: 0 },
            { id: "EM1-2", name: "Extra pollo", price: 15 },
          ],
        },
        {
          id: "EM2",
          name: "Quitar ingredientes Ensalada",
          isRequired: false,
          allowMultipleSelections: true,
          modifiers: [
            { id: "EM2-8", name: "Sin aderezo", price: 0 },
            { id: "EM2-9", name: "Sin betabel crujiente", price: 0 },
            { id: "EM2-2", name: "Sin chile morrón", price: 0 },
            { id: "EM2-3", name: "Sin elote", price: 0 },
            { id: "EM2-10", name: "Sin jamón", price: 0 },
            { id: "EM2-5", name: "Sin jitomate", price: 0 },
            { id: "EM2-4", name: "Sin lechuga", price: 0 },
            { id: "EM2-1", name: "Sin pollo", price: 0 },
            { id: "EM2-7", name: "Sin queso parmesano", price: 0 },
            { id: "EM2-6", name: "Sin zanahoria", price: 0 },
          ],
        },
      ],
    },
    // PIZZAS
    {
      id: "PZ",
      name: "Pizza",
      description: "Pizzas artesanales horneadas en horno de leña",
      hasVariants: true,
      isPizza: true,
      subcategoryId: "COM-S2",
      variants: [
        { id: "PZ-V-1", name: "Pizza Grande", price: 240 },
        { id: "PZ-V-2", name: "Pizza Mediana", price: 190 },
        { id: "PZ-V-3", name: "Pizza Chica", price: 140 },
        { id: "PZ-V-4", name: "Pizza Grande Con Orilla Rellena de Queso", price: 270 },
        { id: "PZ-V-5", name: "Pizza Mediana Con Orilla Rellena de Queso", price: 220 },
        { id: "PZ-V-6", name: "Pizza Chica Con Orilla Rellena de Queso", price: 160 },
      ],
      modifierGroups: [
        {
          id: "PZ-M1",
          name: "Observaciones de Pizza",
          isRequired: false,
          allowMultipleSelections: true,
          modifiers: [
            { id: "PZ-M1-1", name: "Con catsup", price: 0 },
            { id: "PZ-M1-2", name: "Extra aderezo", price: 0 },
            { id: "PZ-M1-3", name: "Extra chile de aceite", price: 0 },
            { id: "PZ-M1-4", name: "Extra dorada", price: 0 },
            { id: "PZ-M1-5", name: "Menos dorada", price: 0 },
            { id: "PZ-M1-6", name: "Sin salsa", price: 0 },
          ],
        },
      ],
    },
    {
      id: "CHCH",
      name: "Chile chillon",
      description: "Chile jalapeño relleno de queso",
      price: 35,
      subcategoryId: "COM-S2",
    },
  ];

  // Create pizza ingredients separately
  const pizzaIngredients = [
    // Pizzas especiales (completas)
    { id: "PZ-I-1", name: "Adelita", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-2", name: "Carnes Frias", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-3", name: "Carranza", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-4", name: "Especial", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-5", name: "Hawaiana", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-6", name: "Kahlo", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-7", name: "La Leña", ingredientValue: 6, productIds: ["PZ"] },
    { id: "PZ-I-8", name: "La Maria", ingredientValue: 6, productIds: ["PZ"] },
    { id: "PZ-I-9", name: "Lupita", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-10", name: "Malinche", ingredientValue: 6, productIds: ["PZ"] },
    { id: "PZ-I-11", name: "Margarita", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-12", name: "Mexicana", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-13", name: "Pepperoni", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-14", name: "Rivera", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-15", name: "Villa", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-16", name: "Zapata", ingredientValue: 4, productIds: ["PZ"] },
    { id: "PZ-I-17", name: "3 Quesos", ingredientValue: 2, productIds: ["PZ"] },
    // Ingredientes individuales
    { id: "PZ-I-18", name: "Albahaca", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-19", name: "Arandano", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-20", name: "Calabaza", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-21", name: "Cebolla", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-22", name: "Champiñon", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-23", name: "Chile Jalapeño", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-24", name: "Chile Morron", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-25", name: "Chile Seco", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-26", name: "Chorizo", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-27", name: "Elote", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-28", name: "Jamon", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-29", name: "Jitomate", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-30", name: "Molida", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-31", name: "Pierna", ingredientValue: 2, productIds: ["PZ"] },
    { id: "PZ-I-32", name: "Piña", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-33", name: "Pollo BBQ", ingredientValue: 2, productIds: ["PZ"] },
    { id: "PZ-I-34", name: "Queso", ingredientValue: 0, productIds: ["PZ"] },
    { id: "PZ-I-35", name: "Queso de cabra", ingredientValue: 2, productIds: ["PZ"] },
    { id: "PZ-I-36", name: "Salami", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-37", name: "Salchicha", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-38", name: "Salsa de tomate", ingredientValue: 0, productIds: ["PZ"] },
    { id: "PZ-I-39", name: "Tocino", ingredientValue: 1, productIds: ["PZ"] },
    { id: "PZ-I-40", name: "Pepperoni", ingredientValue: 1, productIds: ["PZ"] },
  ];

  // Create all pizza ingredients first
  for (const ingredient of pizzaIngredients) {
    await prisma.pizzaIngredient.create({
      data: {
        id: ingredient.id,
        name: ingredient.name,
        ingredientValue: ingredient.ingredientValue,
        productIds: ingredient.productIds,
        isActive: true
      }
    });
  }

  // Create products with their variants and modifiers
  for (const product of products) {
    const { variants, modifierGroups, ...productData } = product;
    
    await prisma.product.create({
      data: {
        ...productData,
        isActive: true,
        hasVariants: productData.hasVariants || false,
        isPizza: productData.isPizza || false,
        variants: variants ? {
          create: variants.map(v => {
            const { description, ...variantData } = v as any;
            return { 
              ...variantData, 
              isActive: true
            };
          })
        } : undefined,
        modifierGroups: modifierGroups ? {
          create: modifierGroups.map(mg => ({
            id: mg.id,
            name: mg.name,
            allowMultipleSelections: mg.allowMultipleSelections,
            isRequired: mg.isRequired,
            productModifiers: {
              create: mg.modifiers.map(m => ({ 
                ...m, 
                isActive: true 
              }))
            }
          }))
        } : undefined,
        // Connect pizza ingredients to pizza product
        pizzaIngredients: productData.isPizza ? {
          connect: pizzaIngredients.map(pi => ({ id: pi.id }))
        } : undefined
      }
    });
  }

  console.log('Complete seed finished successfully');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

================
File: backend/package.json
================
{
  "name": "backend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "ts-node --transpile-only src/server.ts",
    "dev:all": "cd .. && ./dev.sh",
    "dev:frontend": "cd .. && ./dev-frontend.sh",
    "build": "tsc",
    "start": "node dist/server.js",
    "start:prod": "node dist/server.js",
    "migrate": "prisma migrate deploy",
    "migrate:dev": "prisma migrate dev",
    "generate": "prisma generate",
    "studio": "prisma studio",
    "seed": "ts-node --transpile-only prisma/seed.ts",
    "postinstall": "prisma generate"
  },
  "prisma": {
    "seed": "ts-node --transpile-only prisma/seed.ts"
  },
  "dependencies": {
    "@google/genai": "^1.5.1",
    "@prisma/client": "^6.9.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "axios": "^1.7.7",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^4.21.2",
    "moment": "^2.30.1",
    "moment-timezone": "^0.5.45",
    "pg": "^8.13.0",
    "prisma": "^6.9.0",
    "string-similarity": "^4.0.4",
    "stripe": "^17.3.1",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@types/axios": "^0.14.0",
    "@types/string-similarity": "^4.0.2",
    "ts-node": "^10.9.2"
  }
}




================================================================
End of Codebase
================================================================
