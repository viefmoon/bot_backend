This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.claude/settings.local.json
.gitignore
backend/.claude/settings.local.json
backend/.env.example
backend/.gitignore
backend/ecosystem.config.js
backend/package.json
backend/prisma/migrations/20250718185619_initial_migration/migration.sql
backend/prisma/migrations/migration_lock.toml
backend/prisma/schema.prisma
backend/README.md
backend/scripts/generate-embeddings.js
backend/scripts/production-pgvector-setup.sql
backend/scripts/README_PGVECTOR.md
backend/scripts/reset-db.sh
backend/scripts/setup-local-pgvector.sh
backend/src/api/audio/audioHealth.controller.ts
backend/src/api/audio/audioOrder.controller.ts
backend/src/api/audio/audioOrder.routes.ts
backend/src/common/config/envValidator.ts
backend/src/common/config/predefinedMessages.ts
backend/src/common/constants/contextKeys.ts
backend/src/common/constants/index.ts
backend/src/common/constants/interactiveActions.ts
backend/src/common/constants/redisKeys.ts
backend/src/common/middlewares/apiKeyAuth.middleware.ts
backend/src/common/middlewares/errorHandler.ts
backend/src/common/middlewares/otp.middleware.ts
backend/src/common/middlewares/validation.middleware.ts
backend/src/common/services/errors/CustomErrors.ts
backend/src/common/services/errors/errorMessages.ts
backend/src/common/services/errors/index.ts
backend/src/common/services/errors/types.ts
backend/src/common/types/index.ts
backend/src/common/types/menu.ts
backend/src/common/types/order-item.types.ts
backend/src/common/types/order.types.ts
backend/src/common/types/preorder.types.ts
backend/src/common/types/restaurant.ts
backend/src/common/types/services.types.ts
backend/src/common/types/whatsapp-messages.types.ts
backend/src/common/utils/addressFormatter.ts
backend/src/common/utils/logger.ts
backend/src/common/utils/messageSplitter.ts
backend/src/common/utils/timeUtils.ts
backend/src/common/utils/whatsappErrorHandler.ts
backend/src/dto/address/address.dto.ts
backend/src/dto/address/create-address.dto.ts
backend/src/dto/address/delete-address.dto.ts
backend/src/dto/address/get-addresses-query.dto.ts
backend/src/dto/address/index.ts
backend/src/dto/address/set-default-address.dto.ts
backend/src/dto/address/update-address.dto.ts
backend/src/dto/auth/index.ts
backend/src/dto/auth/invalidate-otp.dto.ts
backend/src/dto/auth/verify-otp.dto.ts
backend/src/dto/customer/index.ts
backend/src/dto/customer/update-customer-name.dto.ts
backend/src/dto/index.ts
backend/src/dto/order/create-order.dto.ts
backend/src/dto/order/index.ts
backend/src/dto/order/process-audio-order.dto.ts
backend/src/dto/whatsapp/index.ts
backend/src/dto/whatsapp/send-message.dto.ts
backend/src/lib/prisma.ts
backend/src/queues/messageQueue.ts
backend/src/queues/types.ts
backend/src/routes/address-registration.ts
backend/src/routes/sync.ts
backend/src/routes/webhook.ts
backend/src/run-workers.ts
backend/src/server.ts
backend/src/services/ai/AgentService.ts
backend/src/services/ai/GeminiService.ts
backend/src/services/ai/index.ts
backend/src/services/ai/MenuSearchService.ts
backend/src/services/ai/prompts/generalAgent.prompt.ts
backend/src/services/ai/prompts/index.ts
backend/src/services/ai/prompts/orderAgent.prompt.ts
backend/src/services/ai/tools/generalAgent.tools.ts
backend/src/services/ai/tools/handlers/generateAddressUpdateLinkHandler.ts
backend/src/services/ai/tools/handlers/getBusinessHoursHandler.ts
backend/src/services/ai/tools/handlers/getWaitTimesHandler.ts
backend/src/services/ai/tools/handlers/mapOrderItemsHandler.ts
backend/src/services/ai/tools/handlers/prepareOrderContextHandler.ts
backend/src/services/ai/tools/handlers/resetConversationHandler.ts
backend/src/services/ai/tools/handlers/sendBotInstructionsHandler.ts
backend/src/services/ai/tools/handlers/sendMenuHandler.ts
backend/src/services/ai/tools/index.ts
backend/src/services/ai/tools/orderAgent.tools.ts
backend/src/services/ai/tools/toolHandlers.ts
backend/src/services/ai/tools/types.ts
backend/src/services/audio/AudioOrderService.ts
backend/src/services/config/ConfigService.ts
backend/src/services/messaging/index.ts
backend/src/services/messaging/MessageContext.ts
backend/src/services/messaging/MessageProcessor.ts
backend/src/services/messaging/middlewares/AddressRequiredMiddleware.ts
backend/src/services/messaging/middlewares/CustomerValidationMiddleware.ts
backend/src/services/messaging/middlewares/MessageProcessingMiddleware.ts
backend/src/services/messaging/middlewares/MessageTypeMiddleware.ts
backend/src/services/messaging/middlewares/RateLimitMiddleware.ts
backend/src/services/messaging/middlewares/RestaurantHoursMiddleware.ts
backend/src/services/messaging/pipeline/MessagePipeline.ts
backend/src/services/messaging/README.md
backend/src/services/messaging/strategies/AudioMessageStrategy.ts
backend/src/services/messaging/strategies/InteractiveMessageStrategy.ts
backend/src/services/messaging/strategies/MessageStrategy.ts
backend/src/services/messaging/strategies/TextMessageStrategy.ts
backend/src/services/messaging/TextProcessingService.ts
backend/src/services/messaging/types.ts
backend/src/services/messaging/types/responses.ts
backend/src/services/orders/OrderService.ts
backend/src/services/orders/PreOrderService.ts
backend/src/services/orders/PreOrderWorkflowService.ts
backend/src/services/orders/services/DeliveryInfoService.ts
backend/src/services/orders/services/OrderFormattingService.ts
backend/src/services/orders/services/OrderManagementService.ts
backend/src/services/orders/services/ProductCalculationService.ts
backend/src/services/orders/services/SchedulingService.ts
backend/src/services/payment/StripeService.ts
backend/src/services/products/ProductService.ts
backend/src/services/redis/RedisService.ts
backend/src/services/restaurant/RestaurantService.ts
backend/src/services/security/OTPService.ts
backend/src/services/sync/EmbeddingManager.ts
backend/src/services/sync/EmbeddingService.ts
backend/src/services/sync/SyncMetadataService.ts
backend/src/services/sync/SyncNotificationService.ts
backend/src/services/sync/UnifiedSyncService.ts
backend/src/services/whatsapp/index.ts
backend/src/services/whatsapp/WhatsAppService.ts
backend/src/startup/embeddingInitializer.ts
backend/src/whatsapp/handlers/interactive/addressActions.ts
backend/src/whatsapp/handlers/interactive/index.ts
backend/src/whatsapp/handlers/interactive/infoActions.ts
backend/src/whatsapp/handlers/interactive/paymentActions.ts
backend/src/whatsapp/handlers/interactive/preOrderActions.ts
backend/src/whatsapp/handlers/interactiveMessageHandler.ts
backend/src/whatsapp/handlers/orders/index.ts
backend/src/whatsapp/handlers/orders/orderFormatters.ts
backend/src/workers/messageWorker.ts
backend/tsconfig.json
CLAUDE.md
cleanup-ports.bat
COMPLETE_DIGITALOCEAN_DEPLOY.md
docker-compose.yml
frontend-app/.env.example
frontend-app/.gitignore
frontend-app/eslint.config.js
frontend-app/index.html
frontend-app/package.json
frontend-app/postcss.config.js
frontend-app/public/delivery-address.svg
frontend-app/README.md
frontend-app/src/api/addressApi.ts
frontend-app/src/app.css
frontend-app/src/components/AddressForm/AddressForm.tsx
frontend-app/src/components/AddressForm/index.ts
frontend-app/src/components/AddressRegistration.tsx
frontend-app/src/components/BasicMap/BasicMap.tsx
frontend-app/src/components/BasicMap/index.ts
frontend-app/src/components/CustomerNameForm.tsx
frontend-app/src/components/ui/index.ts
frontend-app/src/components/ui/Input.tsx
frontend-app/src/config/index.ts
frontend-app/src/hooks/useAddressQueries.ts
frontend-app/src/i18n/index.ts
frontend-app/src/i18n/translations.ts
frontend-app/src/index.css
frontend-app/src/main.tsx
frontend-app/src/Router.tsx
frontend-app/src/services/api.ts
frontend-app/src/store/addressRegistrationStore.ts
frontend-app/src/styles/toast-animations.css
frontend-app/src/types/api.types.ts
frontend-app/src/types/customer.types.ts
frontend-app/src/types/index.ts
frontend-app/src/utils/errorHandlers.ts
frontend-app/src/utils/loadGoogleMaps.ts
frontend-app/src/utils/polygonUtils.ts
frontend-app/src/vite-env.d.ts
frontend-app/tailwind.config.js
frontend-app/tsconfig.app.json
frontend-app/tsconfig.json
frontend-app/tsconfig.node.json
frontend-app/vite.config.ts
LOCAL_DEVELOPMENT.md
package.json
PRODUCTION_UPDATE_GUIDE.md
QUICK_START.md
README.md
scripts/configure-nginx-ssl.sh
scripts/health-check.sh
scripts/install-dependencies.sh
scripts/quick-deploy.sh
scripts/reset-database-production-safe.sh
scripts/reset-database-production.sh
scripts/setup-app.sh
scripts/setup-database.sh
scripts/update-app-with-reset.sh
scripts/update-app.sh
start-dev.bat
start-dev.sh

================================================================
Files
================================================================

================
File: .gitignore
================
node_modules
.next/
.package-lock.json.swp
package.json.save
.env
.env.local
backend/dist/

================
File: backend/.gitignore
================
# Dependencies
node_modules/

# Build output
dist

# Environment files
.env
.env.local
.env.production

# IDE
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Testing
coverage/
.nyc_output/

# Temporary files
*.tmp
*.temp
.cache/

# repomix
.repomix/

/generated/prisma

================
File: backend/prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

================
File: backend/README.md
================
# Backend - WhatsApp Restaurant Bot

Backend service for a WhatsApp restaurant bot using Express, Prisma, and PostgreSQL.

## Quick Start

See the main README.md in the parent directory for setup instructions.

## Environment Variables

Required environment variables:

```bash
# Database
DATABASE_URL=postgresql://postgres:postgres@localhost:5433/bot_db

# Google AI
GOOGLE_AI_API_KEY=your_api_key  # Get from https://makersuite.google.com/app/apikey
GEMINI_MODEL=gemini-2.5-pro

# WhatsApp Business API
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=your_phone_id
WHATSAPP_ACCESS_TOKEN=your_access_token
WHATSAPP_VERIFY_TOKEN=your_verify_token

# Application
FRONTEND_BASE_URL=http://localhost:3000
NODE_ENV=development
PORT=5000

# Rate Limiting
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5

# Optional - Stripe Payments
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=
```

## Database Schema

The database uses Prisma ORM with the following main tables:
- Customer: WhatsApp customer information
- Product: Restaurant menu items
- Order: Customer orders
- PreOrder: Temporary cart items
- Address: Customer addresses

## API Endpoints

- `GET /backend` - Health check
- `POST /backend/webhook` - WhatsApp webhook
- `POST /backend/otp/verify` - Verify OTP
- `POST /backend/customer-delivery-info` - Create delivery info
- `PUT /backend/customer-delivery-info/:customerId` - Update delivery info
- `GET /backend/customer-delivery-info/:customerId` - Get delivery info
- `POST /backend/pre-orders/select-products` - Add products to cart

## Development

```bash
npm run dev         # Start development server
npm run build       # Build for production
npm run studio      # Open Prisma Studio
npm run migrate:dev # Run migrations
npm run seed        # Seed database
```

================
File: backend/scripts/production-pgvector-setup.sql
================
-- Script para configurar pgvector en producci√≥n (Railway PostgreSQL)
-- Ejecutar este script en la base de datos de producci√≥n

-- 1. Habilitar la extensi√≥n pgvector
CREATE EXTENSION IF NOT EXISTS vector;

-- 2. Agregar la columna embedding a la tabla Product
ALTER TABLE "Product" ADD COLUMN IF NOT EXISTS embedding vector(768);

-- 3. Crear √≠ndice para b√∫squedas eficientes (opcional pero recomendado)
-- HNSW es el √≠ndice m√°s eficiente para b√∫squedas de similitud
CREATE INDEX IF NOT EXISTS product_embedding_idx ON "Product" 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- 4. Verificar que todo est√° configurado correctamente
SELECT 
    COUNT(*) as total_products,
    COUNT(embedding) as products_with_embeddings
FROM "Product"
WHERE "isActive" = true;

-- Nota: Despu√©s de ejecutar este script, debes ejecutar el script de generaci√≥n
-- de embeddings con la variable DATABASE_URL apuntando a producci√≥n

================
File: backend/src/common/middlewares/errorHandler.ts
================
import { Request, Response, NextFunction } from 'express';
import { 
  BaseError, 
  ErrorType,
  ValidationError,
  BusinessLogicError,
  NotFoundError,
  RateLimitError,
  TechnicalError,
  ExternalServiceError
} from '../services/errors';
import logger from '../utils/logger';

interface ErrorResponse {
  error: {
    code: string;
    message: string;
    type: string;
    timestamp: string;
    requestId?: string;
    details?: any;
  };
}

/**
 * Maps custom error types to HTTP status codes
 */
function mapErrorTypeToStatusCode(error: BaseError): number {
  if (error instanceof ValidationError) return 400;
  if (error instanceof NotFoundError) return 404;
  if (error instanceof BusinessLogicError) return 409;
  if (error instanceof RateLimitError) return 429;
  if (error instanceof ExternalServiceError) return 502;
  if (error instanceof TechnicalError) return 500;
  
  // Fallback based on error type enum
  switch (error.type) {
    case ErrorType.VALIDATION:
      return 400;
    case ErrorType.NOT_FOUND:
      return 404;
    case ErrorType.BUSINESS_LOGIC:
      return 409;
    case ErrorType.RATE_LIMIT:
      return 429;
    case ErrorType.EXTERNAL_SERVICE:
      return 502;
    case ErrorType.TECHNICAL:
    default:
      return 500;
  }
}

/**
 * Global error handling middleware for Express
 * Provides consistent error responses and proper logging
 */
export function globalErrorHandler(
  err: Error, 
  req: Request, 
  res: Response, 
  next: NextFunction
): void {
  // Generate request ID for tracking
  const requestId = req.headers['x-request-id'] as string || generateRequestId();
  
  // Handle custom errors
  if (err instanceof BaseError) {
    const statusCode = mapErrorTypeToStatusCode(err);
    
    // Log based on severity
    if (statusCode >= 500) {
      logger.error('Server Error:', {
        error: err.message,
        code: err.code,
        type: err.type,
        context: err.context,
        stack: err.stack,
        requestId,
        path: req.path,
        method: req.method
      });
    } else {
      logger.warn('Client Error:', {
        error: err.message,
        code: err.code,
        type: err.type,
        context: err.context,
        requestId,
        path: req.path,
        method: req.method
      });
    }
    
    const errorResponse: ErrorResponse = {
      error: {
        code: err.code,
        message: err.message,
        type: err.type,
        timestamp: new Date().toISOString(),
        requestId
      }
    };
    
    // Include additional details in development
    if (process.env.NODE_ENV === 'development' && err.context) {
      errorResponse.error.details = err.context;
    }
    
    res.status(statusCode).json(errorResponse);
    return;
  }
  
  // Handle Prisma errors
  if (err.name === 'PrismaClientKnownRequestError') {
    const prismaError = err as any;
    let statusCode = 400;
    let message = 'Database operation failed';
    
    switch (prismaError.code) {
      case 'P2002':
        message = 'A unique constraint would be violated';
        break;
      case 'P2025':
        statusCode = 404;
        message = 'Record not found';
        break;
      case 'P2003':
        message = 'Foreign key constraint failed';
        break;
    }
    
    logger.error('Prisma Error:', {
      error: message,
      code: prismaError.code,
      meta: prismaError.meta,
      requestId,
      path: req.path,
      method: req.method
    });
    
    const errorResponse: ErrorResponse = {
      error: {
        code: `PRISMA_${prismaError.code}`,
        message,
        type: ErrorType.TECHNICAL,
        timestamp: new Date().toISOString(),
        requestId
      }
    };
    
    res.status(statusCode).json(errorResponse);
    return;
  }
  
  // Handle unexpected errors
  logger.error('Unhandled Internal Server Error:', {
    error: err.message,
    stack: err.stack,
    requestId,
    path: req.path,
    method: req.method,
    body: req.body,
    query: req.query
  });
  
  const errorResponse: ErrorResponse = {
    error: {
      code: 'INTERNAL_SERVER_ERROR',
      message: process.env.NODE_ENV === 'production' 
        ? 'An unexpected error occurred. Please try again later.' 
        : err.message,
      type: ErrorType.TECHNICAL,
      timestamp: new Date().toISOString(),
      requestId
    }
  };
  
  res.status(500).json(errorResponse);
}

/**
 * Async error handler wrapper for route handlers
 * Catches async errors and passes them to the error middleware
 */
export function asyncHandler(fn: Function) {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

/**
 * Generate a simple request ID
 */
function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

================
File: backend/src/common/middlewares/validation.middleware.ts
================
import { plainToInstance } from 'class-transformer';
import { validate, ValidationError as ClassValidationError } from 'class-validator';
import { RequestHandler } from 'express';
import { ValidationError, ErrorCode } from '../services/errors';

/**
 * Middleware para validar autom√°ticamente DTOs usando class-validator
 * @param type La clase DTO a validar
 * @param skipMissingProperties Si se deben omitir propiedades faltantes (default: false)
 * @returns Express middleware
 */
export function validationMiddleware(
  type: any,
  skipMissingProperties = false
): RequestHandler {
  return async (req, _res, next) => {
    try {
      // Transformar el body a la instancia del DTO
      const dto = plainToInstance(type, req.body);
      
      // Validar el DTO
      const errors: ClassValidationError[] = await validate(dto as object, {
        skipMissingProperties,
        whitelist: true, // Remover propiedades no definidas en el DTO
        forbidNonWhitelisted: true, // Lanzar error si hay propiedades no definidas
      });

      if (errors.length > 0) {
        // Formatear mensajes de error
        const messages = errors.map((error: ClassValidationError) => {
          const constraints = error.constraints || {};
          return `${error.property}: ${Object.values(constraints).join(', ')}`;
        });
        
        next(new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          `Validation failed: ${messages.join('; ')}`
        ));
      } else {
        // Reemplazar req.body con el DTO validado y transformado
        req.body = dto;
        next();
      }
    } catch (error) {
      next(error);
    }
  };
}

/**
 * Middleware para validar query parameters
 */
export function queryValidationMiddleware(
  type: any,
  skipMissingProperties = false
): RequestHandler {
  return async (req, _res, next) => {
    try {
      const dto = plainToInstance(type, req.query);
      const errors: ClassValidationError[] = await validate(dto as object, {
        skipMissingProperties,
        whitelist: true,
        forbidNonWhitelisted: true,
      });

      if (errors.length > 0) {
        const messages = errors.map((error: ClassValidationError) => {
          const constraints = error.constraints || {};
          return `${error.property}: ${Object.values(constraints).join(', ')}`;
        });
        
        next(new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          `Query validation failed: ${messages.join('; ')}`
        ));
      } else {
        req.query = dto as any;
        next();
      }
    } catch (error) {
      next(error);
    }
  };
}

================
File: backend/src/common/services/errors/CustomErrors.ts
================
import { ErrorCode, ErrorType, ErrorContext } from './types';

export class BaseError extends Error {
  constructor(
    public code: ErrorCode,
    public type: ErrorType,
    message: string,
    public context?: ErrorContext
  ) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
}

export class BusinessLogicError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.BUSINESS_LOGIC, message, context);
    this.name = 'BusinessLogicError';
  }
}

export class ValidationError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.VALIDATION, message, context);
    this.name = 'ValidationError';
  }
}

export class TechnicalError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.TECHNICAL, message, context);
    this.name = 'TechnicalError';
  }
}

export class ExternalServiceError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.EXTERNAL_SERVICE, message, context);
    this.name = 'ExternalServiceError';
  }
}

export class NotFoundError extends BaseError {
  constructor(code: ErrorCode, message: string, context?: ErrorContext) {
    super(code, ErrorType.BUSINESS_LOGIC, message, context);
    this.name = 'NotFoundError';
  }
}

export class RateLimitError extends BaseError {
  constructor(message: string, context?: ErrorContext) {
    super(ErrorCode.RATE_LIMIT_EXCEEDED, ErrorType.RATE_LIMIT, message, context);
    this.name = 'RateLimitError';
  }
}

================
File: backend/src/common/types/restaurant.ts
================
/**
 * Tipo para la informaci√≥n del restaurante
 * Usado en predefinedMessages.ts
 */
export interface RestaurantInfo {
  restaurantName: string;
  phoneMain: string;
  phoneSecondary: string;
  address: string;
  city: string;
  state: string;
  postalCode: string;
}

================
File: backend/src/dto/address/get-addresses-query.dto.ts
================
import { IsOptional, IsBoolean } from 'class-validator';
import { Transform } from 'class-transformer';

export class GetAddressesQueryDto {
  @IsOptional()
  @Transform(({ value }: { value: any }) => value === 'true')
  @IsBoolean()
  includeInactive?: boolean;
}

================
File: backend/src/dto/whatsapp/send-message.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class SendMessageDto {
  @IsNotEmpty({ message: 'to is required' })
  @IsString({ message: 'to must be a string' })
  to!: string;

  @IsNotEmpty({ message: 'message is required' })
  @IsString({ message: 'message must be a string' })
  message!: string;
}

================
File: backend/src/services/ai/index.ts
================
export * from './GeminiService';
export * from './AgentService';
export * from './MenuSearchService';

================
File: backend/src/services/ai/prompts/generalAgent.prompt.ts
================
/**
 * General Agent prompt template
 * Handles general queries, intent detection, and routing to appropriate tools
 */
export function getGeneralAgentPrompt(menuJson: string, restaurantName: string): string {
  return `
      Eres un asistente virtual de ${restaurantName}. Tu funci√≥n es ayudar a los clientes con sus consultas y pedidos.
      
      REGLAS ESTRICTAS:
      - SOLO puedes proporcionar informaci√≥n que est√° en tu contexto o usar las herramientas disponibles
      - NO inventes informaci√≥n sobre productos, precios, ingredientes o disponibilidad
      - NO asumas o adivines caracter√≠sticas de productos que no est√°n en tu contexto
      - Si no tienes informaci√≥n espec√≠fica, indica al cliente que no dispones de esa informaci√≥n
      - NUNCA proporciones precios individuales, solo a trav√©s de la herramienta "send_menu"
      
      1. DETECTAR INTENCI√ìN:
         - Si el cliente quiere ordenar algo, usa la herramienta "prepare_order_context"
         - Si es una consulta general, responde directamente
      
      2. CONSULTAS GENERALES:
         - Men√∫ completo con precios: usa "send_menu" 
         - Informaci√≥n del restaurante: usa "get_business_hours"
         - Tiempos de espera: usa "get_wait_times"
         - Actualizar direcci√≥n: usa "generate_address_update_link"
         - Instrucciones del bot: usa "send_bot_instructions"
         - Para otras consultas: responde SOLO con informaci√≥n disponible en tu contexto
      
      3. DETECCI√ìN DE √ìRDENES:
         Cuando detectes intenci√≥n de ordenar (palabras clave: quiero, pedir, ordenar, dame, tr√°eme, etc.):
         
         PRIMERO: Verifica el tipo de orden
         - Si el cliente NO ha especificado si es para llevar o entrega a domicilio:
           * PREGUNTA: "¬øTu pedido es para entrega a domicilio o para recoger en el restaurante?"
           * NO ejecutes "prepare_order_context" hasta tener esta informaci√≥n
         
         - Detecta el tipo de orden SOLO cuando el cliente lo especifique:
           * DELIVERY: "a domicilio", "env√≠o", "traer", "mi casa", "mi direcci√≥n", "que me lo traigan"
           * TAKE_AWAY: "para llevar", "recoger", "paso por", "voy por", "lo recojo"
         
         DESPU√âS de confirmar el tipo de orden:
         - Extrae TODOS los art√≠culos mencionados
         - Incluye cantidades si las menciona
         - USA "prepare_order_context" con el tipo de orden confirmado
         
         NUNCA asumas el tipo de orden - SIEMPRE debe ser especificado por el cliente
      
      4. ACTUALIZACI√ìN DE DIRECCI√ìN:
         Si el cliente quiere actualizar su direcci√≥n o agregar una nueva direcci√≥n de entrega:
         - Usa "generate_address_update_link" para generar un enlace seguro
         - NO agregues mensajes adicionales, la herramienta ya env√≠a el mensaje interactivo
      
      5. INSTRUCCIONES DEL BOT:
         Si el cliente pregunta c√≥mo usar el bot, c√≥mo funciona, qu√© puede hacer, o necesita ayuda:
         - Usa "send_bot_instructions" para enviar las instrucciones completas
         - Detecta preguntas como: "c√≥mo usar", "c√≥mo funciona", "qu√© puedo hacer", "ayuda", "tutorial", "instrucciones"
      
      6. RESETEAR CONVERSACI√ìN:
         Si el cliente quiere reiniciar la conversaci√≥n o borrar el historial:
         - Usa "reset_conversation" para limpiar el contexto
         - Detecta frases como: "olvida lo anterior", "reinicia la conversaci√≥n", "borra el historial", "empecemos de nuevo", "olvida todo", "reinicia el chat"
      
      LIMITACIONES Y RESTRICCIONES:
      - Solo puedes responder sobre productos que existen en el men√∫
      - No puedes inventar o sugerir productos que no est√°n disponibles
      - No puedes modificar ingredientes base de los productos
      - No puedes prometer tiempos de entrega espec√≠ficos fuera de los establecidos
      - No puedes ofrecer descuentos o promociones no autorizadas
      - Si el cliente pide algo que no est√° en el men√∫, debes indicarlo claramente
      
      MANEJO DE ERRORES:
      - Si no entiendes la solicitud: pide aclaraci√≥n de manera amable
      - Si el producto no existe: sugiere alternativas del men√∫ disponible
      - Si hay ambig√ºedad: pregunta para confirmar antes de proceder
      
      IMPORTANTE:
      - Responde siempre en espa√±ol
      - S√© cordial y profesional pero mantente dentro de tus capacidades
      - Para √≥rdenes, NO intentes mapear productos, solo extrae lo que el cliente dice
      - NUNCA proporciones precios individuales bajo ninguna circunstancia
      - Si preguntan por precios, SIEMPRE ejecuta "send_menu"
      
      ESTRUCTURA DEL MEN√ö DISPONIBLE:
      ${menuJson}
      
      Esta estructura muestra TODO lo que puedes ofrecer. Si algo no est√° aqu√≠, NO lo ofrezcas.
      √ösala para validar las solicitudes del cliente y sugerir alternativas v√°lidas.
    `;
}

================
File: backend/src/services/ai/prompts/index.ts
================
/**
 * AI Agent Prompts
 * Centralized export for all agent prompt templates
 */
export { getGeneralAgentPrompt } from './generalAgent.prompt';
export { getOrderAgentPrompt } from './orderAgent.prompt';

================
File: backend/src/services/ai/tools/generalAgent.tools.ts
================
/**
 * General Agent tool definitions
 * These tools are available to the general agent for handling various customer requests
 */

export function getGeneralAgentTools(): any[] {
  return [
    {
      name: "send_menu",
      description: "Env√≠a el men√∫ completo al usuario cuando lo solicite",
      parameters: {
        type: "object",
        properties: {}
      }
    },
    {
      name: "get_business_hours",
      description: "Obtiene informaci√≥n completa del restaurante incluyendo ubicaci√≥n, tel√©fonos y horarios",
      parameters: {
        type: "object",
        properties: {}
      }
    },
    {
      name: "get_wait_times",
      description: "Obtiene los tiempos de espera estimados para recolecci√≥n y entrega a domicilio",
      parameters: {
        type: "object",
        properties: {}
      }
    },
    {
      name: "prepare_order_context",
      description: "Prepara el contexto para procesar una orden cuando el cliente quiere pedir algo",
      parameters: {
        type: "object",
        properties: {
          itemsSummary: {
            type: "string",
            description: "Lista de todos los art√≠culos que el cliente mencion√≥ (ej: '2 pizzas hawaianas grandes, 1 coca cola, papas fritas')"
          },
          orderType: {
            type: "string", 
            enum: ["DELIVERY", "TAKE_AWAY"],
            description: "Tipo de orden: DELIVERY (entrega a domicilio), TAKE_AWAY (para llevar/recoger)"
          }
        },
        required: ["itemsSummary", "orderType"]
      }
    },
    {
      name: "generate_address_update_link",
      description: "Genera un enlace seguro para que el cliente actualice o agregue una direcci√≥n de entrega",
      parameters: {
        type: "object",
        properties: {
          reason: {
            type: "string",
            description: "Raz√≥n por la cual el cliente quiere actualizar la direcci√≥n"
          }
        }
      }
    },
    {
      name: "send_bot_instructions",
      description: "Env√≠a las instrucciones completas de c√≥mo usar el bot cuando el cliente lo solicite",
      parameters: {
        type: "object",
        properties: {}
      }
    },
    {
      name: "reset_conversation",
      description: "Reinicia la conversaci√≥n y borra el historial relevante cuando el cliente lo solicite",
      parameters: {
        type: "object",
        properties: {}
      }
    }
  ];
}

================
File: backend/src/services/ai/tools/index.ts
================
/**
 * AI Agent Tools
 * Centralized export for all agent tool definitions
 */
export { getGeneralAgentTools } from './generalAgent.tools';
export { getOrderAgentTools } from './orderAgent.tools';

================
File: backend/src/services/messaging/index.ts
================
export * from './types';
export { MessageContext } from './MessageContext';
export * from './pipeline/MessagePipeline';
export * from './MessageProcessor';

// Export middlewares
export * from './middlewares/RateLimitMiddleware';
export * from './middlewares/CustomerValidationMiddleware';
export * from './middlewares/MessageTypeMiddleware';

================
File: backend/src/services/messaging/MessageProcessor.ts
================
import { MessagePipeline } from './pipeline/MessagePipeline';
import { IncomingMessage } from './types';
import logger from '../../common/utils/logger';

// Esta clase proporciona una interfaz simple para procesar mensajes de WhatsApp
// a trav√©s de nuestro pipeline de procesamiento de mensajes

export class MessageProcessor {
  private static pipeline: MessagePipeline | null = null;
  
  static getPipeline(): MessagePipeline {
    if (!this.pipeline) {
      this.pipeline = new MessagePipeline();
    }
    return this.pipeline;
  }
  
  // Este m√©todo procesa los mensajes entrantes a trav√©s del pipeline
  static async processWithPipeline(message: any): Promise<void> {
    try {
      // Convertir el formato del mensaje al formato del pipeline
      const incomingMessage: IncomingMessage = {
        id: message.id,
        from: message.from,
        type: message.type,
        timestamp: message.timestamp,
        text: message.text,
        interactive: message.interactive,
        audio: message.audio
      };
      
      // Procesar con el pipeline
      await this.getPipeline().process(incomingMessage);
    } catch (error) {
      logger.error('Error in MessageProcessor:', error);
      throw error; // Dejar que el llamador maneje el error
    }
  }
}

================
File: backend/src/services/messaging/middlewares/MessageProcessingMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { MessageStrategy } from '../strategies/MessageStrategy';
import { TextMessageStrategy } from '../strategies/TextMessageStrategy';
import { InteractiveMessageStrategy } from '../strategies/InteractiveMessageStrategy';
import { AudioMessageStrategy } from '../strategies/AudioMessageStrategy';
import logger from '../../../common/utils/logger';

export class MessageProcessingMiddleware implements MessageMiddleware {
  name = 'MessageProcessingMiddleware';
  
  private strategies: MessageStrategy[] = [
    new AudioMessageStrategy(),      // Audio primero para convertir a texto
    new InteractiveMessageStrategy(), // Mensajes interactivos
    new TextMessageStrategy(),        // Mensajes de texto
  ];
  
  async process(context: MessageContext): Promise<MessageContext> {
    try {
      // Encontrar la estrategia apropiada
      for (const strategy of this.strategies) {
        if (strategy.canHandle(context)) {
          await strategy.execute(context);
          
          // Si el audio se convirti√≥ a texto, continuar procesando
          if (strategy.name === 'AudioMessageStrategy' && context.message.type === 'text') {
            continue;
          }
          
          break;
        }
      }
      
      return context;
    } catch (error) {
      logger.error('Error in MessageProcessingMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/middlewares/RestaurantHoursMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { RestaurantService } from '../../restaurant/RestaurantService';
import { sendWhatsAppMessage } from '../../whatsapp';
import { RESTAURANT_CLOSED_MESSAGE } from '../../../common/config/predefinedMessages';
import { getFormattedBusinessHours } from '../../../common/utils/timeUtils';
import logger from '../../../common/utils/logger';
import { getCurrentMexicoTime } from '../../../common/utils/timeUtils';

export class RestaurantHoursMiddleware implements MessageMiddleware {
  name = 'RestaurantHoursMiddleware';

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      // Get restaurant configuration
      const config = await RestaurantService.getConfig();
      
      // Check if restaurant is accepting orders
      if (!config.acceptingOrders) {
        const formattedHours = await getFormattedBusinessHours();
        const closedMessage = RESTAURANT_CLOSED_MESSAGE(formattedHours);
        await sendWhatsAppMessage(context.message.from, closedMessage);
        context.stop();
        return context;
      }

      // Get current restaurant time
      const currentTime = await getCurrentMexicoTime();
      const dayOfWeek = currentTime.day();
      const currentMinutes = currentTime.hours() * 60 + currentTime.minutes();

      // Get business hours for today
      const businessHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
      
      if (!businessHours || businessHours.isClosed || !businessHours.openingTime || !businessHours.closingTime) {
        logger.info(`Restaurant is closed on day ${dayOfWeek}`);
        const formattedHours = await getFormattedBusinessHours();
        const closedMessage = RESTAURANT_CLOSED_MESSAGE(formattedHours);
        await sendWhatsAppMessage(context.message.from, closedMessage);
        context.stop();
        return context;
      }

      // Parse opening and closing times
      const [openHour, openMinute] = businessHours.openingTime.split(':').map(Number);
      const [closeHour, closeMinute] = businessHours.closingTime.split(':').map(Number);
      
      const openTime = openHour * 60 + openMinute;
      const closeTime = closeHour * 60 + closeMinute;
      
      // Apply grace periods
      const effectiveOpenTime = openTime + (config.openingGracePeriod || 0);
      const effectiveCloseTime = closeTime - (config.closingGracePeriod || 0);

      // Check if current time is within operating hours (with grace periods)
      if (currentMinutes < effectiveOpenTime || currentMinutes > effectiveCloseTime) {
        logger.info(`Restaurant hours check failed: current=${currentMinutes}, open=${effectiveOpenTime}, close=${effectiveCloseTime}`);
        
        // Check if we're in a grace period
        let message: string;
        if (currentMinutes >= openTime && currentMinutes < effectiveOpenTime) {
          // In opening grace period
          const minutesUntilOpen = effectiveOpenTime - currentMinutes;
          message = `‚è∞ ¬°Buenos d√≠as! Aunque nuestro restaurante ya abri√≥, todav√≠a no estamos recibiendo pedidos.

üïê Comenzaremos a tomar pedidos en ${minutesUntilOpen} minutos.

üìç *Horario de hoy:*
Apertura: ${businessHours.openingTime}
Inicio de pedidos: ${Math.floor(effectiveOpenTime / 60)}:${(effectiveOpenTime % 60).toString().padStart(2, '0')}
Cierre de pedidos: ${Math.floor(effectiveCloseTime / 60)}:${(effectiveCloseTime % 60).toString().padStart(2, '0')}
Cierre: ${businessHours.closingTime}

¬°Gracias por tu paciencia! üôè`;
        } else if (currentMinutes > effectiveCloseTime && currentMinutes <= closeTime) {
          // In closing grace period
          message = `‚è∞ Lo sentimos, ya no estamos recibiendo nuevos pedidos por hoy.

üïê Dejamos de tomar pedidos ${config.closingGracePeriod} minutos antes del cierre para garantizar la calidad del servicio.

üìç *Horario de hoy:*
√öltimo pedido: ${Math.floor(effectiveCloseTime / 60)}:${(effectiveCloseTime % 60).toString().padStart(2, '0')}
Cierre: ${businessHours.closingTime}

¬°Te esperamos ma√±ana! üòä`;
        } else {
          // Outside business hours completely
          const formattedHours = await getFormattedBusinessHours();
          const closedMessage = RESTAURANT_CLOSED_MESSAGE(formattedHours);
          message = closedMessage;
        }
        
        await sendWhatsAppMessage(context.message.from, message);
        context.stop();
        return context;
      }

      // Restaurant is open, continue processing
      return context;
    } catch (error) {
      logger.error('Error in RestaurantHoursMiddleware:', error);
      // In case of error, allow message to continue (fail open)
      return context;
    }
  }
}

================
File: backend/src/services/messaging/README.md
================
# Pipeline de Procesamiento de Mensajes

Este sistema de pipeline permite un procesamiento de mensajes modular y mantenible para el bot de WhatsApp.

## Arquitectura

### Pipeline Principal
- `MessagePipeline`: Orquesta el flujo de procesamiento de mensajes
- `MessageContext`: Contiene toda la informaci√≥n del mensaje y su procesamiento
- `MessageProcessor`: Interfaz principal para procesar mensajes de WhatsApp

### Middlewares
Los middlewares se ejecutan en orden y cada uno puede:
- Modificar el contexto
- Detener el procesamiento (`context.stop()`)
- Agregar respuestas
- Manejar errores

#### Middlewares Actuales:
1. **RateLimitMiddleware**: Controla el l√≠mite de mensajes por usuario
2. **CustomerValidationMiddleware**: Valida y carga informaci√≥n del cliente
3. **MessageTypeMiddleware**: Maneja diferentes tipos de mensajes y mensajes de bienvenida

## Uso

### Flujo de Procesamiento

1. **Webhook de WhatsApp** ‚Üí `messageProcessor.ts`
2. **MessageProcessor** convierte el mensaje al formato del pipeline
3. **Pipeline** ejecuta los middlewares en orden:
   - Crea un `MessageContext`
   - Ejecuta cada middleware
   - Procesa el mensaje seg√∫n su tipo
   - Env√≠a respuestas
   - Actualiza el historial del chat

### Agregar Nuevos Middlewares

```typescript
// Crear el middleware
export class MyMiddleware implements MessageMiddleware {
  name = 'MyMiddleware';
  
  async process(context: MessageContext): Promise<MessageContext> {
    // Tu l√≥gica aqu√≠
    return context;
  }
}

// Agregarlo al pipeline
pipeline.addMiddleware(new MyMiddleware());
```

## Estructura de Estrategias

### Estrategias de Procesamiento
- **TextMessageStrategy**: Procesa mensajes de texto con AI
- **InteractiveMessageStrategy**: Maneja botones y listas interactivas
- **AudioMessageStrategy**: Transcribe audio a texto usando Gemini

### Extensibilidad
Para agregar soporte a nuevos tipos de mensajes, simplemente crea una nueva estrategia que extienda `MessageStrategy`.

## Ventajas del Sistema

1. **Modularidad**: Cada responsabilidad en su propio middleware
2. **Testabilidad**: F√°cil testear cada componente por separado
3. **Mantenibilidad**: C√≥digo m√°s limpio y organizado
4. **Extensibilidad**: F√°cil agregar nuevas funcionalidades
5. **Escalabilidad**: Dise√±ado para crecer con nuevos requerimientos

## Debugging

El pipeline incluye logs detallados:
```
DEBUG: Running middleware: RateLimitMiddleware
DEBUG: Running middleware: CustomerValidationMiddleware
DEBUG: Pipeline stopped by middleware: RateLimitMiddleware
```

Esto facilita identificar d√≥nde ocurren problemas.

================
File: backend/src/services/messaging/strategies/InteractiveMessageStrategy.ts
================
import { MessageStrategy } from './MessageStrategy';
import { MessageContext } from '../MessageContext';
import { handleInteractiveMessage } from '../../../whatsapp/handlers/interactiveMessageHandler';
import logger from '../../../common/utils/logger';

export class InteractiveMessageStrategy extends MessageStrategy {
  name = 'InteractiveMessageStrategy';
  
  canHandle(context: MessageContext): boolean {
    return context.message.type === 'interactive';
  }
  
  async execute(context: MessageContext): Promise<void> {
    try {
      // Delegar al manejador de mensajes interactivos existente
      await handleInteractiveMessage(context.message.from, context.message);
      
      // Detener procesamiento adicional ya que los mensajes interactivos se manejan completamente
      context.stop();
    } catch (error) {
      logger.error('Error handling interactive message:', error);
      // El manejo de errores ya se hace en handleInteractiveMessage
      context.stop();
    }
  }
}

================
File: backend/src/services/whatsapp/index.ts
================
/**
 * Central export file for WhatsApp functionality
 * Re-exports commonly used functions for easier imports
 */

// Re-export from WhatsAppService
export { 
  WhatsAppService,
  WhatsAppService as default 
} from './WhatsAppService';

// Re-export specific WhatsApp functions
import { WhatsAppService } from './WhatsAppService';

export const sendWhatsAppMessage = WhatsAppService.sendWhatsAppMessage.bind(WhatsAppService);
export const sendWhatsAppInteractiveMessage = WhatsAppService.sendInteractiveMessage.bind(WhatsAppService);
export const sendMessageWithUrlButton = WhatsAppService.sendMessageWithUrlButton.bind(WhatsAppService);
export const getWhatsAppMediaUrl = WhatsAppService.getMediaUrl.bind(WhatsAppService);
export const downloadWhatsAppMedia = WhatsAppService.downloadMedia.bind(WhatsAppService);
export const verifyWhatsAppWebhook = WhatsAppService.verifyWebhook.bind(WhatsAppService);
export const handleWhatsAppWebhook = WhatsAppService.handleWebhook.bind(WhatsAppService);

================
File: backend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": ".",
    "strict": true,
    "strictPropertyInitialization": false,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "types": ["node"],
    "allowJs": true,
    "noEmit": false,
    "incremental": true,
    "sourceMap": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*", "prisma/seed.ts"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "transpileOnly": true,
    "files": true,
    "compilerOptions": {
      "module": "commonjs"
    }
  }
}

================
File: docker-compose.yml
================
services:
  postgres:
    image: pgvector/pgvector:pg15
    container_name: postgres_bot_backend
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: bot_db
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backend/scripts/init-pgvector.sql:/docker-entrypoint-initdb.d/01-init-pgvector.sql
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: redis_bot_backend
    ports:
      - "6380:6379"
    restart: unless-stopped

volumes:
  postgres_data:

================
File: frontend-app/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Environment variables
.env
.env.local
.env.production

================
File: frontend-app/eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: frontend-app/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/delivery-address.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Registro de Direcci√≥n</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: frontend-app/package.json
================
{
  "name": "frontend-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@googlemaps/js-api-loader": "^1.16.8",
    "@hookform/resolvers": "^5.1.1",
    "@react-google-maps/api": "^2.20.6",
    "@tanstack/react-query": "^5.80.10",
    "@tanstack/react-query-devtools": "^5.80.10",
    "@types/node": "^24.0.3",
    "axios": "^1.9.0",
    "clsx": "^2.1.1",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.57.0",
    "react-hot-toast": "^2.5.2",
    "react-router-dom": "^7.6.2",
    "yup": "^1.6.1",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@tailwindcss/postcss": "^4.1.10",
    "@types/google.maps": "^3.58.1",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.4.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "postcss": "^8.5.5",
    "tailwindcss": "^4.1.10",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5"
  }
}

================
File: frontend-app/postcss.config.js
================
export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}

================
File: frontend-app/public/delivery-address.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" fill="none">
  <!-- Background circle with gradient -->
  <defs>
    <linearGradient id="bgGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#f97316;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#ec4899;stop-opacity:1" />
    </linearGradient>
  </defs>
  <circle cx="16" cy="16" r="15" fill="url(#bgGradient)" stroke="#ea580c" stroke-width="2"/>
  
  <!-- Location pin -->
  <path d="M16 6c-4 0-7.5 3.5-7.5 7.5c0 5.25 7.5 13 7.5 13s7.5-7.75 7.5-13c0-4-3.5-7.5-7.5-7.5z" fill="white" opacity="0.95"/>
  
  <!-- Inner circle -->
  <circle cx="16" cy="13.5" r="3" fill="#f97316"/>
  
  <!-- House icon inside pin -->
  <path d="M16 11.5l-2 1.5v2.5h1.5v-1.5h1v1.5h1.5v-2.5l-2-1.5z" fill="white"/>
  <path d="M14.5 11l1.5-1l1.5 1" fill="none" stroke="white" stroke-width="0.5"/>
</svg>

================
File: frontend-app/README.md
================
# Frontend - Formulario de Direcci√≥n de Entrega

Aplicaci√≥n frontend construida con Vite + React + TypeScript para el registro de direcciones de entrega.

## üöÄ Tecnolog√≠as

- **Vite** - Build tool ultra-r√°pido
- **React 18** - Biblioteca UI
- **TypeScript** - Type safety
- **Tailwind CSS** - Estilos utility-first
- **React Hook Form + Yup** - Manejo de formularios y validaci√≥n
- **React Google Maps** - Integraci√≥n con Google Maps
- **Axios** - Cliente HTTP
- **React Hot Toast** - Notificaciones

## üì¶ Instalaci√≥n

```bash
npm install
```

## üîß Configuraci√≥n

1. Copia el archivo `.env.example` a `.env`:
```bash
cp .env.example .env
```

2. Configura las variables de entorno:
```env
VITE_API_URL=http://localhost:3001
VITE_GOOGLE_MAPS_API_KEY=tu-api-key
VITE_BOT_WHATSAPP_NUMBER=521234567890
VITE_POLYGON_COORDS='[{"lat": 20.54, "lng": -102.79}]'
```

## üõ†Ô∏è Scripts

```bash
# Desarrollo
npm run dev

# Build para producci√≥n
npm run build

# Preview de producci√≥n
npm run preview

# Type checking
npm run type-check

# Linting
npm run lint
```

## üìÅ Estructura

```
src/
‚îú‚îÄ‚îÄ components/       # Componentes React
‚îÇ   ‚îú‚îÄ‚îÄ AddressForm/  # Formulario de direcci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Map/          # Componente de mapa
‚îÇ   ‚îî‚îÄ‚îÄ ui/           # Componentes UI reutilizables
‚îú‚îÄ‚îÄ services/         # Servicios API
‚îú‚îÄ‚îÄ types/            # Tipos TypeScript
‚îú‚îÄ‚îÄ hooks/            # Custom hooks
‚îî‚îÄ‚îÄ utils/            # Utilidades
```

## üåê Caracter√≠sticas

- ‚úÖ Formulario de direcci√≥n con validaci√≥n
- ‚úÖ Integraci√≥n con Google Maps
- ‚úÖ Autocompletado de direcciones
- ‚úÖ Geolocalizaci√≥n
- ‚úÖ Validaci√≥n de √°rea de entrega
- ‚úÖ Soporte para actualizaci√≥n de direcciones
- ‚úÖ Notificaciones via WhatsApp
- ‚úÖ Dise√±o responsive

## üîó URLs

La aplicaci√≥n espera los siguientes par√°metros en la URL:
- `from`: ID del cliente
- `otp`: Token de verificaci√≥n
- `preOrderId`: (opcional) ID de preorden para actualizar

Ejemplo:
```
http://localhost:3000/?from=521234567890@c.us&otp=123456
```

## üöÄ Despliegue

1. Build de producci√≥n:
```bash
npm run build
```

2. Los archivos de producci√≥n estar√°n en `dist/`

3. Puedes servir los archivos est√°ticos con cualquier servidor web (Nginx, Apache, etc.)

================
File: frontend-app/src/app.css
================
@import "tailwindcss";

/* Custom styles if needed */

================
File: frontend-app/src/components/AddressForm/index.ts
================
export { AddressForm } from './AddressForm';

================
File: frontend-app/src/components/BasicMap/index.ts
================
export { BasicMap } from './BasicMap';

================
File: frontend-app/src/i18n/translations.ts
================
export const translations = {
  'es-MX': {
    common: {
      loading: 'Cargando...',
      error: 'Error',
      success: '√âxito',
      save: 'Guardar',
      cancel: 'Cancelar',
      continue: 'Continuar',
      back: 'Atr√°s',
      close: 'Cerrar',
    },
    otp: {
      verifying: 'Verificando enlace...',
      invalidLink: 'Enlace inv√°lido',
      expiredLink: 'Este enlace ha expirado o no es v√°lido. Por favor, solicita un nuevo enlace desde WhatsApp.',
      continueWhatsApp: 'Continuar en WhatsApp',
    },
    address: {
      title: 'Registrar Direcci√≥n de Entrega',
      updateTitle: 'Actualizar Direcci√≥n',
      welcome: '¬°Hola{name}! Por favor completa tu informaci√≥n de entrega.',
      yourNumber: 'Tu n√∫mero: {number}',
      useMyLocation: 'Usar mi ubicaci√≥n actual',
      searchPlaceholder: 'Busca tu direcci√≥n en M√©xico...',
      mapError: 'Error al cargar el mapa. Por favor, recarga la p√°gina.',
      locationError: 'No se pudo obtener tu ubicaci√≥n',
      addressDetails: 'Detalles de la direcci√≥n',
      
      // Form fields
      street: 'Calle y n√∫mero',
      neighborhood: 'Colonia',
      zipCode: 'C√≥digo postal',
      city: 'Ciudad',
      state: 'Estado',
      country: 'Pa√≠s',
      references: 'Referencias para encontrar tu domicilio',
      referencesPlaceholder: 'Entre calles, color de casa, puntos de referencia...',
      
      // Messages
      selectLocation: 'Por favor, selecciona una ubicaci√≥n en el mapa',
      completeFields: 'Por favor completa todos los campos requeridos',
      outOfDeliveryArea: 'La direcci√≥n est√° fuera del √°rea de entrega',
      savingAddress: 'Guardando direcci√≥n...',
      updatingAddress: 'Actualizando direcci√≥n...',
      addressSaved: 'Direcci√≥n guardada exitosamente',
      addressUpdated: 'Direcci√≥n actualizada exitosamente',
      redirecting: 'Redirigiendo a WhatsApp...',
      errorSaving: 'Error al guardar la direcci√≥n',
      errorUpdating: 'Error al actualizar la direcci√≥n',
    },
    geolocation: {
      notSupported: 'Tu navegador no soporta geolocalizaci√≥n',
      permissionDenied: 'Permiso de ubicaci√≥n denegado',
      positionUnavailable: 'Ubicaci√≥n no disponible',
      timeout: 'Tiempo de espera agotado',
      unknownError: 'Error desconocido al obtener ubicaci√≥n',
    },
  },
  'en-US': {
    common: {
      loading: 'Loading...',
      error: 'Error',
      success: 'Success',
      save: 'Save',
      cancel: 'Cancel',
      continue: 'Continue',
      back: 'Back',
      close: 'Close',
    },
    otp: {
      verifying: 'Verifying link...',
      invalidLink: 'Invalid link',
      expiredLink: 'This link has expired or is invalid. Please request a new link from WhatsApp.',
      continueWhatsApp: 'Continue on WhatsApp',
    },
    address: {
      title: 'Register Delivery Address',
      updateTitle: 'Update Address',
      welcome: 'Hello{name}! Please complete your delivery information.',
      yourNumber: 'Your number: {number}',
      useMyLocation: 'Use my current location',
      searchPlaceholder: 'Search for your address...',
      mapError: 'Error loading map. Please reload the page.',
      locationError: 'Could not get your location',
      addressDetails: 'Address details',
      
      // Form fields
      street: 'Street and number',
      neighborhood: 'Neighborhood',
      zipCode: 'ZIP code',
      city: 'City',
      state: 'State',
      country: 'Country',
      references: 'References to find your address',
      referencesPlaceholder: 'Between streets, house color, landmarks...',
      
      // Messages
      selectLocation: 'Please select a location on the map',
      completeFields: 'Please complete all required fields',
      outOfDeliveryArea: 'Address is outside delivery area',
      savingAddress: 'Saving address...',
      updatingAddress: 'Updating address...',
      addressSaved: 'Address saved successfully',
      addressUpdated: 'Address updated successfully',
      redirecting: 'Redirecting to WhatsApp...',
      errorSaving: 'Error saving address',
      errorUpdating: 'Error updating address',
    },
    geolocation: {
      notSupported: 'Your browser does not support geolocation',
      permissionDenied: 'Location permission denied',
      positionUnavailable: 'Location unavailable',
      timeout: 'Request timeout',
      unknownError: 'Unknown error getting location',
    },
  },
};

export type TranslationKey = keyof typeof translations['es-MX'];
export type Locale = keyof typeof translations;

================
File: frontend-app/src/index.css
================
@import "tailwindcss";

================
File: frontend-app/src/main.tsx
================
import { createRoot } from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import './index.css'
import './styles/toast-animations.css'
import Router from './Router.tsx'

// Configure React Query Client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
    mutations: {
      retry: 0,
    },
  },
});

createRoot(document.getElementById('root')!).render(
  <QueryClientProvider client={queryClient}>
    <BrowserRouter>
      <Router />
    </BrowserRouter>
    <ReactQueryDevtools initialIsOpen={false} />
  </QueryClientProvider>
)

================
File: frontend-app/src/Router.tsx
================
import { Routes, Route } from 'react-router-dom';
import AddressRegistration from './components/AddressRegistration';

function Router() {
  return (
    <Routes>
      <Route path="/" element={<div>Welcome</div>} />
      <Route path="/address-registration/:customerId" element={<AddressRegistration />} />
    </Routes>
  );
}

export default Router;

================
File: frontend-app/src/services/api.ts
================
import axios from 'axios';
import type { AxiosInstance, AxiosError } from 'axios';
import type { ApiError } from '@/types/api.types';

class ApiService {
  private api: AxiosInstance;

  constructor() {
    this.api = axios.create({
      baseURL: import.meta.env.VITE_API_URL || '',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Response interceptor for error handling
    this.api.interceptors.response.use(
      (response) => response,
      (error: AxiosError<ApiError>) => {
        const apiError: ApiError = {
          message: error.response?.data?.message || error.message || 'An error occurred',
          statusCode: error.response?.status || 500,
          error: error.response?.data?.error,
        };
        return Promise.reject(apiError);
      }
    );
  }

  get instance() {
    return this.api;
  }
}

const apiService = new ApiService();
export default apiService.instance;

================
File: frontend-app/src/styles/toast-animations.css
================
/* Custom toast animations */
@keyframes toast-enter {
  0% {
    transform: translateY(-100px) scale(0.8);
    opacity: 0;
  }
  100% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
}

@keyframes toast-exit {
  0% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translateY(-20px) scale(0.9);
    opacity: 0;
  }
}

/* Apply animations to react-hot-toast */
[data-hot-toast] {
  animation: toast-enter 0.35s cubic-bezier(0.21, 1.02, 0.73, 1) forwards;
}

[data-hot-toast][data-visible="false"] {
  animation: toast-exit 0.4s forwards;
}

/* Add a subtle pulse effect for success toasts */
[data-hot-toast][data-type="success"] {
  animation: toast-enter 0.35s cubic-bezier(0.21, 1.02, 0.73, 1) forwards, pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.02);
  }
}

/* Bounce effect for error toasts */
[data-hot-toast][data-type="error"] {
  animation: toast-enter 0.35s cubic-bezier(0.21, 1.02, 0.73, 1) forwards, shake 0.5s ease-in-out;
}

@keyframes shake {
  0%, 100% {
    transform: translateX(0);
  }
  10%, 30%, 50%, 70%, 90% {
    transform: translateX(-2px);
  }
  20%, 40%, 60%, 80% {
    transform: translateX(2px);
  }
}

/* Loading toast animation */
[data-hot-toast][data-type="loading"] svg {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

================
File: frontend-app/src/utils/loadGoogleMaps.ts
================
let isLoading = false;
let isLoaded = false;

export function loadGoogleMaps(): Promise<void> {
  return new Promise((resolve, reject) => {
    // If already loaded, resolve immediately
    if (isLoaded && window.google?.maps) {
      resolve();
      return;
    }

    // If currently loading, wait for it to complete
    if (isLoading) {
      const checkInterval = setInterval(() => {
        if (isLoaded && window.google?.maps) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
      return;
    }

    isLoading = true;

    // Check if Google Maps is already available
    if (window.google?.maps) {
      isLoaded = true;
      isLoading = false;
      resolve();
      return;
    }

    // Load Google Maps script
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${import.meta.env.VITE_GOOGLE_MAPS_API_KEY}&libraries=places,geometry`;
    script.async = true;
    script.defer = true;

    script.onload = () => {
      isLoaded = true;
      isLoading = false;
      resolve();
    };

    script.onerror = () => {
      isLoading = false;
      reject(new Error('Failed to load Google Maps'));
    };

    document.head.appendChild(script);
  });
}

================
File: frontend-app/src/utils/polygonUtils.ts
================
/**
 * Check if a point is inside a polygon using the ray casting algorithm
 * @param point The point to check
 * @param polygon The polygon vertices
 * @returns true if the point is inside the polygon
 */
export function isPointInPolygon(
  point: { lat: number; lng: number },
  polygon: { lat: number; lng: number }[]
): boolean {
  if (polygon.length < 3) return false;

  let inside = false;
  const x = point.lat;
  const y = point.lng;

  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].lat;
    const yi = polygon[i].lng;
    const xj = polygon[j].lat;
    const yj = polygon[j].lng;

    const intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    
    if (intersect) inside = !inside;
  }

  return inside;
}

/**
 * Get the center point of a polygon
 * @param polygon The polygon vertices
 * @returns The center point
 */
export function getPolygonCenter(polygon: { lat: number; lng: number }[]): { lat: number; lng: number } {
  if (polygon.length === 0) {
    return { lat: 0, lng: 0 };
  }

  let totalLat = 0;
  let totalLng = 0;

  polygon.forEach(point => {
    totalLat += point.lat;
    totalLng += point.lng;
  });

  return {
    lat: totalLat / polygon.length,
    lng: totalLng / polygon.length
  };
}

================
File: frontend-app/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: frontend-app/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: frontend-app/tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    
    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"]
}

================
File: frontend-app/tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: frontend-app/tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: frontend-app/vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    strictPort: true,
    proxy: {
      '/backend': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
  },
})

================
File: package.json
================
{
  "name": "bot_app",
  "version": "1.0.0",
  "scripts": {
    "dev": "concurrently \"npm run dev:backend\" \"npm run dev:frontend\"",
    "dev:backend": "cd backend && npm run dev",
    "dev:frontend": "cd frontend-app && npm run dev",
    "build": "cd backend && npm run build && cd ../frontend-app && npm run build",
    "start": "npm run build && concurrently \"npm run start:backend\" \"npm run start:frontend\"",
    "start:backend": "cd backend && npm start",
    "start:frontend": "cd frontend-app && npm run dev",
    "install:all": "npm install && npm --prefix backend install && npm --prefix frontend-app install"
  },
  "devDependencies": {
    "concurrently": "^7.0.0"
  },
  "dependencies": {
    "winston": "^3.15.0"
  }
}

================
File: backend/.claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(npx prisma migrate dev:*)",
      "Bash(DATABASE_URL=\"postgresql://postgres:postgres@localhost:5433/bot_db\" npx prisma migrate dev --name remove_message_rate_limit_table --create-only)",
      "Bash(powershell:*)",
      "Bash(mkdir:*)",
      "Bash(Remove-Item -Path \"C:\\Users\\Leonel\\Desktop\\bot_backend\\backend\\prisma\\migrations\" -Recurse -Force)"
    ],
    "deny": []
  }
}

================
File: backend/prisma/migrations/20250718185619_initial_migration/migration.sql
================
-- CreateExtension
CREATE EXTENSION IF NOT EXISTS "vector";

-- CreateEnum
CREATE TYPE "OrderType" AS ENUM ('DINE_IN', 'TAKE_AWAY', 'DELIVERY');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'IN_PREPARATION', 'READY', 'IN_DELIVERY', 'DELIVERED', 'COMPLETED', 'CANCELLED');

-- CreateEnum
CREATE TYPE "PaymentStatus" AS ENUM ('PENDING', 'PAID', 'FAILED', 'REFUNDED', 'CANCELLED');

-- CreateEnum
CREATE TYPE "PaymentMethod" AS ENUM ('CASH', 'CREDIT_CARD', 'DEBIT_CARD', 'TRANSFER', 'STRIPE', 'PAYPAL', 'OTHER');

-- CreateEnum
CREATE TYPE "PizzaHalf" AS ENUM ('FULL', 'HALF_1', 'HALF_2');

-- CreateEnum
CREATE TYPE "CustomizationAction" AS ENUM ('ADD', 'REMOVE');

-- CreateEnum
CREATE TYPE "CustomizationType" AS ENUM ('FLAVOR', 'INGREDIENT');

-- CreateEnum
CREATE TYPE "PreparationStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'READY', 'DELIVERED', 'CANCELLED');

-- CreateTable
CREATE TABLE "Category" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "photoId" TEXT,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Category_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Customer" (
    "id" UUID NOT NULL,
    "whatsappPhoneNumber" TEXT NOT NULL,
    "firstName" VARCHAR(100),
    "lastName" VARCHAR(100),
    "email" VARCHAR(255),
    "birthDate" DATE,
    "fullChatHistory" JSONB,
    "relevantChatHistory" JSONB,
    "stripeCustomerId" TEXT,
    "lastInteraction" TIMESTAMP(3),
    "totalOrders" INTEGER NOT NULL DEFAULT 0,
    "totalSpent" DECIMAL(10,2) NOT NULL DEFAULT 0,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "isBanned" BOOLEAN NOT NULL DEFAULT false,
    "bannedAt" TIMESTAMP(3),
    "banReason" TEXT,
    "deletedAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Customer_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Address" (
    "id" UUID NOT NULL,
    "customerId" UUID NOT NULL,
    "name" VARCHAR(100) NOT NULL,
    "street" VARCHAR(200) NOT NULL,
    "number" VARCHAR(50) NOT NULL,
    "interiorNumber" VARCHAR(50),
    "neighborhood" VARCHAR(150),
    "city" VARCHAR(100),
    "state" VARCHAR(100),
    "zipCode" VARCHAR(10),
    "country" VARCHAR(100),
    "deliveryInstructions" TEXT,
    "latitude" DECIMAL(10,8),
    "longitude" DECIMAL(11,8),
    "isDefault" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Address_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "MessageLog" (
    "id" SERIAL NOT NULL,
    "messageId" TEXT NOT NULL,
    "processed" BOOLEAN NOT NULL DEFAULT false,

    CONSTRAINT "MessageLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductModifier" (
    "id" TEXT NOT NULL,
    "modifierGroupId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "price" DOUBLE PRECISION,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "isDefault" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "ProductModifier_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ModifierGroup" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "minSelections" INTEGER NOT NULL DEFAULT 0,
    "maxSelections" INTEGER NOT NULL DEFAULT 1,
    "isRequired" BOOLEAN NOT NULL DEFAULT false,
    "allowMultipleSelections" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "ModifierGroup_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Order" (
    "id" UUID NOT NULL,
    "shiftOrderNumber" INTEGER,
    "orderType" "OrderType" NOT NULL,
    "orderStatus" "OrderStatus" NOT NULL DEFAULT 'PENDING',
    "subtotal" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "total" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "customerId" UUID NOT NULL,
    "estimatedDeliveryTime" TIMESTAMP(3),
    "scheduledAt" TIMESTAMP(3),
    "notes" TEXT,
    "isFromWhatsApp" BOOLEAN NOT NULL DEFAULT true,
    "finalizedAt" TIMESTAMP(3),
    "shiftId" UUID,
    "userId" UUID,
    "tableId" UUID,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Order_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "DeliveryInfo" (
    "id" UUID NOT NULL,
    "orderId" UUID,
    "preOrderId" INTEGER,
    "name" VARCHAR(100),
    "fullAddress" TEXT,
    "street" VARCHAR(200),
    "number" VARCHAR(50),
    "interiorNumber" VARCHAR(50),
    "neighborhood" VARCHAR(150),
    "city" VARCHAR(100),
    "state" VARCHAR(100),
    "zipCode" VARCHAR(10),
    "country" VARCHAR(100),
    "recipientName" VARCHAR(255),
    "recipientPhone" VARCHAR(50),
    "deliveryInstructions" TEXT,
    "latitude" DECIMAL(10,8),
    "longitude" DECIMAL(11,8),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "DeliveryInfo_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "OrderItem" (
    "id" UUID NOT NULL,
    "orderId" UUID,
    "preOrderId" INTEGER,
    "productId" TEXT NOT NULL,
    "productVariantId" TEXT,
    "basePrice" DOUBLE PRECISION NOT NULL,
    "finalPrice" DOUBLE PRECISION NOT NULL,
    "preparationStatus" "PreparationStatus" NOT NULL DEFAULT 'PENDING',
    "statusChangedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "preparationNotes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "OrderItem_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PizzaCustomization" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "type" "CustomizationType" NOT NULL,
    "ingredients" TEXT,
    "toppingValue" INTEGER NOT NULL DEFAULT 1,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "PizzaCustomization_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PizzaConfiguration" (
    "id" UUID NOT NULL,
    "productId" TEXT NOT NULL,
    "includedToppings" INTEGER NOT NULL DEFAULT 4,
    "extraToppingCost" DOUBLE PRECISION NOT NULL DEFAULT 20,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "PizzaConfiguration_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PreOrder" (
    "id" SERIAL NOT NULL,
    "orderType" "OrderType" NOT NULL,
    "estimatedDeliveryTime" INTEGER NOT NULL DEFAULT 0,
    "scheduledAt" TIMESTAMP(3),
    "notes" TEXT,
    "subtotal" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "total" DOUBLE PRECISION NOT NULL DEFAULT 0,
    "whatsappPhoneNumber" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "PreOrder_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Product" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "price" DOUBLE PRECISION,
    "hasVariants" BOOLEAN NOT NULL DEFAULT false,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "isPizza" BOOLEAN NOT NULL DEFAULT false,
    "subcategoryId" TEXT NOT NULL,
    "preparationScreenId" TEXT,
    "photoId" TEXT,
    "estimatedPrepTime" INTEGER NOT NULL DEFAULT 0,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),
    "embedding" vector(768),

    CONSTRAINT "Product_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductVariant" (
    "id" TEXT NOT NULL,
    "productId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price" DOUBLE PRECISION NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "ProductVariant_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "RestaurantConfig" (
    "id" SERIAL NOT NULL,
    "restaurantName" TEXT NOT NULL DEFAULT 'La Le√±a',
    "phoneMain" TEXT,
    "phoneSecondary" TEXT,
    "address" TEXT,
    "city" TEXT,
    "state" TEXT,
    "postalCode" TEXT,
    "country" TEXT,
    "acceptingOrders" BOOLEAN NOT NULL DEFAULT true,
    "estimatedPickupTime" INTEGER NOT NULL DEFAULT 20,
    "estimatedDeliveryTime" INTEGER NOT NULL DEFAULT 40,
    "openingGracePeriod" INTEGER NOT NULL DEFAULT 30,
    "closingGracePeriod" INTEGER NOT NULL DEFAULT 30,
    "timeZone" TEXT NOT NULL DEFAULT 'America/Mexico_City',
    "deliveryCoverageArea" JSONB,

    CONSTRAINT "RestaurantConfig_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "BusinessHours" (
    "id" SERIAL NOT NULL,
    "dayOfWeek" INTEGER NOT NULL,
    "openingTime" TEXT,
    "closingTime" TEXT,
    "isClosed" BOOLEAN NOT NULL DEFAULT false,
    "restaurantConfigId" INTEGER NOT NULL,

    CONSTRAINT "BusinessHours_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SelectedPizzaCustomization" (
    "id" UUID NOT NULL,
    "orderItemId" UUID NOT NULL,
    "pizzaCustomizationId" TEXT NOT NULL,
    "half" "PizzaHalf" NOT NULL DEFAULT 'FULL',
    "action" "CustomizationAction" NOT NULL DEFAULT 'ADD',

    CONSTRAINT "SelectedPizzaCustomization_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Subcategory" (
    "id" TEXT NOT NULL,
    "categoryId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "photoId" TEXT,
    "sortOrder" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Subcategory_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SyncLog" (
    "id" TEXT NOT NULL,
    "syncType" TEXT NOT NULL,
    "recordsAffected" INTEGER NOT NULL DEFAULT 0,
    "status" TEXT NOT NULL,
    "error" TEXT,
    "startedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "SyncLog_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Payment" (
    "id" UUID NOT NULL,
    "orderId" UUID NOT NULL,
    "paymentMethod" "PaymentMethod" NOT NULL DEFAULT 'CASH',
    "amount" DECIMAL(10,2) NOT NULL,
    "status" "PaymentStatus" NOT NULL DEFAULT 'PENDING',
    "stripePaymentId" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Payment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Shift" (
    "id" UUID NOT NULL,
    "shiftDate" DATE NOT NULL,
    "shiftNumber" INTEGER NOT NULL DEFAULT 1,
    "startTime" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "endTime" TIMESTAMP(3),
    "orderCounter" INTEGER NOT NULL DEFAULT 0,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Shift_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Table" (
    "id" UUID NOT NULL,
    "tableNumber" TEXT NOT NULL,
    "capacity" INTEGER NOT NULL DEFAULT 4,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Table_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" UUID NOT NULL,
    "username" TEXT NOT NULL,
    "email" TEXT,
    "firstName" TEXT,
    "lastName" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "TicketImpression" (
    "id" UUID NOT NULL,
    "orderId" UUID NOT NULL,
    "printedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "printerName" TEXT,

    CONSTRAINT "TicketImpression_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Adjustment" (
    "id" UUID NOT NULL,
    "orderId" UUID,
    "preOrderId" INTEGER,
    "orderItemId" UUID,
    "type" TEXT NOT NULL,
    "amount" DECIMAL(10,2) NOT NULL,
    "reason" TEXT,
    "appliedBy" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Adjustment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SyncMetadata" (
    "id" TEXT NOT NULL,
    "entityType" TEXT NOT NULL,
    "entityId" TEXT NOT NULL,
    "lastModifiedAt" TIMESTAMP(3) NOT NULL,
    "modifiedBy" TEXT NOT NULL DEFAULT 'REMOTE',
    "syncPending" BOOLEAN NOT NULL DEFAULT false,
    "syncVersion" INTEGER NOT NULL DEFAULT 1,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "SyncMetadata_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_ProductModifierGroups" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_ProductModifierGroups_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateTable
CREATE TABLE "_OrderItemProductModifiers" (
    "A" UUID NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_OrderItemProductModifiers_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateTable
CREATE TABLE "_ProductPizzaCustomizations" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_ProductPizzaCustomizations_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE UNIQUE INDEX "Category_name_key" ON "Category"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Customer_whatsappPhoneNumber_key" ON "Customer"("whatsappPhoneNumber");

-- CreateIndex
CREATE UNIQUE INDEX "Customer_stripeCustomerId_key" ON "Customer"("stripeCustomerId");

-- CreateIndex
CREATE INDEX "Customer_whatsappPhoneNumber_idx" ON "Customer"("whatsappPhoneNumber");

-- CreateIndex
CREATE INDEX "Customer_email_idx" ON "Customer"("email");

-- CreateIndex
CREATE INDEX "Address_customerId_idx" ON "Address"("customerId");

-- CreateIndex
CREATE INDEX "Address_zipCode_idx" ON "Address"("zipCode");

-- CreateIndex
CREATE UNIQUE INDEX "MessageLog_messageId_key" ON "MessageLog"("messageId");

-- CreateIndex
CREATE INDEX "Order_shiftId_idx" ON "Order"("shiftId");

-- CreateIndex
CREATE INDEX "Order_tableId_idx" ON "Order"("tableId");

-- CreateIndex
CREATE INDEX "Order_userId_idx" ON "Order"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "DeliveryInfo_orderId_key" ON "DeliveryInfo"("orderId");

-- CreateIndex
CREATE UNIQUE INDEX "DeliveryInfo_preOrderId_key" ON "DeliveryInfo"("preOrderId");

-- CreateIndex
CREATE INDEX "OrderItem_orderId_idx" ON "OrderItem"("orderId");

-- CreateIndex
CREATE INDEX "OrderItem_preOrderId_idx" ON "OrderItem"("preOrderId");

-- CreateIndex
CREATE UNIQUE INDEX "PizzaConfiguration_productId_key" ON "PizzaConfiguration"("productId");

-- CreateIndex
CREATE INDEX "PreOrder_whatsappPhoneNumber_idx" ON "PreOrder"("whatsappPhoneNumber");

-- CreateIndex
CREATE UNIQUE INDEX "BusinessHours_restaurantConfigId_dayOfWeek_key" ON "BusinessHours"("restaurantConfigId", "dayOfWeek");

-- CreateIndex
CREATE UNIQUE INDEX "SelectedPizzaCustomization_orderItemId_pizzaCustomizationId_key" ON "SelectedPizzaCustomization"("orderItemId", "pizzaCustomizationId", "half", "action");

-- CreateIndex
CREATE UNIQUE INDEX "Subcategory_name_key" ON "Subcategory"("name");

-- CreateIndex
CREATE INDEX "SyncLog_syncType_idx" ON "SyncLog"("syncType");

-- CreateIndex
CREATE INDEX "SyncLog_status_idx" ON "SyncLog"("status");

-- CreateIndex
CREATE INDEX "Payment_orderId_idx" ON "Payment"("orderId");

-- CreateIndex
CREATE INDEX "Payment_status_idx" ON "Payment"("status");

-- CreateIndex
CREATE INDEX "Shift_shiftDate_idx" ON "Shift"("shiftDate");

-- CreateIndex
CREATE INDEX "Shift_startTime_idx" ON "Shift"("startTime");

-- CreateIndex
CREATE UNIQUE INDEX "Shift_shiftDate_shiftNumber_key" ON "Shift"("shiftDate", "shiftNumber");

-- CreateIndex
CREATE UNIQUE INDEX "Table_tableNumber_key" ON "Table"("tableNumber");

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE INDEX "TicketImpression_orderId_idx" ON "TicketImpression"("orderId");

-- CreateIndex
CREATE INDEX "Adjustment_orderId_idx" ON "Adjustment"("orderId");

-- CreateIndex
CREATE INDEX "Adjustment_preOrderId_idx" ON "Adjustment"("preOrderId");

-- CreateIndex
CREATE INDEX "Adjustment_orderItemId_idx" ON "Adjustment"("orderItemId");

-- CreateIndex
CREATE INDEX "SyncMetadata_syncPending_entityType_idx" ON "SyncMetadata"("syncPending", "entityType");

-- CreateIndex
CREATE INDEX "SyncMetadata_lastModifiedAt_idx" ON "SyncMetadata"("lastModifiedAt");

-- CreateIndex
CREATE INDEX "SyncMetadata_entityId_idx" ON "SyncMetadata"("entityId");

-- CreateIndex
CREATE UNIQUE INDEX "SyncMetadata_entityType_entityId_key" ON "SyncMetadata"("entityType", "entityId");

-- CreateIndex
CREATE INDEX "_ProductModifierGroups_B_index" ON "_ProductModifierGroups"("B");

-- CreateIndex
CREATE INDEX "_OrderItemProductModifiers_B_index" ON "_OrderItemProductModifiers"("B");

-- CreateIndex
CREATE INDEX "_ProductPizzaCustomizations_B_index" ON "_ProductPizzaCustomizations"("B");

-- AddForeignKey
ALTER TABLE "Address" ADD CONSTRAINT "Address_customerId_fkey" FOREIGN KEY ("customerId") REFERENCES "Customer"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductModifier" ADD CONSTRAINT "ProductModifier_modifierGroupId_fkey" FOREIGN KEY ("modifierGroupId") REFERENCES "ModifierGroup"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_customerId_fkey" FOREIGN KEY ("customerId") REFERENCES "Customer"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_shiftId_fkey" FOREIGN KEY ("shiftId") REFERENCES "Shift"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_tableId_fkey" FOREIGN KEY ("tableId") REFERENCES "Table"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DeliveryInfo" ADD CONSTRAINT "DeliveryInfo_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DeliveryInfo" ADD CONSTRAINT "DeliveryInfo_preOrderId_fkey" FOREIGN KEY ("preOrderId") REFERENCES "PreOrder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_preOrderId_fkey" FOREIGN KEY ("preOrderId") REFERENCES "PreOrder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OrderItem" ADD CONSTRAINT "OrderItem_productVariantId_fkey" FOREIGN KEY ("productVariantId") REFERENCES "ProductVariant"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "PizzaConfiguration" ADD CONSTRAINT "PizzaConfiguration_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_subcategoryId_fkey" FOREIGN KEY ("subcategoryId") REFERENCES "Subcategory"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductVariant" ADD CONSTRAINT "ProductVariant_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BusinessHours" ADD CONSTRAINT "BusinessHours_restaurantConfigId_fkey" FOREIGN KEY ("restaurantConfigId") REFERENCES "RestaurantConfig"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SelectedPizzaCustomization" ADD CONSTRAINT "SelectedPizzaCustomization_orderItemId_fkey" FOREIGN KEY ("orderItemId") REFERENCES "OrderItem"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SelectedPizzaCustomization" ADD CONSTRAINT "SelectedPizzaCustomization_pizzaCustomizationId_fkey" FOREIGN KEY ("pizzaCustomizationId") REFERENCES "PizzaCustomization"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Subcategory" ADD CONSTRAINT "Subcategory_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Payment" ADD CONSTRAINT "Payment_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "TicketImpression" ADD CONSTRAINT "TicketImpression_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Adjustment" ADD CONSTRAINT "Adjustment_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "Order"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Adjustment" ADD CONSTRAINT "Adjustment_preOrderId_fkey" FOREIGN KEY ("preOrderId") REFERENCES "PreOrder"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Adjustment" ADD CONSTRAINT "Adjustment_orderItemId_fkey" FOREIGN KEY ("orderItemId") REFERENCES "OrderItem"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductModifierGroups" ADD CONSTRAINT "_ProductModifierGroups_A_fkey" FOREIGN KEY ("A") REFERENCES "ModifierGroup"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductModifierGroups" ADD CONSTRAINT "_ProductModifierGroups_B_fkey" FOREIGN KEY ("B") REFERENCES "Product"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_OrderItemProductModifiers" ADD CONSTRAINT "_OrderItemProductModifiers_A_fkey" FOREIGN KEY ("A") REFERENCES "OrderItem"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_OrderItemProductModifiers" ADD CONSTRAINT "_OrderItemProductModifiers_B_fkey" FOREIGN KEY ("B") REFERENCES "ProductModifier"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductPizzaCustomizations" ADD CONSTRAINT "_ProductPizzaCustomizations_A_fkey" FOREIGN KEY ("A") REFERENCES "PizzaCustomization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ProductPizzaCustomizations" ADD CONSTRAINT "_ProductPizzaCustomizations_B_fkey" FOREIGN KEY ("B") REFERENCES "Product"("id") ON DELETE CASCADE ON UPDATE CASCADE;

================
File: backend/scripts/generate-embeddings.js
================
#!/usr/bin/env node

/**
 * Script to manually generate embeddings for all products
 * Can be run with: npm run seed:embeddings
 */

const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function main() {
  try {
    console.log('üöÄ Starting embedding generation...\n');
    
    // Check if products exist
    const productCount = await prisma.product.count({
      where: { isActive: true }
    });
    
    if (productCount === 0) {
      console.log('‚ùå No active products found in database');
      console.log('üí° Embeddings will be generated automatically after menu sync');
      return;
    }
    
    console.log(`Found ${productCount} active products\n`);
    
    // Import and use EmbeddingManager
    const { EmbeddingManager } = require('../dist/services/sync/EmbeddingManager');
    
    // Check current status
    const status = await EmbeddingManager.getEmbeddingStatus();
    console.log('üìä Current status:');
    console.log(`   Total products: ${status.totalProducts}`);
    console.log(`   With embeddings: ${status.productsWithEmbeddings}`);
    console.log(`   Need embeddings: ${status.productsNeedingEmbeddings}\n`);
    
    if (status.productsNeedingEmbeddings === 0) {
      console.log('‚úÖ All products already have embeddings!');
      return;
    }
    
    // Generate embeddings
    console.log('‚è≥ Generating embeddings...\n');
    const updatedCount = await EmbeddingManager.generateEmbeddingsAfterSync();
    
    // Check final status
    const finalStatus = await EmbeddingManager.getEmbeddingStatus();
    console.log('\n‚úÖ Embedding generation completed!');
    console.log(`   Generated: ${updatedCount} embeddings`);
    console.log(`   Total with embeddings: ${finalStatus.productsWithEmbeddings}/${finalStatus.totalProducts}`);
    
  } catch (error) {
    console.error('‚ùå Error generating embeddings:', error.message);
    if (error.message.includes('Cannot find module')) {
      console.error('\nüí° Make sure to build the project first: npm run build');
    }
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Check for required environment variable
if (!process.env.GOOGLE_AI_API_KEY) {
  console.error('‚ùå GOOGLE_AI_API_KEY environment variable is not set');
  console.error('üí° Add it to your .env file to enable embedding generation');
  process.exit(1);
}

main().catch(console.error);

================
File: backend/scripts/README_PGVECTOR.md
================
# pgvector Setup Documentation

## Overview
This project uses pgvector for semantic search capabilities. pgvector is a PostgreSQL extension that enables vector similarity search, which powers our AI-based menu search functionality.

## Automatic Setup
When you run `start-dev.sh` (Linux/Mac) or `start-dev.bat` (Windows), everything is configured automatically:
1. Docker Compose uses the `pgvector/pgvector:pg15` image
2. Database migrations create the vector extension and embedding column
3. Product embeddings are generated automatically when the server starts
4. Embeddings update automatically when products change

## Production Setup
For production environments (e.g., Railway), you need to enable pgvector:

1. Execute `production-pgvector-setup.sql` in your production database:
```sql
-- Enable pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- Create index for efficient similarity search
CREATE INDEX IF NOT EXISTS product_embedding_idx ON "Product" 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

2. Deploy your application - embeddings will be generated automatically on first startup

## How It Works

### Embedding Generation
- Each product gets a 768-dimensional vector embedding
- Embeddings include: name, category, subcategory, description, ingredients, variants, and modifiers
- Generated using Google's text-embedding-004 model

### Automatic Updates
- On server startup: Checks for products without embeddings
- Every hour: Checks for product changes and updates embeddings
- All embedding generation is automatic - no manual steps required

### Search Process
1. User query is converted to embedding
2. pgvector finds the 15 most similar products using cosine similarity
3. Results are returned sorted by relevance

## Troubleshooting

### "type vector does not exist" error
- Ensure you're using `pgvector/pgvector:pg15` Docker image
- Restart Docker: `docker-compose down && docker-compose up -d`
- The migration should create the extension automatically

### Embeddings not generating
- Check `GOOGLE_AI_API_KEY` is set in `.env`
- Verify pgvector is installed: `SELECT * FROM pg_extension WHERE extname = 'vector';`
- Check server logs for rate limiting errors from Google AI API

### Search returning empty results
- Verify embeddings exist: `SELECT COUNT(*) FROM "Product" WHERE embedding IS NOT NULL;`
- Restart the server - embeddings generate automatically on startup
- Check server logs for errors during embedding generation

## Performance Notes
- HNSW index provides fast similarity searches
- Initial embedding generation takes ~300ms per product (rate limited)
- Search queries typically complete in <100ms
- Index parameters: m=16, ef_construction=64 (balanced for accuracy/speed)

================
File: backend/scripts/setup-local-pgvector.sh
================
#!/bin/bash

echo "Configurando pgvector en base de datos local..."

# Verificar si pgvector est√° disponible
docker compose exec -T postgres psql -U postgres -d bot_db -c "CREATE EXTENSION IF NOT EXISTS vector;" 2>/dev/null

if [ $? -eq 0 ]; then
    echo "‚úÖ pgvector configurado exitosamente"
    exit 0
else
    echo "‚ö†Ô∏è  No se pudo configurar pgvector (la extensi√≥n podr√≠a no estar disponible)"
    exit 1
fi

================
File: backend/src/common/constants/contextKeys.ts
================
/**
 * Centralized constants for MessageContext keys
 * This prevents typos and makes refactoring easier
 */
export const CONTEXT_KEYS = {
  // Customer state
  IS_NEW_CUSTOMER: 'isNewCustomer',
  HAS_NO_ADDRESS: 'hasNoAddress',
  IS_NEW_CONVERSATION: 'isNewConversation',
  
  // Chat history
  FULL_CHAT_HISTORY: 'fullChatHistory',
  RELEVANT_CHAT_HISTORY: 'relevantChatHistory',
  SKIP_HISTORY_UPDATE: 'skipHistoryUpdate',
  
  // Message processing
  MESSAGE_TYPE: 'messageType',
  NEEDS_TRANSCRIPTION: 'needsTranscription',
  
  // PreOrder flow
  LAST_PREORDER_TOKEN: 'lastPreOrderToken',
  INTERACTIVE_RESPONSE_SENT: 'interactiveResponseSent',
  
  // Conversation state
  IS_RESETTING_CONVERSATION: 'isResettingConversation',
} as const;

// Type for context keys
export type ContextKey = typeof CONTEXT_KEYS[keyof typeof CONTEXT_KEYS];

================
File: backend/src/common/constants/index.ts
================
export * from './interactiveActions';
export * from './contextKeys';
export * from './redisKeys';

================
File: backend/src/common/constants/redisKeys.ts
================
/**
 * Centralized constants for Redis key patterns
 * This ensures consistency and prevents typos in Redis operations
 */
export const REDIS_KEYS = {
  // Rate limiting
  RATE_LIMIT_PREFIX: 'rate-limit:',
  
  // OTP verification
  OTP_PREFIX: 'otp:',
  
  // PreOrder management
  PREORDER_TOKEN_PREFIX: 'preorder:token:',
  PREORDER_UPDATING_PREFIX: 'preorder:updating:',
  
  // Message processing locks
  USER_LOCK_PREFIX: 'user-lock:',
  
  // Restaurant data caching
  RESTAURANT_CONFIG: 'restaurant:config',
  RESTAURANT_BUSINESS_HOURS: 'restaurant:business_hours',
} as const;

// Helper functions to generate Redis keys
export const redisKeys = {
  // Rate limiting
  rateLimit: (phoneNumber: string) => `${REDIS_KEYS.RATE_LIMIT_PREFIX}${phoneNumber}`,
  
  // OTP
  otp: (phoneNumber: string) => `${REDIS_KEYS.OTP_PREFIX}${phoneNumber}`,
  
  // PreOrder
  preorderToken: (token: string) => `${REDIS_KEYS.PREORDER_TOKEN_PREFIX}${token}`,
  preorderUpdating: (phoneNumber: string) => `${REDIS_KEYS.PREORDER_UPDATING_PREFIX}${phoneNumber}`,
  
  // User locks
  userLock: (userId: string) => `${REDIS_KEYS.USER_LOCK_PREFIX}${userId}`,
  
  // Restaurant (static keys)
  restaurantConfig: () => REDIS_KEYS.RESTAURANT_CONFIG,
  restaurantBusinessHours: () => REDIS_KEYS.RESTAURANT_BUSINESS_HOURS,
};

// Type for Redis keys
export type RedisKey = typeof REDIS_KEYS[keyof typeof REDIS_KEYS];

================
File: backend/src/common/middlewares/apiKeyAuth.middleware.ts
================
import { Request, Response, NextFunction } from 'express';
import { TechnicalError, ErrorCode } from '../services/errors';
import logger from '../utils/logger';

export interface ApiKeyAuthRequest extends Request {
  apiKey?: string;
}

export async function apiKeyAuthMiddleware(
  req: ApiKeyAuthRequest,
  _res: Response,
  next: NextFunction
): Promise<void> {
  try {
    // Get API key from header
    const apiKey = req.headers['x-api-key'] as string;
    
    if (!apiKey) {
      throw new TechnicalError(
        ErrorCode.AUTHENTICATION_REQUIRED,
        'API key required for this operation'
      );
    }
    
    // Validate API key against environment variable
    const validApiKey = process.env.CLOUD_API_KEY;
    
    if (!validApiKey) {
      logger.error('CLOUD_API_KEY not configured in environment');
      throw new TechnicalError(
        ErrorCode.DATABASE_ERROR,
        'API key not configured'
      );
    }
    
    if (apiKey !== validApiKey) {
      throw new TechnicalError(
        ErrorCode.INVALID_CREDENTIALS,
        'Invalid API key'
      );
    }
    
    // Store API key in request for logging/tracking
    req.apiKey = apiKey;
    
    next();
  } catch (error) {
    next(error);
  }
}

================
File: backend/src/common/middlewares/otp.middleware.ts
================
import { Request, Response, NextFunction } from 'express';
import { OTPService } from '../../services/security/OTPService';
import { prisma } from '../../lib/prisma';
import { ValidationError, NotFoundError, ErrorCode } from '../services/errors';
import { asyncHandler } from './errorHandler';

/**
 * Extended Request interface with authenticated customer
 */
export interface AuthenticatedRequest extends Request {
  customer: {
    id: string;
    whatsappPhoneNumber: string;
    firstName?: string | null;
    lastName?: string | null;
  };
}

/**
 * Middleware for OTP authentication
 * Verifies OTP and attaches customer information to the request
 * 
 * Looks for whatsappPhoneNumber and otp in:
 * 1. Request body (for POST/PUT/DELETE)
 * 2. Query parameters (for GET)
 */
export const otpAuthMiddleware = asyncHandler(async (req: Request, res: Response, next: NextFunction) => {
  // Extract whatsappPhoneNumber and otp from body or query
  let whatsappPhoneNumber: string | undefined;
  let otp: string | undefined;

  if (req.method === 'GET') {
    // For GET requests, check query parameters
    whatsappPhoneNumber = req.query.whatsappPhoneNumber as string;
    otp = req.query.otp as string;
  } else {
    // For other methods, check body
    whatsappPhoneNumber = req.body.whatsappPhoneNumber;
    otp = req.body.otp;
  }

  // Special case: if route has :customerId param that's actually a phone number
  if (!whatsappPhoneNumber && req.params.customerId && req.params.customerId.startsWith('+')) {
    whatsappPhoneNumber = req.params.customerId;
  }

  // Validate required fields
  if (!whatsappPhoneNumber || !otp) {
    throw new ValidationError(
      ErrorCode.MISSING_REQUIRED_FIELD,
      'whatsappPhoneNumber and otp are required'
    );
  }

  // Verify OTP
  const isValid = await OTPService.verifyOTP(whatsappPhoneNumber, otp);
  if (!isValid) {
    throw new ValidationError(
      ErrorCode.INVALID_OTP,
      'Invalid or expired OTP'
    );
  }

  // Get customer record
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber },
    select: {
      id: true,
      whatsappPhoneNumber: true,
      firstName: true,
      lastName: true
    }
  });

  if (!customer) {
    throw new NotFoundError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found',
      { whatsappPhoneNumber }
    );
  }

  // Attach customer to request
  (req as AuthenticatedRequest).customer = customer;
  
  next();
});

================
File: backend/src/common/services/errors/index.ts
================
export * from './types';
export * from './CustomErrors';
export * from './errorMessages';

================
File: backend/src/common/types/menu.ts
================
export interface ProductoInfo {
  productId: string;
  name: string;
  productVariants?: Array<{
    productVariantId: string;
    name: string;
  }>;
  modifierGroups?: Array<{
    modifierGroupId: string;
    name: string;
    minSelections: number;
    maxSelections: number;
    isRequired: boolean;
    allowMultipleSelections: boolean;
    productModifiers?: Array<{
      productModifierId: string;
      name: string;
    }>;
  }>;
  pizzaCustomizations?: Array<{
    pizzaCustomizationId: string;
    name: string;
    type: 'FLAVOR' | 'INGREDIENT';
    ingredients?: string;
  }>;
}

================
File: backend/src/common/types/order-item.types.ts
================
/**
 * Unified types for order items throughout the system
 * This file serves as the single source of truth for order item structures
 */

/**
 * Base structure for pizza customizations
 */
export interface PizzaCustomizationData {
  pizzaCustomizationId: string;
  half: 'FULL' | 'HALF_1' | 'HALF_2';
  action: 'ADD' | 'REMOVE';
}

/**
 * Base order item structure used throughout the system
 * This is the canonical format - no field name variations allowed
 */
export interface BaseOrderItem {
  productId: string;
  productVariantId?: string | null;
  quantity: number;
  comments?: string | null;
  selectedModifiers?: string[];
  selectedPizzaCustomizations?: PizzaCustomizationData[];
}

/**
 * Order item as it comes from the AI agent
 * We'll transform this immediately to BaseOrderItem format
 */
export interface AIOrderItem {
  productId: string;
  variantId?: string | null;  // AI uses 'variantId' instead of 'productVariantId'
  quantity: number;
  modifiers?: string[];  // AI uses 'modifiers' instead of 'selectedModifiers'
  pizzaCustomizations?: Array<{
    customizationId: string;  // AI uses 'customizationId' instead of 'pizzaCustomizationId'
    half: string;
    action: string;
  }>;
}

/**
 * Order item with calculated pricing information
 * This is what we store in the PreOrder JSON field
 */
export interface CalculatedOrderItem extends BaseOrderItem {
  basePrice: number;  // Price before modifiers
  modifiersPrice: number;  // Total price of modifiers
  unitPrice: number;  // basePrice + modifiersPrice
  totalPrice: number;  // unitPrice * quantity
  productName: string;  // For display purposes
  variantName?: string | null;  // For display purposes
  // Optional enriched data for display
  modifierNames?: string[];  // Names of selected modifiers
  pizzaCustomizationDetails?: Array<{
    pizzaCustomizationId: string;
    name: string;
    type: 'FLAVOR' | 'INGREDIENT';
    half: 'FULL' | 'HALF_1' | 'HALF_2';
    action: 'ADD' | 'REMOVE';
  }>;
}

/**
 * Order item data for creating an actual Order
 * This matches what OrderService expects
 */
export type CreateOrderItem = BaseOrderItem;

/**
 * Transform AI order item to base format
 */
export function transformAIOrderItem(aiItem: AIOrderItem): BaseOrderItem {
  return {
    productId: aiItem.productId,
    productVariantId: aiItem.variantId || null,
    quantity: aiItem.quantity || 1,
    selectedModifiers: aiItem.modifiers || [],
    selectedPizzaCustomizations: aiItem.pizzaCustomizations?.map(pc => ({
      pizzaCustomizationId: pc.customizationId,
      half: (pc.half || 'FULL') as 'FULL' | 'HALF_1' | 'HALF_2',
      action: (pc.action || 'ADD') as 'ADD' | 'REMOVE'
    })) || []
  };
}

/**
 * Transform calculated item back to base format for order creation
 */
export function extractBaseOrderItem(calculated: CalculatedOrderItem): CreateOrderItem {
  return {
    productId: calculated.productId,
    productVariantId: calculated.productVariantId,
    quantity: calculated.quantity,
    comments: calculated.comments,
    selectedModifiers: calculated.selectedModifiers,
    selectedPizzaCustomizations: calculated.selectedPizzaCustomizations
  };
}

================
File: backend/src/common/types/whatsapp-messages.types.ts
================
/**
 * Tipos consolidados para mensajes de WhatsApp
 * Este archivo unifica todas las definiciones de tipos relacionadas con WhatsApp
 */

// Tipos de mensajes entrantes
export interface IncomingMessage {
  id: string;
  from: string;
  type: 'text' | 'interactive' | 'audio' | 'image' | 'document' | 'location';
  timestamp: string;
  text?: {
    body: string;
  };
  interactive?: {
    type: 'button_reply' | 'list_reply';
    button_reply?: {
      id: string;
      title: string;
    };
    list_reply?: {
      id: string;
      title: string;
      description?: string;
    };
  };
  audio?: {
    id: string;
    mime_type: string;
  };
}

// Estructura del webhook de WhatsApp
export interface WebhookEntry {
  changes: Array<{
    value: {
      messages?: IncomingMessage[];
      messaging_product?: string;
      metadata?: {
        display_phone_number: string;
        phone_number_id: string;
      };
    };
  }>;
}

export interface WebhookBody {
  object: string;
  entry: WebhookEntry[];
}

// Tipos de mensajes salientes
export interface OutgoingTextMessage {
  messaging_product: 'whatsapp';
  to: string;
  type: 'text';
  text: { body: string };
}

export interface InteractiveButton {
  type: 'reply';
  reply: {
    id: string;
    title: string;
  };
}

export interface InteractiveSection {
  title?: string;
  rows: Array<{
    id: string;
    title: string;
    description?: string;
  }>;
}

export interface InteractiveContent {
  header?: {
    type: 'text' | 'image';
    text?: string;
    image?: {
      link: string;
    };
  };
  body: {
    text: string;
  };
  footer?: {
    text: string;
  };
  action: {
    button?: string;
    buttons?: InteractiveButton[];
    sections?: InteractiveSection[];
  };
}

export interface OutgoingInteractiveMessage {
  messaging_product: 'whatsapp';
  recipient_type: 'individual';
  to: string;
  type: 'interactive';
  interactive: InteractiveContent;
}

// Union type para cualquier mensaje saliente
export type OutgoingMessage = OutgoingTextMessage | OutgoingInteractiveMessage;

// Respuesta de la API de WhatsApp
export interface WhatsAppApiResponse {
  messages: [{
    id: string;
  }];
}

================
File: backend/src/common/utils/addressFormatter.ts
================
/**
 * Utility functions for formatting addresses consistently across the application
 */

export function formatAddressFull(address: any): string {
  const parts = [];
  
  if (address.name) {
    parts.push(`*${address.name}*`);
  }
  
  if (address.street && address.number) {
    let streetLine = `${address.street} ${address.number}`;
    if (address.interiorNumber) {
      streetLine += ` Int. ${address.interiorNumber}`;
    }
    parts.push(streetLine);
  }
  
  if (address.neighborhood) parts.push(address.neighborhood);
  
  if (address.city && address.state) {
    parts.push(`${address.city}, ${address.state}`);
  }
  
  if (address.deliveryInstructions) {
    parts.push(`Referencias: ${address.deliveryInstructions}`);
  }
  
  return parts.join('\n');
}

export function formatAddressShort(address: any): string {
  const parts = [];
  if (address.name) parts.push(`*${address.name}*`);
  parts.push(`${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}`);
  if (address.neighborhood) parts.push(address.neighborhood);
  parts.push(`${address.city}, ${address.state}`);
  return parts.join('\n');
}

export function formatAddressDescription(address: any): string {
  const parts = [];
  if (address.street && address.number) {
    parts.push(`${address.street} ${address.number}`);
  }
  if (address.neighborhood) parts.push(address.neighborhood);
  if (address.city) parts.push(address.city);
  if (address.isDefault) parts.push('(Principal)');
  return parts.join(', ');
}

================
File: backend/src/common/utils/logger.ts
================
import * as winston from 'winston';

// Helper function to format JSON for better readability
const formatJSON = (obj: any, indent = 2): string => {
  try {
    if (typeof obj === 'string') {
      // Try to parse if it's a JSON string
      try {
        const parsed = JSON.parse(obj);
        return JSON.stringify(parsed, null, indent);
      } catch {
        return obj;
      }
    }
    return JSON.stringify(obj, null, indent);
  } catch (error) {
    return String(obj);
  }
};

const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message, ...meta }) => {
      // Helper function to safely stringify objects with circular references
      const safeStringify = (obj: any, indent = 0): string => {
        const seen = new WeakSet();
        return JSON.stringify(obj, (key, value) => {
          if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
              return '[Circular Reference]';
            }
            seen.add(value);
          }
          return value;
        }, indent);
      };
      
      // Si el mensaje es un objeto, convertirlo a string
      const formattedMessage = typeof message === 'object' 
        ? safeStringify(message, 2)
        : String(message);
      
      // Si hay metadata adicional, incluirla en el log
      const metadata = Object.keys(meta).length ? `\n${safeStringify(meta, 2)}` : '';
      
      return `${timestamp} [${level}]: ${formattedMessage}${metadata}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
});

// Add helper methods for JSON logging
(logger as any).json = function(message: string, data: any) {
  this.debug(`${message}\n${formatJSON(data)}`);
};

(logger as any).jsonInfo = function(message: string, data: any) {
  this.info(`${message}\n${formatJSON(data)}`);
};

export default logger;

================
File: backend/src/common/utils/whatsappErrorHandler.ts
================
import { sendWhatsAppMessage } from '../../services/whatsapp';
import logger from './logger';
import { BaseError } from '../services/errors/CustomErrors';
import { ERROR_MESSAGES } from '../services/errors/errorMessages';

/**
 * Handles errors in WhatsApp message processing by:
 * 1. Logging the error with context
 * 2. Sending an appropriate error message to the user
 * 
 * This is specifically for WhatsApp handlers where we can't use HTTP responses
 */
export async function handleWhatsAppError(
  error: unknown,
  whatsappNumber: string,
  context: {
    userId?: string;
    operation: string;
    metadata?: any;
  }
): Promise<void> {
  // Log the error with full context
  logger.error('WhatsApp handler error:', {
    error: error instanceof Error ? {
      name: error.name,
      message: error.message,
      stack: error.stack
    } : error,
    whatsappNumber,
    context,
    timestamp: new Date().toISOString()
  });

  // Determine user message
  let userMessage: string;
  
  if (error instanceof BaseError) {
    // Use the specific error message for known errors
    const errorConfig = ERROR_MESSAGES[error.code];
    userMessage = errorConfig?.user || 'üòî Lo siento, ocurri√≥ un error. Por favor intenta de nuevo.';
  } else if (error instanceof Error) {
    // For unexpected errors, use a generic message
    userMessage = 'üòî Lo siento, ocurri√≥ un error inesperado. Por favor intenta de nuevo m√°s tarde.';
  } else {
    userMessage = 'üòî Lo siento, algo sali√≥ mal. Por favor intenta de nuevo.';
  }

  // Send error message to user
  try {
    await sendWhatsAppMessage(whatsappNumber, userMessage);
  } catch (sendError) {
    logger.error('Failed to send error message to WhatsApp user:', {
      whatsappNumber,
      originalError: error,
      sendError,
      context
    });
  }
}

/**
 * Wraps a WhatsApp handler function to automatically handle errors
 * Usage: wrapWhatsAppHandler(async (from, message) => { ... })
 */
export function wrapWhatsAppHandler<T extends any[], R>(
  handler: (...args: T) => Promise<R>,
  operation: string
): (...args: T) => Promise<R | void> {
  return async (...args: T): Promise<R | void> => {
    try {
      return await handler(...args);
    } catch (error) {
      // Assume first argument is the WhatsApp number (from)
      const whatsappNumber = args[0] as string;
      await handleWhatsAppError(error, whatsappNumber, {
        operation,
        userId: whatsappNumber
      });
    }
  };
}

================
File: backend/src/dto/address/address.dto.ts
================
import { IsNotEmpty, IsString, IsNumber, IsOptional, IsBoolean } from 'class-validator';

export class AddressDto {
  @IsNotEmpty({ message: 'El nombre de la direcci√≥n es requerido' })
  @IsString()
  name!: string;

  @IsNotEmpty({ message: 'La calle es requerida' })
  @IsString()
  street!: string;

  @IsNotEmpty({ message: 'El n√∫mero es requerido' })
  @IsString()
  number!: string;

  @IsOptional()
  @IsString()
  interiorNumber?: string;

  @IsOptional()
  @IsString()
  neighborhood?: string;

  @IsNotEmpty({ message: 'La ciudad es requerida' })
  @IsString()
  city!: string;

  @IsNotEmpty({ message: 'El estado es requerido' })
  @IsString()
  state!: string;

  @IsOptional()
  @IsString()
  zipCode?: string;

  @IsNotEmpty({ message: 'El pa√≠s es requerido' })
  @IsString()
  country!: string;

  @IsNotEmpty({ message: 'La latitud es requerida' })
  @IsNumber()
  latitude!: number;

  @IsNotEmpty({ message: 'La longitud es requerida' })
  @IsNumber()
  longitude!: number;

  @IsOptional()
  @IsString()
  deliveryInstructions?: string;

  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;
}

================
File: backend/src/dto/address/delete-address.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class DeleteAddressDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;

  @IsNotEmpty({ message: 'otp is required' })
  @IsString({ message: 'otp must be a string' })
  otp!: string;
}

================
File: backend/src/dto/address/set-default-address.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class SetDefaultAddressDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;

  @IsNotEmpty({ message: 'otp is required' })
  @IsString({ message: 'otp must be a string' })
  otp!: string;
}

================
File: backend/src/dto/address/update-address.dto.ts
================
import { IsOptional, IsString, IsNumber, IsBoolean } from 'class-validator';

export class UpdateAddressDto {
  @IsOptional()
  @IsString({ message: 'name must be a string' })
  name?: string;

  @IsOptional()
  @IsString({ message: 'street must be a string' })
  street?: string;

  @IsOptional()
  @IsString({ message: 'number must be a string' })
  number?: string;

  @IsOptional()
  @IsString({ message: 'interiorNumber must be a string' })
  interiorNumber?: string;

  @IsOptional()
  @IsString({ message: 'neighborhood must be a string' })
  neighborhood?: string;

  @IsOptional()
  @IsString({ message: 'city must be a string' })
  city?: string;

  @IsOptional()
  @IsString({ message: 'state must be a string' })
  state?: string;

  @IsOptional()
  @IsString({ message: 'zipCode must be a string' })
  zipCode?: string;

  @IsOptional()
  @IsString({ message: 'country must be a string' })
  country?: string;

  @IsOptional()
  @IsNumber({}, { message: 'latitude must be a number' })
  latitude?: number;

  @IsOptional()
  @IsNumber({}, { message: 'longitude must be a number' })
  longitude?: number;

  @IsOptional()
  @IsString({ message: 'deliveryInstructions must be a string' })
  deliveryInstructions?: string;

  @IsOptional()
  @IsBoolean({ message: 'isDefault must be a boolean' })
  isDefault?: boolean;
}

================
File: backend/src/dto/auth/index.ts
================
// Auth/OTP DTOs
export * from './verify-otp.dto';
export * from './invalidate-otp.dto';

================
File: backend/src/dto/auth/invalidate-otp.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class InvalidateOtpDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;
}

================
File: backend/src/dto/auth/verify-otp.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class VerifyOtpDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;

  @IsNotEmpty({ message: 'otp is required' })
  @IsString({ message: 'otp must be a string' })
  otp!: string;
}

================
File: backend/src/dto/customer/index.ts
================
// Customer DTOs
export * from './update-customer-name.dto';

================
File: backend/src/dto/customer/update-customer-name.dto.ts
================
import { IsString, IsNotEmpty, MaxLength, Matches } from 'class-validator';

export class UpdateCustomerNameDto {
  @IsString()
  @IsNotEmpty({ message: 'El nombre es requerido' })
  @MaxLength(100, { message: 'El nombre no puede tener m√°s de 100 caracteres' })
  @Matches(/^[a-zA-Z√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë\s]+$/, {
    message: 'El nombre solo puede contener letras y espacios'
  })
  firstName!: string;

  @IsString()
  @IsNotEmpty({ message: 'El apellido es requerido' })
  @MaxLength(100, { message: 'El apellido no puede tener m√°s de 100 caracteres' })
  @Matches(/^[a-zA-Z√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë\s]+$/, {
    message: 'El apellido solo puede contener letras y espacios'
  })
  lastName!: string;

  @IsString()
  @IsNotEmpty()
  otp!: string;

  @IsString()
  @IsNotEmpty()
  whatsappPhoneNumber!: string;
}

================
File: backend/src/dto/index.ts
================
/**
 * Central export for all DTOs
 * Organized by business domain
 */

// Address-related DTOs
export * from './address';

// Auth/OTP-related DTOs
export * from './auth';

// Customer-related DTOs
export * from './customer';

// Order-related DTOs
export * from './order';

// WhatsApp messaging DTOs
export * from './whatsapp';

================
File: backend/src/dto/order/create-order.dto.ts
================
import {
  IsString,
  IsArray,
  IsOptional,
  IsDateString,
  ValidateNested,
  IsNotEmpty,
  IsNumber,
  IsEnum,
} from "class-validator";
import { Type } from "class-transformer";
import { OrderType } from '@prisma/client';

class OrderItemDto {
  @IsString()
  productId: string;

  @IsOptional()
  @IsString()
  productVariantId?: string;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => SelectedPizzaCustomizationDto)
  selectedPizzaCustomizations: SelectedPizzaCustomizationDto[];

  @IsArray()
  @IsString({ each: true })
  selectedModifiers: string[]; // Array of modifier IDs

  @IsNotEmpty()
  quantity: number;

  @IsOptional()
  @IsString()
  comments?: string;
}

class SelectedPizzaCustomizationDto {
  @IsString()
  pizzaCustomizationId: string;

  @IsString()
  half: string;

  @IsString()
  action: string;
}

class DeliveryInfoDto {
  @IsString()
  @IsOptional()
  id?: string; // UUID now

  @IsString()
  @IsOptional()
  fullAddress?: string;

  @IsString()
  @IsOptional()
  street?: string;

  @IsString()
  @IsOptional()
  number?: string;

  @IsString()
  @IsOptional()
  interiorNumber?: string;

  @IsString()
  @IsOptional()
  neighborhood?: string;

  @IsString()
  @IsOptional()
  zipCode?: string;

  @IsString()
  @IsOptional()
  city?: string;

  @IsString()
  @IsOptional()
  state?: string;

  @IsString()
  @IsOptional()
  country?: string;

  @IsNumber()
  @IsOptional()
  latitude?: number;

  @IsNumber()
  @IsOptional()
  longitude?: number;

  @IsString()
  @IsOptional()
  recipientName?: string;

  @IsString()
  @IsOptional()
  recipientPhone?: string;

  @IsString()
  @IsOptional()
  deliveryInstructions?: string;

  @IsNumber()
  @IsOptional()
  preOrderId?: number;

  @IsString()
  @IsOptional()
  orderId?: string;
}

export class CreateOrderDto {
  @IsEnum(OrderType, { message: 'orderType must be a valid OrderType enum value' })
  orderType: OrderType;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => OrderItemDto)
  orderItems: OrderItemDto[];

  @IsOptional()
  @ValidateNested()
  @Type(() => DeliveryInfoDto)
  deliveryInfo?: DeliveryInfoDto;

  @IsString()
  whatsappPhoneNumber: string;

  @IsOptional()
  @IsDateString()
  scheduledAt?: string;

  @IsOptional()
  @IsNumber()
  subtotal?: number;

  @IsOptional()
  @IsNumber()
  total?: number;
}

================
File: backend/src/dto/order/index.ts
================
// Order DTOs
export * from './create-order.dto';
export * from './process-audio-order.dto';

================
File: backend/src/dto/order/process-audio-order.dto.ts
================
import { IsString, IsNotEmpty } from 'class-validator';

export class ProcessAudioOrderDto {
  @IsString()
  @IsNotEmpty()
  transcription: string;
}

================
File: backend/src/dto/whatsapp/index.ts
================
// WhatsApp DTOs
export * from './send-message.dto';

================
File: backend/src/lib/prisma.ts
================
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient();

// Handle cleanup on process termination
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});

================
File: backend/src/queues/types.ts
================
export interface WhatsAppMessageJob {
  id: string;
  from: string;
  type: string;
  timestamp: string;
  text?: any;
  interactive?: any;
  audio?: any;
}

================
File: backend/src/routes/webhook.ts
================
import { Router, Request, Response } from 'express';
import express from 'express';
import { WhatsAppService } from '../services/whatsapp';
import { StripeService } from '../services/payment/StripeService';
import { asyncHandler } from '../common/middlewares/errorHandler';

const router = Router();

// Webhook verification (GET)
router.get('/', asyncHandler(async (req: Request, res: Response) => {
  const result = WhatsAppService.verifyWebhook(req.query);
  if (result.verified) {
    res.status(200).send(result.challenge);
  } else {
    res.status(403).send('Forbidden');
  }
}));

// Webhook handler (POST)
router.post('/', express.raw({ type: '*/*' }), asyncHandler(async (req: Request, res: Response) => {
  // Check if it's a Stripe webhook
  const stripeSignature = req.headers['stripe-signature'];
  
  if (stripeSignature) {
    // Handle Stripe webhook
    await StripeService.handleWebhook(req, res);
  } else {
    // Handle WhatsApp webhook
    await WhatsAppService.handleWebhook(req, res);
  }
}));

export default router;

================
File: backend/src/run-workers.ts
================
import 'reflect-metadata';
import { envValidator } from './common/config/envValidator';
import logger from './common/utils/logger';
import { startMessageWorker, stopMessageWorker } from './queues/messageQueue';
import { prisma } from './lib/prisma';

async function startWorkers() {
  try {
    // Validate environment variables
    envValidator.validate();
    
    logger.info('Starting BullMQ workers...');
    
    // Initialize the message worker
    startMessageWorker();
    
    logger.info('Workers started successfully');
    
    // Graceful shutdown handlers
    const shutdown = async () => {
      logger.info('Shutting down workers...');
      
      try {
        await stopMessageWorker();
        await prisma.$disconnect();
        logger.info('Workers shut down successfully');
        process.exit(0);
      } catch (error) {
        logger.error('Error during shutdown:', error);
        process.exit(1);
      }
    };
    
    process.on('SIGINT', shutdown);
    process.on('SIGTERM', shutdown);
    
    // Keep the process alive
    process.on('uncaughtException', (error) => {
      logger.error('Uncaught exception in worker:', error);
      shutdown();
    });
    
    process.on('unhandledRejection', (reason, promise) => {
      logger.error('Unhandled rejection in worker:', { reason, promise });
      shutdown();
    });
    
  } catch (error) {
    logger.error('Failed to start workers:', error);
    process.exit(1);
  }
}

// Start the workers
startWorkers();

================
File: backend/src/services/ai/tools/toolHandlers.ts
================
import { ToolHandler } from './types';
import { handleMapOrderItems } from './handlers/mapOrderItemsHandler';
import { handleSendMenu } from './handlers/sendMenuHandler';
import { handleGetBusinessHours } from './handlers/getBusinessHoursHandler';
import { handlePrepareOrderContext } from './handlers/prepareOrderContextHandler';
import { handleGenerateAddressUpdateLink } from './handlers/generateAddressUpdateLinkHandler';
import { handleSendBotInstructions } from './handlers/sendBotInstructionsHandler';
import { handleGetWaitTimes } from './handlers/getWaitTimesHandler';
import { handleResetConversation } from './handlers/resetConversationHandler';

/**
 * Registry of all available tool handlers
 * Maps function names to their corresponding handler implementations
 */
export const toolHandlers: Record<string, ToolHandler> = {
  'map_order_items': handleMapOrderItems,
  'send_menu': handleSendMenu,
  'get_business_hours': handleGetBusinessHours,
  'prepare_order_context': handlePrepareOrderContext,
  'generate_address_update_link': handleGenerateAddressUpdateLink,
  'send_bot_instructions': handleSendBotInstructions,
  'get_wait_times': handleGetWaitTimes,
  'reset_conversation': handleResetConversation,
};

/**
 * Get a tool handler by name
 * @param name The name of the function to handle
 * @returns The handler function or undefined if not found
 */
export function getToolHandler(name: string): ToolHandler | undefined {
  return toolHandlers[name];
}

================
File: backend/src/services/audio/AudioOrderService.ts
================
import { MenuSearchService } from '../ai/MenuSearchService';
import { GeminiService } from '../ai/GeminiService';
import { BusinessLogicError, ErrorCode, TechnicalError } from '../../common/services/errors';
import logger from '../../common/utils/logger';
import { ConfigService } from '../config/ConfigService';

// Types
interface PizzaCustomization {
  customizationId: string;
  half: "FULL" | "HALF_1" | "HALF_2";
  action: "ADD" | "REMOVE";
}

interface AIOrderItem {
  productId: string;
  variantId?: string;
  quantity: number;
  modifiers?: string[];
  pizzaCustomizations?: PizzaCustomization[];
}

interface DeliveryInfoData {
  fullAddress?: string;
  recipientName?: string;
  recipientPhone?: string;
}

interface ScheduledDeliveryData {
  time?: string; // HH:mm format
}

interface AudioProcessingResult {
  orderItems?: AIOrderItem[];
  orderType?: "DELIVERY" | "TAKE_AWAY" | "DINE_IN";
  deliveryInfo?: DeliveryInfoData;
  scheduledDelivery?: ScheduledDeliveryData;
  warnings?: string;
}

interface ProcessAudioParams {
  audioBuffer: Buffer;
  audioMimeType: string;
  transcription: string;
}

interface ProcessWithGeminiParams {
  audioBase64: string;
  audioMimeType: string;
  transcription: string;
  relevantMenu: string;
}

export class AudioOrderService {
  private static readonly MAX_AUDIO_SIZE = 10 * 1024 * 1024; // 10MB

  static async processAudioOrder(params: ProcessAudioParams): Promise<AudioProcessingResult> {
    try {
      logger.info('Starting audio order processing', {
        audioSize: params.audioBuffer.length,
        mimeType: params.audioMimeType
      });

      // Validate audio size
      if (params.audioBuffer.length > this.MAX_AUDIO_SIZE) {
        throw new BusinessLogicError(
          ErrorCode.FILE_TOO_LARGE,
          'El archivo de audio es demasiado grande. M√°ximo 10MB permitido.'
        );
      }

      // Process in parallel for better performance
      const [relevantMenuJson, audioBase64] = await Promise.all([
        MenuSearchService.getRelevantMenu(params.transcription),
        Promise.resolve(this.prepareAudioBase64(params.audioBuffer))
      ]);

      const searchResults = JSON.parse(relevantMenuJson);
      // Use empty array if no products found - we can still extract delivery info
      const relevantMenu = searchResults?.length > 0 ? relevantMenuJson : '[]';
      
      // Debug logging
      logger.debug('Audio processing debug info', {
        transcription: params.transcription,
        transcriptionLength: params.transcription.length,
        relevantMenuProductCount: searchResults?.length || 0,
        relevantMenu: relevantMenu
      });

      const extractedData = await this.processWithGemini({
        audioBase64,
        audioMimeType: params.audioMimeType,
        transcription: params.transcription,
        relevantMenu
      });

      logger.info('Audio order processing completed', {
        hasOrderItems: !!extractedData.orderItems?.length,
        orderType: extractedData.orderType,
        hasDeliveryInfo: !!extractedData.deliveryInfo,
        hasScheduledDelivery: !!extractedData.scheduledDelivery
      });

      return extractedData;
    } catch (error) {
      logger.error('Error processing audio order', { error });
      throw error;
    }
  }

  private static prepareAudioBase64(audioBuffer: Buffer): string {
    return audioBuffer.toString('base64');
  }

  private static async processWithGemini(params: ProcessWithGeminiParams): Promise<AudioProcessingResult> {
    const config = ConfigService.getConfig();
    const systemPrompt = this.buildAudioOrderPrompt(config.restaurantName);
    
    const orderContext = {
      transcription: params.transcription,
      relevantMenu: params.relevantMenu
    };

    // Debug log the context being sent to Gemini
    logger.debug('Gemini request context', {
      transcriptionPreview: params.transcription.substring(0, 100) + '...',
      relevantMenuPreview: params.relevantMenu.substring(0, 200) + '...',
      fullContextSize: JSON.stringify(orderContext).length
    });

    const userPrompt = `Analiza el audio del pedido. La transcripci√≥n puede tener errores, prioriza el audio.

Contexto:
${JSON.stringify(orderContext, null, 2)}

Solo extrae informaci√≥n mencionada EXPL√çCITAMENTE. No inventes datos.`;

    const contents = [{
      role: "user" as const,
      parts: [
        { text: userPrompt },
        { 
          inlineData: { 
            mimeType: params.audioMimeType, 
            data: params.audioBase64 
          } 
        }
      ]
    }];

    const toolDefinition = this.buildExtractOrderDataTool();

    const response = await GeminiService.generateContentWithHistory(
      contents,
      systemPrompt,
      [toolDefinition],
      {
        functionCallingConfig: {
          mode: 'ANY',
          allowedFunctionNames: ['extract_order_data']
        }
      }
    );

    const functionCall = response.candidates?.[0]?.content?.parts?.[0]?.functionCall;
    
    if (!functionCall || functionCall.name !== 'extract_order_data') {
      logger.error('Gemini response error - no function call', {
        response: JSON.stringify(response, null, 2)
      });
      throw new TechnicalError(
        ErrorCode.AI_PROCESSING_ERROR,
        'No se pudo procesar el audio'
      );
    }

    // Debug log the extracted data
    logger.debug('Gemini extracted data', {
      functionCallArgs: functionCall.args,
      hasOrderItems: !!(functionCall.args as any).orderItems?.length,
      orderType: (functionCall.args as any).orderType,
      hasDeliveryInfo: !!(functionCall.args as any).deliveryInfo,
      hasScheduledDelivery: !!(functionCall.args as any).scheduledDelivery
    });

    return functionCall.args as AudioProcessingResult;
  }

  private static buildExtractOrderDataTool() {
    return {
      name: 'extract_order_data',
      description: 'Extrae informaci√≥n del audio del pedido',
      parameters: {
        type: 'object',
        properties: {
          orderType: {
            type: 'string',
            enum: ['DELIVERY', 'TAKE_AWAY', 'DINE_IN'],
            description: 'Tipo de orden inferido del contexto'
          },
          orderItems: {
            type: 'array',
            description: 'Productos del men√∫ mencionados',
            items: {
              type: 'object',
              properties: {
                productId: { type: 'string' },
                variantId: { type: 'string' },
                quantity: { type: 'number' },
                modifiers: {
                  type: 'array',
                  items: { type: 'string' }
                },
                pizzaCustomizations: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      customizationId: { type: 'string' },
                      half: { type: 'string', enum: ['FULL', 'HALF_1', 'HALF_2'] },
                      action: { type: 'string', enum: ['ADD', 'REMOVE'] }
                    },
                    required: ['customizationId', 'half', 'action']
                  }
                }
              },
              required: ['productId', 'quantity']
            }
          },
          deliveryInfo: {
            type: 'object',
            description: 'Informaci√≥n de entrega',
            properties: {
              fullAddress: { type: 'string' },
              recipientName: { type: 'string' },
              recipientPhone: { type: 'string' }
            }
          },
          scheduledDelivery: {
            type: 'object',
            description: 'Hora de entrega programada',
            properties: {
              time: { type: 'string', description: 'Formato HH:mm' }
            }
          },
          warnings: {
            type: 'string',
            description: 'Productos no identificados o informaci√≥n confusa'
          }
        }
      }
    };
  }

  private static buildAudioOrderPrompt(restaurantName: string): string {
    return `Eres un asistente de ${restaurantName} especializado en procesar pedidos de audio.

REGLAS:
1. Extrae SOLO informaci√≥n mencionada expl√≠citamente en el audio
2. NO inventes datos que no se mencionen
3. Usa solo productos de relevantMenu
4. Si hasVariants: true, especifica variantId
5. Convierte horarios a formato 24h (ej: "3pm" ‚Üí "15:00")
6. NO extraigas fechas, solo horas

TIPO DE ORDEN (orderType):
- DELIVERY: Si mencionan direcci√≥n de entrega o domicilio
- TAKE_AWAY: Si mencionan recoger, pasar por, o nombre para recolecci√≥n sin direcci√≥n
- DINE_IN: Si no mencionan ni direcci√≥n ni recolecci√≥n (por defecto)

EJEMPLOS:
- "Pizza hawaiana grande" ‚Üí orderType: "DINE_IN", orderItems con producto
- "Entregar en Ju√°rez 123" ‚Üí orderType: "DELIVERY", deliveryInfo.fullAddress
- "Para recoger a nombre de Juan" ‚Üí orderType: "TAKE_AWAY", deliveryInfo.recipientName
- "Mi tel√©fono 555-1234" ‚Üí deliveryInfo.recipientPhone
- "A las 3 de la tarde" ‚Üí scheduledDelivery.time: "15:00"`;
  }
}

================
File: backend/src/services/messaging/strategies/AudioMessageStrategy.ts
================
import { MessageStrategy } from './MessageStrategy';
import { MessageContext } from '../MessageContext';
import { GeminiService } from '../../ai';
import { sendWhatsAppMessage, getWhatsAppMediaUrl } from '../../whatsapp';
import { AUDIO_TRANSCRIPTION_ERROR } from '../../../common/config/predefinedMessages';
import { TextProcessingService } from '../TextProcessingService';
import logger from '../../../common/utils/logger';
import { env } from '../../../common/config/envValidator';
import axios from 'axios';
import { ValidationError, ErrorCode } from '../../../common/services/errors';

export class AudioMessageStrategy extends MessageStrategy {
  name = 'AudioMessageStrategy';
  
  canHandle(context: MessageContext): boolean {
    return context.message.type === 'audio';
  }
  
  async execute(context: MessageContext): Promise<void> {
    if (!context.message.audio) return;
    
    try {
      logger.info(`Processing audio message from ${context.message.from}`);
      
      // Notificar al usuario que estamos procesando
      await sendWhatsAppMessage(
        context.message.from,
        "üé§ Recib√≠ tu mensaje de voz. Dame un momento mientras lo proceso..."
      );
      
      // Obtener URL del audio
      const audioUrl = await getWhatsAppMediaUrl(context.message.audio.id);
      if (!audioUrl) {
        throw new ValidationError(
          ErrorCode.WHATSAPP_API_ERROR,
          'Could not get audio URL',
          { metadata: { audioId: context.message.audio.id } }
        );
      }
      
      // Descargar audio
      const audioResponse = await axios.get(audioUrl, {
        responseType: 'arraybuffer',
        headers: {
          'Authorization': `Bearer ${env.WHATSAPP_ACCESS_TOKEN}`
        },
        timeout: 30000
      });
      
      // Determinar tipo MIME
      const mimeType = context.message.audio.mime_type || 'audio/ogg';
      const validMimeTypes = ['audio/ogg', 'audio/mpeg', 'audio/mp4', 'audio/wav'];
      
      if (!validMimeTypes.includes(mimeType)) {
        throw new ValidationError(
          ErrorCode.TRANSCRIPTION_ERROR,
          `Unsupported audio format: ${mimeType}`,
          { metadata: { mimeType, validMimeTypes } }
        );
      }
      
      // Convertir a base64
      const audioBase64 = Buffer.from(audioResponse.data).toString('base64');
      
      // Transcribir con el servicio centralizado de Gemini
      const transcription = await GeminiService.transcribeAudio(audioBase64, mimeType);
      
      logger.info(`Audio transcribed successfully: "${transcription}"`);
      
      // Notificar al usuario de la transcripci√≥n
      await sendWhatsAppMessage(
        context.message.from,
        `üé§ Entend√≠: "${transcription}"\n\nProcesando tu mensaje...`
      );
      
      // Process the transcribed text directly using the shared service
      await TextProcessingService.processTextMessage(transcription, context);
      
      // Stop the pipeline here since we've already processed the message
      context.stop();
      
    } catch (error) {
      logger.error('Error processing audio message:', error);
      await sendWhatsAppMessage(context.message.from, AUDIO_TRANSCRIPTION_ERROR);
      context.stop();
    }
  }
}

================
File: backend/src/services/messaging/strategies/MessageStrategy.ts
================
import { MessageContext } from '../MessageContext';

export abstract class MessageStrategy {
  abstract name: string;
  
  abstract canHandle(context: MessageContext): boolean;
  
  abstract execute(context: MessageContext): Promise<void>;
}

================
File: backend/src/services/redis/RedisService.ts
================
import Redis from 'ioredis';
import logger from '../../common/utils/logger';
import { env } from '../../common/config/envValidator';

export class RedisService {
  private static instance: RedisService;
  private client: Redis | null = null;
  private isConnected = false;

  private constructor() {}

  static getInstance(): RedisService {
    if (!RedisService.instance) {
      RedisService.instance = new RedisService();
    }
    return RedisService.instance;
  }

  async connect(): Promise<void> {
    if (this.isConnected && this.client) {
      return;
    }

    try {
      this.client = new Redis({
        host: env.REDIS_HOST || 'localhost',
        port: parseInt(env.REDIS_PORT || '6379', 10),
        password: env.REDIS_PASSWORD,
        retryStrategy: (times) => {
          const delay = Math.min(times * 50, 2000);
          return delay;
        },
        maxRetriesPerRequest: 3,
      });

      this.client.on('connect', () => {
        logger.info('Redis connected successfully');
        this.isConnected = true;
      });

      this.client.on('error', (error) => {
        logger.error('Redis connection error:', error);
        this.isConnected = false;
      });

      this.client.on('close', () => {
        logger.warn('Redis connection closed');
        this.isConnected = false;
      });

      await this.client.ping();
    } catch (error) {
      logger.error('Failed to connect to Redis:', error);
      // Don't throw - allow app to work without Redis (fallback to memory)
      this.client = null;
      this.isConnected = false;
    }
  }

  getClient(): Redis | null {
    return this.client;
  }

  isAvailable(): boolean {
    return this.isConnected && this.client !== null;
  }

  async set(key: string, value: string, expiresInSeconds?: number): Promise<boolean> {
    if (!this.isAvailable() || !this.client) {
      return false;
    }

    try {
      if (expiresInSeconds) {
        await this.client.set(key, value, 'EX', expiresInSeconds);
      } else {
        await this.client.set(key, value);
      }
      return true;
    } catch (error) {
      logger.error('Redis SET error:', error);
      return false;
    }
  }

  async get(key: string): Promise<string | null> {
    if (!this.isAvailable() || !this.client) {
      return null;
    }

    try {
      return await this.client.get(key);
    } catch (error) {
      logger.error('Redis GET error:', error);
      return null;
    }
  }

  async del(key: string): Promise<boolean> {
    if (!this.isAvailable() || !this.client) {
      return false;
    }

    try {
      await this.client.del(key);
      return true;
    } catch (error) {
      logger.error('Redis DEL error:', error);
      return false;
    }
  }

  async exists(key: string): Promise<boolean> {
    if (!this.isAvailable() || !this.client) {
      return false;
    }

    try {
      const result = await this.client.exists(key);
      return result === 1;
    } catch (error) {
      logger.error('Redis EXISTS error:', error);
      return false;
    }
  }

  async keys(pattern: string): Promise<string[]> {
    if (!this.isAvailable() || !this.client) {
      return [];
    }

    try {
      return await this.client.keys(pattern);
    } catch (error) {
      logger.error('Redis KEYS error:', error);
      return [];
    }
  }

  async setJSON(key: string, value: any, expiresInSeconds?: number): Promise<boolean> {
    try {
      const jsonString = JSON.stringify(value);
      return await this.set(key, jsonString, expiresInSeconds);
    } catch (error) {
      logger.error('Redis setJSON error:', error);
      return false;
    }
  }

  async getJSON<T>(key: string): Promise<T | null> {
    try {
      const value = await this.get(key);
      if (!value) return null;
      return JSON.parse(value) as T;
    } catch (error) {
      logger.error('Redis getJSON error:', error);
      return null;
    }
  }

  async disconnect(): Promise<void> {
    if (this.client) {
      await this.client.quit();
      this.client = null;
      this.isConnected = false;
      logger.info('Redis disconnected');
    }
  }
}

export const redisService = RedisService.getInstance();

================
File: backend/src/services/sync/EmbeddingManager.ts
================
import { prisma } from '../../lib/prisma';
import { EmbeddingService } from './EmbeddingService';
import logger from '../../common/utils/logger';
import { env } from '../../common/config/envValidator';

/**
 * Manages embedding lifecycle and automatic generation
 * Coordinates with sync service to generate embeddings after menu updates
 */
export class EmbeddingManager {
  private static isGenerating = false;
  private static lastGenerationTime: Date | null = null;
  private static generationAttempts = 0;
  private static readonly MAX_ATTEMPTS = 3;
  private static readonly RETRY_DELAY_MS = 5 * 60 * 1000; // 5 minutes
  private static scheduledCheckInterval: NodeJS.Timeout | null = null;

  /**
   * Check if embeddings can be generated (products exist)
   */
  static async canGenerateEmbeddings(): Promise<boolean> {
    const productCount = await prisma.product.count({
      where: { isActive: true }
    });
    return productCount > 0;
  }

  /**
   * Get embedding generation status
   */
  static async getEmbeddingStatus(): Promise<{
    hasProducts: boolean;
    totalProducts: number;
    productsWithEmbeddings: number;
    productsNeedingEmbeddings: number;
    lastGenerationTime: Date | null;
    isGenerating: boolean;
  }> {
    const totalProducts = await prisma.product.count({
      where: { isActive: true }
    });

    // Count products with embeddings using raw query
    const productsWithEmbeddings: { count: bigint }[] = await prisma.$queryRaw`
      SELECT COUNT(*) as count 
      FROM "Product" 
      WHERE "isActive" = true 
      AND embedding IS NOT NULL
    `;
    const withEmbeddingsCount = Number(productsWithEmbeddings[0]?.count || 0);

    return {
      hasProducts: totalProducts > 0,
      totalProducts,
      productsWithEmbeddings: withEmbeddingsCount,
      productsNeedingEmbeddings: totalProducts - withEmbeddingsCount,
      lastGenerationTime: this.lastGenerationTime,
      isGenerating: this.isGenerating
    };
  }

  /**
   * Trigger embedding generation after sync
   * Called automatically after menu sync completes
   */
  static async generateEmbeddingsAfterSync(): Promise<number> {
    try {
      // Check if API key is configured
      if (!env.GOOGLE_AI_API_KEY) {
        logger.warn('‚ö†Ô∏è  Google AI API key not configured, skipping embedding generation');
        return 0;
      }

      // Prevent concurrent generation
      if (this.isGenerating) {
        logger.info('Embedding generation already in progress, skipping');
        return 0;
      }

      // Check if we can generate embeddings
      const canGenerate = await this.canGenerateEmbeddings();
      if (!canGenerate) {
        logger.info('No products available for embedding generation');
        return 0;
      }

      // Check status
      const status = await this.getEmbeddingStatus();
      if (status.productsNeedingEmbeddings === 0) {
        logger.info('All products already have embeddings');
        return 0;
      }

      logger.info(`üöÄ Starting embedding generation for ${status.productsNeedingEmbeddings} products`);
      this.isGenerating = true;

      // Generate embeddings
      const updatedCount = await EmbeddingService.checkAndUpdateEmbeddings();
      
      this.lastGenerationTime = new Date();
      this.generationAttempts = 0; // Reset attempts on success
      
      logger.info(`‚úÖ Embedding generation completed: ${updatedCount} products updated`);
      return updatedCount;
    } catch (error) {
      logger.error('Error generating embeddings after sync:', error);
      this.generationAttempts++;
      
      // Schedule retry if under max attempts
      if (this.generationAttempts < this.MAX_ATTEMPTS) {
        logger.info(`Scheduling embedding generation retry (attempt ${this.generationAttempts + 1}/${this.MAX_ATTEMPTS}) in 5 minutes`);
        setTimeout(() => this.generateEmbeddingsAfterSync(), this.RETRY_DELAY_MS);
      }
      return 0; // Return 0 on error
    } finally {
      this.isGenerating = false;
    }
  }

  /**
   * Initialize embedding management
   * Sets up periodic checks and initial generation
   */
  static async initialize(): Promise<void> {
    try {
      // Check if API key is configured
      if (!env.GOOGLE_AI_API_KEY) {
        logger.warn('‚ö†Ô∏è  Google AI API key not configured, embedding features disabled');
        return;
      }

      const status = await this.getEmbeddingStatus();
      
      if (!status.hasProducts) {
        logger.info('üì¶ No products in database yet, embeddings will be generated after first sync');
        // Schedule periodic checks for when products arrive
        this.schedulePeriodicChecks();
        return;
      }

      if (status.productsNeedingEmbeddings > 0) {
        logger.info(`Found ${status.productsNeedingEmbeddings} products without embeddings`);
        // Don't block startup, generate in background
        setTimeout(() => this.generateEmbeddingsAfterSync(), 5000);
      } else {
        logger.info('‚úÖ All products have embeddings');
      }

      // Schedule periodic checks
      this.schedulePeriodicChecks();
    } catch (error) {
      logger.error('Error initializing embedding manager:', error);
    }
  }

  /**
   * Schedule periodic embedding checks
   * Runs every hour to catch any missed updates
   */
  private static schedulePeriodicChecks(): void {
    // Clear any existing interval
    if (this.scheduledCheckInterval) {
      clearInterval(this.scheduledCheckInterval);
    }

    // Check every hour
    const INTERVAL_MS = 60 * 60 * 1000;
    
    this.scheduledCheckInterval = setInterval(async () => {
      try {
        const status = await this.getEmbeddingStatus();
        
        if (status.hasProducts && status.productsNeedingEmbeddings > 0) {
          logger.info(`Periodic check found ${status.productsNeedingEmbeddings} products needing embeddings`);
          await this.generateEmbeddingsAfterSync();
        }
      } catch (error) {
        logger.error('Error in periodic embedding check:', error);
      }
    }, INTERVAL_MS);
    
    logger.info('üìÖ Scheduled periodic embedding checks every hour');
  }

  /**
   * Force regenerate all embeddings
   * Useful for debugging or after major changes
   */
  static async forceRegenerateAll(): Promise<number> {
    try {
      logger.info('üîÑ Force regenerating all embeddings...');
      
      // Clear all existing embeddings using raw query
      await prisma.$executeRaw`
        UPDATE "Product" 
        SET embedding = NULL 
        WHERE "isActive" = true
      `;
      
      // Generate new embeddings
      return await EmbeddingService.checkAndUpdateEmbeddings();
    } catch (error) {
      logger.error('Error force regenerating embeddings:', error);
      throw error;
    }
  }
}

================
File: backend/src/whatsapp/handlers/interactive/addressActions.ts
================
/**
 * Address related interactive message handlers
 */
import { prisma } from '../../../lib/prisma';
import { sendWhatsAppMessage, sendMessageWithUrlButton } from '../../../services/whatsapp';
import { OTPService } from '../../../services/security/OTPService';
import { env } from '../../../common/config/envValidator';
import { BusinessLogicError, ErrorCode } from '../../../common/services/errors';
import { extractIdFromAction, INTERACTIVE_ACTIONS } from '../../../common/constants/interactiveActions';
import { formatAddressFull } from '../../../common/utils/addressFormatter';
import logger from '../../../common/utils/logger';

/**
 * Handle general change delivery info request
 */
export async function handleChangeDeliveryInfo(from: string): Promise<void> {
  const otp = OTPService.generateOTP();
  await OTPService.storeOTP(from, otp, true); // true for address registration
  const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${from}?otp=${otp}`;
  
  // Send message with URL button
  await sendMessageWithUrlButton(
    from,
    "üöö Actualizar Direcci√≥n",
    "Puedes actualizar o agregar una nueva direcci√≥n de entrega haciendo clic en el bot√≥n de abajo.",
    "Actualizar Direcci√≥n",
    updateLink
  );
}


/**
 * Handle address selection
 */
export async function handleAddressSelection(from: string, selectionId: string): Promise<void> {
  // Check if this is from a preorder change address flow
  // Format can be: select_address_[addressId] or select_address_[addressId]:[preOrderId]
  let addressId: string;
  let preOrderId: number | null = null;
  
  if (selectionId.includes(':')) {
    // This is from preorder change address flow
    const baseId = selectionId.split(':')[0];
    addressId = extractIdFromAction(baseId, INTERACTIVE_ACTIONS.SELECT_ADDRESS);
    preOrderId = parseInt(selectionId.split(':')[1], 10);
  } else {
    // Regular address selection
    addressId = extractIdFromAction(selectionId, INTERACTIVE_ACTIONS.SELECT_ADDRESS);
  }
    
    // Get customer
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: from },
      include: {
        addresses: {
          where: { id: addressId }
        }
      }
    });
    
    if (!customer || customer.addresses.length === 0) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer or address not found',
        { userId: from }
      );
    }
    
    const selectedAddress = customer.addresses[0];
    const formattedAddress = formatAddressFull(selectedAddress);
    
    // If we have a specific preOrderId, use it. Otherwise, check for recent preorder
    if (preOrderId) {
      // Recreate preorder with selected address
      const { PreOrderWorkflowService } = await import('../../../services/orders/PreOrderWorkflowService');
      
      try {
        // This will create a new preOrder with the new address and discard the old one
        await PreOrderWorkflowService.recreatePreOrderWithNewAddress({
          oldPreOrderId: preOrderId,
          newAddressId: selectedAddress.id,
          whatsappNumber: from
        });
        
        // The new preOrder summary is automatically sent by recreatePreOrderWithNewAddress
        // No need to send additional messages
      } catch (error) {
        logger.error('Error recreating preOrder with new address:', error);
        await sendWhatsAppMessage(
          from,
          `‚ùå Hubo un error al actualizar la direcci√≥n. Por favor intenta nuevamente.`
        );
      }
    } else {
      // No preOrderId provided, just confirming address selection for future use
      await sendWhatsAppMessage(
        from,
        `‚úÖ *Direcci√≥n seleccionada*\n\nüìç *Direcci√≥n de entrega:*\n${formattedAddress}\n\nEsta direcci√≥n se usar√° para tu pr√≥ximo pedido.`
      );
    }
}

/**
 * Handle add new address request
 */
export async function handleAddNewAddress(from: string): Promise<void> {
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber: from }
  });
  
  if (!customer) {
    throw new BusinessLogicError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found',
      { userId: from }
    );
  }
    
  const preOrder = await prisma.preOrder.findFirst({
    where: { 
      whatsappPhoneNumber: customer.whatsappPhoneNumber,
      createdAt: {
        gte: new Date(Date.now() - 10 * 60 * 1000)
      }
    },
    orderBy: { createdAt: 'desc' }
  });
  
  const otp = OTPService.generateOTP();
  await OTPService.storeOTP(customer.whatsappPhoneNumber, otp, true);
  
  const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${customer.whatsappPhoneNumber}?otp=${otp}${preOrder ? `&preOrderId=${preOrder.id}` : ''}&viewMode=form`;
  
  await sendMessageWithUrlButton(
    from,
    "üìç Agregar Nueva Direcci√≥n",
    "Haz clic en el bot√≥n de abajo para registrar una nueva direcci√≥n de entrega.",
    "Agregar Direcci√≥n",
    updateLink
  );
}

/**
 * Handle add new address for a specific preorder
 */
export async function handleAddNewAddressForPreOrder(from: string, preOrderId: number): Promise<void> {
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber: from }
  });
  
  if (!customer) {
    throw new BusinessLogicError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found',
      { userId: from }
    );
  }
  
  const otp = OTPService.generateOTP();
  await OTPService.storeOTP(customer.whatsappPhoneNumber, otp, true);
  
  const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${customer.whatsappPhoneNumber}?otp=${otp}&preOrderId=${preOrderId}&viewMode=form`;
  
  await sendMessageWithUrlButton(
    from,
    "üìç Agregar Nueva Direcci√≥n",
    "Haz clic en el bot√≥n de abajo para registrar una nueva direcci√≥n de entrega para tu pedido actual.",
    "Agregar Direcci√≥n",
    updateLink
  );
}

/**
 * Handler for add new address button (from button reply)
 */
export async function handleAddNewAddressFromButton(from: string, buttonId: string): Promise<void> {
  const parts = buttonId.split(':');
  if (parts.length < 2) {
    await sendWhatsAppMessage(from, "‚ùå Error al procesar la solicitud. Por favor intenta nuevamente.");
    return;
  }
  
  const preOrderId = parseInt(parts[1], 10);
  if (isNaN(preOrderId)) {
    await sendWhatsAppMessage(from, "‚ùå Error al procesar la solicitud. Por favor intenta nuevamente.");
    return;
  }
  
  await handleAddNewAddressForPreOrder(from, preOrderId);
}

/**
 * Handler for address selection button (from button reply)
 */
export async function handleAddressSelectionButton(from: string, buttonId: string): Promise<void> {
  await handleAddressSelection(from, buttonId);
}

================
File: backend/src/whatsapp/handlers/interactive/index.ts
================
/**
 * Interactive message handlers registry
 * Exports all handlers and constructs the unified action registry
 */
import { INTERACTIVE_ACTIONS, startsWithAction } from '../../../common/constants/interactiveActions';

// Import all domain-specific handlers
import {
  handlePreOrderAction,
  handlePreOrderChangeAddress
} from './preOrderActions';

import {
  handleChangeDeliveryInfo,
  handleAddressSelection,
  handleAddNewAddress,
  handleAddNewAddressForPreOrder,
  handleAddNewAddressFromButton,
  handleAddressSelectionButton
} from './addressActions';

import {
  sendMenu,
  handleWaitTimes,
  handleRestaurantInfo,
  handleChatbotHelp
} from './infoActions';

import {
  handleOnlinePaymentWithId
} from './paymentActions';

// Export all handlers for individual use
export * from './preOrderActions';
export * from './addressActions';
export * from './infoActions';
export * from './paymentActions';

// Handler type definition
type InteractiveHandler = (from: string, id: string) => Promise<void>;

/**
 * Unified action registry for all interactive messages
 * Maps action IDs to their corresponding handlers
 */
export const actionRegistry = new Map<string, InteractiveHandler>([
  // List actions (exact match)
  [INTERACTIVE_ACTIONS.WAIT_TIMES, async (from, id) => handleWaitTimes(from)],
  [INTERACTIVE_ACTIONS.VIEW_MENU, async (from, id) => sendMenu(from)],
  [INTERACTIVE_ACTIONS.RESTAURANT_INFO, async (from, id) => handleRestaurantInfo(from)],
  [INTERACTIVE_ACTIONS.CHATBOT_HELP, async (from, id) => handleChatbotHelp(from)],
  [INTERACTIVE_ACTIONS.CHANGE_DELIVERY_INFO, async (from, id) => handleChangeDeliveryInfo(from)],
  [INTERACTIVE_ACTIONS.ADD_NEW_ADDRESS, async (from, id) => handleAddNewAddress(from)],
  
  // Button actions (prefix match - remove trailing colon)
  [INTERACTIVE_ACTIONS.PREORDER_CONFIRM.slice(0, -1), handlePreOrderAction],
  [INTERACTIVE_ACTIONS.PREORDER_DISCARD.slice(0, -1), handlePreOrderAction],
  [INTERACTIVE_ACTIONS.PREORDER_CHANGE_ADDRESS.slice(0, -1), handlePreOrderChangeAddress],
  [INTERACTIVE_ACTIONS.SELECT_ADDRESS.slice(0, -1), handleAddressSelection],
  [INTERACTIVE_ACTIONS.PAY_ONLINE, handleOnlinePaymentWithId],
  ['add_new_address_preorder', async (from, id) => {
    // Special case: parse preOrderId from id
    if (id.includes(':')) {
      const preOrderId = parseInt(id.split(':')[1], 10);
      await handleAddNewAddressForPreOrder(from, preOrderId);
    } else {
      await handleAddNewAddressFromButton(from, id);
    }
  }],
  ['select_address', handleAddressSelectionButton],
  
  // Special case handlers with full ID
  [INTERACTIVE_ACTIONS.CHANGE_ADDRESS, async (from, id) => handleChangeDeliveryInfo(from)],
]);

/**
 * Find handler for an interactive action ID
 * Supports both exact matches and prefix-based matches
 */
export function findHandler(actionId: string): InteractiveHandler | undefined {
  // First, try exact match
  let handler = actionRegistry.get(actionId);
  
  // If no exact match, try prefix match for actions with parameters
  if (!handler) {
    const [actionPrefix] = actionId.split(':');
    handler = actionRegistry.get(actionPrefix);
    
    // Special handling for actions that start with a prefix
    if (!handler && actionId.includes(':')) {
      // Check for actions that use startsWithAction pattern
      for (const [key, value] of actionRegistry) {
        if (actionId.startsWith(key + ':')) {
          handler = value;
          break;
        }
      }
    }
  }
  
  return handler;
}

================
File: backend/src/whatsapp/handlers/interactive/infoActions.ts
================
/**
 * Informational interactive message handlers
 */
import { prisma } from '../../../lib/prisma';
import { sendWhatsAppMessage } from '../../../services/whatsapp';
import { getMenuResponses } from '../../../services/ai/tools/handlers/sendMenuHandler';
import { 
  WAIT_TIMES_MESSAGE,
  RESTAURANT_INFO_MESSAGE,
  CHATBOT_HELP_MESSAGE 
} from '../../../common/config/predefinedMessages';
import { ConfigService } from '../../../services/config/ConfigService';
import { getFormattedBusinessHours } from '../../../common/utils/timeUtils';
import { BusinessLogicError, ErrorCode } from '../../../common/services/errors';
import logger from '../../../common/utils/logger';

/**
 * Send menu to customer
 */
export async function sendMenu(phoneNumber: string): Promise<void> {
  // No hay try...catch aqu√≠. Si algo falla, el error sube al manejador principal.
  
  // Usa la l√≥gica centralizada para obtener y dividir el men√∫
  const toolResponse = await getMenuResponses();
  
  // Normaliza a array para manejar ambos casos (respuesta √∫nica o m√∫ltiple)
  const responses = Array.isArray(toolResponse) ? toolResponse : [toolResponse];
  
  // Env√≠a cada parte del men√∫ por separado
  // La divisi√≥n ya fue manejada por getMenuResponses usando splitMenu
  for (const response of responses) {
    if (response && response.content?.text) {
      // sendWhatsAppMessage no volver√° a dividir porque cada parte es < 3500 chars
      const result = await sendWhatsAppMessage(phoneNumber, response.content.text);
      if (!result) {
        // Lanza un error para que el manejador principal lo capture
        throw new BusinessLogicError(
          ErrorCode.WHATSAPP_ERROR,
          `Failed to send menu part to ${phoneNumber}`
        );
      }
    }
  }
}

/**
 * Handle wait times request
 */
export async function handleWaitTimes(customerId: string): Promise<void> {
  const config = await prisma.restaurantConfig.findFirst();
  if (!config) {
    throw new BusinessLogicError(ErrorCode.DATABASE_ERROR, 'Restaurant configuration not found');
  }
  const message = WAIT_TIMES_MESSAGE(
    config.estimatedPickupTime,
    config.estimatedDeliveryTime
  );
  await sendWhatsAppMessage(customerId, message);
}

/**
 * Handle restaurant info request
 */
export async function handleRestaurantInfo(customerId: string): Promise<void> {
  const config = ConfigService.getConfig();
  const formattedHours = await getFormattedBusinessHours();
  const message = RESTAURANT_INFO_MESSAGE(config, formattedHours);
  await sendWhatsAppMessage(customerId, message);
}

/**
 * Handle chatbot help request
 */
export async function handleChatbotHelp(whatsappPhoneNumber: string): Promise<void> {
  const config = ConfigService.getConfig();
  const message = CHATBOT_HELP_MESSAGE(config);
  await sendWhatsAppMessage(whatsappPhoneNumber, message);
}

================
File: backend/src/whatsapp/handlers/interactive/paymentActions.ts
================
/**
 * Payment related interactive message handlers
 */
import { prisma } from '../../../lib/prisma';
import { sendWhatsAppMessage } from '../../../services/whatsapp';
import Stripe from 'stripe';
import { env } from '../../../common/config/envValidator';
import { BusinessLogicError, ErrorCode } from '../../../common/services/errors';
import { getCurrentMexicoTime } from '../../../common/utils/timeUtils';
import logger from '../../../common/utils/logger';

const stripeClient = env.STRIPE_SECRET_KEY 
  ? new Stripe(env.STRIPE_SECRET_KEY, {
      apiVersion: "2024-10-28.acacia",
    })
  : null;

/**
 * Handle online payment with button ID
 */
export async function handleOnlinePaymentWithId(
  customerId: string,
  buttonId: string
): Promise<void> {
  // Extract orderId from buttonId (format: "pay_online:orderId")
  const [, orderId] = buttonId.split(':');
  if (!orderId) {
    throw new BusinessLogicError(
      ErrorCode.ORDER_NOT_FOUND,
      'Invalid button ID format',
      { userId: customerId, operation: 'handleOnlinePayment' }
    );
  }
  
  return handleOnlinePayment(customerId, orderId);
}

/**
 * Core online payment handler
 */
async function handleOnlinePayment(
  customerId: string,
  orderId: string
): Promise<void> {
  if (!stripeClient) {
    throw new BusinessLogicError(
      ErrorCode.STRIPE_ERROR,
      'Stripe client not configured',
      { userId: customerId, operation: 'handleOnlinePayment' }
    );
  }
    const order = await prisma.order.findUnique({ where: { id: orderId } });
    if (!order) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'Order not found for payment processing',
        { userId: customerId, operation: 'handleOnlinePayment' }
      );
    }

    // Check if a payment session already exists
    const existingPayment = await prisma.payment.findFirst({
      where: {
        orderId: order.id,
        paymentMethod: 'STRIPE',
        stripePaymentId: { not: null }
      }
    });
    
    if (existingPayment) {
      throw new BusinessLogicError(
        ErrorCode.PAYMENT_LINK_EXISTS,
        'Payment link already exists for this order',
        { userId: customerId, metadata: { orderId: order.id }, operation: 'handleOnlinePayment' }
      );
    }

    // Verificar el estado de la orden
    let mensaje: string | undefined;
    switch (order.orderStatus) {
      case "PENDING":
      case "IN_PROGRESS":
        // Continuar con el proceso de pago
        break;
      case "IN_PREPARATION":
        mensaje =
          "‚ùå Esta orden ya est√° en preparaci√≥n. Por favor, contacta con el restaurante para opciones de pago.";
        break;
      case "READY":
        mensaje =
          "‚ùå Esta orden ya est√° preparada. Por favor, contacta con el restaurante para opciones de pago.";
        break;
      case "IN_DELIVERY":
        mensaje =
          "‚ùå Esta orden ya est√° en camino. Por favor, paga al repartidor o contacta con el restaurante.";
        break;
      case "CANCELLED":
        mensaje =
          "‚ùå Esta orden ya ha sido cancelada y no se puede procesar el pago.";
        break;
      case "COMPLETED":
        mensaje =
          "‚ùå Esta orden ya ha sido finalizada y no se puede procesar el pago.";
        break;
      default:
        mensaje =
          "‚ùå Lo sentimos, pero no se puede procesar el pago en este momento debido al estado actual de la orden.";
    }

    if (mensaje) {
      // Get customer's WhatsApp phone number
      const customerForMessage = await prisma.customer.findUnique({
        where: { id: customerId },
        select: { whatsappPhoneNumber: true }
      });
      
      if (customerForMessage?.whatsappPhoneNumber) {
        await sendWhatsAppMessage(customerForMessage.whatsappPhoneNumber, mensaje);
      }
      return;
    }

    let customer = await prisma.customer.findUnique({ where: { id: customerId } });
    
    if (!customer) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer not found during payment process'
      );
    }
    
    let stripeCustomerId = customer.stripeCustomerId;

    if (!stripeCustomerId) {
      const stripeCustomer = await stripeClient.customers.create({
        phone: customer.whatsappPhoneNumber,
        metadata: { whatsappId: customer.whatsappPhoneNumber },
      });
      stripeCustomerId = stripeCustomer.id;
      await prisma.customer.update({
        where: { id: customer.id },
        data: { stripeCustomerId }
      });
    }

    const session = await stripeClient.checkout.sessions.create({
      payment_method_types: ["card"],
      customer: stripeCustomerId,
      line_items: [
        {
          price_data: {
            currency: "mxn",
            product_data: {
              name: `Orden #${
                order.shiftOrderNumber
              } - ${(await getCurrentMexicoTime()).format("DD/MM/YYYY")}`,
            },
            unit_amount: Math.round(order.total * 100),
          },
          quantity: 1,
        },
      ],
      mode: "payment",
      success_url: `${env.FRONTEND_BASE_URL}/payment-success`,
      cancel_url: `${env.FRONTEND_BASE_URL}/payment-cancel`,
    });

    // Create payment record with Stripe session ID
    await prisma.payment.create({
      data: {
        orderId: order.id,
        paymentMethod: 'STRIPE',
        amount: order.total,
        status: 'PENDING',
        stripePaymentId: session.id,
        metadata: {
          sessionUrl: session.url,
          createdAt: new Date().toISOString()
        }
      }
    });

    const paymentLink = session.url;
    await sendWhatsAppMessage(
      customerId,
      `üí≥ Por favor, haz clic en el siguiente enlace para proceder con el pago: üîó ${paymentLink} üí∞`
    );
}

================
File: backend/src/whatsapp/handlers/interactive/preOrderActions.ts
================
/**
 * Pre-order related interactive message handlers
 */
import { PreOrderWorkflowService } from '../../../services/orders/PreOrderWorkflowService';
import { startsWithAction, INTERACTIVE_ACTIONS, extractIdFromAction } from '../../../common/constants/interactiveActions';
import { prisma } from '../../../lib/prisma';
import { redisService } from '../../../services/redis/RedisService';
import { OTPService } from '../../../services/security/OTPService';
import { WhatsAppService, sendMessageWithUrlButton } from '../../../services/whatsapp';
import { env } from '../../../common/config/envValidator';
import { BusinessLogicError, ErrorCode } from '../../../common/services/errors';
import { redisKeys } from '../../../common/constants';
import { formatAddressShort, formatAddressDescription } from '../../../common/utils/addressFormatter';
import logger from '../../../common/utils/logger';

/**
 * Handles preorder actions (confirm/discard) using the token-based system
 */
export async function handlePreOrderAction(from: string, buttonId: string): Promise<void> {
  // Extract token from button ID
  // Format: preorder_confirm:token or preorder_discard:token
  const parts = buttonId.split(':');
  const token = parts[1];
  
  if (!token) {
    throw new BusinessLogicError(
      ErrorCode.INVALID_TOKEN,
      'Invalid button format - missing token'
    );
  }
    
    // Determine action based on button prefix
    const action: 'confirm' | 'discard' = 
      startsWithAction(buttonId, INTERACTIVE_ACTIONS.PREORDER_CONFIRM) ? 'confirm' : 'discard';
    
    logger.info('Processing preorder action', { 
      from, 
      action, 
      tokenPrefix: token.substring(0, 8) + '...' 
    });
    
    // Process the action using the workflow service
    await PreOrderWorkflowService.processAction({
      action,
      token,
      whatsappNumber: from
    });
}

/**
 * Handles preorder change address action
 */
export async function handlePreOrderChangeAddress(from: string, buttonId: string): Promise<void> {
  // Extract token from button ID
  const parts = buttonId.split(':');
  const token = parts[1];
  
  if (!token) {
    throw new BusinessLogicError(
      ErrorCode.INVALID_TOKEN,
      'Invalid button format - missing token'
    );
  }
  
  // Validate token and get preOrderId
  const key = redisKeys.preorderToken(token);
  const preOrderIdStr = await redisService.get(key);
  
  if (!preOrderIdStr) {
    throw new BusinessLogicError(
      ErrorCode.INVALID_TOKEN,
      'Token no encontrado o expirado'
    );
  }
  
  const preOrderId = parseInt(preOrderIdStr, 10);
  
  // Get customer
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber: from },
    include: {
      addresses: {
        where: { deletedAt: null },
        orderBy: [
          { isDefault: 'desc' },
          { createdAt: 'desc' }
        ],
        take: 5
      }
    }
  });
  
  if (!customer) {
    throw new BusinessLogicError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found'
    );
  }
  
  // If no addresses, send link to add one
  if (customer.addresses.length === 0) {
    const otp = OTPService.generateOTP();
    await OTPService.storeOTP(from, otp, true);
    const updateLink = `${env.FRONTEND_BASE_URL}/address-registration/${from}?otp=${otp}&preOrderId=${preOrderId}`;
    
    await sendMessageWithUrlButton(
      from,
      "üìç Registrar Direcci√≥n",
      "No tienes direcciones guardadas. Por favor, registra una direcci√≥n de entrega haciendo clic en el bot√≥n de abajo.",
      "Agregar Direcci√≥n",
      updateLink
    );
    return;
  }
  
  // Always use list for consistency (even with one address)
  const sections = [
    {
      title: "Mis direcciones",
      rows: customer.addresses.map((address) => ({
        id: `select_address_${address.id}:${preOrderId}`,
        title: address.name || `${address.street} ${address.number}`.substring(0, 24),
        description: formatAddressDescription(address).substring(0, 72)
      }))
    }
  ];
  
  // Add option for new address
  sections[0].rows.push({
    id: `add_new_address_preorder:${preOrderId}`,
    title: "‚ûï Nueva direcci√≥n",
    description: "Registrar una nueva direcci√≥n de entrega"
  });
  
  // Determine body text based on number of addresses
  const bodyText = customer.addresses.length === 1
    ? "Puedes usar tu direcci√≥n actual o agregar una nueva:"
    : "Selecciona la nueva direcci√≥n de entrega para tu pedido:";
  
  await WhatsAppService.sendInteractiveMessage(from, {
    type: "list",
    header: {
      type: "text",
      text: "üìç Cambiar Direcci√≥n"
    },
    body: {
      text: bodyText
    },
    footer: {
      text: "Elige una opci√≥n"
    },
    action: {
      button: "Ver opciones",
      sections
    }
  });
}

================
File: cleanup-ports.bat
================
@echo off
echo Cleaning up ports and processes...

REM Kill processes on port 5000 (Backend API)
echo Checking port 5000...
for /f "tokens=5" %%a in ('netstat -aon ^| findstr :5000 ^| findstr LISTENING') do (
    echo Killing process %%a on port 5000
    taskkill /F /PID %%a >nul 2>&1
)

REM Kill processes on port 3000 (Frontend)
echo Checking port 3000...
for /f "tokens=5" %%a in ('netstat -aon ^| findstr :3000 ^| findstr LISTENING') do (
    echo Killing process %%a on port 3000
    taskkill /F /PID %%a >nul 2>&1
)

REM Kill any Node.js processes that might be stuck
echo Checking for stuck Node.js processes...
taskkill /F /IM node.exe >nul 2>&1

REM Clean up Prisma client if exists
if exist backend\node_modules\.prisma (
    echo Cleaning up Prisma client...
    rmdir /s /q backend\node_modules\.prisma >nul 2>&1
)

echo.
echo Cleanup completed!
echo You can now run start-dev.bat
pause

================
File: frontend-app/src/components/BasicMap/BasicMap.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import { loadGoogleMaps } from '@/utils/loadGoogleMaps';
import { config } from '@/config';
import { isPointInPolygon } from '@/utils/polygonUtils';

interface Location {
  lat: number;
  lng: number;
}

interface BasicMapProps {
  center: Location;
  onLocationSelect: (location: Location) => void;
  selectedLocation: Location | null;
  polygonCoords?: Location[];
  onLocationError?: (error: string) => void;
}

export const BasicMap: React.FC<BasicMapProps> = ({
  center,
  onLocationSelect,
  selectedLocation,
  polygonCoords = [],
  onLocationError,
}) => {
  const mapRef = useRef<HTMLDivElement>(null);
  const searchBoxRef = useRef<HTMLInputElement>(null);
  const polygonCoordsRef = useRef<Location[]>(polygonCoords);
  const [map, setMap] = useState<google.maps.Map | null>(null);
  const markerRef = useRef<google.maps.Marker | null>(null);
  const [isMapLoaded, setIsMapLoaded] = useState(false);
  const [mapError, setMapError] = useState<string | null>(null);
  const [isDragging] = useState(false);

  // Update polygon coords ref when prop changes
  useEffect(() => {
    polygonCoordsRef.current = polygonCoords;
  }, [polygonCoords]);

  useEffect(() => {
    loadGoogleMaps()
      .then(() => {
        console.log('Google Maps loaded successfully');
        setIsMapLoaded(true);
        
        if (mapRef.current && !map) {
          // Initialize map with custom styles
          const mapInstance = new google.maps.Map(mapRef.current, {
            center,
            zoom: config.maps.defaultZoom.initial,
            mapTypeControl: false,
            fullscreenControl: false,
            streetViewControl: false,
            zoomControl: true,
            zoomControlOptions: {
              position: google.maps.ControlPosition.RIGHT_CENTER
            },
            gestureHandling: 'greedy', // Allow one-finger pan on mobile
            clickableIcons: false, // Disable POI clicks
            disableDoubleClickZoom: false, // Allow double click zoom
            styles: [
              {
                featureType: 'poi',
                elementType: 'labels',
                stylers: [{ visibility: 'off' }]
              },
              {
                featureType: 'transit',
                elementType: 'labels',
                stylers: [{ visibility: 'off' }]
              }
            ]
          });

          // Add click listener
          mapInstance.addListener('click', (e: google.maps.MapMouseEvent) => {
            if (e.latLng) {
              const location = {
                lat: e.latLng.lat(),
                lng: e.latLng.lng(),
              };
              
              // Validate if location is inside polygon
              if (polygonCoordsRef.current.length > 0 && !isPointInPolygon(location, polygonCoordsRef.current)) {
                if (onLocationError) {
                  onLocationError('‚ö†Ô∏è Por favor selecciona una ubicaci√≥n dentro de nuestra √°rea de cobertura');
                }
                return;
              }
              
              // Create or update marker immediately
              if (markerRef.current) {
                markerRef.current.setPosition(location);
              } else {
                markerRef.current = new google.maps.Marker({
                  position: location,
                  map: mapInstance,
                  animation: google.maps.Animation.DROP,
                  draggable: true,
                  icon: {
                    url: 'data:image/svg+xml;charset=UTF-8;base64,' + btoa(`
                      <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                          <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                            <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity="0.3"/>
                          </filter>
                        </defs>
                        <path d="M24 4C16.27 4 10 10.27 10 18c0 10.5 14 26 14 26s14-15.5 14-26c0-7.73-6.27-14-14-14z" fill="#EF4444" filter="url(#shadow)"/>
                        <circle cx="24" cy="18" r="6" fill="#ffffff"/>
                        <circle cx="24" cy="18" r="3" fill="#EF4444"/>
                      </svg>
                    `),
                    scaledSize: new google.maps.Size(48, 48),
                    anchor: new google.maps.Point(24, 48),
                  },
                  cursor: 'move'
                });
                
                // Set up drag listeners
                markerRef.current.addListener('dragend', () => {
                  const newPosition = markerRef.current?.getPosition();
                  if (newPosition) {
                    const newLocation = {
                      lat: newPosition.lat(),
                      lng: newPosition.lng(),
                    };
                    
                    // Validate if new location is inside polygon
                    if (polygonCoordsRef.current.length > 0 && !isPointInPolygon(newLocation, polygonCoordsRef.current)) {
                      // Return marker to previous position
                      markerRef.current?.setPosition(location);
                      if (onLocationError) {
                        onLocationError('‚ö†Ô∏è Por favor selecciona una ubicaci√≥n dentro de nuestra √°rea de cobertura');
                      }
                      return;
                    }
                    
                    onLocationSelect(newLocation);
                  }
                });
              }
              
              // Call location select
              onLocationSelect(location);
              
              // Pan to location
              mapInstance.panTo(location);
              mapInstance.setZoom(16);
            }
          });

          // Draw polygon if provided
          if (polygonCoords.length > 0) {
            new google.maps.Polygon({
              paths: polygonCoords,
              strokeColor: '#10B981',
              strokeOpacity: 0.9,
              strokeWeight: 3,
              fillColor: '#10B981',
              fillOpacity: 0.2,
              map: mapInstance,
              clickable: false,  // IMPORTANTE: Permite que los clicks pasen a trav√©s del pol√≠gono
              zIndex: 1  // Asegura que est√© detr√°s de otros elementos
            });

            // No agregamos listeners de hover ya que el pol√≠gono no es clickeable

            // Fit map to polygon bounds
            const bounds = new google.maps.LatLngBounds();
            polygonCoords.forEach(coord => {
              bounds.extend(new google.maps.LatLng(coord.lat, coord.lng));
            });
            mapInstance.fitBounds(bounds);
            
            // Add some padding
            const padding = { top: 50, right: 50, bottom: 50, left: 50 };
            mapInstance.fitBounds(bounds, padding);
          }

          setMap(mapInstance);

          // Initialize autocomplete
          if (searchBoxRef.current) {
            const autocomplete = new google.maps.places.Autocomplete(searchBoxRef.current, {
              componentRestrictions: { country: config.regional.countryCode },
              fields: ['geometry', 'formatted_address', 'name'],
              types: ['geocode', 'establishment']
            });

            // Bias results to current map bounds
            autocomplete.bindTo('bounds', mapInstance);

            // Listen for place selection
            autocomplete.addListener('place_changed', () => {
              const place = autocomplete.getPlace();
              
              if (!place.geometry || !place.geometry.location) {
                console.log('No se encontr√≥ la ubicaci√≥n');
                return;
              }

              const location = {
                lat: place.geometry.location.lat(),
                lng: place.geometry.location.lng(),
              };

              // Validate if location is inside polygon
              if (polygonCoords.length > 0 && !isPointInPolygon(location, polygonCoords)) {
                if (onLocationError) {
                  onLocationError('‚ö†Ô∏è La direcci√≥n seleccionada est√° fuera de nuestra √°rea de cobertura');
                }
                // Clear the input
                if (searchBoxRef.current) {
                  searchBoxRef.current.value = '';
                }
                return;
              }

              onLocationSelect(location);
              mapInstance.panTo(location);
              mapInstance.setZoom(config.maps.defaultZoom.search);
            });
          }
        }
      })
      .catch((error) => {
        console.error('Error loading Google Maps:', error);
        setMapError('Error al cargar el mapa. Por favor, recarga la p√°gina.');
      });
  }, []);

  // Update marker when location changes (from search or other sources)
  useEffect(() => {
    if (map && selectedLocation) {
      if (markerRef.current) {
        // If we already have a marker, just update its position
        markerRef.current.setPosition(selectedLocation);
      } else {
        // Create a new marker if it doesn't exist
        const newMarker = new google.maps.Marker({
          position: selectedLocation,
          map: map,
          animation: google.maps.Animation.DROP,
          draggable: true,
          icon: {
            url: 'data:image/svg+xml;charset=UTF-8;base64,' + btoa(`
              <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
                <defs>
                  <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                    <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity="0.3"/>
                  </filter>
                </defs>
                <path d="M24 4C16.27 4 10 10.27 10 18c0 10.5 14 26 14 26s14-15.5 14-26c0-7.73-6.27-14-14-14z" fill="#EF4444" filter="url(#shadow)"/>
                <circle cx="24" cy="18" r="6" fill="#ffffff"/>
                <circle cx="24" cy="18" r="3" fill="#EF4444"/>
              </svg>
            `),
            scaledSize: new google.maps.Size(48, 48),
            anchor: new google.maps.Point(24, 48),
          },
          cursor: 'move'
        });
        
        // Set up drag listeners for the new marker
        newMarker.addListener('dragend', () => {
          const newPosition = newMarker.getPosition();
          if (newPosition) {
            const newLocation = {
              lat: newPosition.lat(),
              lng: newPosition.lng(),
            };
            
            // Validate if location is inside polygon
            if (polygonCoordsRef.current.length > 0 && !isPointInPolygon(newLocation, polygonCoordsRef.current)) {
              // Return marker to previous position
              newMarker.setPosition(selectedLocation);
              if (onLocationError) {
                onLocationError('‚ö†Ô∏è Por favor selecciona una ubicaci√≥n dentro de nuestra √°rea de cobertura');
              }
              return;
            }
            
            onLocationSelect(newLocation);
          }
        });
        
        markerRef.current = newMarker;
      }
      
      // Pan to location
      map.panTo(selectedLocation);
      map.setZoom(16);
    } else if (map && !selectedLocation && markerRef.current) {
      // Remove marker if selectedLocation is null
      markerRef.current.setMap(null);
      markerRef.current = null;
    }
  }, [map, selectedLocation]);

  if (mapError) {
    return (
      <div className="w-full h-[400px] flex items-center justify-center bg-gray-100 rounded-lg">
        <div className="text-center text-red-600">
          <p>{mapError}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Search Box */}
      <div className="relative">
        <input
          ref={searchBoxRef}
          type="text"
          placeholder="Busca tu direcci√≥n o haz clic en el mapa..."
          className="w-full px-4 py-3 pl-10 pr-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200"
          disabled={!isMapLoaded}
        />
        <svg className="absolute left-3 top-3.5 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
        </svg>
      </div>

      {/* Map Container */}
      <div className="relative w-full h-[300px] sm:h-[400px] rounded-lg overflow-hidden shadow-md border-2 border-gray-200">
        <div ref={mapRef} className="w-full h-full" />
        
        {!isMapLoaded && (
          <div className="absolute inset-0 flex items-center justify-center bg-gray-100">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
              <p className="mt-2 text-sm text-gray-600">Cargando mapa...</p>
            </div>
          </div>
        )}
        
        {/* Instructions overlay */}
        {isMapLoaded && !selectedLocation && (
          <div className="absolute top-2 left-2 sm:top-4 sm:left-4 bg-orange-500 bg-opacity-95 backdrop-blur-sm rounded-lg shadow-lg p-3 max-w-[220px] sm:max-w-xs z-10 animate-pulse">
            <div className="space-y-1">
              <p className="text-sm text-white font-semibold">
                üëÜ Toca cualquier punto del mapa para marcar tu ubicaci√≥n
              </p>
            </div>
          </div>
        )}
        
        {/* Instructions for dragging - only show when marker exists */}
        {isMapLoaded && selectedLocation && markerRef.current && (
          <div className="absolute top-2 left-2 sm:top-4 sm:left-4 bg-white bg-opacity-95 backdrop-blur-sm rounded-lg shadow-lg p-2 sm:p-3 max-w-[200px] sm:max-w-xs z-10">
            <p className="text-xs text-gray-700">
              <span className="font-semibold">‚úã Arrastra el marcador</span> para ajustar tu ubicaci√≥n
            </p>
          </div>
        )}
        
        
        {/* Center on marker button */}
        {selectedLocation && map && (
          <button
            onClick={() => {
              map.panTo(selectedLocation);
              map.setZoom(17);
            }}
            className="absolute bottom-20 right-2 sm:bottom-24 sm:right-4 bg-white bg-opacity-95 backdrop-blur-sm rounded-full shadow-lg p-3 hover:bg-gray-100 transition-colors z-10"
            title="Centrar en mi ubicaci√≥n"
          >
            <svg className="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l-4 4m0 0l-4-4m4 4V3" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </button>
        )}
        
        {/* Coordinates display */}
        {selectedLocation && !isDragging && (
          <div className="absolute bottom-2 right-2 sm:bottom-4 sm:right-4 bg-white bg-opacity-95 backdrop-blur-sm rounded-lg shadow-lg p-2 sm:p-3 z-10">
            <p className="text-xs text-gray-700 font-medium">üìç Ubicaci√≥n seleccionada:</p>
            <p className="text-xs text-gray-600 font-mono">
              Lat: {selectedLocation.lat.toFixed(6)}
            </p>
            <p className="text-xs text-gray-600 font-mono">
              Lng: {selectedLocation.lng.toFixed(6)}
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default BasicMap;

================
File: frontend-app/src/components/ui/Input.tsx
================
import { forwardRef } from 'react';
import { clsx } from 'clsx';

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement | HTMLTextAreaElement> {
  label?: string;
  error?: string;
  hint?: string;
  as?: 'input' | 'textarea';
  rows?: number;
  required?: boolean;
}

export const Input = forwardRef<HTMLInputElement | HTMLTextAreaElement, InputProps>(
  ({ label, error, hint, className, as = 'input', required, ...props }, ref) => {
    const Component = as;
    
    return (
      <div className="mb-4">
        {label && (
          <label className="block text-sm font-medium text-gray-700 mb-2">
            {label}
            {required && <span className="text-red-500 ml-1">*</span>}
          </label>
        )}
        {hint && (
          <p className="text-xs text-gray-500 mb-2">{hint}</p>
        )}
        <Component
          ref={ref as React.Ref<HTMLInputElement> & React.Ref<HTMLTextAreaElement>}
          className={clsx(
            'w-full px-4 py-3 text-sm border rounded-lg transition duration-200',
            'focus:outline-none focus:ring-2 focus:ring-offset-0',
            error
              ? 'border-red-300 focus:ring-red-500 focus:border-red-500 bg-red-50'
              : 'border-gray-300 focus:ring-blue-500 focus:border-blue-500 hover:border-gray-400',
            className
          )}
          {...props}
        />
        {error && (
          <p className="text-red-600 text-xs mt-2 flex items-center">
            <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
            {error}
          </p>
        )}
      </div>
    );
  }
);

Input.displayName = 'Input';

================
File: frontend-app/src/config/index.ts
================
export const config = {
  // API Configuration
  api: {
    baseUrl: import.meta.env.VITE_BACKEND_BASE_URL || 'http://localhost:5000',
    prefix: import.meta.env.VITE_API_PREFIX || '/backend',
  },
  
  
  // Regional Configuration
  regional: {
    countryCode: import.meta.env.VITE_COUNTRY_CODE || 'mx',
    locale: import.meta.env.VITE_LOCALE || 'es-MX',
    timezone: import.meta.env.VITE_TIMEZONE || 'America/Mexico_City',
  },
  
  // Google Maps Configuration
  maps: {
    apiKey: import.meta.env.VITE_GOOGLE_MAPS_API_KEY,
    libraries: ['places', 'geometry'] as ('places' | 'geometry')[],
    defaultZoom: {
      initial: 14,
      search: 17,
      selected: 16,
    },
    padding: { top: 50, right: 50, bottom: 50, left: 50 },
  },
  
  // UI Configuration
  ui: {
    mapHeight: {
      mobile: 'h-[300px]',
      desktop: 'sm:h-[400px]',
    },
    colors: {
      primary: '#3B82F6',
      marker: {
        fill: '#3B82F6',
        stroke: '#ffffff',
      },
      polygon: {
        fill: '#3B82F6',
        fillOpacity: 0.2,
        stroke: '#3B82F6',
        strokeOpacity: 0.8,
        strokeWeight: 2,
      },
    },
  },
};

// API Endpoints
export const endpoints = {
  addressRegistration: {
    verifyOtp: `${config.api.prefix}/address-registration/verify-otp`,
    create: `${config.api.prefix}/address-registration/create`,
    update: (addressId: string) => `${config.api.prefix}/address-registration/${addressId}`,
    delete: (addressId: string) => `${config.api.prefix}/address-registration/${addressId}`,
    setDefault: (addressId: string) => `${config.api.prefix}/address-registration/${addressId}/default`,
    getAddresses: (customerId: string) => `${config.api.prefix}/address-registration/${customerId}/addresses`,
    getDeliveryArea: `${config.api.prefix}/address-registration/delivery-area`,
  },
};

================
File: frontend-app/src/i18n/index.ts
================
import { translations, type Locale } from './translations';
import { config } from '@/config';

class I18n {
  private locale: Locale;

  constructor() {
    this.locale = (config.regional.locale || 'es-MX') as Locale;
  }

  /**
   * Get translated text
   */
  t(path: string, params?: Record<string, string>): string {
    const keys = path.split('.');
    let value: unknown = translations[this.locale];

    for (const key of keys) {
      if (typeof value === 'object' && value !== null) {
        value = (value as Record<string, unknown>)[key];
      } else {
        value = undefined;
      }
      if (!value) {
        console.warn(`Translation not found for key: ${path}`);
        return path;
      }
    }

    if (typeof value !== 'string') {
      console.warn(`Translation value is not a string for key: ${path}`);
      return path;
    }

    // Replace parameters
    if (params) {
      return value.replace(/{(\w+)}/g, (match, key) => params[key] || match);
    }

    return value;
  }

  /**
   * Change locale
   */
  setLocale(locale: Locale): void {
    if (translations[locale]) {
      this.locale = locale;
    } else {
      console.warn(`Locale ${locale} not found`);
    }
  }

  /**
   * Get current locale
   */
  getLocale(): Locale {
    return this.locale;
  }
}

export const i18n = new I18n();
export const t = i18n.t.bind(i18n);

================
File: frontend-app/src/types/api.types.ts
================
export interface ApiResponse<T> {
  data: T;
  success?: boolean;
  message?: string;
  error?: string;
}

export interface ApiError {
  message: string;
  statusCode: number;
  error?: unknown;
}

================
File: frontend-app/src/types/customer.types.ts
================
export interface Customer {
  customerId: string;
  firstName?: string | null;
  lastName?: string | null;
  hasAddresses: boolean;
  addresses: Address[];
}

export interface Address {
  id: string;
  name: string;
  customerId: string;
  street: string;
  number: string;
  interiorNumber?: string | null;
  neighborhood?: string | null;
  city?: string | null;
  state?: string | null;
  zipCode?: string | null;
  country?: string | null;
  deliveryInstructions?: string | null;
  latitude?: number | null;
  longitude?: number | null;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
  deletedAt?: string | null;
}

export interface AddressFormData {
  name: string;
  street: string;
  number: string;
  interiorNumber?: string;
  neighborhood?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
  deliveryInstructions?: string;
  latitude: number;
  longitude: number;
  isDefault?: boolean;
}

export interface OTPVerificationResponse {
  valid: boolean;
  customer?: Customer;
}

export interface AddressRegistrationResponse {
  success: boolean;
  address: Address;
}

// Legacy types for backward compatibility
export interface CustomerDeliveryInfo {
  customerId?: string;
  pickupName?: string;
  streetAddress?: string;
  neighborhood?: string | null;
  postalCode?: string | null;
  city?: string | null;
  state?: string | null;
  country?: string | null;
  latitude?: string | number;
  longitude?: string | number;
  additionalDetails?: string | null;
}

// Location type
export interface Location {
  lat: number;
  lng: number;
}

================
File: LOCAL_DEVELOPMENT.md
================
# Gu√≠a de Desarrollo Local

## Script Automatizado (Recomendado)

La forma m√°s f√°cil de iniciar el desarrollo local es usando el script automatizado:

```bash
./start-dev.sh      # Linux/Mac
start-dev.bat       # Windows
```

Este script:
- Inicia PostgreSQL con pgvector y Redis usando Docker
- Configura la base de datos y ejecuta migraciones
- Instala dependencias
- Genera embeddings autom√°ticamente
- Inicia el backend y frontend

## Desarrollo Manual con Docker

Si prefieres configurar todo manualmente, sigue esta gu√≠a:

## Requisitos Previos

- Docker y Docker Compose instalados
- Git
- Node.js 18+ (para ejecutar comandos npm)
- Una API Key de Google AI (Gemini)

## Paso 1: Clonar el Repositorio

```bash
git clone <tu-repositorio>
cd bot_backend
```

## Paso 2: Crear Docker Compose

Crea un archivo `docker-compose.yml` en la ra√≠z del proyecto:

```yaml
version: '3.8'

services:
  postgres:
    image: pgvector/pgvector:pg15
    container_name: postgres_bot_backend
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: bot_backend
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: redis_bot_backend
    ports:
      - "6379:6379"
    restart: unless-stopped

volumes:
  postgres_data:
```

## Paso 3: Configurar Variables de Entorno

Crea el archivo `backend/.env.local` con tus valores:

```bash
cd backend
cp .env.example .env.local
```

Edita `backend/.env.local` con tus valores (ver QUICK_START.md para detalles)

## Paso 4: Iniciar los Servicios

```bash
# Desde la ra√≠z del proyecto
docker-compose up -d

# Instalar dependencias del backend
cd backend
npm install

# Ejecutar migraciones
npm run migrate:dev

# Ejecutar seed (datos iniciales)
npm run seed

# Iniciar el servidor de desarrollo
npm run dev
```

**Nota**: pgvector se configura autom√°ticamente:
- La migraci√≥n crea la extensi√≥n vector y la columna embedding
- Los embeddings se generan autom√°ticamente al iniciar el servidor
- No se requieren pasos manuales adicionales

## Paso 5: Verificar que Todo Funciona

### 1. Health Check
```bash
curl http://localhost:5000/backend
```

Deber√≠as ver:
```json
{
  "message": "Bot Backend API is running",
  "version": "2.0.0",
  "timestamp": "2024-01-15T..."
}
```

### 2. Prisma Studio (Visualizar Base de Datos)
```bash
cd backend
npm run studio
```
Abre http://localhost:5555 en tu navegador

### 3. Probar Webhook
```bash
# Verificaci√≥n GET
curl "http://localhost:5000/backend/webhook?hub.mode=subscribe&hub.verify_token=mi_token_verificacion_local&hub.challenge=test123"
```

### 4. Simular Mensaje de WhatsApp
```bash
curl -X POST http://localhost:5000/backend/webhook \
  -H "Content-Type: application/json" \
  -d '{
    "entry": [{
      "id": "ENTRY_ID",
      "changes": [{
        "value": {
          "messaging_product": "whatsapp",
          "metadata": {
            "display_phone_number": "15551234567",
            "phone_number_id": "123456789"
          },
          "messages": [{
            "from": "521234567890",
            "id": "MESSAGE_ID",
            "timestamp": "1234567890",
            "type": "text",
            "text": {
              "body": "Hola, quiero ver el men√∫"
            }
          }]
        }
      }]
    }]
  }'
```

## Comandos √ötiles de Docker

```bash
# Detener servicios
docker-compose down

# Detener y eliminar vol√∫menes (BORRA LA BD)
docker-compose down -v

# Ejecutar comandos del backend
cd backend
npm run migrate:dev
npm run seed
npm run studio

# Ver logs de Docker
docker-compose logs -f postgres
docker-compose logs -f redis
```

## Desarrollo con Hot Reload

El backend se ejecuta con `ts-node --transpile-only`, por lo que:
- Los cambios en el c√≥digo se reflejan autom√°ticamente
- No necesitas reiniciar el servidor
- Solo guarda los archivos y el servidor se recargar√°

## Soluci√≥n de Problemas

### Error: "Cannot connect to database"
```bash
# Verifica que PostgreSQL est√© corriendo
docker-compose ps

# Revisa los logs de PostgreSQL
docker-compose logs postgres
```

### Error: "Google AI API key not valid"
- Aseg√∫rate de tener una API key v√°lida de Google AI
- Obt√©n una en: https://makersuite.google.com/app/apikey

### Error: "Port 5000 already in use"
```bash
# Encuentra qu√© proceso usa el puerto
lsof -i :5000

# O cambia el puerto en el archivo .env
PORT=5001
```

### Limpiar y empezar de nuevo
```bash
# Detener todo y eliminar vol√∫menes
docker-compose down -v

# Eliminar node_modules
rm -rf backend/node_modules

# Reiniciar Docker
docker-compose down
docker-compose up -d

# Reinstalar dependencias del backend
cd backend
npm install
```

## Testing Local

### Script de Pruebas Automatizadas

Crea `test-local.sh`:

```bash
#!/bin/bash

echo "üß™ Ejecutando pruebas del backend..."

# Colores
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

# URL base
BASE_URL="http://localhost:5000/backend"

# 1. Health check
echo -e "\n1. Health Check:"
response=$(curl -s -w "\n%{http_code}" $BASE_URL)
http_code=$(echo "$response" | tail -n1)
body=$(echo "$response" | head -n-1)

if [ "$http_code" == "200" ]; then
    echo -e "${GREEN}‚úì Health check pas√≥${NC}"
    echo "$body" | jq '.'
else
    echo -e "${RED}‚úó Health check fall√≥ (HTTP $http_code)${NC}"
fi

# 2. Webhook verification
echo -e "\n2. Verificaci√≥n de Webhook:"
response=$(curl -s -w "\n%{http_code}" "$BASE_URL/webhook?hub.mode=subscribe&hub.verify_token=mi_token_verificacion_local&hub.challenge=test123")
http_code=$(echo "$response" | tail -n1)
body=$(echo "$response" | head -n-1)

if [ "$http_code" == "200" ] && [ "$body" == "test123" ]; then
    echo -e "${GREEN}‚úì Verificaci√≥n de webhook pas√≥${NC}"
else
    echo -e "${RED}‚úó Verificaci√≥n de webhook fall√≥${NC}"
fi

# 3. Test OTP
echo -e "\n3. Test de OTP:"
response=$(curl -s -w "\n%{http_code}" -X POST $BASE_URL/otp/verify \
  -H "Content-Type: application/json" \
  -d '{"customerId":"test123","otp":"123456"}')
http_code=$(echo "$response" | tail -n1)

if [ "$http_code" == "200" ]; then
    echo -e "${GREEN}‚úì Endpoint OTP funcionando${NC}"
else
    echo -e "${RED}‚úó Endpoint OTP fall√≥${NC}"
fi

echo -e "\n‚úÖ Pruebas completadas"
```

Hazlo ejecutable:
```bash
chmod +x test-local.sh
./test-local.sh
```

## Integraci√≥n con ngrok (para webhooks reales)

Si quieres probar con webhooks reales de WhatsApp:

```bash
# Instalar ngrok
brew install ngrok  # macOS
# o descarga de https://ngrok.com

# Exponer tu backend local
ngrok http 5000

# Obtendr√°s una URL como: https://abc123.ngrok.io
# Usa esta URL en Meta Developers como webhook:
# https://abc123.ngrok.io/backend/webhook
```

## Pr√≥ximos Pasos

1. **Desarrollo**: Modifica el c√≥digo en `backend/src`
2. **Pruebas**: Usa los scripts de prueba
3. **Depuraci√≥n**: Revisa logs con `docker-compose logs -f backend`
4. **Base de datos**: Usa Prisma Studio para ver/editar datos
5. **Deployment**: Cuando est√©s listo, despliega a Railway

¬°Feliz desarrollo! üöÄ

================
File: PRODUCTION_UPDATE_GUIDE.md
================
# üöÄ Gu√≠a de Actualizaci√≥n en Producci√≥n

Esta gu√≠a explica c√≥mo actualizar tu Bot Backend en producci√≥n de manera segura y eficiente.

## üìã Scripts Disponibles

### 1. **update-app.sh** - Actualizaci√≥n Est√°ndar
- Actualiza el c√≥digo desde GitHub
- Instala dependencias nuevas
- Aplica migraciones incrementales
- Mantiene todos los datos existentes
- Zero-downtime con PM2 reload

### 2. **reset-database-production.sh** - Reset Completo de BD
- **‚ö†Ô∏è ELIMINA TODOS LOS DATOS**
- Crea backup antes de eliminar
- Limpia completamente la base de datos
- Regenera desde cero con migraciones nuevas
- √ötil para cambios estructurales mayores

### 3. **update-app-with-reset.sh** - Actualizaci√≥n Combinada (NUEVO)
- Combina ambas opciones en un solo script
- Modo normal: actualizaci√≥n est√°ndar
- Modo `--reset-db`: actualizaci√≥n + reset de BD
- Interfaz unificada para ambos casos

## üîÑ Proceso de Actualizaci√≥n

### Actualizaci√≥n Normal (Recomendado)

```bash
# Conectar al servidor
ssh cloudbite@[TU-IP-DROPLET]

# Ir al directorio del proyecto
cd ~/bot_backend

# Ejecutar actualizaci√≥n est√°ndar
./scripts/update-app.sh
```

**Qu√© hace:**
1. Guarda cambios locales si existen
2. Descarga √∫ltimos cambios de GitHub
3. Instala nuevas dependencias
4. Aplica migraciones incrementales
5. Compila el proyecto
6. Recarga servicios sin downtime
7. Verifica que todo funcione

### Actualizaci√≥n con Reset de BD (Cambios Mayores)

```bash
# Conectar al servidor
ssh cloudbite@[TU-IP-DROPLET]

# Ir al directorio del proyecto
cd ~/bot_backend

# Ejecutar actualizaci√≥n con reset
./scripts/update-app-with-reset.sh --reset-db
```

**‚ö†Ô∏è ADVERTENCIAS:**
- Elimina TODOS los datos
- Requiere doble confirmaci√≥n
- Crea backup autom√°tico antes de proceder
- Usar solo cuando sea absolutamente necesario

## üìä Cu√°ndo Usar Cada Opci√≥n

### Usa Actualizaci√≥n Normal cuando:
- Agregues nuevas funcionalidades
- Corrijas bugs
- Agregues nuevos campos a tablas existentes
- Hagas cambios menores en el esquema
- Actualices dependencias

### Usa Reset de BD cuando:
- Cambies tipos de datos fundamentales
- Elimines tablas o relaciones complejas
- Tengas migraciones corruptas o conflictivas
- Necesites empezar desde cero en desarrollo
- Cambies la estructura base del esquema

## üõ°Ô∏è Mejores Pr√°cticas

### Antes de Actualizar

1. **Revisa los cambios:**
   ```bash
   git fetch origin
   git log HEAD..origin/main --oneline
   ```

2. **Verifica el estado actual:**
   ```bash
   pm2 status
   pm2 logs --lines 50
   ```

3. **Considera el impacto:**
   - ¬øHay usuarios activos?
   - ¬øLos cambios son breaking?
   - ¬øNecesitas notificar a usuarios?

### Durante la Actualizaci√≥n

1. **Monitorea los logs:**
   ```bash
   # En otra terminal
   pm2 logs --lines 100
   ```

2. **Si algo sale mal:**
   ```bash
   # Revertir a commit anterior
   git reset --hard [COMMIT-ANTERIOR]
   cd backend && npm install && npm run build
   pm2 restart all
   ```

### Despu√©s de Actualizar

1. **Verifica funcionamiento:**
   ```bash
   # API Health
   curl https://cloudbiteapp.com/api/backend
   
   # Logs sin errores
   pm2 logs --err --lines 50
   
   # M√©tricas
   pm2 monit
   ```

2. **Prueba funcionalidades cr√≠ticas:**
   - Env√≠a mensaje de prueba al bot
   - Verifica webhook de WhatsApp
   - Confirma que el frontend carga

## üîß Soluci√≥n de Problemas

### Error: "npm install failed"
```bash
# Limpiar cache de npm
cd backend
rm -rf node_modules package-lock.json
npm cache clean --force
npm install
```

### Error: "Migration failed"
```bash
# Ver estado de migraciones
cd backend
npx prisma migrate status

# Si hay problemas, resetear
./scripts/reset-database-production.sh
```

### Error: "PM2 process crashed"
```bash
# Ver logs detallados
pm2 logs --err --lines 200

# Reiniciar todo
pm2 delete all
cd backend && pm2 start ecosystem.config.js
```

### Error: "Port already in use"
```bash
# Encontrar proceso en puerto 5000
sudo lsof -i :5000
# Kill el proceso si es necesario
sudo kill -9 [PID]
```

## üìù Checklist de Actualizaci√≥n

- [ ] Revisar cambios pendientes en GitHub
- [ ] Verificar espacio en disco: `df -h`
- [ ] Confirmar backup reciente de BD
- [ ] Ejecutar script de actualizaci√≥n apropiado
- [ ] Verificar logs sin errores
- [ ] Probar endpoint de health
- [ ] Enviar mensaje de prueba al bot
- [ ] Verificar que frontend carga correctamente
- [ ] Monitorear por 5-10 minutos

## üÜò Comandos de Emergencia

```bash
# Ver todos los logs
pm2 logs

# Reiniciar todo
pm2 restart all

# Detener todo
pm2 stop all

# Estado detallado
pm2 show bot-backend-api

# Monitoreo en vivo
pm2 monit

# Restaurar backup de BD (si existe)
PGPASSWORD=$DB_PASSWORD psql -U bot_user -h localhost bot_db < ~/backup_[FECHA].sql
```

## üìû Soporte

Si encuentras problemas:
1. Revisa los logs: `pm2 logs --err`
2. Verifica la documentaci√≥n en `/CLAUDE.md`
3. Revisa issues en GitHub
4. Contacta soporte si es cr√≠tico

---

**Recuerda:** Siempre es mejor hacer actualizaciones frecuentes y peque√±as que acumular muchos cambios para una actualizaci√≥n grande.

================
File: QUICK_START.md
================
# üöÄ Inicio R√°pido - Bot WhatsApp Local

## Requisitos Previos
1. **Docker** instalado
2. **Node.js 18+** instalado
3. **ngrok** (para WhatsApp real) - ver configuraci√≥n abajo
4. **API Key de Google AI** (gratis en https://makersuite.google.com/app/apikey)
5. **Cuenta Meta Developer** con app WhatsApp Business configurada

## üîß Configuraci√≥n Inicial (solo la primera vez)

### 1Ô∏è‚É£ Obtener Credenciales de WhatsApp

1. Ve a [Meta for Developers](https://developers.facebook.com)
2. Crea o selecciona tu app
3. En WhatsApp > API Setup, obt√©n:
   - `Phone number ID` (WHATSAPP_PHONE_NUMBER_MESSAGING_ID)
   - `WhatsApp Business Account ID`
   - `Permanent Access Token` (WHATSAPP_ACCESS_TOKEN)
4. Anota tu n√∫mero de WhatsApp Business
5. **IMPORTANTE para desarrollo**: En la secci√≥n "To" o "Recipients", agrega tu n√∫mero personal:
   - Click en "Add phone number" o "Manage phone number list"
   - Agrega el n√∫mero desde el cual enviar√°s mensajes de prueba
   - Verifica con el c√≥digo que recibir√°s por WhatsApp

### 2Ô∏è‚É£ Configurar Variables de Entorno

Edita `backend/.env.local` (NO `.env`) y actualiza:

```env
# Google AI - REQUERIDO
GOOGLE_AI_API_KEY=tu_api_key_real_aqui

# WhatsApp Business API - REQUERIDO
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=tu_phone_number_id
WHATSAPP_ACCESS_TOKEN=tu_access_token_permanente
WHATSAPP_VERIFY_TOKEN=un_token_secreto_que_tu_elijas
```

### 3Ô∏è‚É£ Configurar Ngrok

Ngrok ahora requiere autenticaci√≥n (cuenta gratuita):

1. **Crea una cuenta** en https://dashboard.ngrok.com/signup
2. **Obt√©n tu authtoken** en https://dashboard.ngrok.com/get-started/your-authtoken
3. **Configura ngrok** con tu token:
   ```bash
   ngrok config add-authtoken TU_TOKEN_AQUI
   ```

## üöÄ Iniciar el Bot

### 1Ô∏è‚É£ Iniciar Backend y Base de Datos
```bash
./start-dev.sh      # Linux/Mac
start-dev.bat       # Windows
```

Esto autom√°ticamente:
- ‚úÖ Inicia PostgreSQL con Docker
- ‚úÖ Instala dependencias
- ‚úÖ Crea las tablas y carga el men√∫
- ‚úÖ Inicia el servidor en http://localhost:5000/backend

### 2Ô∏è‚É£ Exponer el Servidor con Ngrok

En otra terminal:
```bash
ngrok http 5000
```

Ver√°s algo como:
```
Forwarding  https://abc123.ngrok-free.app -> http://localhost:5000
```

**IMPORTANTE**: 
- Copia la URL HTTPS (cambia cada vez que reinicias ngrok)
- Si no configuraste ngrok anteriormente, ver la secci√≥n 3Ô∏è‚É£ arriba

### 3Ô∏è‚É£ Configurar Webhook en Meta

1. Ve a tu app en [Meta for Developers](https://developers.facebook.com)
2. WhatsApp > Configuration > Webhook
3. Configura:
   - **Callback URL**: `https://abc123.ngrok-free.app/backend/webhook`
   - **Verify token**: El mismo que pusiste en WHATSAPP_VERIFY_TOKEN
4. Click en "Verify and save"
5. Suscr√≠bete a los campos: `messages`

## ‚úÖ ¬°Listo para Probar!

1. **Env√≠a un mensaje** a tu n√∫mero de WhatsApp Business
2. **Ver√°s los logs** en la terminal donde ejecutaste el script de inicio
3. **El bot responder√°** directamente por WhatsApp

### Mensajes de Prueba:
- "Hola" - Saludo inicial
- "Quiero ver el men√∫" - Muestra el men√∫
- "Quiero 2 pizzas hawaianas grandes" - Inicia un pedido

## üõ†Ô∏è Comandos √ötiles

```bash
# Ver y editar datos en la base de datos (en otra terminal)
cd backend && npx prisma studio
# Esto abre una interfaz web en http://localhost:5555

# Ver logs de Docker
docker compose logs -f

# Reiniciar todo
docker compose down && ./start-dev.sh  # O start-dev.bat en Windows
```

## üõë Para Detener Todo

1. `Ctrl+C` en la terminal del servidor
2. `Ctrl+C` en la terminal de ngrok
3. `docker-compose down` para detener PostgreSQL

## ‚ö†Ô∏è Soluci√≥n de Problemas

### "Webhook no se verifica"
- Aseg√∫rate que el verify token coincida exactamente
- La URL debe ser HTTPS (ngrok lo proporciona)
- El servidor debe estar corriendo antes de verificar

### "No recibo mensajes"
- Verifica que est√©s suscrito a "messages" en el webhook
- Revisa los logs del servidor
- En Meta > Webhooks > Recent errors

### "Error: Recipient phone number not in allowed list"
- Tu app est√° en modo desarrollo
- Ve a WhatsApp > API Setup > secci√≥n "To" o "Recipients"
- Agrega el n√∫mero desde el cual env√≠as mensajes
- Verifica con el c√≥digo que recibes por WhatsApp

### "El bot no responde"
- Verifica que tengas tu Google AI API key configurada
- Revisa los logs para ver errores
- Aseg√∫rate que el n√∫mero que env√≠a est√° en formato internacional

## üìù Notas Importantes

- **Ngrok gratis**: La URL cambia cada vez, debes actualizar el webhook
- **Rate limits**: WhatsApp tiene l√≠mites de mensajes por minuto
- **Desarrollo**: Usa un n√∫mero de prueba para no afectar el principal
- **Logs**: Todos los mensajes y respuestas aparecen en la terminal

================
File: README.md
================
# ü§ñ Bot Backend - WhatsApp Restaurant Bot

Backend para un bot de WhatsApp para restaurante, usando Express, Prisma y PostgreSQL.

## üöÄ Inicio R√°pido

Ver la gu√≠a completa en: **[QUICK_START.md](QUICK_START.md)**

### Resumen:
1. Configura credenciales de WhatsApp y Google AI
2. Ejecuta `./start-dev.sh` (Linux/Mac) o `start-dev.bat` (Windows)
3. Usa ngrok para exponer el webhook
4. ¬°Listo! El bot responde por WhatsApp

### Requisitos:
- Docker y Docker Compose
- Node.js 18+
- ngrok
- API Key de Google AI
- Cuenta Meta Developer con WhatsApp Business

## üìÅ Estructura del Proyecto

```
backend/
‚îú‚îÄ‚îÄ prisma/
‚îÇ   ‚îú‚îÄ‚îÄ schema.prisma    # Esquema de la base de datos
‚îÇ   ‚îî‚îÄ‚îÄ seed.ts          # Datos iniciales (men√∫)
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ config/          # Configuraciones y mensajes predefinidos
‚îÇ   ‚îú‚îÄ‚îÄ services/        # L√≥gica de negocio
‚îÇ   ‚îú‚îÄ‚îÄ utils/           # Utilidades y procesador de IA
‚îÇ   ‚îú‚îÄ‚îÄ whatsapp/        # Handlers de WhatsApp
‚îÇ   ‚îî‚îÄ‚îÄ server.ts        # Servidor Express principal
‚îî‚îÄ‚îÄ .env.local           # Variables de entorno para desarrollo
```

## üöÄ Deploy en Railway

### 1. Preparar el Proyecto

Aseg√∫rate de que todo funciona localmente primero.

### 2. Crear Proyecto en Railway

1. Ve a [Railway.app](https://railway.app)
2. Crea un nuevo proyecto
3. Agrega un servicio PostgreSQL
4. Agrega tu repositorio de GitHub

### 3. Configurar Variables de Entorno

En Railway, agrega estas variables:

```env
# WhatsApp Business API
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=tu_numero_id
WHATSAPP_ACCESS_TOKEN=tu_access_token
WHATSAPP_VERIFY_TOKEN=tu_verify_token

# Google AI
GOOGLE_AI_API_KEY=tu_api_key

# URLs
FRONTEND_BASE_URL=https://tu-dominio.com

# L√≠mites de mensajes
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5

# Stripe (opcional)
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=
```

### 4. Configurar el Build

En Railway, configura:
- **Build Command**: `cd backend && npm install && npm run build`
- **Start Command**: `cd backend && npm run migrate && npm run seed && npm start`

### 5. Deploy

Railway desplegar√° autom√°ticamente cuando hagas push a tu repositorio.

## üîß Scripts de Desarrollo

### Scripts Principales

```bash
# Iniciar todo (backend + frontend + PostgreSQL)
./start-dev.sh      # Linux/Mac
start-dev.bat       # Windows

# Iniciar solo el frontend (requiere backend corriendo)
./start-frontend.sh

# Desarrollo completo con hot-reload (backend + frontend)
./dev.sh

# Solo backend
./dev-backend.sh

# Solo frontend
./dev-frontend.sh
```

### Comandos NPM

```bash
# Desarrollo local
npm run dev

# Generar cliente de Prisma
npm run generate

# Ejecutar migraciones
npm run migrate:dev

# Ver base de datos
npm run studio

# Ejecutar seed
npm run seed
```

## üìù Notas Importantes

- El bot usa Google Gemini AI para procesar mensajes
- La base de datos PostgreSQL se configura autom√°ticamente en Railway
- Los webhooks de WhatsApp deben apuntar a: `https://tu-app.railway.app/backend/webhook`
- El puerto 5433 se usa localmente para evitar conflictos con PostgreSQL existente
- Para probar con WhatsApp real en local, usa ngrok o similar

================
File: scripts/install-dependencies.sh
================
#!/bin/bash

# Script de instalaci√≥n r√°pida de dependencias para Ubuntu
# Autor: Bot Backend Deployment Script
# Uso: sudo ./install-dependencies.sh

set -e  # Salir si hay alg√∫n error

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Funci√≥n para imprimir con color
print_step() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

# Verificar que se ejecuta como root
if [[ $EUID -ne 0 ]]; then
   print_error "Este script debe ejecutarse como root (usa sudo)"
   exit 1
fi

print_step "Iniciando instalaci√≥n de dependencias..."

# Actualizar sistema
print_step "Actualizando sistema..."
apt update && apt upgrade -y
print_success "Sistema actualizado"

# Instalar herramientas b√°sicas
print_step "Instalando herramientas b√°sicas..."
apt install -y curl wget git build-essential software-properties-common apt-transport-https ca-certificates gnupg lsb-release
print_success "Herramientas b√°sicas instaladas"

# Instalar Node.js 20.x
print_step "Instalando Node.js 20.x LTS..."
curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
apt-get install -y nodejs
print_success "Node.js $(node --version) instalado"
print_success "npm $(npm --version) instalado"

# Instalar PostgreSQL 15
print_step "Configurando repositorio de PostgreSQL..."
sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add -
apt update

print_step "Instalando PostgreSQL 15..."
apt install -y postgresql-15 postgresql-contrib-15 postgresql-15-pgvector
print_success "PostgreSQL 15 con pgvector instalado"

# Instalar Redis
print_step "Instalando Redis..."
apt install -y redis-server

# Configurar Redis para producci√≥n
sed -i 's/supervised no/supervised systemd/g' /etc/redis/redis.conf
sed -i 's/# maxmemory <bytes>/maxmemory 512mb/g' /etc/redis/redis.conf
sed -i 's/# maxmemory-policy noeviction/maxmemory-policy allkeys-lru/g' /etc/redis/redis.conf

systemctl restart redis-server
systemctl enable redis-server
print_success "Redis instalado y configurado"

# Instalar PM2
print_step "Instalando PM2 globalmente..."
npm install -g pm2
print_success "PM2 instalado"

# Instalar Nginx
print_step "Instalando Nginx..."
apt install -y nginx
print_success "Nginx instalado"

# Instalar Certbot para SSL
print_step "Instalando Certbot para SSL..."
apt install -y certbot python3-certbot-nginx
print_success "Certbot instalado"

# Instalar herramientas de monitoreo
print_step "Instalando herramientas de monitoreo..."
apt install -y htop iotop nethogs
print_success "Herramientas de monitoreo instaladas"

# Instalar fail2ban para seguridad
print_step "Instalando fail2ban..."
apt install -y fail2ban
systemctl enable fail2ban
print_success "fail2ban instalado"

# Instalar unattended-upgrades
print_step "Instalando actualizaciones autom√°ticas de seguridad..."
apt install -y unattended-upgrades
print_success "Actualizaciones autom√°ticas configuradas"

# Verificar servicios
print_step "Verificando servicios..."
echo ""
echo "Estado de servicios:"
echo "-------------------"

# PostgreSQL
if systemctl is-active --quiet postgresql; then
    print_success "PostgreSQL: Activo"
else
    print_error "PostgreSQL: Inactivo"
fi

# Redis
if systemctl is-active --quiet redis-server; then
    print_success "Redis: Activo"
else
    print_error "Redis: Inactivo"
fi

# Nginx
if systemctl is-active --quiet nginx; then
    print_success "Nginx: Activo"
else
    print_error "Nginx: Inactivo"
fi

echo ""
print_success "¬°Instalaci√≥n de dependencias completada!"
echo ""
print_warning "Pr√≥ximos pasos:"
echo "1. Crear usuario no-root para la aplicaci√≥n"
echo "2. Configurar PostgreSQL con usuario y base de datos"
echo "3. Clonar el repositorio y configurar variables de entorno"
echo "4. Ejecutar el script setup-app.sh"
echo ""
print_step "Versiones instaladas:"
echo "Node.js: $(node --version)"
echo "npm: $(npm --version)"
echo "PostgreSQL: $(psql --version | awk '{print $3}')"
echo "Redis: $(redis-server --version | awk '{print $3}' | cut -d'=' -f2)"
echo "Nginx: $(nginx -v 2>&1 | awk '{print $3}' | cut -d'/' -f2)"

================
File: scripts/setup-app.sh
================
#!/bin/bash

# Script para configurar la aplicaci√≥n Bot Backend
# Autor: Bot Backend Deployment Script
# Uso: ./setup-app.sh (NO requiere sudo)

set -e

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Funci√≥n para imprimir con color
print_step() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

# Verificar que NO se ejecuta como root
if [[ $EUID -eq 0 ]]; then
   print_error "Este script NO debe ejecutarse como root"
   exit 1
fi

# Verificar que estamos en el directorio correcto
if [ ! -f "backend/package.json" ]; then
    print_error "Este script debe ejecutarse desde el directorio ra√≠z del proyecto (bot_backend)"
    exit 1
fi

print_step "Configurando aplicaci√≥n Bot Backend..."

# Instalar dependencias del backend
print_step "Instalando dependencias del backend..."
cd backend
npm install --production
print_success "Dependencias del backend instaladas"

# Instalar y construir frontend
print_step "Instalando y construyendo frontend..."
cd ../frontend-app
npm install
npm run build
print_success "Frontend construido para producci√≥n"

# Volver al backend
cd ../backend

# Copiar archivo de entorno
if [ ! -f ".env" ]; then
    print_step "Creando archivo .env..."
    cp .env.example .env
    print_warning "Archivo .env creado. DEBES editarlo con tus credenciales reales"
else
    print_success "Archivo .env ya existe"
fi

# Generar cliente Prisma
print_step "Generando cliente Prisma..."
npm run generate
print_success "Cliente Prisma generado"

# Solicitar confirmaci√≥n para migraciones
echo ""
print_warning "¬øHas configurado las variables de entorno en .env?"
read -p "¬øDeseas ejecutar las migraciones de base de datos ahora? (s/n): " -n 1 -r
echo ""

if [[ $REPLY =~ ^[Ss]$ ]]; then
    print_step "Ejecutando migraciones de base de datos..."
    npm run migrate
    print_success "Migraciones aplicadas"
    
    # Preguntar por embeddings
    read -p "¬øDeseas generar embeddings para b√∫squeda sem√°ntica? (s/n): " -n 1 -r
    echo ""
    
    if [[ $REPLY =~ ^[Ss]$ ]]; then
        print_step "Generando embeddings..."
        npm run seed:embeddings
        print_success "Embeddings generados"
    fi
else
    print_warning "Migraciones omitidas. Ejecuta 'npm run migrate' cuando hayas configurado .env"
fi

# Compilar el proyecto
print_step "Compilando proyecto TypeScript..."
npm run build
print_success "Proyecto compilado"

# Configurar PM2
print_step "Configurando PM2..."
pm2 startup systemd -u $USER --hp $HOME
print_success "PM2 configurado para inicio autom√°tico"

# Crear directorios necesarios
print_step "Creando directorios necesarios..."
mkdir -p logs
mkdir -p uploads
print_success "Directorios creados"

# Verificar configuraci√≥n
print_step "Verificando configuraci√≥n..."
echo ""

# Verificar archivo .env
if [ -f ".env" ]; then
    # Contar variables configuradas
    CONFIGURED_VARS=$(grep -E "^[A-Z_]+=" .env | grep -v "=$" | wc -l)
    TOTAL_VARS=$(grep -E "^[A-Z_]+=" .env | wc -l)
    
    if [ $CONFIGURED_VARS -eq $TOTAL_VARS ]; then
        print_success "Todas las variables de entorno parecen estar configuradas ($CONFIGURED_VARS/$TOTAL_VARS)"
    else
        print_warning "Solo $CONFIGURED_VARS de $TOTAL_VARS variables est√°n configuradas"
        print_warning "Revisa y completa el archivo .env"
    fi
else
    print_error "Archivo .env no encontrado"
fi

# Mostrar resumen
echo ""
echo "================================="
echo "RESUMEN DE CONFIGURACI√ìN"
echo "================================="
echo ""
print_success "Instalaci√≥n completada"
echo ""
echo "Para iniciar la aplicaci√≥n:"
echo ""
echo "1. Edita el archivo backend/.env con tus credenciales:"
echo "   cd backend && nano .env"
echo ""
echo "2. Si no ejecutaste las migraciones, hazlo ahora:"
echo "   cd backend && npm run migrate"
echo ""
echo "3. Inicia la aplicaci√≥n con PM2:"
echo "   cd backend && npm run pm2:start"
echo ""
echo "4. Verifica los logs:"
echo "   pm2 logs"
echo ""
echo "5. Monitorea los procesos:"
echo "   pm2 monit"
echo ""
print_warning "IMPORTANTE: Configura Nginx para servir el frontend y hacer proxy al API"
print_success "Frontend construido en: ~/bot_backend/frontend-app/dist"

# Guardar informaci√≥n √∫til
cat > ~/bot_backend_info.txt <<EOF
================================
BOT BACKEND - INFORMACI√ìN √öTIL
================================

COMANDOS PM2:
- Ver estado: pm2 status
- Ver logs: pm2 logs
- Reiniciar: pm2 restart all
- Detener: pm2 stop all
- Monitorear: pm2 monit

RUTAS DE LA APLICACI√ìN:
- Backend: ~/bot_backend/backend
- Frontend: ~/bot_backend/frontend-app/dist
- Logs: ~/bot_backend/backend/logs
- Uploads: ~/bot_backend/backend/uploads

PUERTOS:
- API Backend: 5000
- PostgreSQL: 5432
- Redis: 6379

COMANDOS √öTILES:
- Actualizar app: cd ~/bot_backend && git pull && cd backend && npm install && npm run build && pm2 reload all
- Ver logs en tiempo real: pm2 logs --lines 100
- Backup de BD: pg_dump -U bot_user bot_db > backup.sql

================================
EOF

print_success "Informaci√≥n guardada en ~/bot_backend_info.txt"

================
File: scripts/setup-database.sh
================
#!/bin/bash

# Script para configurar PostgreSQL y crear la base de datos
# Autor: Bot Backend Deployment Script
# Uso: sudo ./setup-database.sh

set -e

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Funci√≥n para imprimir con color
print_step() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

# Verificar que se ejecuta como root
if [[ $EUID -ne 0 ]]; then
   print_error "Este script debe ejecutarse como root (usa sudo)"
   exit 1
fi

# Solicitar informaci√≥n
read -p "Nombre de usuario para la base de datos (default: bot_user): " DB_USER
DB_USER=${DB_USER:-bot_user}

read -sp "Contrase√±a para el usuario $DB_USER: " DB_PASSWORD
echo ""

if [ -z "$DB_PASSWORD" ]; then
    print_error "La contrase√±a no puede estar vac√≠a"
    exit 1
fi

read -p "Nombre de la base de datos (default: bot_db): " DB_NAME
DB_NAME=${DB_NAME:-bot_db}

print_step "Configurando PostgreSQL..."

# Crear usuario y base de datos
sudo -u postgres psql <<EOF
-- Verificar si el usuario existe antes de crearlo
DO \$\$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_user WHERE usename = '$DB_USER') THEN
        CREATE USER $DB_USER WITH PASSWORD '$DB_PASSWORD';
    ELSE
        ALTER USER $DB_USER WITH PASSWORD '$DB_PASSWORD';
    END IF;
END
\$\$;

-- Verificar si la base de datos existe antes de crearla
SELECT 'CREATE DATABASE $DB_NAME OWNER $DB_USER'
WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '$DB_NAME')\gexec

-- Otorgar todos los privilegios
GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;

-- Conectar a la base de datos y crear la extensi√≥n pgvector
\c $DB_NAME
CREATE EXTENSION IF NOT EXISTS vector;
GRANT ALL ON SCHEMA public TO $DB_USER;
EOF

print_success "Base de datos configurada correctamente"

# Verificar la configuraci√≥n de PostgreSQL
print_step "Verificando configuraci√≥n de PostgreSQL..."

# Obtener la versi√≥n de PostgreSQL
PG_VERSION=$(sudo -u postgres psql -t -c "SELECT version();" | grep -oP '\d+\.\d+' | head -1 | cut -d. -f1)

# Configurar pg_hba.conf para permitir conexiones locales
PG_CONFIG_DIR="/etc/postgresql/$PG_VERSION/main"

if [ -d "$PG_CONFIG_DIR" ]; then
    # Hacer backup del archivo original
    cp "$PG_CONFIG_DIR/pg_hba.conf" "$PG_CONFIG_DIR/pg_hba.conf.backup"
    
    # Asegurar que permite conexiones locales con md5
    if ! grep -q "local   all             $DB_USER" "$PG_CONFIG_DIR/pg_hba.conf"; then
        echo "local   all             $DB_USER                                md5" >> "$PG_CONFIG_DIR/pg_hba.conf"
    fi
    
    # Reiniciar PostgreSQL
    systemctl restart postgresql
    print_success "Configuraci√≥n de PostgreSQL actualizada"
else
    print_warning "No se pudo encontrar el directorio de configuraci√≥n de PostgreSQL"
fi

# Probar la conexi√≥n
print_step "Probando conexi√≥n a la base de datos..."
export PGPASSWORD=$DB_PASSWORD
if psql -U $DB_USER -h localhost -d $DB_NAME -c '\q' 2>/dev/null; then
    print_success "Conexi√≥n exitosa a la base de datos"
else
    print_error "No se pudo conectar a la base de datos"
    print_warning "Verifica la configuraci√≥n en pg_hba.conf"
fi
unset PGPASSWORD

# Crear archivo con la cadena de conexi√≥n
print_step "Guardando informaci√≥n de conexi√≥n..."
cat > ~/db_connection_info.txt <<EOF
=================================
INFORMACI√ìN DE CONEXI√ìN A LA BASE DE DATOS
=================================

Base de datos: $DB_NAME
Usuario: $DB_USER
Puerto: 5432

Cadena de conexi√≥n para .env:
DATABASE_URL=postgresql://$DB_USER:$DB_PASSWORD@localhost:5432/$DB_NAME

IMPORTANTE: Guarda esta informaci√≥n de forma segura y elimina este archivo despu√©s de usarlo.
=================================
EOF

chmod 600 ~/db_connection_info.txt
print_success "Informaci√≥n guardada en ~/db_connection_info.txt"

echo ""
print_success "¬°Configuraci√≥n de base de datos completada!"
echo ""
print_warning "IMPORTANTE:"
echo "1. La informaci√≥n de conexi√≥n se guard√≥ en ~/db_connection_info.txt"
echo "2. Copia la cadena DATABASE_URL a tu archivo .env"
echo "3. Elimina el archivo db_connection_info.txt despu√©s de usarlo"
echo ""
echo "Cadena de conexi√≥n:"
echo -e "${GREEN}DATABASE_URL=postgresql://$DB_USER:$DB_PASSWORD@localhost:5432/$DB_NAME${NC}"

================
File: start-dev.bat
================
@echo off
echo Starting WhatsApp Bot Backend with Workers...

REM Check if Docker is running
docker version >nul 2>&1
if errorlevel 1 (
    echo ERROR: Docker is not running. Please start Docker Desktop first.
    pause
    exit /b 1
)

REM Kill processes using our ports
echo Cleaning up ports...
for /f "tokens=5" %%a in ('netstat -aon ^| findstr :5000 ^| findstr LISTENING') do (
    taskkill /F /PID %%a >nul 2>&1
)
for /f "tokens=5" %%a in ('netstat -aon ^| findstr :3000 ^| findstr LISTENING') do (
    taskkill /F /PID %%a >nul 2>&1
)

REM Stop any existing containers
echo Cleaning up existing containers...
docker compose down --remove-orphans >nul 2>&1

REM Start Docker containers
echo Starting PostgreSQL and Redis...
docker compose up -d

REM Wait for PostgreSQL to be ready
echo Waiting for PostgreSQL to be ready...
set max_attempts=30
set attempt=0

:wait_postgres
docker compose exec -T postgres pg_isready -U postgres >nul 2>&1
if %errorlevel% equ 0 goto postgres_ready

set /a attempt+=1
if %attempt% geq %max_attempts% (
    echo ERROR: PostgreSQL failed to start after %max_attempts% attempts
    echo Try running: docker compose logs postgres
    pause
    exit /b 1
)

timeout /t 1 /nobreak >nul
goto wait_postgres

:postgres_ready
echo PostgreSQL is ready!

REM Wait for Redis to be ready
echo Waiting for Redis to be ready...
set max_attempts=15
set attempt=0

:wait_redis
docker compose exec -T redis redis-cli ping >nul 2>&1
if %errorlevel% equ 0 goto redis_ready

set /a attempt+=1
if %attempt% geq %max_attempts% (
    echo WARNING: Redis not ready, but continuing (system will work without Redis)
    goto continue_setup
)

timeout /t 1 /nobreak >nul
goto wait_redis

:redis_ready
echo Redis is ready!

:continue_setup
REM Navigate to backend directory
cd backend

REM Check if .env exists
if not exist .env (
    if exist .env.local (
        echo Copying .env.local to .env...
        copy .env.local .env >nul
    ) else if exist .env.example (
        echo Creating .env from .env.example...
        copy .env.example .env >nul
        echo.
        echo IMPORTANT: You must configure backend\.env with your credentials
        echo See QUICK_START.md for detailed instructions
        pause
        exit /b 1
    )
)

REM Install dependencies if needed
if not exist node_modules (
    echo Installing backend dependencies...
    call npm install
)

REM Generate Prisma client
echo Generating Prisma client...
REM Try to delete old Prisma client to avoid permission issues
if exist node_modules\.prisma (
    rmdir /s /q node_modules\.prisma >nul 2>&1
)
call npm run generate
if errorlevel 1 (
    echo WARNING: Prisma client generation had issues, retrying...
    timeout /t 2 /nobreak >nul
    call npm run generate
)

REM Check if migrations exist
echo Checking database migrations...
if exist prisma\migrations (
    echo Applying existing migrations...
    call npx prisma migrate deploy
    if errorlevel 1 (
        echo.
        echo ERROR: Failed to apply migrations
        echo Try running manually: cd backend ^&^& npm run migrate:dev
        pause
        exit /b 1
    )
) else (
    echo.
    echo No migrations found. Creating initial migration...
    call npx prisma migrate dev --name initial_setup
    if errorlevel 1 (
        echo.
        echo ERROR: Failed to create initial migration
        echo Make sure PostgreSQL is running and accessible
        pause
        exit /b 1
    )
)

REM Check frontend
if exist ..\frontend-app\package.json (
    cd ..\frontend-app
    if not exist node_modules (
        echo Installing frontend dependencies...
        call npm install
    )
    cd ..\backend
)

REM Start services in new windows
echo.
echo Starting services...

REM Start API server
echo Starting API server...
start "WhatsApp Bot API" cmd /k npm run dev

REM Wait a bit for API to start
timeout /t 3 /nobreak >nul

REM Start worker
echo Starting message worker...
start "WhatsApp Bot Worker" cmd /k npm run dev:worker

REM Start frontend if exists
if exist ..\frontend-app\package.json (
    echo Starting frontend...
    cd ..\frontend-app
    start "WhatsApp Bot Frontend" cmd /k npm run dev
    cd ..\backend
)

REM Display information
echo.
echo ===================================================
echo Services started successfully!
echo ===================================================
echo Backend API:  http://localhost:5000
echo Worker:       Processing messages in background
if exist ..\frontend-app\package.json (
    echo Frontend:     http://localhost:3000
)
echo.
echo Additional tools:
echo - Prisma Studio: cd backend ^&^& npx prisma studio
echo - Docker logs:   docker compose logs -f
echo.
echo To connect WhatsApp:
echo 1. In another terminal run: ngrok http 5000
echo 2. Copy the HTTPS URL from ngrok
echo 3. Configure webhook in Meta Developers
echo 4. Send messages to your WhatsApp number!
echo.
echo To stop all services:
echo - Close all command windows
echo - Run: docker compose down
echo ===================================================
echo.
pause

================
File: start-dev.sh
================
#!/bin/bash

echo "üöÄ Iniciando backend con workers localmente..."

# Colores
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

# Funci√≥n para matar proceso en un puerto
kill_port() {
    local port=$1
    # Intentar m√∫ltiples m√©todos para encontrar el PID
    local pid=$(lsof -ti:$port 2>/dev/null)
    
    # Si lsof no funciona, intentar con fuser
    if [ -z "$pid" ]; then
        pid=$(fuser $port/tcp 2>/dev/null | tr -d ' ')
    fi
    
    if [ ! -z "$pid" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Puerto $port en uso por proceso(es) $pid. Liberando puerto...${NC}"
        # Intentar kill normal primero
        kill $pid 2>/dev/null || true
        sleep 1
        
        # Si a√∫n existe, forzar
        if kill -0 $pid 2>/dev/null; then
            kill -9 $pid 2>/dev/null || true
            sleep 1
        fi
    fi
    
    # Verificar si el puerto sigue ocupado
    if lsof -i:$port >/dev/null 2>&1 || fuser $port/tcp >/dev/null 2>&1; then
        echo -e "${RED}‚ùå No se pudo liberar el puerto $port. Puede requerir permisos de sudo.${NC}"
        echo -e "${YELLOW}   Intenta ejecutar: sudo kill -9 \$(sudo lsof -ti:$port)${NC}"
    fi
}

# Funci√≥n para limpiar contenedores Docker espec√≠ficos
cleanup_docker_containers() {
    echo -e "${YELLOW}Limpiando contenedores Docker...${NC}"
    
    # Lista de contenedores espec√≠ficos del proyecto
    local containers=("redis_bot_backend" "postgres_bot_backend")
    
    for container in "${containers[@]}"; do
        if docker ps -a --format "{{.Names}}" | grep -q "^${container}$"; then
            echo -e "${YELLOW}   Deteniendo y eliminando contenedor: $container${NC}"
            docker stop "$container" 2>/dev/null || true
            docker rm "$container" 2>/dev/null || true
        fi
    done
    
    # Tambi√©n detener usando docker compose
    docker compose down --remove-orphans 2>/dev/null || true
    
    # Esperar un poco para asegurar que los procesos docker-proxy se liberen
    sleep 3
    
    # Buscar y matar procesos docker-proxy hu√©rfanos que est√©n usando nuestros puertos
    for port in 5433 6380; do
        local docker_proxy_pids=$(ps aux | grep docker-proxy | grep "\-host-port $port" | awk '{print $2}' | tr '\n' ' ')
        if [ ! -z "$docker_proxy_pids" ]; then
            echo -e "${YELLOW}   Encontrados procesos docker-proxy hu√©rfanos en puerto $port: $docker_proxy_pids${NC}"
            echo -e "${YELLOW}   Estos procesos requieren permisos de root para eliminarlos.${NC}"
            
            # Intentar matarlos normalmente primero
            for pid in $docker_proxy_pids; do
                if kill -9 $pid 2>/dev/null; then
                    echo -e "${GREEN}   ‚úì Proceso $pid eliminado${NC}"
                else
                    echo -e "${RED}   ‚úó No se pudo eliminar proceso $pid (requiere sudo)${NC}"
                    echo -e "${YELLOW}   Por favor ejecuta: sudo kill -9 $pid${NC}"
                fi
            done
        fi
    done
    
    # Verificar si los contenedores zombis a√∫n existen
    local zombie_containers=$(docker ps -a | grep -E "(redis_bot_backend|postgres_bot_backend)" | grep -E "(Dead|Removal In Progress)" | awk '{print $1}')
    if [ ! -z "$zombie_containers" ]; then
        echo -e "${YELLOW}   Encontrados contenedores zombis: $zombie_containers${NC}"
        for container_id in $zombie_containers; do
            docker rm -f "$container_id" 2>/dev/null || true
        done
    fi
}

# Limpiar puertos antes de iniciar
echo -e "\n${YELLOW}0. Limpiando puertos y contenedores...${NC}"

# Verificar si hay procesos docker-proxy hu√©rfanos antes de empezar
DOCKER_PROXY_FOUND=false
for port in 5433 6380; do
    if ps aux | grep docker-proxy | grep -q "\-host-port $port"; then
        DOCKER_PROXY_FOUND=true
        echo -e "${RED}‚ùå Detectados procesos docker-proxy hu√©rfanos en puerto $port${NC}"
        pids=$(ps aux | grep docker-proxy | grep "\-host-port $port" | awk '{print $2}')
        echo -e "${YELLOW}   PIDs: $pids${NC}"
    fi
done

if [ "$DOCKER_PROXY_FOUND" = true ]; then
    echo -e "\n${YELLOW}‚ö†Ô∏è  Se encontraron procesos docker-proxy que requieren permisos de root para eliminar.${NC}"
    echo -e "${YELLOW}Por favor, ejecuta los siguientes comandos para limpiarlos:${NC}\n"
    
    # Generar comandos sudo para cada proceso
    for port in 5433 6380; do
        pids=$(ps aux | grep docker-proxy | grep "\-host-port $port" | awk '{print $2}' | tr '\n' ' ')
        if [ ! -z "$pids" ]; then
            echo -e "${BLUE}sudo kill -9 $pids${NC}"
        fi
    done
    
    echo -e "\n${YELLOW}Alternativamente, puedes ejecutar:${NC}"
    echo -e "${BLUE}./cleanup-ports.sh${NC}"
    echo -e "${YELLOW}para limpiar autom√°ticamente todos los puertos y contenedores.${NC}"
    
    echo -e "\n${YELLOW}Despu√©s de ejecutar uno de los comandos anteriores, vuelve a ejecutar este script.${NC}"
    exit 1
fi

# Primero limpiar contenedores Docker
cleanup_docker_containers

# Luego limpiar puertos
kill_port 3000  # Frontend
kill_port 5000  # Backend
kill_port 5433  # PostgreSQL
kill_port 6380  # Redis

# Verificaci√≥n final de puertos
for port in 5433 6380; do
    if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
        echo -e "${RED}‚ùå El puerto $port sigue en uso despu√©s de la limpieza.${NC}"
        echo -e "${YELLOW}   Intentando limpieza forzada...${NC}"
        # Intentar con fuser como √∫ltimo recurso
        fuser -k $port/tcp 2>/dev/null || true
        sleep 1
    fi
done

# Paso 1: Iniciar PostgreSQL y Redis con Docker
echo -e "\n${YELLOW}1. Iniciando PostgreSQL y Redis...${NC}"
docker compose up -d

# Esperar a que PostgreSQL est√© listo
echo -e "${YELLOW}   Esperando a que PostgreSQL est√© listo...${NC}"
max_attempts=30
attempt=0
until docker compose exec -T postgres pg_isready -U postgres >/dev/null 2>&1 || [ $attempt -eq $max_attempts ]; do
    attempt=$((attempt + 1))
    printf "\r   Esperando... intento $attempt/$max_attempts"
    sleep 1
done

if [ $attempt -eq $max_attempts ]; then
    echo -e "\n${RED}‚ùå PostgreSQL no pudo iniciar despu√©s de $max_attempts intentos${NC}"
    echo "   Intenta ejecutar: docker compose logs postgres"
    exit 1
fi
echo -e "\n${GREEN}   ‚úÖ PostgreSQL est√° listo!${NC}"

# Esperar a que Redis est√© listo
echo -e "${YELLOW}   Esperando a que Redis est√© listo...${NC}"
max_attempts=15
attempt=0
until docker compose exec -T redis redis-cli ping >/dev/null 2>&1 || [ $attempt -eq $max_attempts ]; do
    attempt=$((attempt + 1))
    printf "\r   Esperando... intento $attempt/$max_attempts"
    sleep 1
done

if [ $attempt -eq $max_attempts ]; then
    echo -e "\n${YELLOW}‚ö†Ô∏è  Redis no pudo iniciar, pero continuaremos (el sistema funcionar√° sin Redis)${NC}"
else
    echo -e "\n${GREEN}   ‚úÖ Redis est√° listo!${NC}"
fi

# Paso 2: Verificar configuraci√≥n antes de copiar
echo -e "\n${YELLOW}2. Verificando configuraci√≥n...${NC}"
cd backend

# Verificar si existe .env.local (para compatibilidad con instalaciones anteriores)
if [ -f ".env.local" ]; then
    # Verificar configuraci√≥n en .env.local
    echo -e "${YELLOW}Verificando .env.local...${NC}"
    
    # Verificar API Key de Google
    if grep -q "TU_API_KEY_AQUI" .env.local || grep -q "tu_api_key_real_aqui" .env.local; then
        echo -e "\n${RED}‚ùå FALTA: Google AI API Key${NC}"
        echo "   Edita backend/.env.local y configura GOOGLE_AI_API_KEY"
        echo "   Obt√©n una en: https://makersuite.google.com/app/apikey"
        missing_config=true
    else
        echo -e "${GREEN}‚úÖ Google AI API Key configurada${NC}"
    fi
    
    # Verificar credenciales de WhatsApp
    if grep -q "tu_phone_number_id" .env.local || grep -q "tu_access_token_permanente" .env.local || grep -q "un_token_secreto_que_tu_elijas" .env.local; then
        echo -e "\n${RED}‚ùå FALTA: Credenciales de WhatsApp${NC}"
        echo "   Edita backend/.env.local y configura:"
        echo "   - WHATSAPP_PHONE_NUMBER_MESSAGING_ID"
        echo "   - WHATSAPP_ACCESS_TOKEN"
        echo "   - WHATSAPP_VERIFY_TOKEN"
        echo "   - BOT_WHATSAPP_NUMBER"
        echo "   Obt√©n las credenciales en: https://developers.facebook.com"
        missing_config=true
    else
        echo -e "${GREEN}‚úÖ Credenciales de WhatsApp configuradas${NC}"
    fi
    
    if [ "$missing_config" = true ]; then
        echo -e "\n${YELLOW}Ver QUICK_START.md para instrucciones detalladas${NC}"
        echo ""
        read -p "Presiona ENTER cuando hayas configurado todo..."
    fi
    
    # Copiar archivo de entorno
    echo -e "\n${YELLOW}Copiando .env.local a .env...${NC}"
    cp .env.local .env
    echo -e "${GREEN}‚úÖ Archivo .env creado${NC}"
elif [ ! -f ".env" ]; then
    # Si no existe .env ni .env.local, crear uno desde .env.example
    echo -e "${YELLOW}No se encontr√≥ .env, cre√°ndolo desde .env.example...${NC}"
    cp .env.example .env
    echo -e "${RED}‚ùå IMPORTANTE: Debes configurar el archivo backend/.env con tus credenciales${NC}"
    echo -e "${YELLOW}Ver QUICK_START.md para instrucciones detalladas${NC}"
    exit 1
fi

# Paso 3: Instalar dependencias
echo -e "\n${YELLOW}3. Instalando dependencias...${NC}"
npm install

# Paso 4: Generar Prisma Client
echo -e "\n${YELLOW}4. Generando Prisma Client...${NC}"
npm run generate

# Paso 5: Ejecutar migraciones
echo -e "\n${YELLOW}5. Creando tablas en la base de datos...${NC}"
npx prisma migrate deploy 2>/dev/null || npx prisma migrate dev --name init

# Paso 6.5: Configurar pgvector si est√° disponible
echo -e "\n${YELLOW}6.5. Configurando b√∫squeda sem√°ntica (pgvector)...${NC}"
if [ -f "./scripts/setup-local-pgvector.sh" ]; then
    ./scripts/setup-local-pgvector.sh
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úÖ pgvector configurado correctamente${NC}"
        echo -e "${YELLOW}   Los embeddings se generar√°n autom√°ticamente al iniciar el servidor${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  pgvector no pudo configurarse (b√∫squeda sem√°ntica no disponible)${NC}"
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  Script de configuraci√≥n no encontrado${NC}"
fi

# Paso 7: Verificar e instalar dependencias del frontend si existe
if [ -d "../frontend-app" ] && [ -f "../frontend-app/package.json" ]; then
    echo -e "\n${YELLOW}7. Verificando frontend...${NC}"
    cd ../frontend-app
    if [ ! -d "node_modules" ]; then
        echo -e "${YELLOW}   Instalando dependencias del frontend...${NC}"
        npm install
    fi
    cd ../backend
fi

# Variables de proceso
BACKEND_PID=""
WORKER_PID=""
FRONTEND_PID=""

# Funci√≥n para limpiar al salir
cleanup() {
    echo -e "\n${YELLOW}‚èπÔ∏è  Deteniendo servicios...${NC}"
    
    # Matar procesos hijos (backend, worker y frontend)
    if [ ! -z "$BACKEND_PID" ]; then
        echo -e "${YELLOW}   Deteniendo proceso backend (PID: $BACKEND_PID)...${NC}"
        kill $BACKEND_PID 2>/dev/null || true
    fi
    
    if [ ! -z "$WORKER_PID" ]; then
        echo -e "${YELLOW}   Deteniendo proceso worker (PID: $WORKER_PID)...${NC}"
        kill $WORKER_PID 2>/dev/null || true
    fi
    
    if [ ! -z "$FRONTEND_PID" ]; then
        echo -e "${YELLOW}   Deteniendo proceso frontend (PID: $FRONTEND_PID)...${NC}"
        kill $FRONTEND_PID 2>/dev/null || true
    fi
    
    # Matar cualquier otro proceso hijo
    pkill -P $$ 2>/dev/null || true
    
    # Dar tiempo para que los procesos terminen
    sleep 2
    
    # Limpiar contenedores Docker
    echo -e "${YELLOW}   Limpiando contenedores Docker...${NC}"
    cleanup_docker_containers
    
    # Limpiar puertos por si acaso
    echo -e "${YELLOW}   Liberando puertos...${NC}"
    kill_port 3000
    kill_port 5000
    kill_port 5433
    kill_port 6380
    
    echo -e "${GREEN}‚úÖ Todos los servicios y puertos han sido liberados${NC}"
    exit 0
}

# Capturar se√±ales de terminaci√≥n
trap cleanup INT TERM EXIT

# Paso 8: Iniciar servicios
echo -e "\n${GREEN}‚úÖ Todo listo! Iniciando servicios...${NC}"

# Iniciar backend API
echo -e "${YELLOW}üñ•Ô∏è  Iniciando Backend API...${NC}"
npm run dev 2>&1 | sed 's/^/[API] /' &
BACKEND_PID=$!

# Esperar un poco para que el backend API inicie
sleep 3

# Iniciar worker de BullMQ
echo -e "${YELLOW}‚öôÔ∏è  Iniciando Worker de BullMQ...${NC}"
npm run dev:worker 2>&1 | sed 's/^/[Worker] /' &
WORKER_PID=$!

# Iniciar frontend si existe
if [ -d "../frontend-app" ] && [ -f "../frontend-app/package.json" ]; then
    echo -e "${YELLOW}üåê Iniciando Frontend...${NC}"
    cd ../frontend-app && npm run dev 2>&1 | sed 's/^/[Frontend] /' &
    FRONTEND_PID=$!
    cd ../backend
fi

# Leer configuraci√≥n de workers
WORKER_CONCURRENCY=$(grep BULLMQ_WORKER_CONCURRENCY .env | cut -d '=' -f2 || echo "2")
NUM_WORKERS=$(grep NUM_WORKERS .env | cut -d '=' -f2 || echo "1")

echo -e "\n${GREEN}‚úÖ Servicios iniciados:${NC}"
echo -e "   Backend API:  ${BLUE}http://localhost:5000${NC}"
echo -e "   Worker:       ${GREEN}Procesando mensajes (Concurrencia: $WORKER_CONCURRENCY)${NC}"
if [ ! -z "$FRONTEND_PID" ]; then
    echo -e "   Frontend:     ${BLUE}http://localhost:3000${NC}"
fi
echo -e "\n${YELLOW}üìä Herramientas adicionales:${NC}"
echo -e "   Prisma Studio: ${YELLOW}cd backend && npx prisma studio${NC}"
echo -e "   Logs de Docker: ${YELLOW}docker compose logs -f${NC}"
echo -e "\n${BLUE}üì± Para conectar WhatsApp:${NC}"
echo -e "   1. En otra terminal ejecuta: ${YELLOW}ngrok http 5000${NC}"
echo -e "   2. Copia la URL HTTPS que te da ngrok"
echo -e "   3. Configura el webhook en Meta Developers"
echo -e "   4. ¬°Env√≠a mensajes a tu n√∫mero de WhatsApp!"
echo -e "\n${GREEN}üöÄ Configuraci√≥n de Workers:${NC}"
echo -e "   Concurrencia por worker: ${YELLOW}$WORKER_CONCURRENCY trabajos simult√°neos${NC}"
echo -e "   N√∫mero de workers (dev): ${YELLOW}1 (para producci√≥n usa PM2)${NC}"
echo -e "   Para cambiar: edita ${YELLOW}BULLMQ_WORKER_CONCURRENCY${NC} en backend/.env"
echo -e "\n${YELLOW}Para detener todo: Ctrl+C (el script limpiar√° todo autom√°ticamente)${NC}"
echo ""

# Esperar a los procesos
wait $BACKEND_PID

================
File: backend/ecosystem.config.js
================
// PM2 Configuration for WhatsApp Bot
// This file configures how PM2 manages the API and worker processes

// Load environment variables from .env file
require('dotenv').config();

module.exports = {
  apps: [
    {
      // API Server Configuration
      name: 'whatsapp-api',
      script: 'dist/src/server.js',
      instances: 1, // API usually needs only one instance
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      env: {
        NODE_ENV: 'production',
      },
      error_file: 'logs/api-error.log',
      out_file: 'logs/api-out.log',
      log_file: 'logs/api-combined.log',
      time: true,
    },
    {
      // Worker Configuration
      name: 'whatsapp-worker',
      script: 'dist/src/workers/messageWorker.js',
      instances: parseInt(process.env.NUM_WORKERS || '1', 10), // Read from .env
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      env: {
        NODE_ENV: 'production',
      },
      error_file: 'logs/worker-error.log',
      out_file: 'logs/worker-out.log',
      log_file: 'logs/worker-combined.log',
      time: true,
      exec_mode: 'cluster', // Enable cluster mode for multiple instances
    },
  ],

  // Deploy section (optional, for remote deployments)
  deploy: {
    production: {
      user: 'node',
      host: 'your-server.com',
      ref: 'origin/main',
      repo: 'git@github.com:your-username/your-repo.git',
      path: '/var/www/whatsapp-bot',
      'post-deploy': 'npm install && npm run build && pm2 reload ecosystem.config.js --env production',
    },
  },
};

================
File: backend/scripts/reset-db.sh
================
#!/bin/bash
# Script to reset database and apply initial migration

echo "üóëÔ∏è  Resetting database..."
npx prisma migrate reset --force --skip-seed

echo "üìù Creating initial migration..."
npx prisma migrate dev --name initial_schema --skip-seed

echo "‚úÖ Database reset complete!"

================
File: backend/src/api/audio/audioOrder.controller.ts
================
import { Request, Response } from 'express';
import { AudioOrderService } from '../../services/audio/AudioOrderService';
import { BusinessLogicError, ErrorCode } from '../../common/services/errors';
import logger from '../../common/utils/logger';

interface MulterRequest extends Request {
  file?: Express.Multer.File;
}

export class AudioOrderController {
  static async processAudioOrder(req: MulterRequest, res: Response): Promise<void> {
    if (!req.file) {
      throw new BusinessLogicError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        'El archivo de audio es requerido'
      );
    }

    const { transcription } = req.body;
    
    // Debug incoming request
    logger.debug('Audio order request received', {
      fileSize: req.file.size,
      mimeType: req.file.mimetype,
      transcriptionLength: transcription?.length || 0,
      transcriptionPreview: transcription?.substring(0, 100) || 'No transcription'
    });

    const result = await AudioOrderService.processAudioOrder({
      audioBuffer: req.file.buffer,
      audioMimeType: req.file.mimetype,
      transcription
    });

    res.status(200).json({
      success: true,
      data: {
        orderItems: result.orderItems,
        orderType: result.orderType,
        deliveryInfo: result.deliveryInfo,
        scheduledDelivery: result.scheduledDelivery,
        warnings: result.warnings
      }
    });
  }
}

================
File: backend/src/common/config/predefinedMessages.ts
================
import { RestaurantInfo } from "../types/restaurant";

// Address registration messages
export const ADDRESS_REGISTRATION_SUCCESS = (address: any): string => {
  return `‚úÖ *¬°Direcci√≥n registrada exitosamente!*

üìç *Tu direcci√≥n de entrega:*
${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}
${address.neighborhood ? `Col. ${address.neighborhood}\n` : ''}${address.city}, ${address.state}

¬°Perfecto! Tu direcci√≥n ha sido guardada. Ahora puedes realizar tu pedido. üéâ`;
};

export const ADDRESS_UPDATE_SUCCESS = (address: any): string => {
  return `‚úÖ *¬°Direcci√≥n actualizada correctamente!*

üìç *Tu nueva direcci√≥n de entrega:*
${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}
${address.neighborhood ? `Col. ${address.neighborhood}\n` : ''}${address.city}, ${address.state}

Tu informaci√≥n de entrega ha sido actualizada exitosamente. üëç`;
};

// Restaurant messages that depend on configuration
export const BANNED_USER_MESSAGE = (config: RestaurantInfo): string => {
  return `Lo sentimos, tu n√∫mero ha sido baneado debido a la detecci√≥n de un uso inadecuado de nuestro servicio.

Si crees que es un error, por favor contacta directamente con nosotros:

${config.phoneMain ? `üìû Tel√©fono: ${config.phoneMain}` : ''}
${config.phoneSecondary ? `üìû Tel√©fono: ${config.phoneSecondary}` : ''}

Agradecemos tu comprensi√≥n y esperamos resolver cualquier malentendido.`;
};

export const WAIT_TIMES_MESSAGE = (
  pickupTime: number,
  deliveryTime: number
): string => `
üïí *Tiempos de espera estimados:*

üè† Recolecci√≥n en establecimiento: ${pickupTime} minutos
üöö Entrega a domicilio: ${deliveryTime} minutos

Estos tiempos son aproximados y pueden variar seg√∫n la demanda actual.
`;

export const RESTAURANT_INFO_MESSAGE = (
  config: RestaurantInfo,
  formattedHours: string
): string => {
  const fullAddress = [config.address, config.city, config.state, config.postalCode]
    .filter(Boolean)
    .join(", ");
  
  return `
üìç *Informaci√≥n y horarios de ${config.restaurantName}*

${fullAddress ? `üìç *Ubicaci√≥n:* ${fullAddress}` : ''}

üìû *Tel√©fonos:*
${config.phoneMain ? `   ${config.phoneMain}` : ''}
${config.phoneSecondary ? `   ${config.phoneSecondary}` : ''}

üïí *Horarios:*
${formattedHours.split('\n').map(line => '   ' + line).join('\n')}

¬°Gracias por tu inter√©s! Esperamos verte pronto.
`;
};

export const CHATBOT_HELP_MESSAGE = (config: RestaurantInfo): string => {
  return `
ü§ñüí¨ *¬°Bienvenido al Chatbot de ${config.restaurantName}!*

Este asistente virtual est√° potenciado por inteligencia artificial para brindarte una experiencia fluida y natural. Aqu√≠ te explicamos c√≥mo usarlo:

üöÄ *Opciones disponibles:*
Al enviar cualquier mensaje, recibir√°s un men√∫ con las siguientes opciones:
   üìú Ver Men√∫ - Consulta nuestros productos disponibles
   ‚è±Ô∏è Tiempos de espera - Conoce el tiempo estimado de preparaci√≥n
   ‚ÑπÔ∏è Informaci√≥n y horarios - Direcci√≥n, tel√©fonos y horarios
   üöö Actualizar entrega - Cambia tu direcci√≥n de entrega registrada
   ü§ñ ¬øC√≥mo usar el bot? - Esta ayuda

üçΩÔ∏è *Realizar un pedido:*
1. Escribe o env√≠a un audio con los productos que deseas, especificando:
   - Cantidad de cada producto
   - Detalles o especificaciones (sin cebolla, extra queso, etc.)
   - Tipo de pedido: entrega a domicilio o recolecci√≥n

2. Para entrega a domicilio:
   - Usaremos la direcci√≥n predeterminadaque registraste al inicio
   - Si necesitas cambiarla, usa la opci√≥n "üöö Actualizar entrega"

3. Para recolecci√≥n en establecimiento:
   - Indica que es para recoger y la recolectaras con el nombre que registraste al inicio

Ejemplos:
   '2 hamburguesas tradicionales con papas y una coca cola para entrega a domicilio'
   'Una pizza grande especial sin pi√±a para recoger'

üìù *Proceso del pedido:*
1. Recibir√°s un resumen con botones de Confirmar o Descartar
2. Al confirmar, tu pedido ser√° enviado al restaurante
3. Recibir√°s opciones para pagar en l√≠nea o por defecto en efectivo

üí≥ *Pago:*
- Despu√©s de confirmar tu pedido, puedes generar un enlace de pago
- Si no pagas en l√≠nea, el pago ser√° en efectivo al recibir tu pedido

‚ö†Ô∏è *IMPORTANTE:*
- Los pedidos confirmados NO se pueden modificar ni cancelar
- Tu direcci√≥n de entrega debe estar registrada antes de ordenar
- Env√≠a un mensaje a la vez y espera la respuesta

üìû *¬øNecesitas hacer cambios en tu pedido?*
Si necesitas modificar algo despu√©s de confirmar, comun√≠cate directamente con el restaurante:
${config.phoneMain ? `   üì± ${config.phoneMain}` : ''}
${config.phoneSecondary ? `   üì± ${config.phoneSecondary}` : ''}

¬°Disfruta tu experiencia con nuestro chatbot! üçΩÔ∏èü§ñ
`;
};

export const CHANGE_DELIVERY_INFO_MESSAGE = (updateLink: string): string => `
üöö ¬°Actualiza tu informaci√≥n de entrega! üìù

üëá *PRESIONA AQU√ç PARA ACTUALIZAR* üëá

${updateLink}`;

export const RESTAURANT_NOT_ACCEPTING_ORDERS_MESSAGE = (config: RestaurantInfo): string => {
  return `
üö´üçΩÔ∏è Lo sentimos, no estamos aceptando pedidos en este momento. üòî

‚è≥ Puedes intentar m√°s tarde o llamarnos directamente:
${config.phoneMain ? `üìû Tel√©fono: ${config.phoneMain}` : ''}
${config.phoneSecondary ? `üìû Tel√©fono: ${config.phoneSecondary}` : ''}

¬°Gracias por tu comprensi√≥n! üôè
`;
};

export const RESTAURANT_CLOSED_MESSAGE = (formattedHours: string): string => {
  return `
üö´ Lo sentimos, estamos cerrados en este momento. üò¥

üïí Nuestro horario de atenci√≥n es:
${formattedHours.split('\n').map(line => '   üóìÔ∏è ' + line).join('\n')}

üôè Gracias por tu comprensi√≥n. ¬°Esperamos atenderte pronto! üòä
`;
};

export const DELIVERY_INFO_REGISTRATION_MESSAGE = (
  registrationLink: string
): string => `
¬°Hola! üëã Antes de continuar, necesitamos que registres tu informaci√≥n de entrega. üìù

üëá *PRESIONA AQU√ç PARA REGISTRARTE* üëá

${registrationLink}
`;

export const PAYMENT_CONFIRMATION_MESSAGE = (orderNumber: number): string => `
¬°Tu pago para la orden #${orderNumber} ha sido confirmado! üéâ‚úÖ Gracias por tu compra. üõçÔ∏èüòä
`;

export const WELCOME_MESSAGE_INTERACTIVE = (config: RestaurantInfo) => {
  return {
    type: "list",
    header: {
      type: "text",
      text: `Bienvenido a ${config.restaurantName} üçΩÔ∏è`
    },
    body: {
      text: "¬øC√≥mo podemos ayudarte hoy? üòä"
    },
    footer: {
      text: "Selecciona una opci√≥n:"
    },
    action: {
      button: "Ver opciones",
      sections: [
        {
          title: "Acciones",
          rows: [
            { id: "view_menu", title: "üìú Ver Men√∫" },
            { id: "wait_times", title: "‚è±Ô∏è Tiempos de espera" },
            { id: "restaurant_info", title: "‚ÑπÔ∏è Informaci√≥n y horarios" },
            { id: "chatbot_help", title: "ü§ñ ¬øC√≥mo usar el bot?" },
            {
              id: "change_delivery_info",
              title: "üöö Actualizar entrega"
            }
          ]
        }
      ]
    }
  };
};

// Static messages that don't depend on configuration
export const CONVERSATION_RESET_MESSAGE = "üîÑ Entendido, he olvidado el contexto anterior. ¬øEn qu√© puedo ayudarte ahora? üòä";

export const GENERIC_ERROR_MESSAGE = "Lo siento, ocurri√≥ un error procesando tu mensaje. Por favor intenta de nuevo.";

export const UNSUPPORTED_MESSAGE_TYPE = "Lo siento, solo puedo procesar mensajes de texto por el momento.";

export const AUDIO_TRANSCRIPTION_ERROR = "üé§ Hubo un problema al procesar tu mensaje de audio. Por favor, intenta nuevamente o env√≠a un mensaje de texto.";

export const RATE_LIMIT_MESSAGE = "Has alcanzado el l√≠mite de mensajes. Por favor espera unos minutos antes de enviar m√°s mensajes.";

export const ORDER_NOT_FOUND_MESSAGE = "‚ùå Lo siento, no se pudo encontrar tu orden. üö´üîç";


export const STRIPE_NOT_AVAILABLE_MESSAGE = "‚ùå Lo siento, los pagos en l√≠nea no est√°n disponibles en este momento. Por favor, realiza el pago en efectivo al recibir tu pedido. üíµ";

export const PAYMENT_LINK_EXISTS_MESSAGE = "‚ö†Ô∏è Ya existe un enlace de pago activo para esta orden. Por favor, utiliza el enlace enviado anteriormente o cont√°ctanos si necesitas ayuda. üîÑ";

export const DEFAULT_ADDRESS_CHANGED = (address: any): string => {
  return `‚úÖ *Direcci√≥n principal actualizada*\n\n` +
    `Tu direcci√≥n principal ahora es:\n\n` +
    `üìç *${address.name || 'Direcci√≥n'}*\n` +
    `${address.street} ${address.number}${address.interiorNumber ? ` Int. ${address.interiorNumber}` : ''}\n` +
    `${address.neighborhood ? `${address.neighborhood}, ` : ''}${address.city}, ${address.state}\n` +
    `${address.deliveryInstructions ? `\nüìù _${address.deliveryInstructions}_` : ''}\n\n` +
    `Esta ser√° la direcci√≥n que usaremos para tus pr√≥ximas entregas a domicilio.`;
};

================
File: backend/src/common/utils/timeUtils.ts
================
import moment from "moment-timezone";
import logger from "./logger";
import { RestaurantService } from "../../services/restaurant/RestaurantService";

// Cache for timezone
let cachedTimeZone: string | null = null;

async function getTimeZone(): Promise<string> {
  try {
    if (cachedTimeZone) {
      return cachedTimeZone;
    }
    
    const config = await RestaurantService.getConfig();
    cachedTimeZone = config.timeZone || "America/Mexico_City";
    return cachedTimeZone;
  } catch (error) {
    logger.error("Error getting timezone from config:", error);
    // Fallback to default timezone
    return "America/Mexico_City";
  }
}

const parseTime = (timeString: string): number => {
  const [hours, minutes] = timeString.split(":").map(Number);
  return hours * 60 + minutes;
};

const getCurrentMexicoTime = async (): Promise<moment.Moment> => {
  const timeZone = await getTimeZone();
  return moment().tz(timeZone);
};

const getUTCTime = (): moment.Moment => {
  return moment().utc();
};

// Helper function to clear timezone cache when config changes
export function clearTimeZoneCache(): void {
  cachedTimeZone = null;
}

const isBusinessOpen = async (): Promise<boolean> => {
  try {
    const now = await getCurrentMexicoTime();
    const dayOfWeek = now.day();
    const currentMinutes = now.hours() * 60 + now.minutes();

    // Get business hours for current day
    const todayHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
    
    if (!todayHours || todayHours.isClosed || !todayHours.openingTime || !todayHours.closingTime) {
      return false;
    }

    const openingMinutes = parseTime(todayHours.openingTime);
    const closingMinutes = parseTime(todayHours.closingTime);

    // Get restaurant config for grace periods
    const config = await RestaurantService.getConfig();
    
    // Apply grace periods
    const effectiveOpeningTime = openingMinutes + (config.openingGracePeriod || 0);
    const effectiveClosingTime = closingMinutes - (config.closingGracePeriod || 0);

    return currentMinutes >= effectiveOpeningTime && currentMinutes < effectiveClosingTime;
  } catch (error) {
    logger.error("Error checking if business is open:", error);
    // Fallback to closed if database fails
    return false;
  }
};

export { getCurrentMexicoTime, isBusinessOpen, getUTCTime };

export async function getFormattedBusinessHours(): Promise<string> {
  try {
    const hours = await RestaurantService.getAllBusinessHours();
    
    const dayNames = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
    
    const formattedHours = hours.map(h => {
      if (h.isClosed || !h.openingTime || !h.closingTime) {
        return `${dayNames[h.dayOfWeek]}: Cerrado`;
      }
      return `${dayNames[h.dayOfWeek]}: ${h.openingTime} - ${h.closingTime}`;
    });
    
    return formattedHours.join('\n');
  } catch (error) {
    logger.error("Error getting formatted business hours:", error);
    return "Horarios no disponibles";
  }
}

export async function getBusinessStatus(): Promise<{
  isOpen: boolean;
  message: string;
  nextOpeningTime?: string;
}> {
  try {
    const now = await getCurrentMexicoTime();
    const dayOfWeek = now.day();
    const currentMinutes = now.hours() * 60 + now.minutes();
    
    const todayHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
    const config = await RestaurantService.getConfig();
    
    if (!todayHours || todayHours.isClosed || !todayHours.openingTime || !todayHours.closingTime) {
      // Find next opening day
      let nextDay = (dayOfWeek + 1) % 7;
      let daysChecked = 0;
      
      while (daysChecked < 7) {
        const nextDayHours = await RestaurantService.getBusinessHoursForDay(nextDay);
        if (nextDayHours && !nextDayHours.isClosed && nextDayHours.openingTime) {
          const dayName = ['domingo', 'lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado'][nextDay];
          return {
            isOpen: false,
            message: `‚è∞ Estamos cerrados hoy. Abrimos el ${dayName} a las ${nextDayHours.openingTime} hrs. üçï`,
            nextOpeningTime: nextDayHours.openingTime
          };
        }
        nextDay = (nextDay + 1) % 7;
        daysChecked++;
      }
      
      return {
        isOpen: false,
        message: "‚è∞ Estamos cerrados. Por favor, contacta al restaurante para m√°s informaci√≥n. üìû"
      };
    }
    
    const openingMinutes = parseTime(todayHours.openingTime);
    const closingMinutes = parseTime(todayHours.closingTime);
    const effectiveOpeningTime = openingMinutes + (config.openingGracePeriod || 0);
    const effectiveClosingTime = closingMinutes - (config.closingGracePeriod || 0);
    
    // Before opening (including grace period)
    if (currentMinutes < effectiveOpeningTime) {
      const minutesUntilOpen = effectiveOpeningTime - currentMinutes;
      if (minutesUntilOpen <= 60) {
        return {
          isOpen: false,
          message: `‚è∞ Abrimos en ${minutesUntilOpen} minutos. Por favor, espera un momento. üçï`,
          nextOpeningTime: todayHours.openingTime
        };
      }
      return {
        isOpen: false,
        message: `‚è∞ Abrimos a las ${todayHours.openingTime} hrs. ¬°Te esperamos! üçï`,
        nextOpeningTime: todayHours.openingTime
      };
    }
    
    // Near closing time (within grace period)
    if (currentMinutes >= effectiveClosingTime && currentMinutes < closingMinutes) {
      const minutesUntilClose = closingMinutes - currentMinutes;
      return {
        isOpen: false,
        message: `‚è∞ Ya no estamos tomando pedidos. Cerramos en ${minutesUntilClose} minutos. ¬°Vuelve ma√±ana! üçï`
      };
    }
    
    // After closing
    if (currentMinutes >= closingMinutes) {
      // Find next opening (tomorrow or next available day)
      let nextDay = (dayOfWeek + 1) % 7;
      let daysChecked = 0;
      
      while (daysChecked < 7) {
        const nextDayHours = await RestaurantService.getBusinessHoursForDay(nextDay);
        if (nextDayHours && !nextDayHours.isClosed && nextDayHours.openingTime) {
          const dayName = ['domingo', 'lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado'][nextDay];
          return {
            isOpen: false,
            message: `‚è∞ Ya cerramos por hoy. Abrimos el ${dayName} a las ${nextDayHours.openingTime} hrs. ¬°Te esperamos! üçï`,
            nextOpeningTime: nextDayHours.openingTime
          };
        }
        nextDay = (nextDay + 1) % 7;
        daysChecked++;
      }
    }
    
    // Restaurant is open
    const minutesUntilEffectiveClose = effectiveClosingTime - currentMinutes;
    if (minutesUntilEffectiveClose <= 30) {
      return {
        isOpen: true,
        message: `‚úÖ Estamos abiertos. ‚ö†Ô∏è √öltimo momento para ordenar, cerramos pronto (en ${minutesUntilEffectiveClose} minutos).`
      };
    }
    
    return {
      isOpen: true,
      message: "‚úÖ Estamos abiertos y listos para tomar tu pedido. üçï"
    };
  } catch (error) {
    logger.error("Error getting business status:", error);
    return {
      isOpen: false,
      message: "‚ùå Error al verificar el horario. Por favor, contacta al restaurante."
    };
  }
}


export async function getMexicoDayRange(dateString: string): Promise<{
  startDate: Date;
  endDate: Date;
}> {
  const timeZone = await getTimeZone();
  const mexicoDate = moment.tz(dateString, timeZone).startOf("day");

  const startDate = mexicoDate.clone().utc().toDate();
  const endDate = mexicoDate.clone().endOf("day").utc().toDate();

  return { startDate, endDate };
}

================
File: backend/src/dto/address/create-address.dto.ts
================
import { IsNotEmpty, IsString, IsObject, ValidateNested, IsOptional } from 'class-validator';
import { Type } from 'class-transformer';
import { AddressDto } from './address.dto';

export class CreateAddressDto {
  @IsNotEmpty({ message: 'whatsappPhoneNumber is required' })
  @IsString({ message: 'whatsappPhoneNumber must be a string' })
  whatsappPhoneNumber!: string;

  @IsNotEmpty({ message: 'otp is required' })
  @IsString({ message: 'otp must be a string' })
  otp!: string;

  @IsNotEmpty({ message: 'address is required' })
  @IsObject({ message: 'address must be an object' })
  @ValidateNested()
  @Type(() => AddressDto)
  address!: AddressDto;
  
  @IsOptional()
  @IsString({ message: 'preOrderId must be a string' })
  preOrderId?: string;
}

================
File: backend/src/dto/address/index.ts
================
// Address DTOs
export * from './address.dto';
export * from './create-address.dto';
export * from './update-address.dto';
export * from './delete-address.dto';
export * from './get-addresses-query.dto';
export * from './set-default-address.dto';

================
File: backend/src/services/ai/tools/handlers/mapOrderItemsHandler.ts
================
import { ToolHandler } from '../types';
import { AIOrderItem, transformAIOrderItem } from '../../../../common/types';
import { UnifiedResponse, ResponseBuilder } from '../../../messaging/types/responses';
import logger from '../../../../common/utils/logger';

/**
 * Handles the map_order_items function call
 * Transforms AI order items to consistent format for pre-order creation
 */
export const handleMapOrderItems: ToolHandler = async (args): Promise<UnifiedResponse> => {
  logger.debug('Processing map_order_items with args:', args);
  
  // Transform AI order items to consistent format
  const processedItems = (args.orderItems || []).map((item: AIOrderItem) => 
    transformAIOrderItem(item)
  );
  
  // Return UnifiedResponse with processed data
  return ResponseBuilder.orderProcessing({
    orderItems: processedItems,
    orderType: args.orderType || 'DELIVERY',
    warnings: args.warnings ? [args.warnings] : [],
    scheduledAt: args.scheduledAt || null
  });
};

================
File: backend/src/services/ai/tools/orderAgent.tools.ts
================
/**
 * Order Agent tool definitions
 * Specialized tools for the order processing agent
 */

export function getOrderAgentTools(): any[] {
  return [
    {
      name: "map_order_items",
      description: "Mapear items del pedido con soporte completo para personalizaci√≥n de pizzas",
      parameters: {
        type: "object",
        properties: {
          orderItems: {
            type: "array",
            items: {
              type: "object",
              properties: {
                productId: { 
                  type: "string",
                  description: "ID del producto (ej: 'PZ' para pizza)"
                },
                variantId: { 
                  type: "string",
                  description: "ID de la variante (ej: 'PZ-V-1' para pizza grande)"
                },
                quantity: { 
                  type: "number",
                  description: "Cantidad del producto"
                },
                modifiers: { 
                  type: "array", 
                  items: { type: "string" },
                  description: "Array de IDs de modificadores generales"
                },
                pizzaCustomizations: {
                  type: "array",
                  description: "Personalizaciones de pizza con estructura detallada",
                  items: {
                    type: "object",
                    properties: {
                      customizationId: {
                        type: "string",
                        description: "ID de la personalizaci√≥n (ej: 'PZ-I-1' para Adelita, 'PZ-I-22' para Champi√±√≥n)"
                      },
                      half: {
                        type: "string",
                        enum: ["FULL", "HALF_1", "HALF_2"],
                        description: "En qu√© parte de la pizza: FULL (completa), HALF_1 (primera mitad), HALF_2 (segunda mitad)"
                      },
                      action: {
                        type: "string",
                        enum: ["ADD", "REMOVE"],
                        description: "ADD para agregar, REMOVE para quitar ingrediente"
                      }
                    },
                    required: ["customizationId", "half", "action"]
                  }
                }
              },
              required: ["productId", "quantity"]
            },
            description: `EJEMPLOS DE PIZZAS:
            
1. "Pizza Hawaiana grande":
   pizzaCustomizations: [{
     customizationId: "PZ-I-5", // FLAVOR Hawaiana
     half: "FULL",
     action: "ADD"
   }]

2. "Pizza mitad Hawaiana mitad Pepperoni":
   pizzaCustomizations: [
     { customizationId: "PZ-I-5", half: "HALF_1", action: "ADD" },
     { customizationId: "PZ-I-13", half: "HALF_2", action: "ADD" }
   ]

3. "Pizza Hawaiana con champi√±ones extra":
   pizzaCustomizations: [
     { customizationId: "PZ-I-5", half: "FULL", action: "ADD" },
     { customizationId: "PZ-I-22", half: "FULL", action: "ADD" }
   ]

4. "Pizza Mexicana sin chile jalape√±o":
   pizzaCustomizations: [
     { customizationId: "PZ-I-12", half: "FULL", action: "ADD" },
     { customizationId: "PZ-I-23", half: "FULL", action: "REMOVE" }
   ]

5. "Pizza con pepperoni y champi√±ones" (sin sabor base):
   pizzaCustomizations: [
     { customizationId: "PZ-I-40", half: "FULL", action: "ADD" },
     { customizationId: "PZ-I-22", half: "FULL", action: "ADD" }
   ]`
          },
          orderType: {
            type: "string",
            enum: ["DELIVERY", "TAKE_AWAY"],
            description: "Tipo de orden: DELIVERY o TAKE_AWAY"
          },
          warnings: { 
            type: "string",
            description: "Advertencias o notas sobre el mapeo"
          }
        },
        required: ["orderItems", "orderType"]
      }
    }
  ];
}

================
File: backend/src/services/ai/tools/types.ts
================
import { MessageContext } from '../../messaging/MessageContext';
import { UnifiedResponse } from '../../messaging/types/responses';

/**
 * Base type for all tool handler functions
 */
export type ToolHandler = (args: any, context?: MessageContext) => Promise<UnifiedResponse | UnifiedResponse[] | null>;

================
File: backend/src/services/messaging/MessageContext.ts
================
import { IncomingMessage, UnifiedResponse } from './types';
import { Customer } from '../../common/types';

export class MessageContext {
  public message: IncomingMessage;
  public customer?: Customer;
  public chatHistory: any[] = [];
  public unifiedResponses: UnifiedResponse[] = [];
  public metadata: Map<string, any> = new Map();
  public shouldStop: boolean = false;
  public error?: Error;

  constructor(message: IncomingMessage) {
    this.message = message;
  }
  
  addUnifiedResponse(response: UnifiedResponse) {
    this.unifiedResponses.push(response);
  }

  setCustomer(customer: Customer) {
    this.customer = customer;
  }

  setChatHistory(history: any[]) {
    this.chatHistory = history;
  }

  stop() {
    this.shouldStop = true;
  }

  setError(error: Error) {
    this.error = error;
    this.stop();
  }

  get(key: string): any {
    return this.metadata.get(key);
  }

  set(key: string, value: any): void {
    this.metadata.set(key, value);
  }
}

================
File: backend/src/services/messaging/middlewares/AddressRequiredMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { sendMessageWithUrlButton } from '../../whatsapp';
import { OTPService } from '../../security/OTPService';
import { env } from '../../../common/config/envValidator';
import { CONTEXT_KEYS } from '../../../common/constants';
import logger from '../../../common/utils/logger';

export class AddressRequiredMiddleware implements MessageMiddleware {
  name = 'AddressRequiredMiddleware';

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      const hasNoAddress = context.get(CONTEXT_KEYS.HAS_NO_ADDRESS);
      const customerId = context.message.from;
      
      // Si el cliente no tiene direcci√≥n, bloquear la conversaci√≥n
      if (hasNoAddress) {
        logger.info(`Blocking conversation for customer ${customerId} - no address on file`);
        
        // Generar OTP con expiraci√≥n extendida para registro de direcci√≥n
        const otp = OTPService.generateOTP();
        await OTPService.storeOTP(customerId, otp, true); // true = address registration
        
        // Crear enlace de registro - directo al formulario para primera vez
        const registrationLink = `${env.FRONTEND_BASE_URL}/address-registration/${customerId}?otp=${otp}&viewMode=form`;
        
        // Enviar mensaje con bot√≥n URL
        await sendMessageWithUrlButton(
          customerId,
          "üè† ¬°Bienvenido!",
          "Para poder tomar tu pedido, necesitamos que registres tu direcci√≥n de entrega.\n\nEs muy f√°cil y r√°pido:\n‚Ä¢ Haz clic en el bot√≥n de abajo\n‚Ä¢ Completa tu informaci√≥n\n‚Ä¢ ¬°Listo para ordenar!",
          "Registrar Direcci√≥n",
          registrationLink
        );
        
        // Detener el procesamiento - no procesar ning√∫n mensaje hasta que tenga direcci√≥n
        context.stop();
        return context;
      }
      
      return context;
    } catch (error) {
      logger.error('Error in AddressRequiredMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/middlewares/RateLimitMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { sendWhatsAppMessage } from '../../whatsapp';
import { RATE_LIMIT_MESSAGE } from '../../../common/config/predefinedMessages';
import { redisKeys } from '../../../common/constants';
import logger from '../../../common/utils/logger';
import { env } from '../../../common/config/envValidator';
import { RedisService } from '../../redis/RedisService';

export class RateLimitMiddleware implements MessageMiddleware {
  name = 'RateLimitMiddleware';
  
  private readonly MAX_MESSAGES = parseInt(env.RATE_LIMIT_MAX_MESSAGES);
  private readonly WINDOW_SECONDS = parseInt(env.RATE_LIMIT_TIME_WINDOW_MINUTES) * 60;

  async process(context: MessageContext): Promise<MessageContext> {
    const redisService = RedisService.getInstance();
    
    try {
      // Try to use Redis for rate limiting
      const redisClient = await this.getRedisClient(redisService);
      
      if (redisClient) {
        return await this.processWithRedis(context, redisClient);
      } else {
        // Redis not available - log warning and continue processing
        logger.warn('Redis not available for rate limiting. Allowing message through.');
        return context;
      }
    } catch (error) {
      logger.error('Error in RateLimitMiddleware:', error);
      // On error, allow the message through to avoid blocking legitimate users
      return context;
    }
  }

  private async getRedisClient(redisService: RedisService): Promise<any | null> {
    await redisService.connect();
    return redisService.getClient();
  }

  private async processWithRedis(context: MessageContext, redisClient: any): Promise<MessageContext> {
    const key = redisKeys.rateLimit(context.message.from);
    
    try {
      // Increment the counter atomically
      const currentCount = await redisClient.incr(key);
      
      // If this is the first message, set the expiration
      if (currentCount === 1) {
        await redisClient.expire(key, this.WINDOW_SECONDS);
      }
      
      // Check if rate limit exceeded
      if (currentCount > this.MAX_MESSAGES) {
        logger.warn(`Rate limit exceeded for customer ${context.message.from} (${currentCount}/${this.MAX_MESSAGES})`);
        
        // Only send the warning message once when limit is first exceeded
        if (currentCount === this.MAX_MESSAGES + 1) {
          await sendWhatsAppMessage(context.message.from, RATE_LIMIT_MESSAGE);
        }
        
        context.stop();
        return context;
      }
      
      logger.debug(`Rate limit check passed for ${context.message.from}: ${currentCount}/${this.MAX_MESSAGES}`);
      return context;
      
    } catch (error) {
      logger.error(`Redis error in rate limiting for ${context.message.from}:`, error);
      // On Redis error, allow the message through
      return context;
    }
  }
}

================
File: backend/src/services/orders/services/SchedulingService.ts
================
import { RestaurantService } from "../../restaurant/RestaurantService";
import { ValidationError, ErrorCode } from "../../../common/services/errors";
import { env } from "../../../common/config/envValidator";
import { OrderType } from '@prisma/client';

export class SchedulingService {
  /**
   * Validate and process scheduled delivery time
   */
  static async validateScheduledTime(
    scheduledAt: string | Date | undefined,
    orderType: OrderType
  ): Promise<Date | null> {
    if (!scheduledAt || scheduledAt === "null") {
      return null;
    }

    const now = new Date();
    let fullScheduledDeliveryTime: Date;

    if (scheduledAt instanceof Date) {
      fullScheduledDeliveryTime = scheduledAt;
    } else {
      const timeParts = scheduledAt.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
      if (!timeParts) {
        throw new ValidationError(
          ErrorCode.INVALID_SCHEDULE_TIME,
          'Invalid time format',
          { metadata: { scheduledAt } }
        );
      }

      let hours = parseInt(timeParts[1]);
      const minutes = parseInt(timeParts[2]);
      const meridiem = timeParts[3];

      if (meridiem) {
        if (meridiem.toUpperCase() === "PM" && hours !== 12) {
          hours += 12;
        } else if (meridiem.toUpperCase() === "AM" && hours === 12) {
          hours = 0;
        }
      }

      fullScheduledDeliveryTime = new Date(now);
      fullScheduledDeliveryTime.setHours(hours, minutes, 0, 0);

      if (fullScheduledDeliveryTime <= now) {
        fullScheduledDeliveryTime.setDate(fullScheduledDeliveryTime.getDate() + 1);
      }
    }

    // Validate against business hours
    await this.validateAgainstBusinessHours(fullScheduledDeliveryTime, orderType);

    return fullScheduledDeliveryTime;
  }

  /**
   * Validate scheduled time against business hours
   */
  private static async validateAgainstBusinessHours(
    scheduledTime: Date,
    orderType: OrderType
  ): Promise<void> {
    const config = await RestaurantService.getConfig();
    
    // Convert to Mexico time
    const mexicoTime = new Date(
      scheduledTime.toLocaleString("en-US", {
        timeZone: config.timeZone || env.DEFAULT_TIMEZONE,
      })
    );

    const dayOfWeek = mexicoTime.getDay();
    const scheduledHour = mexicoTime.getHours();
    const scheduledMinute = mexicoTime.getMinutes();

    // Get business hours for the day
    const businessHours = await RestaurantService.getBusinessHoursForDay(dayOfWeek);
    
    if (!businessHours || businessHours.isClosed || !businessHours.openingTime || !businessHours.closingTime) {
      throw new ValidationError(
        ErrorCode.RESTAURANT_CLOSED,
        'üòî El restaurante est√° cerrado en el horario solicitado. Por favor, elige otro horario cuando estemos abiertos.'
      );
    }

    // Parse opening and closing times
    const [openingHour, openingMinute] = businessHours.openingTime.split(":").map(Number);
    const [closingHour, closingMinute] = businessHours.closingTime.split(":").map(Number);
    const openingMinutes = openingHour * 60 + openingMinute;
    const closingMinutes = closingHour * 60 + closingMinute;

    // Apply grace periods
    const openingGracePeriod = config.openingGracePeriod || 0;
    const closingGracePeriod = config.closingGracePeriod || 0;
    const adjustedOpeningMinutes = openingMinutes - openingGracePeriod;
    const adjustedClosingMinutes = closingMinutes + closingGracePeriod;

    // Convert scheduled time to minutes
    const scheduledMinutes = scheduledHour * 60 + scheduledMinute;

    // Check if within hours
    if (scheduledMinutes < adjustedOpeningMinutes || scheduledMinutes > adjustedClosingMinutes) {
      const adjustedOpeningTime = new Date(mexicoTime);
      adjustedOpeningTime.setHours(openingHour, openingMinute - openingGracePeriod);
      
      const adjustedClosingTime = new Date(mexicoTime);
      adjustedClosingTime.setHours(closingHour, closingMinute + closingGracePeriod);

      const openingFormatted = adjustedOpeningTime.toLocaleTimeString("es-MX", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: true,
      });
      const closingFormatted = adjustedClosingTime.toLocaleTimeString("es-MX", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: true,
      });

      throw new ValidationError(
        ErrorCode.INVALID_SCHEDULE_TIME,
        `Scheduled time is outside business hours. Please schedule between ${openingFormatted} and ${closingFormatted}`,
        { metadata: { scheduledMinutes, adjustedOpeningMinutes, adjustedClosingMinutes } }
      );
    }

    // Check minimum time requirement
    const minTimeRequired = orderType === OrderType.TAKE_AWAY 
      ? config.estimatedPickupTime 
      : config.estimatedDeliveryTime;
    
    const now = new Date();
    const timeDifference = (scheduledTime.getTime() - now.getTime()) / (1000 * 60);

    if (timeDifference < minTimeRequired) {
      throw new ValidationError(
        ErrorCode.INVALID_SCHEDULE_TIME,
        `Scheduled time must be at least ${minTimeRequired} minutes from now`,
        { metadata: { timeDifference, minTimeRequired } }
      );
    }
  }
}

================
File: backend/src/services/restaurant/RestaurantService.ts
================
import { prisma } from '../../lib/prisma';
import { RestaurantConfig, BusinessHours } from '../../common/types';
import logger from '../../common/utils/logger';
import { BusinessLogicError, ErrorCode } from '../../common/services/errors';
import { redisService } from '../redis/RedisService';
import { redisKeys } from '../../common/constants';

/**
 * Service for managing restaurant configuration and business hours
 */
export class RestaurantService {
  // Cache configuration
  private static readonly CACHE_TTL = 300; // 5 minutes cache
  
  // Memory cache fallback
  private static memoryConfigCache: RestaurantConfig | null = null;
  private static memoryBusinessHoursCache: BusinessHours[] | null = null;

  /**
   * Get restaurant configuration (with caching)
   */
  static async getConfig(): Promise<RestaurantConfig> {
    try {
      // Try Redis cache first
      if (redisService.isAvailable()) {
        const cached = await redisService.getJSON<RestaurantConfig>(redisKeys.restaurantConfig());
        if (cached) {
          logger.debug('Restaurant config retrieved from Redis cache');
          return cached;
        }
      }
      
      // Try memory cache
      if (this.memoryConfigCache) {
        logger.debug('Restaurant config retrieved from memory cache');
        return this.memoryConfigCache;
      }

      // Get or create config from database
      let config = await prisma.restaurantConfig.findFirst();
      
      if (!config) {
        config = await prisma.restaurantConfig.create({
          data: {
            acceptingOrders: true,
            estimatedPickupTime: 20,
            estimatedDeliveryTime: 40
          }
        });
        logger.info('Created default restaurant configuration');
      }

      // Cache in Redis if available
      if (redisService.isAvailable()) {
        await redisService.setJSON(redisKeys.restaurantConfig(), config, this.CACHE_TTL);
      }
      
      // Cache in memory
      this.memoryConfigCache = config;
      return config;
    } catch (error) {
      logger.error('Error getting restaurant config:', error);
      // Return default config if error
      return {
        id: 1,
        acceptingOrders: true,
        estimatedPickupTime: 20,
        estimatedDeliveryTime: 40
      } as RestaurantConfig;
    }
  }

  /**
   * Update restaurant configuration
   */
  static async updateConfig(data: Partial<RestaurantConfig>): Promise<RestaurantConfig> {
    try {
      const config = await prisma.restaurantConfig.findFirst();
      
      if (!config) {
        throw new BusinessLogicError(
          ErrorCode.ORDER_NOT_FOUND,
          'Restaurant configuration not found'
        );
      }

      const { id, ...updateData } = data;
      const updated = await prisma.restaurantConfig.update({
        where: { id: config.id },
        data: updateData as any
      });

      // Clear caches
      await this.clearCache();
      
      // Clear timezone cache if timezone was updated
      if (data.timeZone) {
        const { clearTimeZoneCache } = await import('../../common/utils/timeUtils');
        clearTimeZoneCache();
      }

      logger.info('Restaurant configuration updated:', data);
      return updated;
    } catch (error) {
      logger.error('Error updating restaurant config:', error);
      throw error;
    }
  }

  /**
   * Toggle accepting orders
   */
  static async toggleAcceptingOrders(accepting: boolean): Promise<RestaurantConfig> {
    return this.updateConfig({ acceptingOrders: accepting });
  }

  /**
   * Get business hours for a specific day
   */
  static async getBusinessHoursForDay(dayOfWeek: number): Promise<BusinessHours | null> {
    try {
      const config = await this.getConfig();
      
      const businessHours = await prisma.businessHours.findUnique({
        where: {
          restaurantConfigId_dayOfWeek: {
            restaurantConfigId: config.id,
            dayOfWeek: dayOfWeek
          }
        }
      });

      return businessHours;
    } catch (error) {
      logger.error(`Error getting business hours for day ${dayOfWeek}:`, error);
      return null;
    }
  }

  /**
   * Get all business hours
   */
  static async getAllBusinessHours(): Promise<BusinessHours[]> {
    try {
      // Try Redis cache first
      if (redisService.isAvailable()) {
        const cached = await redisService.getJSON<BusinessHours[]>(redisKeys.restaurantBusinessHours());
        if (cached) {
          logger.debug('Business hours retrieved from Redis cache');
          return cached;
        }
      }
      
      // Try memory cache
      if (this.memoryBusinessHoursCache) {
        logger.debug('Business hours retrieved from memory cache');
        return this.memoryBusinessHoursCache;
      }

      const config = await this.getConfig();
      const businessHours = await prisma.businessHours.findMany({
        where: { restaurantConfigId: config.id },
        orderBy: { dayOfWeek: 'asc' }
      });

      // Cache in Redis if available
      if (redisService.isAvailable()) {
        await redisService.setJSON(redisKeys.restaurantBusinessHours(), businessHours, this.CACHE_TTL);
      }
      
      // Cache in memory
      this.memoryBusinessHoursCache = businessHours;
      return businessHours;
    } catch (error) {
      logger.error('Error getting all business hours:', error);
      return [];
    }
  }

  /**
   * Update business hours for a specific day
   */
  static async updateBusinessHours(
    dayOfWeek: number, 
    data: { openingTime?: string; closingTime?: string; isClosed?: boolean }
  ): Promise<BusinessHours> {
    try {
      const config = await this.getConfig();

      const businessHours = await prisma.businessHours.upsert({
        where: {
          restaurantConfigId_dayOfWeek: {
            restaurantConfigId: config.id,
            dayOfWeek
          }
        },
        update: data,
        create: {
          restaurantConfigId: config.id,
          dayOfWeek,
          ...data
        }
      });

      // Clear caches
      await this.clearCache();
      
      logger.info(`Updated business hours for day ${dayOfWeek}:`, data);
      return businessHours;
    } catch (error) {
      logger.error('Error updating business hours:', error);
      throw new BusinessLogicError(
        ErrorCode.DATABASE_ERROR,
        'Failed to update business hours',
        { metadata: { dayOfWeek, data } }
      );
    }
  }

  /**
   * Check if restaurant is currently open
   */
  static async isOpen(date: Date = new Date()): Promise<boolean> {
    try {
      const dayOfWeek = date.getDay();
      const businessHours = await this.getBusinessHoursForDay(dayOfWeek);

      if (!businessHours || businessHours.isClosed || !businessHours.openingTime || !businessHours.closingTime) {
        return false;
      }

      const currentTime = date.getHours() * 60 + date.getMinutes();
      const [openHour, openMinute] = businessHours.openingTime.split(':').map(Number);
      const [closeHour, closeMinute] = businessHours.closingTime.split(':').map(Number);
      
      const openTime = openHour * 60 + openMinute;
      const closeTime = closeHour * 60 + closeMinute;

      return currentTime >= openTime && currentTime <= closeTime;
    } catch (error) {
      logger.error('Error checking if restaurant is open:', error);
      return false;
    }
  }

  /**
   * Clear all caches
   */
  static async clearCache(): Promise<void> {
    // Clear Redis cache if available
    if (redisService.isAvailable()) {
      await redisService.del(redisKeys.restaurantConfig());
      await redisService.del(redisKeys.restaurantBusinessHours());
    }
    
    // Clear memory cache
    this.memoryConfigCache = null;
    this.memoryBusinessHoursCache = null;
    logger.debug('Restaurant service caches cleared');
  }

  /**
   * Get delivery coverage area
   */
  static async getDeliveryCoverageArea(): Promise<any> {
    const config = await this.getConfig();
    return config.deliveryCoverageArea;
  }

  /**
   * Update delivery coverage area
   */
  static async updateDeliveryCoverageArea(coverageArea: any): Promise<RestaurantConfig> {
    return this.updateConfig({ deliveryCoverageArea: coverageArea });
  }
}

================
File: backend/src/services/security/OTPService.ts
================
import logger from '../../common/utils/logger';
import crypto from 'crypto';
import { redisService } from '../redis/RedisService';
import { redisKeys, REDIS_KEYS } from '../../common/constants';

/**
 * Service for managing One-Time Passwords (OTP)
 */
export class OTPService {
  // Fallback to memory if Redis is not available
  private static memoryStore = new Map<string, { code: string; expires: Date }>();
  private static cleanupInterval: NodeJS.Timeout | null = null;
  private static readonly OTP_EXPIRY_MINUTES = 10;
  /**
   * Get Redis key for OTP
   */
  private static getRedisKey(whatsappPhoneNumber: string): string {
    return redisKeys.otp(whatsappPhoneNumber);
  }

  /**
   * Generate a new OTP code
   */
  static generateOTP(): string {
    return crypto.randomInt(100000, 999999).toString();
  }

  /**
   * Store an OTP for a WhatsApp phone number
   */
  static async storeOTP(whatsappPhoneNumber: string, otp: string, isAddressRegistration: boolean = false): Promise<void> {
    const expires = new Date(Date.now() + this.OTP_EXPIRY_MINUTES * 60 * 1000);
    const expiresInSeconds = this.OTP_EXPIRY_MINUTES * 60;
    
    // Try Redis first
    if (redisService.isAvailable()) {
      const key = this.getRedisKey(whatsappPhoneNumber);
      const data = { code: otp, expires: expires.toISOString() };
      const stored = await redisService.setJSON(key, data, expiresInSeconds);
      
      if (stored) {
        logger.info(`OTP stored in Redis for phone ${whatsappPhoneNumber} (expires at ${expires.toISOString()})`);
        return;
      }
    }
    
    // Fallback to memory
    this.memoryStore.set(whatsappPhoneNumber, { code: otp, expires });
    logger.info(`OTP stored in memory for phone ${whatsappPhoneNumber} (expires at ${expires.toISOString()})`);
  }

  /**
   * Verify an OTP
   */
  static async verifyOTP(whatsappPhoneNumber: string, code: string): Promise<boolean> {
    try {
      logger.info(`Verifying OTP for phone ${whatsappPhoneNumber}, code: ${code}`);
      
      let storedOTP: { code: string; expires: Date | string } | null = null;
      
      // Try Redis first
      if (redisService.isAvailable()) {
        const key = this.getRedisKey(whatsappPhoneNumber);
        const redisData = await redisService.getJSON<{ code: string; expires: string }>(key);
        
        if (redisData) {
          storedOTP = { code: redisData.code, expires: new Date(redisData.expires) };
          logger.debug(`OTP found in Redis for phone ${whatsappPhoneNumber}`);
        }
      }
      
      // Fallback to memory if not found in Redis
      if (!storedOTP) {
        const memoryData = this.memoryStore.get(whatsappPhoneNumber);
        if (memoryData) {
          storedOTP = memoryData;
          logger.debug(`OTP found in memory for phone ${whatsappPhoneNumber}`);
        }
      }
      
      if (!storedOTP) {
        logger.warn(`No OTP found for phone ${whatsappPhoneNumber}`);
        return false;
      }

      // Check if expired
      const expiryDate = storedOTP.expires instanceof Date ? storedOTP.expires : new Date(storedOTP.expires);
      if (new Date() > expiryDate) {
        await this.invalidateOTP(whatsappPhoneNumber);
        logger.warn(`OTP expired for phone ${whatsappPhoneNumber} - Expired at: ${expiryDate.toISOString()}, Current time: ${new Date().toISOString()}`);
        return false;
      }

      // Verify code
      if (storedOTP.code === code) {
        // Don't delete immediately for address registration - allow multiple verifications
        logger.info(`OTP verified successfully for phone ${whatsappPhoneNumber}`);
        return true;
      }

      logger.warn(`Invalid OTP attempt for phone ${whatsappPhoneNumber} - Expected: ${storedOTP.code}, Received: ${code}`);
      return false;
    } catch (error) {
      logger.error('Error verifying OTP:', error);
      return false;
    }
  }

  /**
   * Invalidate an OTP
   */
  static async invalidateOTP(whatsappPhoneNumber: string): Promise<void> {
    // Try Redis first
    if (redisService.isAvailable()) {
      const key = this.getRedisKey(whatsappPhoneNumber);
      await redisService.del(key);
    }
    
    // Also remove from memory
    this.memoryStore.delete(whatsappPhoneNumber);
    logger.info(`OTP invalidated for phone ${whatsappPhoneNumber}`);
  }


  /**
   * Clean up expired OTPs from memory store
   */
  private static cleanupExpiredOTPs(): void {
    const now = new Date();
    let cleanedCount = 0;
    
    for (const [whatsappPhoneNumber, otp] of this.memoryStore.entries()) {
      if (now > otp.expires) {
        this.memoryStore.delete(whatsappPhoneNumber);
        cleanedCount++;
      }
    }
    
    if (cleanedCount > 0) {
      logger.debug(`Cleaned up ${cleanedCount} expired OTPs from memory`);
    }
    
    // Note: Redis handles expiration automatically, no need to clean up there
  }

  /**
   * Start periodic cleanup of expired OTPs
   */
  static startOTPCleanup(): void {
    if (this.cleanupInterval) return; // Already running
    
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredOTPs();
    }, 60000); // Run every minute
    
    logger.info('OTP cleanup interval started');
  }

  /**
   * Stop periodic cleanup
   */
  static stopOTPCleanup(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
      logger.info('OTP cleanup interval stopped');
    }
  }

}

================
File: backend/src/startup/embeddingInitializer.ts
================
import { EmbeddingManager } from '../services/sync/EmbeddingManager';
import logger from '../common/utils/logger';

/**
 * Initialize embeddings on server startup
 * Uses EmbeddingManager for intelligent embedding lifecycle management
 */
export async function initializeEmbeddings(): Promise<void> {
  try {
    logger.info('üöÄ Initializing embedding manager...');
    await EmbeddingManager.initialize();
  } catch (error) {
    logger.error('Failed to initialize embedding manager:', error);
    // Don't throw - we don't want to prevent server startup if embeddings fail
    logger.warn('‚ö†Ô∏è  Server starting without embedding manager - semantic search may not work properly');
  }
}

================
File: backend/src/workers/messageWorker.ts
================
import { MessageProcessor } from '../services/messaging/MessageProcessor';
import { IncomingMessage } from '../services/messaging/types';
import { WhatsAppMessageJob } from '../queues/types';
import logger from '../common/utils/logger';
import { startMessageWorker } from '../queues/messageQueue';

/**
 * Process a WhatsApp message job from the queue
 * This runs in a separate worker process/thread
 */
export async function processMessageJob(messageData: WhatsAppMessageJob): Promise<void> {
  const startTime = Date.now();
  
  try {
    // Convert job data to IncomingMessage format
    const incomingMessage: IncomingMessage = {
      id: messageData.id,
      from: messageData.from,
      type: messageData.type as 'text' | 'interactive' | 'audio' | 'image' | 'document' | 'location',
      timestamp: messageData.timestamp,
      text: messageData.text,
      interactive: messageData.interactive,
      audio: messageData.audio
    };
    
    logger.info(`Worker processing message ${messageData.id} from ${messageData.from}, type: ${messageData.type}`);
    
    // Process the message through the existing pipeline
    await MessageProcessor.processWithPipeline(incomingMessage);
    
    const processingTime = Date.now() - startTime;
    logger.info(`Message ${messageData.id} from ${messageData.from} processed successfully in ${processingTime}ms`);
    
  } catch (error) {
    const processingTime = Date.now() - startTime;
    logger.error(`Worker failed to process message ${messageData.id} from ${messageData.from} after ${processingTime}ms:`, error);
    
    // Re-throw the error so BullMQ can handle retries according to configuration
    throw error;
  }
}

// Start the worker when this file is executed directly
if (require.main === module) {
  logger.info('Starting message worker process...');
  startMessageWorker();
}

================
File: frontend-app/.env.example
================
# Google Maps - REQUERIDO
# El frontend usa Google Maps para seleccionar direcciones
# Usa la misma API Key que el backend si es posible
# 
# IMPORTANTE: En Google Cloud Console, activa estas APIs:
# - Maps JavaScript API
# - Places API
# - Geocoding API
#
VITE_GOOGLE_MAPS_API_KEY=tu_google_maps_api_key

# Backend URL
VITE_BACKEND_BASE_URL=https://cloudbiteapp.com

# Regional Configuration
# C√≥digo de pa√≠s ISO 3166-1 alpha-2 (mx = M√©xico, us = Estados Unidos, etc.)
VITE_COUNTRY_CODE=mx
# Locale para formato de fecha/hora y textos
VITE_LOCALE=es-MX
# Zona horaria IANA
VITE_TIMEZONE=America/Mexico_City

# API Configuration
# Prefijo para las rutas del API backend
VITE_API_PREFIX=/backend

================
File: frontend-app/src/components/ui/index.ts
================
export { Input } from './Input';

================
File: frontend-app/src/types/index.ts
================
// Export all types from customer.types
export type { 
  Customer,
  Address,
  AddressFormData,
  OTPVerificationResponse,
  AddressRegistrationResponse,
  CustomerDeliveryInfo,
  Location
} from './customer.types';

================
File: frontend-app/src/utils/errorHandlers.ts
================
export interface ApiError {
  response?: {
    status: number;
    data?: {
      error?: {
        code?: string;
        message?: string;
        type?: string;
      };
      message?: string;
    };
  };
  message?: string;
}

export const isOTPError = (error: any): boolean => {
  if (!error?.response) return false;
  
  const status = error.response.status;
  const errorData = error.response.data?.error || error.response.data;
  
  // Check for 400 status and OTP-related error codes or messages
  return status === 400 && (
    errorData?.code === 'INVALID_OTP' ||
    errorData?.code === 'VAL006' ||
    errorData?.message?.toLowerCase().includes('otp') ||
    errorData?.message?.toLowerCase().includes('expired') ||
    error.message?.toLowerCase().includes('otp')
  );
};

export const getErrorMessage = (error: any): string => {
  // Check for OTP errors first
  if (isOTPError(error)) {
    return 'Tu sesi√≥n ha expirado. Por favor, solicita un nuevo enlace desde WhatsApp.';
  }

  // Extract error message from various possible locations
  const errorMessage = 
    error?.response?.data?.error?.message ||
    error?.response?.data?.message ||
    error?.message ||
    'Ha ocurrido un error inesperado';

  return errorMessage;
};

================
File: scripts/health-check.sh
================
#!/bin/bash

# Script de verificaci√≥n de salud del sistema
# Autor: Bot Backend Health Check
# Uso: ./health-check.sh

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m'

print_header() {
    echo -e "\n${MAGENTA}=== $1 ===${NC}"
}

check_service() {
    local service=$1
    local display_name=$2
    
    if systemctl is-active --quiet $service; then
        echo -e "${GREEN}‚úì${NC} $display_name: ${GREEN}Activo${NC}"
        return 0
    else
        echo -e "${RED}‚úó${NC} $display_name: ${RED}Inactivo${NC}"
        return 1
    fi
}

check_port() {
    local port=$1
    local service=$2
    
    if netstat -tuln | grep -q ":$port "; then
        echo -e "${GREEN}‚úì${NC} Puerto $port ($service): ${GREEN}Abierto${NC}"
        return 0
    else
        echo -e "${RED}‚úó${NC} Puerto $port ($service): ${RED}Cerrado${NC}"
        return 1
    fi
}

check_process() {
    local process=$1
    local display_name=$2
    
    if pgrep -f "$process" > /dev/null; then
        local count=$(pgrep -f "$process" | wc -l)
        echo -e "${GREEN}‚úì${NC} $display_name: ${GREEN}$count proceso(s) activo(s)${NC}"
        return 0
    else
        echo -e "${RED}‚úó${NC} $display_name: ${RED}No encontrado${NC}"
        return 1
    fi
}

# Header
clear
echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
echo -e "${BLUE}‚ïë     BOT BACKEND - HEALTH CHECK         ‚ïë${NC}"
echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
echo -e "Fecha: $(date)"

# Sistema
print_header "INFORMACI√ìN DEL SISTEMA"
echo "Hostname: $(hostname)"
echo "IP: $(hostname -I | awk '{print $1}')"
echo "Uptime: $(uptime -p)"
echo ""

# Recursos
print_header "RECURSOS DEL SISTEMA"
echo "CPU: $(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1"%"}')"
echo "RAM: $(free -h | awk '/^Mem:/ {print $3 " / " $2}')"
echo "Disco: $(df -h / | awk 'NR==2 {print $3 " / " $2 " (" $5 " usado)"}')"
echo ""

# Servicios del sistema
print_header "SERVICIOS DEL SISTEMA"
check_service "postgresql" "PostgreSQL"
check_service "redis-server" "Redis"
check_service "nginx" "Nginx"
echo ""

# Puertos
print_header "PUERTOS"
check_port 5000 "Backend API"
check_port 5432 "PostgreSQL" 2>/dev/null || check_port 5433 "PostgreSQL"
check_port 6379 "Redis" 2>/dev/null || check_port 6380 "Redis"
check_port 80 "HTTP"
check_port 443 "HTTPS"
echo ""

# Procesos de la aplicaci√≥n
print_header "PROCESOS DE APLICACI√ìN"
check_process "PM2" "PM2 Manager"
check_process "bot-backend-api" "API Backend"
check_process "bot-backend-worker" "Worker Process"
echo ""

# PM2 Status
if command -v pm2 &> /dev/null; then
    print_header "ESTADO PM2"
    pm2 list --no-color | grep -E "bot-backend|App name|‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo ""
fi

# Verificar conectividad
print_header "CONECTIVIDAD"

# API Health
if curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/backend | grep -q "200"; then
    echo -e "${GREEN}‚úì${NC} API Health: ${GREEN}OK${NC}"
else
    echo -e "${RED}‚úó${NC} API Health: ${RED}Error${NC}"
fi

# Base de datos
if PGPASSWORD=$(grep DATABASE_URL ~/bot_backend/backend/.env 2>/dev/null | sed 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/') psql -U bot_user -h localhost -d bot_db -c '\q' 2>/dev/null; then
    echo -e "${GREEN}‚úì${NC} Conexi√≥n PostgreSQL: ${GREEN}OK${NC}"
else
    echo -e "${YELLOW}!${NC} Conexi√≥n PostgreSQL: ${YELLOW}No verificable${NC}"
fi

# Redis
if redis-cli ping 2>/dev/null | grep -q "PONG"; then
    echo -e "${GREEN}‚úì${NC} Conexi√≥n Redis: ${GREEN}OK${NC}"
else
    echo -e "${RED}‚úó${NC} Conexi√≥n Redis: ${RED}Error${NC}"
fi
echo ""

# Logs recientes
print_header "√öLTIMOS ERRORES (si hay)"
if [ -f /var/log/nginx/bot-backend-error.log ]; then
    tail -5 /var/log/nginx/bot-backend-error.log 2>/dev/null | grep -v "^$" || echo "Sin errores recientes en Nginx"
fi
echo ""

# Resumen
print_header "RESUMEN"
echo -e "${BLUE}Use los siguientes comandos para m√°s informaci√≥n:${NC}"
echo "‚Ä¢ pm2 logs          - Ver logs de la aplicaci√≥n"
echo "‚Ä¢ pm2 monit         - Monitor en tiempo real"
echo "‚Ä¢ systemctl status  - Estado de servicios"
echo "‚Ä¢ htop              - Monitor de recursos"
echo ""

================
File: scripts/reset-database-production.sh
================
#!/bin/bash

# Script para resetear completamente la base de datos en producci√≥n
# ADVERTENCIA: Este script ELIMINAR√Å TODOS LOS DATOS
# Autor: Bot Backend Reset Script
# Uso: ./reset-database-production.sh

set -e

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_step() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

# Banner de advertencia
echo ""
echo "================================================"
echo -e "${RED}‚ö†Ô∏è  ADVERTENCIA - RESET COMPLETO DE BASE DE DATOS ‚ö†Ô∏è${NC}"
echo "================================================"
echo ""
echo "Este script realizar√° las siguientes acciones:"
echo "1. Detener todos los procesos PM2"
echo "2. Hacer backup de la base de datos actual"
echo "3. ELIMINAR completamente la base de datos"
echo "4. Recrear la base de datos vac√≠a"
echo "5. Ejecutar las nuevas migraciones"
echo "6. Reiniciar los servicios"
echo ""
echo -e "${RED}TODOS LOS DATOS SER√ÅN ELIMINADOS${NC}"
echo ""
read -p "¬øEst√°s ABSOLUTAMENTE SEGURO que quieres continuar? Escribe 'SI ESTOY SEGURO': " -r
echo

if [[ ! $REPLY == "SI ESTOY SEGURO" ]]; then
    print_error "Reset cancelado"
    exit 1
fi

# Segunda confirmaci√≥n
echo ""
echo -e "${YELLOW}Segunda confirmaci√≥n por seguridad${NC}"
read -p "¬øRealmente quieres ELIMINAR TODOS LOS DATOS? (s/n): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Ss]$ ]]; then
    print_error "Reset cancelado"
    exit 1
fi

# Verificar que estamos en el servidor correcto
if [ ! -d "$HOME/bot_backend" ]; then
    print_error "No se encontr√≥ el directorio ~/bot_backend"
    print_error "¬øEst√°s seguro que est√°s en el servidor correcto?"
    exit 1
fi

cd ~/bot_backend

# Paso 1: Detener PM2
print_step "Deteniendo todos los procesos PM2..."
pm2 stop all || true
print_success "Procesos detenidos"

# Paso 2: Backup de la base de datos actual
print_step "Creando backup de la base de datos actual..."
BACKUP_FILE="backup_before_reset_$(date +%Y%m%d_%H%M%S).sql"
cd ~/bot_backend/backend

# Obtener credenciales de la base de datos del .env
if [ -f .env ]; then
    export $(cat .env | grep -E '^DATABASE_URL=' | xargs)
    # Extraer componentes de DATABASE_URL
    DB_USER=$(echo $DATABASE_URL | sed -n 's/.*postgresql:\/\/\([^:]*\):.*/\1/p')
    DB_NAME=$(echo $DATABASE_URL | sed -n 's/.*\/\([^?]*\).*/\1/p')
    DB_HOST=$(echo $DATABASE_URL | sed -n 's/.*@\([^:]*\):.*/\1/p')
    DB_PORT=$(echo $DATABASE_URL | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
else
    # Valores por defecto si no encuentra .env
    DB_USER="bot_user"
    DB_NAME="bot_db"
    DB_HOST="localhost"
    DB_PORT="5432"
fi

PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p') pg_dump -U $DB_USER -h $DB_HOST -p $DB_PORT $DB_NAME > ~/$BACKUP_FILE 2>/dev/null || true

if [ -f ~/$BACKUP_FILE ]; then
    print_success "Backup creado: ~/$BACKUP_FILE"
else
    print_warning "No se pudo crear el backup, pero continuando..."
fi

# Paso 3: Eliminar todas las tablas (m√°s seguro que eliminar la base de datos completa)
print_step "Eliminando todas las tablas de la base de datos..."

# Crear script SQL para eliminar todas las tablas
cat > /tmp/drop_all_tables.sql << 'EOF'
DO $$ 
DECLARE
    r RECORD;
BEGIN
    -- Eliminar todas las tablas en el schema public
    FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
        EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
    END LOOP;
    
    -- Eliminar todas las secuencias
    FOR r IN (SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public') LOOP
        EXECUTE 'DROP SEQUENCE IF EXISTS ' || quote_ident(r.sequence_name) || ' CASCADE';
    END LOOP;
    
    -- Eliminar todos los tipos enum
    FOR r IN (SELECT typname FROM pg_type WHERE typnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public') AND typtype = 'e') LOOP
        EXECUTE 'DROP TYPE IF EXISTS ' || quote_ident(r.typname) || ' CASCADE';
    END LOOP;
    
    -- Eliminar la tabla _prisma_migrations si existe
    DROP TABLE IF EXISTS "_prisma_migrations" CASCADE;
END $$;
EOF

PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p') psql -U $DB_USER -h $DB_HOST -p $DB_PORT $DB_NAME < /tmp/drop_all_tables.sql

print_success "Base de datos limpiada"

# Paso 4: Eliminar el historial de migraciones de Prisma
print_step "Eliminando historial de migraciones..."
rm -rf prisma/migrations
print_success "Historial de migraciones eliminado"

# Paso 5: Crear nueva migraci√≥n inicial
print_step "Creando nueva migraci√≥n inicial..."
# En producci√≥n, usar --create-only para evitar el error de shadow database
npx prisma migrate dev --name initial_migration --create-only
print_success "Migraci√≥n inicial creada"

# Paso 6: Aplicar migraciones
print_step "Aplicando migraciones..."
npm run migrate
print_success "Migraciones aplicadas"

# Paso 7: Generar cliente Prisma
print_step "Generando cliente Prisma..."
npm run generate
print_success "Cliente Prisma generado"

# Paso 8: Generar embeddings si est√° configurado
if grep -q "GOOGLE_AI_API_KEY=" .env && grep -q "^GOOGLE_AI_API_KEY=." .env; then
    print_step "Generando embeddings para b√∫squeda sem√°ntica..."
    npm run seed:embeddings || print_warning "No se pudieron generar embeddings"
else
    print_warning "GOOGLE_AI_API_KEY no configurado, omitiendo embeddings"
fi

# Paso 9: Reiniciar servicios
print_step "Reiniciando servicios PM2..."
pm2 start ecosystem.config.js
print_success "Servicios reiniciados"

# Paso 10: Verificar estado
print_step "Verificando estado de la aplicaci√≥n..."
sleep 3
pm2 status

# Resumen
echo ""
echo "================================================"
echo -e "${GREEN}¬°Reset de base de datos completado!${NC}"
echo "================================================"
echo ""
echo "‚úÖ Base de datos completamente limpia"
echo "‚úÖ Nuevas migraciones aplicadas"
echo "‚úÖ Servicios reiniciados"
echo ""
if [ -f ~/$BACKUP_FILE ]; then
    echo -e "${YELLOW}Backup guardado en: ~/$BACKUP_FILE${NC}"
    echo ""
    echo "Para restaurar el backup:"
    echo "PGPASSWORD=\$PASSWORD psql -U $DB_USER -h $DB_HOST -p $DB_PORT $DB_NAME < ~/$BACKUP_FILE"
fi
echo ""
echo "La base de datos est√° ahora completamente vac√≠a."
echo "Necesitar√°s crear nuevos datos de prueba."
echo ""
echo "Comandos √∫tiles:"
echo "‚Ä¢ pm2 logs     - Ver logs"
echo "‚Ä¢ pm2 status   - Ver estado"
echo "‚Ä¢ pm2 monit    - Monitor en tiempo real"

================
File: scripts/update-app-with-reset.sh
================
#!/bin/bash

# Script para actualizar la aplicaci√≥n con opci√≥n de reset completo de base de datos
# Autor: Bot Backend Update Script with Reset Option
# Uso: ./update-app-with-reset.sh [--reset-db]

set -e

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m'

print_step() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

print_info() {
    echo -e "${MAGENTA}‚Ñπ${NC} $1"
}

# Banner
echo ""
echo "================================================"
echo -e "${BLUE}Bot Backend - Script de Actualizaci√≥n Completa${NC}"
echo "================================================"
echo ""

# Verificar par√°metros
RESET_DB=false
if [[ "$1" == "--reset-db" ]]; then
    RESET_DB=true
fi

# Verificar que NO se ejecuta como root
if [[ $EUID -eq 0 ]]; then
   print_error "Este script NO debe ejecutarse como root"
   exit 1
fi

# Verificar que estamos en el directorio correcto
if [ ! -d "$HOME/bot_backend" ]; then
    print_error "No se encontr√≥ el directorio ~/bot_backend"
    exit 1
fi

cd ~/bot_backend

# Mostrar estado actual
print_step "Verificando estado actual..."
CURRENT_COMMIT=$(git rev-parse HEAD)
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
print_info "Rama actual: $CURRENT_BRANCH"
print_info "Commit actual: ${CURRENT_COMMIT:0:7}"

# Guardar cambios locales si existen
print_step "Verificando cambios locales..."
if [[ -n $(git status --porcelain) ]]; then
    print_warning "Hay cambios locales no guardados"
    read -p "¬øDeseas guardarlos temporalmente? (s/n): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Ss]$ ]]; then
        STASH_NAME="update-$(date +%Y%m%d_%H%M%S)"
        git stash save "$STASH_NAME"
        print_success "Cambios guardados como: $STASH_NAME"
    fi
fi

# Obtener √∫ltima versi√≥n
print_step "Obteniendo √∫ltima versi√≥n del repositorio..."
git fetch origin
REMOTE_COMMIT=$(git rev-parse origin/$CURRENT_BRANCH)

# Verificar si hay actualizaciones
if [ "$CURRENT_COMMIT" == "$REMOTE_COMMIT" ]; then
    print_warning "Ya est√°s en la √∫ltima versi√≥n"
    if [ "$RESET_DB" != true ]; then
        print_info "Usa --reset-db si deseas resetear la base de datos de todas formas"
        exit 0
    fi
    print_info "Continuando con el reset de base de datos..."
else
    # Mostrar cambios pendientes
    print_step "Cambios pendientes:"
    git log HEAD..origin/$CURRENT_BRANCH --oneline
fi

# Men√∫ de opciones
echo ""
echo "================================================"
echo -e "${YELLOW}Opciones de Actualizaci√≥n${NC}"
echo "================================================"
echo ""

if [ "$RESET_DB" == true ]; then
    echo -e "${RED}‚ö†Ô∏è  MODO RESET: Se eliminar√° TODA la base de datos ‚ö†Ô∏è${NC}"
    echo ""
    echo "Este modo realizar√°:"
    echo "1. Actualizaci√≥n completa del c√≥digo"
    echo "2. ELIMINACI√ìN completa de la base de datos"
    echo "3. Recreaci√≥n desde cero con nuevas migraciones"
    echo "4. Reinicio completo de servicios"
    echo ""
    echo -e "${RED}TODOS LOS DATOS SER√ÅN ELIMINADOS${NC}"
    echo ""
    read -p "¬øEst√°s ABSOLUTAMENTE SEGURO? Escribe 'SI RESET': " -r
    echo
    if [[ ! $REPLY == "SI RESET" ]]; then
        print_error "Operaci√≥n cancelada"
        exit 1
    fi
else
    echo "Actualizaci√≥n est√°ndar:"
    echo "1. Actualizaci√≥n del c√≥digo"
    echo "2. Instalaci√≥n de dependencias"
    echo "3. Aplicaci√≥n de migraciones (si existen)"
    echo "4. Compilaci√≥n y reinicio de servicios"
    echo ""
    echo -e "${YELLOW}Nota:${NC} Usa --reset-db para reset completo de BD"
    echo ""
    read -p "¬øContinuar con la actualizaci√≥n? (s/n): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Ss]$ ]]; then
        print_warning "Actualizaci√≥n cancelada"
        exit 0
    fi
fi

# Actualizar c√≥digo
print_step "Actualizando c√≥digo..."
git pull origin $CURRENT_BRANCH
NEW_COMMIT=$(git rev-parse HEAD)
print_success "C√≥digo actualizado a ${NEW_COMMIT:0:7}"

# Si es modo reset, ejecutar script de reset
if [ "$RESET_DB" == true ]; then
    print_step "Ejecutando reset completo de base de datos..."
    
    # Verificar que existe el script de reset
    if [ ! -f "./scripts/reset-database-production.sh" ]; then
        print_error "No se encontr√≥ el script de reset de base de datos"
        exit 1
    fi
    
    # Hacer ejecutable y ejecutar
    chmod +x ./scripts/reset-database-production.sh
    ./scripts/reset-database-production.sh
    
    print_success "Reset de base de datos completado"
    
else
    # Actualizaci√≥n est√°ndar
    cd backend
    
    # Instalar dependencias
    print_step "Instalando dependencias..."
    npm install --production
    print_success "Dependencias instaladas"
    
    # Generar cliente Prisma
    print_step "Generando cliente Prisma..."
    npm run generate
    print_success "Cliente Prisma generado"
    
    # Verificar migraciones pendientes
    print_step "Verificando migraciones pendientes..."
    if npm run migrate:pending 2>/dev/null | grep -q "pending"; then
        print_warning "Hay migraciones pendientes"
        echo ""
        echo "Las siguientes migraciones ser√°n aplicadas:"
        npx prisma migrate status | grep "Database schema is not up to date" -A 10 || true
        echo ""
        read -p "¬øAplicar migraciones ahora? (s/n): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Ss]$ ]]; then
            npm run migrate
            print_success "Migraciones aplicadas"
        else
            print_warning "Migraciones omitidas - apl√≠calas manualmente con: npm run migrate"
        fi
    else
        print_success "No hay migraciones pendientes"
    fi
    
    # Limpiar y compilar proyecto
    print_step "Limpiando c√≥digo compilado anterior..."
    rm -rf dist/
    print_success "C√≥digo compilado eliminado"
    
    print_step "Compilando proyecto..."
    npm run build
    print_success "Proyecto compilado"
    
    # Actualizar frontend si existe
    if [ -d "../frontend-app" ]; then
        print_step "Actualizando frontend..."
        cd ../frontend-app
        npm install
        npm run build || print_warning "Build del frontend tuvo advertencias"
        
        # Asegurar permisos correctos
        chmod -R 755 dist/
        chmod 755 ~/bot_backend
        chmod 755 ~/bot_backend/frontend-app
        print_success "Frontend actualizado"
        
        cd ../backend
    fi
    
    # Reload PM2 con zero-downtime
    print_step "Recargando aplicaci√≥n con PM2..."
    pm2 reload ecosystem.config.js
    print_success "Aplicaci√≥n recargada"
fi

# Verificar estado final
print_step "Verificando estado de la aplicaci√≥n..."
sleep 3
pm2 status

# Health check
print_step "Verificando salud de la aplicaci√≥n..."
if curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/backend | grep -q "200"; then
    print_success "API respondiendo correctamente"
else
    print_error "API no responde - verifica los logs con: pm2 logs"
fi

# Resumen final
echo ""
echo "================================================"
if [ "$RESET_DB" == true ]; then
    echo -e "${GREEN}¬°Actualizaci√≥n con Reset Completada!${NC}"
else
    echo -e "${GREEN}¬°Actualizaci√≥n Completada!${NC}"
fi
echo "================================================"
echo ""
echo "Versi√≥n actual:"
git log -1 --pretty=format:"%h - %s (%cr) <%an>" --abbrev-commit
echo ""
echo ""

if [ "$RESET_DB" == true ]; then
    echo -e "${YELLOW}Importante:${NC}"
    echo "‚Ä¢ La base de datos fue completamente reseteada"
    echo "‚Ä¢ Todos los datos anteriores fueron eliminados"
    echo "‚Ä¢ Necesitar√°s crear nuevos datos de prueba"
    echo ""
fi

echo "Comandos √∫tiles:"
echo "‚Ä¢ pm2 logs       - Ver logs en tiempo real"
echo "‚Ä¢ pm2 monit      - Monitor de procesos"
echo "‚Ä¢ pm2 status     - Estado de procesos"
echo "‚Ä¢ pm2 logs --err - Ver solo errores"
echo ""

# Si hay stash guardado, recordar al usuario
if git stash list | grep -q "$STASH_NAME"; then
    print_warning "Recuerda: tienes cambios locales guardados como '$STASH_NAME'"
    echo "Usa 'git stash list' para ver todos los stashes"
    echo "Usa 'git stash pop' para recuperar los cambios"
fi

================
File: scripts/update-app.sh
================
#!/bin/bash

# Script para actualizar la aplicaci√≥n en producci√≥n
# Autor: Bot Backend Update Script
# Uso: ./update-app.sh

set -e

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_step() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

# Verificar que NO se ejecuta como root
if [[ $EUID -eq 0 ]]; then
   print_error "Este script NO debe ejecutarse como root"
   exit 1
fi

# Verificar que estamos en el directorio correcto
if [ ! -d "$HOME/bot_backend" ]; then
    print_error "No se encontr√≥ el directorio ~/bot_backend"
    exit 1
fi

cd ~/bot_backend

print_step "Iniciando actualizaci√≥n de Bot Backend..."

# Guardar cambios locales si existen
print_step "Verificando cambios locales..."
if [[ -n $(git status --porcelain) ]]; then
    print_warning "Hay cambios locales no guardados"
    read -p "¬øDeseas guardarlos temporalmente? (s/n): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Ss]$ ]]; then
        git stash save "Actualizaci√≥n autom√°tica $(date +%Y%m%d_%H%M%S)"
        print_success "Cambios guardados temporalmente"
    fi
fi

# Obtener √∫ltima versi√≥n
print_step "Obteniendo √∫ltima versi√≥n del repositorio..."
git fetch origin
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
print_success "Rama actual: $CURRENT_BRANCH"

# Mostrar cambios pendientes
print_step "Cambios pendientes:"
git log HEAD..origin/$CURRENT_BRANCH --oneline

# Confirmar actualizaci√≥n
echo ""
read -p "¬øDeseas continuar con la actualizaci√≥n? (s/n): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Ss]$ ]]; then
    print_warning "Actualizaci√≥n cancelada"
    exit 0
fi

# Actualizar c√≥digo
print_step "Actualizando c√≥digo..."
git pull origin $CURRENT_BRANCH
print_success "C√≥digo actualizado"

# Cambiar al directorio backend
cd backend

# Instalar dependencias
print_step "Instalando dependencias..."
npm install --production
print_success "Dependencias instaladas"

# Generar cliente Prisma
print_step "Generando cliente Prisma..."
npm run generate
print_success "Cliente Prisma generado"

# Verificar si hay migraciones pendientes
print_step "Verificando migraciones pendientes..."
if npm run migrate:pending 2>/dev/null | grep -q "pending"; then
    print_warning "Hay migraciones pendientes"
    read -p "¬øDeseas aplicar las migraciones ahora? (s/n): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Ss]$ ]]; then
        npm run migrate
        print_success "Migraciones aplicadas"
    else
        print_warning "Migraciones omitidas - apl√≠calas manualmente con: npm run migrate"
    fi
else
    print_success "No hay migraciones pendientes"
fi

# Compilar proyecto
print_step "Compilando proyecto..."
npm run build
print_success "Proyecto compilado"

# Actualizar frontend si existe
if [ -d "../frontend-app" ]; then
    print_step "Actualizando frontend..."
    cd ../frontend-app
    npm install
    npm run build || print_warning "Build del frontend tuvo advertencias"
    
    # Asegurar permisos correctos
    chmod -R 755 dist/
    chmod 755 ~/bot_backend
    chmod 755 ~/bot_backend/frontend-app
    print_success "Frontend actualizado"
    
    cd ../backend
fi

# Reload PM2 con zero-downtime
print_step "Recargando aplicaci√≥n con PM2..."
pm2 reload ecosystem.config.js
print_success "Aplicaci√≥n recargada"

# Verificar estado
print_step "Verificando estado de la aplicaci√≥n..."
sleep 3
pm2 status

# Verificar logs por errores
print_step "Verificando logs..."
echo "√öltimas l√≠neas de logs:"
pm2 logs --nostream --lines 10

# Health check
print_step "Verificando salud de la aplicaci√≥n..."
if curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/health | grep -q "200"; then
    print_success "API respondiendo correctamente"
else
    print_error "API no responde - verifica los logs con: pm2 logs"
fi

# Resumen
echo ""
echo "======================================"
echo -e "${GREEN}¬°Actualizaci√≥n completada!${NC}"
echo "======================================"
echo ""
echo "Versi√≥n actual:"
git log -1 --pretty=format:"%h - %s (%cr) <%an>" --abbrev-commit
echo ""
echo ""
echo "Comandos √∫tiles:"
echo "‚Ä¢ pm2 logs     - Ver logs en tiempo real"
echo "‚Ä¢ pm2 monit    - Monitor de procesos"
echo "‚Ä¢ pm2 status   - Estado de procesos"
echo ""

# Si hay stash guardado, recordar al usuario
if git stash list | grep -q "Actualizaci√≥n autom√°tica"; then
    print_warning "Recuerda: tienes cambios locales guardados. Usa 'git stash pop' para recuperarlos."
fi

================
File: backend/src/api/audio/audioOrder.routes.ts
================
import { Router } from 'express';
import multer from 'multer';
import { AudioOrderController } from './audioOrder.controller';
import { AudioHealthController } from './audioHealth.controller';
import { apiKeyAuthMiddleware } from '../../common/middlewares/apiKeyAuth.middleware';
import { validationMiddleware } from '../../common/middlewares/validation.middleware';
import { asyncHandler } from '../../common/middlewares/errorHandler';
import { ProcessAudioOrderDto } from '../../dto/order';

const router = Router();

const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 1
  },
  fileFilter: (req, file, cb) => {
    const allowedMimeTypes = [
      'audio/mp4',
      'audio/mpeg',
      'audio/ogg',
      'audio/wav',
      'audio/webm'
    ];
    
    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Tipo de archivo no soportado. Use MP4, MP3, OGG, WAV o WEBM.'));
    }
  }
});

// Health check endpoint
router.get(
  '/health',
  apiKeyAuthMiddleware,
  asyncHandler(AudioHealthController.checkHealth)
);

// Process audio order endpoint
router.post(
  '/process-order',
  apiKeyAuthMiddleware,
  upload.single('audio'),
  validationMiddleware(ProcessAudioOrderDto),
  asyncHandler(AudioOrderController.processAudioOrder)
);

export default router;

================
File: backend/src/common/types/preorder.types.ts
================
/**
 * Types for the PreOrder workflow system
 */

export interface ProcessedOrderData {
  orderItems: Array<{
    productId: string;
    productVariantId?: string | null;
    quantity: number;
    selectedModifiers?: string[];
    selectedPizzaCustomizations?: Array<{
      pizzaCustomizationId: string;
      half: 'FULL' | 'HALF_1' | 'HALF_2';
      action: 'ADD' | 'REMOVE';
    }>;
  }>;
  orderType: 'DELIVERY' | 'TAKE_AWAY';
  scheduledAt?: Date | null;
  deliveryInfo?: {
    name?: string | null;
    street?: string;
    number?: string;
    interiorNumber?: string | null;
    neighborhood?: string | null;
    city?: string | null;
    state?: string | null;
    zipCode?: string | null;
    country?: string | null;
    deliveryInstructions?: string | null;
    latitude?: number | null;
    longitude?: number | null;
  };
}

export interface PreOrderWorkflowResult {
  preOrderId: number;
  actionToken: string;
  expiresAt: Date;
}

export interface PreOrderActionParams {
  action: 'confirm' | 'discard';
  token: string;
  whatsappNumber: string;
}

export interface PreOrderSummary {
  items: Array<{
    productName: string;
    variantName?: string;
    quantity: number;
    unitPrice: number;
    totalPrice: number;
    modifiers?: string[];
  }>;
  subtotal: number;
  orderType: string;
  scheduledAt?: Date;
}

export interface PreOrderNotification {
  summary: string;
  actionToken: string;
  expiresInMinutes: number;
}

export interface TokenValidationResult {
  isValid: boolean;
  preOrderId?: number;
  error?: string;
}

================
File: backend/src/common/utils/messageSplitter.ts
================
/**
 * Utilidad unificada para dividir mensajes largos de WhatsApp
 * Consolida la l√≥gica duplicada de divisi√≥n de mensajes
 */

interface SplitOptions {
  maxLength?: number;
  preserveFormatting?: boolean;
}

const DEFAULT_MAX_LENGTH = 4000; // L√≠mite de WhatsApp con margen de seguridad

export class MessageSplitter {
  /**
   * Dividir un mensaje largo en partes respetando el l√≠mite de caracteres
   */
  static split(text: string, options: SplitOptions = {}): string[] {
    const {
      maxLength = DEFAULT_MAX_LENGTH,
      preserveFormatting = true
    } = options;
    
    // Si el mensaje cabe en una parte, devolverlo tal cual
    if (text.length <= maxLength) {
      return [text];
    }
    
    // Divisi√≥n simple por longitud
    const parts = this.simpleSplit(text, maxLength);
    
    // Agregar indicadores de continuaci√≥n si se preserva el formato
    if (preserveFormatting && parts.length > 1) {
      return this.addContinuationIndicators(parts);
    }
    
    return parts;
  }
  
  
  /**
   * Divisi√≥n simple por longitud respetando saltos de l√≠nea
   */
  private static simpleSplit(text: string, maxLength: number): string[] {
    const parts: string[] = [];
    let currentPart = '';
    
    // Dividir por l√≠neas para mantener la estructura
    const lines = text.split('\n');
    
    for (const line of lines) {
      // Si agregar esta l√≠nea excede el l√≠mite
      if (currentPart.length + line.length + 1 > maxLength) {
        // Si la parte actual tiene contenido, guardarla
        if (currentPart.trim()) {
          parts.push(currentPart.trim());
          currentPart = '';
        }
        
        // Si la l√≠nea sola excede el l√≠mite, dividirla por palabras
        if (line.length > maxLength) {
          const words = line.split(/\s+/);
          let tempLine = '';
          
          for (const word of words) {
            if (tempLine.length + word.length + 1 > maxLength) {
              if (tempLine) {
                parts.push(tempLine.trim());
                tempLine = word;
              } else {
                // Palabra muy larga, a√±adirla tal cual
                parts.push(word);
              }
            } else {
              tempLine += (tempLine ? ' ' : '') + word;
            }
          }
          
          if (tempLine) {
            currentPart = tempLine;
          }
        } else {
          currentPart = line;
        }
      } else {
        // Agregar la l√≠nea a la parte actual
        currentPart += (currentPart ? '\n' : '') + line;
      }
    }
    
    // Agregar cualquier contenido restante
    if (currentPart.trim()) {
      parts.push(currentPart.trim());
    }
    
    return parts;
  }
  
  
  /**
   * Agregar indicadores de continuaci√≥n a las partes
   */
  private static addContinuationIndicators(parts: string[]): string[] {
    return parts.map((part, index) => {
      if (index === 0) {
        return part + '\n\n_(Contin√∫a...)_';
      } else if (index === parts.length - 1) {
        return `_(Continuaci√≥n ${index + 1}/${parts.length})_\n\n` + part;
      } else {
        return `_(Continuaci√≥n ${index + 1}/${parts.length})_\n\n` + 
               part + '\n\n_(Contin√∫a...)_';
      }
    });
  }
  
  /**
   * Dividir un men√∫ sin indicadores de continuaci√≥n
   */
  static splitMenu(menuText: string, maxLength: number = DEFAULT_MAX_LENGTH): string[] {
    return this.split(menuText, {
      maxLength,
      preserveFormatting: false // No agregar indicadores de continuaci√≥n
    });
  }
  
  /**
   * Dividir un mensaje de chat normal con indicadores
   */
  static splitMessage(message: string, maxLength: number = DEFAULT_MAX_LENGTH): string[] {
    return this.split(message, {
      maxLength,
      preserveFormatting: true
    });
  }
}

================
File: backend/src/services/ai/AgentService.ts
================
import { GeminiService } from './GeminiService';
import logger from '../../common/utils/logger';
import { ProductService } from '../products/ProductService';
import { getGeneralAgentPrompt, getOrderAgentPrompt } from './prompts';
import { getGeneralAgentTools, getOrderAgentTools } from './tools';
import { MenuSearchService } from './MenuSearchService';

// Definiciones de tipos para el nuevo SDK
interface Content {
  role: 'user' | 'model';
  parts: Array<{ text: string } | { inlineData: { mimeType: string; data: string } }>;
}

// Contexto para el agente de √≥rdenes
interface OrderContext {
  itemsSummary: string;
  relevantMenu: string;
  orderType?: string;
}

/**
 * Servicio de AI con agentes especializados
 */
export class AgentService {
  /**
   * Procesa mensajes con el agente general
   */
  static async processMessage(
    messages: Content[]
  ): Promise<any> {
    try {
      // Usar el agente general para detectar intenci√≥n
      const systemInstruction = await this.getGeneralAgentInstruction();
      const tools = getGeneralAgentTools();
      
      // Log completo de lo que recibe el modelo
      logger.debug('=== COMPLETE AI MODEL INPUT ===');
      logger.debug(`System Instruction:\n${systemInstruction}`);
      (logger as any).json('Messages:', messages);
      (logger as any).json('Tools:', tools.map(t => ({
        name: t.name,
        description: t.description,
        parameters: t.parameters
      })));
      logger.debug('=== END AI MODEL INPUT ===');
      
      const response = await GeminiService.generateContentWithHistory(
        messages,
        systemInstruction,
        tools
      );
      return response;
    } catch (error) {
      logger.error('AgentService: Error procesando mensaje', error);
      throw error;
    }
  }
  
  /**
   * Procesa una orden con el agente especializado
   */
  static async processOrderMapping(
    orderContext: OrderContext
  ): Promise<any> {
    try {
      
      // Crear mensaje para el agente de √≥rdenes
      const messages: Content[] = [{
        role: 'user',
        parts: [{ 
          text: `ORDEN: ${orderContext.itemsSummary}\nTIPO: ${orderContext.orderType || 'DELIVERY'}` 
        }]
      }];
      
      const systemInstruction = this.getOrderAgentInstruction(orderContext.relevantMenu);
      const tools = getOrderAgentTools();
      
      // Configurar modo ANY para forzar la ejecuci√≥n de funci√≥n
      const toolConfig = {
        functionCallingConfig: {
          mode: 'ANY',
          allowedFunctionNames: ['map_order_items']
        }
      };
      
      // Log completo de lo que recibe el modelo de √≥rdenes
      logger.debug('=== COMPLETE ORDER AGENT INPUT ===');
      logger.debug('System Instruction includes menu:');
      logger.debug(`Order: ${orderContext.itemsSummary}`);
      logger.debug(`Type: ${orderContext.orderType || 'DELIVERY'}`);
      try {
        const menuParsed = JSON.parse(orderContext.relevantMenu);
        (logger as any).json('Relevant Menu:', menuParsed);
      } catch (e) {
        logger.debug(`Relevant Menu: ${orderContext.relevantMenu}`);
      }
      logger.debug('=== END ORDER AGENT INPUT ===');
      
      logger.info('Calling Gemini API for order processing...');
      
      const response = await GeminiService.generateContentWithHistory(
        messages,
        systemInstruction,
        tools,
        toolConfig
      );
      
      return response;
    } catch (error) {
      logger.error('OrderAgent: Error procesando orden', error);
      throw error;
    }
  }
  
  /**
   * Instrucciones para el agente general
   */
  private static async getGeneralAgentInstruction(): Promise<string> {
    let menuJson = '{}';
    let restaurantName = 'nuestro restaurante';
    
    try {
      // Obtener estructura del men√∫
      const menuStructure = await ProductService.getMenuStructureForAI();
      menuJson = JSON.stringify(menuStructure, null, 2);
    } catch (error) {
      logger.error('Error obteniendo estructura del men√∫ para AI:', error);
    }
    
    try {
      // Obtener configuraci√≥n del restaurante
      const { RestaurantService } = await import('../restaurant/RestaurantService');
      const restaurantConfig = await RestaurantService.getConfig();
      restaurantName = restaurantConfig.restaurantName;
    } catch (error) {
      logger.error('Error obteniendo configuraci√≥n del restaurante:', error);
    }
    
    return getGeneralAgentPrompt(menuJson, restaurantName);
  }
  
  /**
   * Instrucciones para el agente de √≥rdenes
   */
  private static getOrderAgentInstruction(relevantMenu: string): string {
    return getOrderAgentPrompt(relevantMenu);
  }
  
  /**
   * Obtiene el men√∫ relevante basado en las palabras clave (con IDs)
   * Delega a MenuSearchService para la l√≥gica de b√∫squeda
   */
  static async getRelevantMenu(itemsSummary: string): Promise<string> {
    return MenuSearchService.getRelevantMenu(itemsSummary);
  }
}

================
File: backend/src/services/ai/GeminiService.ts
================
import { GoogleGenAI } from '@google/genai';
import { env } from '../../common/config/envValidator';
import logger from '../../common/utils/logger';
import { ValidationError, ErrorCode } from '../../common/services/errors';

/**
 * Servicio centralizado para todas las interacciones con Gemini AI
 * Maneja la configuraci√≥n, el cliente y las operaciones comunes
 */
export class GeminiService {
  private static instance: GoogleGenAI | null = null;

  /**
   * Obtiene la instancia singleton del cliente de Gemini
   */
  static getClient(): GoogleGenAI {
    if (!this.instance) {
      this.instance = new GoogleGenAI({ apiKey: env.GOOGLE_AI_API_KEY });
      logger.info('GeminiService: Cliente inicializado');
      logger.info(`GeminiService: Using model ${env.GEMINI_MODEL}`);
    }
    return this.instance;
  }

  /**
   * Genera contenido con historial de conversaci√≥n
   */
  static async generateContentWithHistory(
    messages: any[],
    systemInstruction?: string,
    tools?: any[],
    toolConfig?: any
  ): Promise<any> {
    try {
      const client = this.getClient();
      
      // Construir la configuraci√≥n
      const config: any = {
        systemInstruction,
        tools: tools ? [{ functionDeclarations: tools }] : undefined,
      };
      
      // Agregar toolConfig si se proporciona
      if (toolConfig) {
        config.toolConfig = toolConfig;
      }
      
      const response = await client.models.generateContent({
        model: env.GEMINI_MODEL,
        contents: messages,
        config,
      });
      
      // El problema es que response no es serializable directamente con JSON.stringify
      // Vamos a extraer solo las partes importantes para el debug
      // Intentar m√∫ltiples formas de loggear la respuesta
      logger.debug('Response object exists:', !!response);
      logger.debug('Response type:', typeof response);
      
      // M√©todo 1: Intentar con util.inspect
      try {
        const util = require('util');
        logger.debug('Raw Gemini response (inspect):', util.inspect(response, { depth: 4, colors: false }));
      } catch (e1) {
        logger.debug('Could not use util.inspect');
      }
      
      // M√©todo 2: Intentar acceder directamente a las propiedades
      try {
        if (response?.candidates?.[0]) {
          const candidate = response.candidates[0];
          logger.debug('Candidate content:', {
            role: candidate.content?.role,
            partsCount: candidate.content?.parts?.length,
            firstPart: candidate.content?.parts?.[0]
          });
        }
      } catch (e2) {
        logger.debug('Could not access candidate properties');
      }
      
      // M√©todo 3: Intentar JSON.stringify con reemplazador
      try {
        const seen = new WeakSet();
        const debugResponse = JSON.stringify(response, (key, value) => {
          if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
              return '[Circular]';
            }
            seen.add(value);
          }
          return value;
        }, 2);
        logger.debug('Raw Gemini response (JSON):', debugResponse);
      } catch (e3) {
        logger.debug('Could not JSON.stringify response');
      }
      
      return response;
    } catch (error) {
      logger.error('GeminiService: Error generando contenido con historial', error);
      throw error;
    }
  }

  /**
   * Transcribe audio a texto
   */
  static async transcribeAudio(
    audioData: string,
    mimeType: string
  ): Promise<string> {
    try {
      logger.debug('=== GeminiService.transcribeAudio DEBUG ===');
      logger.debug(`MimeType: ${mimeType}`);
      logger.debug(`Audio data length: ${audioData.length}`);
      
      const client = this.getClient();
      
      const prompt = `Transcribe el siguiente audio a texto. 
      Si el audio no es claro o no se puede entender, responde con "ERROR_TRANSCRIPTION".
      Si el audio est√° en otro idioma que no sea espa√±ol, trad√∫celo al espa√±ol.
      Solo devuelve el texto transcrito, sin explicaciones adicionales.`;

      const contents = [
        {
          role: "user",
          parts: [
            { text: prompt },
            {
              inlineData: {
                mimeType,
                data: audioData,
              },
            },
          ],
        },
      ];
      
      logger.debug('Contents structure:', JSON.stringify({
        role: contents[0].role,
        parts: contents[0].parts.map(p => p.text ? 'text' : 'inlineData')
      }, null, 2));

      const response = await client.models.generateContent({
        model: env.GEMINI_MODEL,
        contents,
      });

      const transcription = response.text?.trim() || '';
      logger.debug(`Transcription result: ${transcription}`);
      logger.debug('=== End DEBUG ===');
      
      if (!transcription || transcription === 'ERROR_TRANSCRIPTION' || transcription.length < 2) {
        throw new ValidationError(
          ErrorCode.TRANSCRIPTION_ERROR,
          'No se pudo transcribir el audio',
          { metadata: { transcriptionResult: transcription } }
        );
      }

      return transcription;
    } catch (error) {
      logger.error('GeminiService: Error transcribiendo audio', error);
      throw error;
    }
  }

}

================
File: backend/src/services/ai/tools/handlers/generateAddressUpdateLinkHandler.ts
================
import { ToolHandler } from '../types';
import { MessageContext } from '../../../messaging/MessageContext';
import { OTPService } from '../../../security/OTPService';
import { env } from '../../../../common/config/envValidator';
import { TechnicalError, ErrorCode } from '../../../../common/services/errors';
import { UnifiedResponse, ResponseBuilder, ResponseType } from '../../../messaging/types/responses';
import logger from '../../../../common/utils/logger';

/**
 * Handles the generate_address_update_link function call
 * Generates a secure OTP link for address updates
 */
export const handleGenerateAddressUpdateLink: ToolHandler = async (args, context?: MessageContext): Promise<UnifiedResponse> => {
  logger.debug('Generating address update link:', args);
  
  // Get customerId from context
  const customerId = context?.message?.from;
  if (!customerId) {
    throw new TechnicalError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Could not get customer ID from message context'
    );
  }
  
  // Generate OTP
  const otp = OTPService.generateOTP();
  await OTPService.storeOTP(customerId, otp, true); // true = address registration
  
  // Create registration link
  const registrationLink = `${env.FRONTEND_BASE_URL}/address-registration/${customerId}?otp=${otp}`;
  
  // Create response with URL button using the new dedicated method
  return ResponseBuilder.urlButton(
    "üìç Actualizar Direcci√≥n",
    "Te he generado un enlace seguro para que puedas actualizar o agregar una nueva direcci√≥n de entrega.\n\n" +
    "Este enlace es temporal y expirar√° en 10 minutos por seguridad.",
    "Actualizar Direcci√≥n",
    registrationLink
  );
};

================
File: backend/src/services/ai/tools/handlers/getBusinessHoursHandler.ts
================
import { ToolHandler } from '../types';
import { RESTAURANT_INFO_MESSAGE } from '../../../../common/config/predefinedMessages';
import { ConfigService } from '../../../config/ConfigService';
import { getFormattedBusinessHours } from '../../../../common/utils/timeUtils';
import { UnifiedResponse, ResponseBuilder, ResponseType } from '../../../messaging/types/responses';
import logger from '../../../../common/utils/logger';

/**
 * Handles the get_business_hours function call
 * Returns restaurant information and business hours
 */
export const handleGetBusinessHours: ToolHandler = async (): Promise<UnifiedResponse> => {
  const config = ConfigService.getConfig();
  const formattedHours = await getFormattedBusinessHours();
  const infoMessage = RESTAURANT_INFO_MESSAGE(config, formattedHours);
  
  // Create and return UnifiedResponse directly
  const unifiedResponse = ResponseBuilder.text(infoMessage, true);
  unifiedResponse.metadata.type = ResponseType.RESTAURANT_INFO;
  
  return unifiedResponse;
};

================
File: backend/src/services/ai/tools/handlers/getWaitTimesHandler.ts
================
import { ToolHandler } from '../types';
import { WAIT_TIMES_MESSAGE } from '../../../../common/config/predefinedMessages';
import { RestaurantService } from '../../../restaurant/RestaurantService';
import { UnifiedResponse, ResponseBuilder, ResponseType } from '../../../messaging/types/responses';
import logger from '../../../../common/utils/logger';

/**
 * Handles the get_wait_times function call
 * Returns estimated wait times for pickup and delivery
 */
export const handleGetWaitTimes: ToolHandler = async (): Promise<UnifiedResponse> => {
  logger.debug('Getting wait times');
  
  const config = await RestaurantService.getConfig();
  
  const waitTimesMessage = WAIT_TIMES_MESSAGE(
    config.estimatedPickupTime,
    config.estimatedDeliveryTime
  );
  
  // Create and return UnifiedResponse directly
  const unifiedResponse = ResponseBuilder.text(waitTimesMessage, true);
  unifiedResponse.metadata.type = ResponseType.WAIT_TIME_INFO;
  
  return unifiedResponse;
};

================
File: backend/src/services/ai/tools/handlers/prepareOrderContextHandler.ts
================
import { ToolHandler } from '../types';
import { MessageContext } from '../../../messaging/MessageContext';
import { MenuSearchService } from '../../MenuSearchService';
import { AgentService } from '../../AgentService';
import { UnifiedResponse, ResponseBuilder, ResponseType } from '../../../messaging/types/responses';
import logger from '../../../../common/utils/logger';

/**
 * Handles the prepare_order_context function call
 * Prepares context for the order agent with relevant menu items
 */
export const handlePrepareOrderContext: ToolHandler = async (args, context?: MessageContext): Promise<UnifiedResponse | UnifiedResponse[]> => {
  // Get relevant menu based on mentioned items
  const relevantMenu = await MenuSearchService.getRelevantMenu(args.itemsSummary);
  
  // If no relevant products found
  if (relevantMenu === "[]" || JSON.parse(relevantMenu).length === 0) {
    logger.warn('No relevant products found for order context');
    
    const response = ResponseBuilder.text(
      `üòî No pude encontrar productos que coincidan con "${args.itemsSummary}". Por favor, intenta con otro nombre o revisa nuestro men√∫.`,
      true
    );
    response.metadata.type = ResponseType.ERROR;
    return response;
  }
  
  // Create context for order agent
  const orderContext = {
    itemsSummary: args.itemsSummary,
    relevantMenu: relevantMenu,
    orderType: args.orderType
  };
  
  // Process with order agent
  logger.debug('Calling processOrderMapping with context:', orderContext);
  const orderResponse = await AgentService.processOrderMapping(orderContext);
  logger.debug('Order agent response:', JSON.stringify(orderResponse, null, 2));
  
  // Import TextProcessingService to avoid circular dependency
  const { TextProcessingService } = await import('../../../messaging/TextProcessingService');
  
  // Process the order agent response
  const orderResults = await (TextProcessingService as any).processGeminiResponse(orderResponse, context);
  logger.debug('Processed order results:', orderResults);
  
  // The order agent should always execute map_order_items
  // So we return all results (which are now UnifiedResponse[])
  return orderResults;
};

================
File: backend/src/services/ai/tools/handlers/sendBotInstructionsHandler.ts
================
import { ToolHandler } from '../types';
import { CHATBOT_HELP_MESSAGE } from '../../../../common/config/predefinedMessages';
import { ConfigService } from '../../../config/ConfigService';
import { UnifiedResponse, ResponseBuilder, ResponseType } from '../../../messaging/types/responses';
import logger from '../../../../common/utils/logger';

/**
 * Handles the send_bot_instructions function call
 * Sends instructions on how to use the bot
 */
export const handleSendBotInstructions: ToolHandler = async (): Promise<UnifiedResponse> => {
  logger.debug('Sending bot instructions');
  
  const config = ConfigService.getConfig();
  const instructions = CHATBOT_HELP_MESSAGE(config);
  
  // Create and return unified response directly
  const response = ResponseBuilder.text(instructions, true);
  response.metadata.type = ResponseType.BOT_INSTRUCTIONS;
  
  return response;
};

================
File: backend/src/services/messaging/middlewares/CustomerValidationMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { prisma } from '../../../lib/prisma';
import { sendWhatsAppMessage } from '../../whatsapp';
import { BANNED_USER_MESSAGE } from '../../../common/config/predefinedMessages';
import { ConfigService } from '../../../services/config/ConfigService';
import { SyncMetadataService } from '../../../services/sync/SyncMetadataService';
import { CONTEXT_KEYS } from '../../../common/constants';
import logger from '../../../common/utils/logger';

export class CustomerValidationMiddleware implements MessageMiddleware {
  name = 'CustomerValidationMiddleware';

  private removeDuplicateMessages(messages: any[]): any[] {
    if (messages.length === 0) return messages;
    
    const cleaned: any[] = [messages[0]];
    
    for (let i = 1; i < messages.length; i++) {
      const current = messages[i];
      const previous = messages[i - 1];
      
      // Si el mensaje actual es diferente al anterior, lo agregamos
      if (current.role !== previous.role || current.content !== previous.content) {
        cleaned.push(current);
      }
    }
    
    return cleaned;
  }

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      const whatsappPhoneNumber = context.message.from;
      
      // Obtener o crear cliente con sus direcciones
      let customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber },
        include: { addresses: true }
      });

      if (!customer) {
        // Crear nuevo cliente
        customer = await prisma.customer.create({
          data: {
            whatsappPhoneNumber,
            lastInteraction: new Date(),
            fullChatHistory: [],
            relevantChatHistory: []
          },
          include: { addresses: true }
        });
        
        // Mark for sync
        await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
        
        // Marcar como cliente nuevo para mensaje de bienvenida
        context.set(CONTEXT_KEYS.IS_NEW_CUSTOMER, true);
        context.set(CONTEXT_KEYS.HAS_NO_ADDRESS, true);
      } else {
        // Verificar si el cliente est√° baneado
        if (customer.isBanned) {
          logger.warn(`Banned customer ${whatsappPhoneNumber} tried to send a message`);
          const config = ConfigService.getConfig();
          const bannedMessage = BANNED_USER_MESSAGE(config);
          await sendWhatsAppMessage(whatsappPhoneNumber, bannedMessage);
          context.stop();
          return context;
        }
        
        // Verificar si el cliente tiene direcciones activas
        const activeAddresses = customer.addresses.filter(addr => !addr.deletedAt);
        if (activeAddresses.length === 0) {
          context.set(CONTEXT_KEYS.HAS_NO_ADDRESS, true);
          logger.info(`Customer ${whatsappPhoneNumber} has no active addresses`);
        }
      }

      context.setCustomer(customer);
      
      // Cargar historial de chat
      const fullChatHistory = Array.isArray(customer.fullChatHistory)
        ? customer.fullChatHistory
        : JSON.parse((customer.fullChatHistory as string) || "[]");
      
      let relevantChatHistory = Array.isArray(customer.relevantChatHistory)
        ? customer.relevantChatHistory
        : JSON.parse((customer.relevantChatHistory as string) || "[]");
      
      // Limpiar duplicados consecutivos en el historial relevante
      relevantChatHistory = this.removeDuplicateMessages(relevantChatHistory);
      
      // Limitar el historial relevante a los √∫ltimos 20 mensajes
      if (relevantChatHistory.length > 20) {
        relevantChatHistory = relevantChatHistory.slice(-20);
        logger.debug(`Historial relevante limitado a los √∫ltimos 20 mensajes (de ${relevantChatHistory.length} total)`);
      }
      
      context.set(CONTEXT_KEYS.FULL_CHAT_HISTORY, fullChatHistory);
      context.set(CONTEXT_KEYS.RELEVANT_CHAT_HISTORY, relevantChatHistory);
      
      // Verificar si es una conversaci√≥n nueva (m√°s de 1 hora desde la √∫ltima interacci√≥n)
      const isNewConversation = customer.lastInteraction && 
        (new Date().getTime() - new Date(customer.lastInteraction).getTime() > 60 * 60 * 1000) ||
        relevantChatHistory.length === 0;
      
      if (isNewConversation && !context.get(CONTEXT_KEYS.IS_NEW_CUSTOMER)) {
        context.set(CONTEXT_KEYS.IS_NEW_CONVERSATION, true);
      }

      return context;
    } catch (error) {
      logger.error('Error in CustomerValidationMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/middlewares/MessageTypeMiddleware.ts
================
import { MessageMiddleware } from '../types';
import { MessageContext } from '../MessageContext';
import { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } from '../../whatsapp';
import { WELCOME_MESSAGE_INTERACTIVE, UNSUPPORTED_MESSAGE_TYPE } from '../../../common/config/predefinedMessages';
import { ConfigService } from '../../../services/config/ConfigService';
import { CONTEXT_KEYS, redisKeys } from '../../../common/constants';
import logger from '../../../common/utils/logger';

export class MessageTypeMiddleware implements MessageMiddleware {
  name = 'MessageTypeMiddleware';

  async process(context: MessageContext): Promise<MessageContext> {
    try {
      // Verificar si es un cliente nuevo o conversaci√≥n nueva que necesita mensaje de bienvenida
      const customer = context.customer;
      const isVeryNewCustomer = customer && customer.createdAt && 
        (new Date().getTime() - new Date(customer.createdAt).getTime() < 5 * 60 * 1000); // Created less than 5 minutes ago
      
      // Check if we're in the middle of updating a preOrder
      const { redisService } = await import('../../redis/RedisService');
      const updateKey = redisKeys.preorderUpdating(context.message.from);
      const isUpdatingPreOrder = await redisService.get(updateKey);
      
      // Only send welcome if it's a new conversation (not a brand new customer who just registered)
      // and we're not in the middle of updating a preOrder
      if (context.get(CONTEXT_KEYS.IS_NEW_CONVERSATION) && !isVeryNewCustomer && !isUpdatingPreOrder) {
        const config = ConfigService.getConfig();
        const welcomeMessage = WELCOME_MESSAGE_INTERACTIVE(config);
        await sendWhatsAppInteractiveMessage(context.message.from, welcomeMessage);
      }
      
      // Validar tipo de mensaje
      const supportedTypes = ['text', 'interactive', 'audio'];
      if (!supportedTypes.includes(context.message.type)) {
        await sendWhatsAppMessage(context.message.from, UNSUPPORTED_MESSAGE_TYPE);
        context.stop();
        return context;
      }
      
      // Establecer tipo de mensaje para procesamiento
      context.set(CONTEXT_KEYS.MESSAGE_TYPE, context.message.type);
      
      // Para mensajes de audio, necesitaremos manejar la transcripci√≥n
      if (context.message.type === 'audio') {
        context.set(CONTEXT_KEYS.NEEDS_TRANSCRIPTION, true);
      }
      
      return context;
    } catch (error) {
      logger.error('Error in MessageTypeMiddleware:', error);
      context.setError(error as Error);
      return context;
    }
  }
}

================
File: backend/src/services/messaging/types.ts
================
import { Customer } from '@prisma/client';
import { IncomingMessage } from '../../common/types/whatsapp-messages.types';
import { UnifiedResponse } from './types/responses';

export * from './types/responses';

// Re-exportar tipos de WhatsApp desde la ubicaci√≥n centralizada
export { IncomingMessage };

export interface MessageContext {
  message: IncomingMessage;
  customer?: Customer;
  chatHistory?: any[];
  metadata: Map<string, any>;
  shouldStop: boolean;
  error?: Error;
}

export interface MessageMiddleware {
  name: string;
  process(context: MessageContext): Promise<MessageContext>;
}

export interface MessageStrategy {
  execute(message: IncomingMessage, customer: Customer): Promise<UnifiedResponse[]>;
}

================
File: backend/src/services/sync/SyncNotificationService.ts
================
import { Server as SocketIOServer } from 'socket.io';
import logger from '../../common/utils/logger';
import { prisma } from '../../lib/prisma';
import { env } from '../../common/config/envValidator';

export class SyncNotificationService {
  private static io: SocketIOServer | null = null;
  private static connectedClients = new Map<string, string>(); // socketId -> apiKey

  /**
   * Initialize WebSocket server for real-time notifications
   */
  static initialize(io: SocketIOServer) {
    this.io = io;
    
    // Create sync namespace
    const syncNamespace = io.of('/sync');
    
    syncNamespace.use(async (socket, next) => {
      try {
        const apiKey = socket.handshake.auth.apiKey;
        
        if (!apiKey) {
          return next(new Error('API key required'));
        }
        
        // Validate API key
        if (!env.CLOUD_API_KEY || apiKey !== env.CLOUD_API_KEY) {
          return next(new Error('Invalid API key'));
        }
        
        // Store client connection
        this.connectedClients.set(socket.id, apiKey);
        next();
      } catch (error) {
        next(new Error('Authentication failed'));
      }
    });
    
    syncNamespace.on('connection', (socket) => {
      logger.info(`Local backend connected via WebSocket: ${socket.id}`);
      
      socket.on('disconnect', () => {
        logger.info(`Local backend disconnected: ${socket.id}`);
        this.connectedClients.delete(socket.id);
      });
      
      // Client can request immediate sync
      socket.on('sync:orders', async () => {
        // Get pending order IDs from sync metadata
        const pendingMeta = await prisma.syncMetadata.findMany({
          where: {
            entityType: 'Order',
            syncPending: true
          },
          select: { entityId: true }
        });
        
        const orderIds = pendingMeta.map(m => m.entityId);
        
        const pendingOrders = orderIds.length > 0 ? await prisma.order.findMany({
          where: {
            id: { in: orderIds },
            isFromWhatsApp: true
          }
        }) : [];
        
        socket.emit('orders:pending', {
          count: pendingOrders.length,
          orders: pendingOrders
        });
      });
    });
    
    logger.info('WebSocket sync notification service initialized');
  }
  
  /**
   * Notify all connected local backends about new order
   */
  static async notifyNewOrder(orderId: string) {
    if (!this.io) {
      logger.warn('WebSocket not initialized, cannot send notification');
      return;
    }
    
    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: {
        customer: true,
        orderItems: true,
        deliveryInfo: true
      }
    });
    
    if (!order) return;
    
    // Notify all connected clients
    this.io.of('/sync').emit('order:new', {
      orderId: order.id,
      orderType: order.orderType,
      customerName: `${order.customer.firstName || ''} ${order.customer.lastName || ''}`.trim(),
      total: order.total,
      createdAt: order.createdAt
    });
    
    logger.info(`Notified ${this.connectedClients.size} local backends about new order ${orderId}`);
  }
  
  /**
   * Check if any local backend is connected
   */
  static isAnyClientConnected(): boolean {
    return this.connectedClients.size > 0;
  }
  
  /**
   * Get connected clients info
   */
  static getConnectedClients() {
    return Array.from(this.connectedClients.entries()).map(([socketId, apiKey]) => ({
      socketId,
      apiKeyPrefix: apiKey.substring(0, 10) + '...'
    }));
  }
}

================
File: backend/src/services/whatsapp/WhatsAppService.ts
================
import { Request, Response } from 'express';
import axios from 'axios';
import { prisma } from '../../lib/prisma';
import logger from '../../common/utils/logger';
import { env } from '../../common/config/envValidator';
import { ExternalServiceError, ErrorCode } from '../../common/services/errors';
import { MessageSplitter } from '../../common/utils/messageSplitter';
import { messageQueue } from '../../queues/messageQueue';
import { WhatsAppMessageJob } from '../../queues/types';

export class WhatsAppService {
  private static readonly WHATSAPP_API_URL = 'https://graph.facebook.com/v17.0';
  private static readonly PHONE_NUMBER_ID = env.WHATSAPP_PHONE_NUMBER_MESSAGING_ID;
  private static readonly ACCESS_TOKEN = env.WHATSAPP_ACCESS_TOKEN;
  private static readonly VERIFY_TOKEN = env.WHATSAPP_VERIFY_TOKEN;
  private static readonly MAX_MESSAGE_LENGTH = 4000; // WhatsApp message length limit with margin

  static verifyWebhook(query: any): { verified: boolean; challenge?: string } {
    const mode = query['hub.mode'];
    const token = query['hub.verify_token'];
    const challenge = query['hub.challenge'];

    if (mode && token) {
      if (mode === 'subscribe' && token === this.VERIFY_TOKEN) {
        logger.info('Webhook verified');
        return { verified: true, challenge };
      }
    }
    
    return { verified: false };
  }

  static async handleWebhook(req: Request, res: Response): Promise<void> {
    const body = JSON.parse(req.body.toString());
    
    // Process messages asynchronously to respond quickly to WhatsApp
    if (body.entry && body.entry.length > 0) {
      // Don't await - process in background to respond immediately
      this.processWebhookMessages(body).catch(error => {
        logger.error('Error processing WhatsApp webhook messages:', error);
      });
    }
    
    // Always respond 200 immediately to WhatsApp to prevent retries
    res.sendStatus(200);
  }

  private static async processWebhookMessages(body: any): Promise<void> {
    for (const entry of body.entry) {
      if (entry.changes && entry.changes.length > 0) {
        for (const change of entry.changes) {
          if (change.value.messages && change.value.messages.length > 0) {
            for (const message of change.value.messages) {
              await this.processIncomingMessage(message);
            }
          }
        }
      }
    }
  }

  private static async processIncomingMessage(message: any): Promise<void> {
    try {
      const messageId = message.id;
      const from = message.from;
      
      // Check if message already processed
      const existingLog = await prisma.messageLog.findUnique({
        where: { messageId }
      });
      
      if (existingLog?.processed) {
        logger.info(`Message ${messageId} already processed, skipping queue`);
        return;
      }
      
      // Mark as processed to prevent duplicate processing
      await prisma.messageLog.upsert({
        where: { messageId },
        update: { processed: true },
        create: { messageId, processed: true }
      });
      
      // Prepare job data
      const jobData: WhatsAppMessageJob = {
        id: message.id,
        from: message.from,
        type: message.type,
        timestamp: message.timestamp,
        text: message.text,
        interactive: message.interactive,
        audio: message.audio
      };
      
      // Enqueue message for async processing
      // Note: For sequential processing per user, we'll use a different approach
      await messageQueue.add(`msg-${from}`, jobData, {
        jobId: messageId, // Use WhatsApp message ID for deduplication
      });
      
      logger.info(`Message ${messageId} from ${from} enqueued for processing`);
      
    } catch (error) {
      logger.error('Error enqueuing incoming message:', error);
    }
  }

  static async sendMessage(to: string, message: string): Promise<{ success: boolean; messageId?: string; error?: string }> {
    try {
      const response = await axios.post(
        `${this.WHATSAPP_API_URL}/${this.PHONE_NUMBER_ID}/messages`,
        {
          messaging_product: 'whatsapp',
          to,
          type: 'text',
          text: { body: message }
        },
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      logger.debug(`Full message sent to ${to}:`, message);
      logger.info(`Message sent to ${to} (${message.length} chars)`);
      return { success: true, messageId: response.data.messages[0].id };
    } catch (error: any) {
      logger.error('Error sending WhatsApp message:', error.response?.data || error.message);
      return { success: false, error: error.message };
    }
  }

  static async sendInteractiveMessage(to: string, interactive: any, contextMessageId?: string): Promise<string> {
    try {
      const payload: any = {
        messaging_product: 'whatsapp',
        to,
        type: 'interactive',
        interactive
      };

      if (contextMessageId) {
        payload.context = { message_id: contextMessageId };
      }

      const response = await axios.post(
        `${this.WHATSAPP_API_URL}/${this.PHONE_NUMBER_ID}/messages`,
        payload,
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      const messageType = interactive.type || 'interactive';
      const buttonText = interactive.action?.button || interactive.action?.buttons?.[0]?.reply?.title || '';
      logger.info(`Interactive message (${messageType}) sent to ${to}${buttonText ? `: "${buttonText}"` : ''}`);
      return response.data.messages[0].id;
    } catch (error: any) {
      logger.error('Error sending interactive message:', error.response?.data || error.message);
      throw new ExternalServiceError(
        ErrorCode.WHATSAPP_ERROR,
        'Failed to send interactive message',
        { metadata: { to, error: error.message } }
      );
    }
  }

  static async getMediaUrl(mediaId: string): Promise<string | null> {
    try {
      const response = await axios.get(
        `${this.WHATSAPP_API_URL}/${mediaId}`,
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`
          }
        }
      );
      
      return response.data.url;
    } catch (error: any) {
      logger.error('Error getting media URL:', error.response?.data || error.message);
      return null;
    }
  }

  static async downloadMedia(mediaUrl: string): Promise<Buffer | null> {
    try {
      const response = await axios.get(mediaUrl, {
        headers: {
          'Authorization': `Bearer ${this.ACCESS_TOKEN}`
        },
        responseType: 'arraybuffer'
      });

      return Buffer.from(response.data);
    } catch (error: any) {
      logger.error('Error downloading media:', error.response?.data || error.message);
      return null;
    }
  }

  static async markMessageAsRead(messageId: string): Promise<boolean> {
    try {
      await axios.post(
        `${this.WHATSAPP_API_URL}/${this.PHONE_NUMBER_ID}/messages`,
        {
          messaging_product: 'whatsapp',
          status: 'read',
          message_id: messageId
        },
        {
          headers: {
            'Authorization': `Bearer ${this.ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      return true;
    } catch (error: any) {
      logger.error('Error marking message as read:', error.response?.data || error.message);
      return false;
    }
  }

  static async sendMessageWithUrlButton(
    to: string, 
    headerText: string,
    bodyText: string, 
    buttonText: string, 
    url: string,
    footerText?: string
  ): Promise<boolean> {
    try {
      const interactive = {
        type: "cta_url",
        header: {
          type: "text",
          text: headerText
        },
        body: {
          text: bodyText
        },
        footer: footerText ? { text: footerText } : undefined,
        action: {
          name: "cta_url",
          parameters: {
            display_text: buttonText,
            url: url
          }
        }
      };

      await this.sendInteractiveMessage(to, interactive);
      return true;
    } catch (error) {
      logger.error('Error sending message with URL button:', error);
      return false;
    }
  }

  /**
   * Send a WhatsApp message, automatically splitting long messages
   */
  static async sendWhatsAppMessage(to: string, message: string): Promise<boolean> {
    try {
      if (message.length <= this.MAX_MESSAGE_LENGTH) {
        const result = await this.sendMessage(to, message);
        if (!result.success) {
          throw new ExternalServiceError(
            ErrorCode.WHATSAPP_ERROR,
            result.error || 'Failed to send message',
            { metadata: { to, messageLength: message.length } }
          );
        }
        return true;
      }
      
      // Split long message using unified utility
      const parts = MessageSplitter.splitMessage(message, this.MAX_MESSAGE_LENGTH);
      logger.debug(`Message split into ${parts.length} parts`);
      
      // Send each part
      for (const part of parts) {
        const result = await this.sendMessage(to, part);
        if (!result.success) {
          throw new ExternalServiceError(
            ErrorCode.WHATSAPP_ERROR,
            result.error || 'Failed to send message part',
            { metadata: { to, partLength: part.length } }
          );
        }
      }
      
      return true;
    } catch (error) {
      logger.error('Error sending WhatsApp message:', error);
      return false;
    }
  }

}

================
File: backend/src/whatsapp/handlers/orders/index.ts
================
/**
 * Order handlers index
 * Exports all order-related handlers
 */

// Order confirmation moved to OrderManagementService
// Order cancellation functionality has been removed

export {
  generateProductSummary,
  generateOrderSummary
} from './orderFormatters';

================
File: frontend-app/src/components/AddressForm/AddressForm.tsx
================
import React from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { Input } from '@/components/ui';
import type { AddressFormData } from '@/types';

const schema = yup.object({
  name: yup.string().trim().required('El nombre de la direcci√≥n es obligatorio'),
  street: yup.string().trim().required('La calle es obligatoria'),
  number: yup.string().trim().required('El n√∫mero es obligatorio'),
  interiorNumber: yup.string().transform((value) => value || undefined).optional(),
  deliveryInstructions: yup.string().transform((value) => value || undefined).optional(),
  neighborhood: yup.string().transform((value) => value || undefined).optional(),
  zipCode: yup.string().transform((value) => value || undefined).optional(),
  city: yup.string().transform((value) => value || undefined).optional(),
  state: yup.string().transform((value) => value || undefined).optional(),
  country: yup.string().transform((value) => value || undefined).optional(),
  latitude: yup.number().required('La ubicaci√≥n es obligatoria'),
  longitude: yup.number().required('La ubicaci√≥n es obligatoria'),
});

interface AddressFormProps {
  formData: AddressFormData;
  onSubmit: (data: AddressFormData) => Promise<void>;
  errors?: Record<string, string>;
  isUpdating?: boolean;
}

export const AddressForm: React.FC<AddressFormProps> = ({ 
  formData, 
  onSubmit,
  errors: externalErrors = {}
}) => {
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue
  } = useForm<AddressFormData>({
    resolver: yupResolver(schema) as any,
    defaultValues: formData,
  });

  React.useEffect(() => {
    // Update form when formData changes
    Object.entries(formData).forEach(([key, value]) => {
      setValue(key as keyof AddressFormData, value);
    });
  }, [formData, setValue]);

  const fieldTranslations = {
    street: 'Calle',
    number: 'N√∫mero',
    interiorNumber: 'N√∫mero interior',
    neighborhood: 'Colonia',
    zipCode: 'C√≥digo postal',
    city: 'Ciudad',
    state: 'Estado',
    country: 'Pa√≠s',
    deliveryInstructions: 'Instrucciones de entrega',
  };

  const handleFormSubmit = (data: AddressFormData) => {
    return onSubmit(data);
  };

  return (
    <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-6">
      {/* Nombre de la direcci√≥n */}
      <div className="space-y-4">
        <h3 className="text-sm font-semibold text-gray-700 flex items-center">
          <svg className="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
          </svg>
          Identificaci√≥n
        </h3>
        
        <Input
          label="Nombre de la direcci√≥n"
          {...register('name')}
          error={errors.name?.message || externalErrors.name}
          required
          placeholder="Ej: Casa, Oficina, Casa de mam√°"
        />
      </div>

      {/* Direcci√≥n principal */}
      <div className="space-y-4">
        <h3 className="text-sm font-semibold text-gray-700 flex items-center">
          <svg className="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
          </svg>
          Direcci√≥n Principal
        </h3>
        
        <div className="grid grid-cols-3 gap-3">
          <div className="col-span-2">
            <Input
              label={fieldTranslations.street}
              {...register('street')}
              error={errors.street?.message || externalErrors.street}
              required
              placeholder="Ej: Av. Principal"
            />
          </div>
          <div>
            <Input
              label={fieldTranslations.number}
              {...register('number')}
              error={errors.number?.message || externalErrors.number}
              required
              placeholder="123"
            />
          </div>
        </div>

        <div className="grid grid-cols-2 gap-3">
          <Input
            label={fieldTranslations.interiorNumber}
            {...register('interiorNumber')}
            error={errors.interiorNumber?.message}
            placeholder="Depto 4B (Opcional)"
          />
        </div>
      </div>

      {/* Instrucciones de entrega */}
      <div className="space-y-4">
        <h3 className="text-sm font-semibold text-gray-700 flex items-center">
          <svg className="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          Instrucciones de entrega
        </h3>
        
        <Input
          label=""
          {...register('deliveryInstructions')}
          error={errors.deliveryInstructions?.message}
          as="textarea"
          rows={3}
          placeholder="Entre calles, puntos de referencia, color de la casa, etc."
          className="resize-none"
        />
      </div>

      {/* Informaci√≥n adicional */}
      <div className="space-y-4">
        <h3 className="text-sm font-semibold text-gray-700 flex items-center justify-between">
          <span className="flex items-center">
            <svg className="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
            Informaci√≥n Geogr√°fica
          </span>
          <span className="text-xs font-normal bg-gray-200 text-gray-600 px-2 py-1 rounded-full flex items-center">
            <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
            </svg>
            Campos autom√°ticos
          </span>
        </h3>
        
        <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
          <div className="relative">
            <Input
              label={fieldTranslations.neighborhood}
              {...register('neighborhood')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
          <div className="relative">
            <Input
              label={fieldTranslations.zipCode}
              {...register('zipCode')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
          <div className="relative">
            <Input
              label={fieldTranslations.city}
              {...register('city')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
          <div className="relative">
            <Input
              label={fieldTranslations.state}
              {...register('state')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
          <div className="relative">
            <Input
              label={fieldTranslations.country}
              {...register('country')}
              readOnly
              className="bg-gray-100 cursor-not-allowed text-gray-600 border-gray-200"
            />
            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none mt-7">
              <svg className="h-4 w-4 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
            </div>
          </div>
        </div>

        <div className="bg-amber-50 border border-amber-200 rounded-lg p-3">
          <p className="text-xs text-amber-800 flex items-start font-medium">
            <svg className="w-4 h-4 mr-1.5 flex-shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
            </svg>
            Estos campos se completan autom√°ticamente cuando seleccionas tu ubicaci√≥n en el mapa. No es necesario editarlos manualmente.
          </p>
        </div>
      </div>

      {/* Hidden fields for coordinates */}
      <input type="hidden" {...register('latitude')} />
      <input type="hidden" {...register('longitude')} />
      
      {/* Submit button for form validation */}
      <button type="submit" className="hidden" id="address-form-submit">Submit</button>
    </form>
  );
};

================
File: frontend-app/src/components/CustomerNameForm.tsx
================
import { useState } from 'react';
import toast from 'react-hot-toast';

interface CustomerNameFormProps {
  onSubmit: (firstName: string, lastName: string) => Promise<void>;
  isSubmitting?: boolean;
  initialFirstName?: string;
  initialLastName?: string;
  isEditing?: boolean;
  onCancel?: () => void;
}

export function CustomerNameForm({ 
  onSubmit, 
  isSubmitting = false,
  initialFirstName = '',
  initialLastName = '',
  isEditing = false,
  onCancel
}: CustomerNameFormProps) {
  const [firstName, setFirstName] = useState(initialFirstName);
  const [lastName, setLastName] = useState(initialLastName);
  const [errors, setErrors] = useState<{ firstName?: string; lastName?: string }>({});

  const validateForm = () => {
    const newErrors: { firstName?: string; lastName?: string } = {};
    
    if (!firstName.trim()) {
      newErrors.firstName = 'El nombre es requerido';
    } else if (!/^[a-zA-Z√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë\s]+$/.test(firstName.trim())) {
      newErrors.firstName = 'El nombre solo puede contener letras';
    }
    
    if (!lastName.trim()) {
      newErrors.lastName = 'El apellido es requerido';
    } else if (!/^[a-zA-Z√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë\s]+$/.test(lastName.trim())) {
      newErrors.lastName = 'El apellido solo puede contener letras';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }
    
    try {
      await onSubmit(firstName.trim(), lastName.trim());
    } catch {
      toast.error('Error al guardar tu nombre');
    }
  };

  return (
    <div className="bg-gradient-to-br from-orange-50 via-red-50 to-pink-50 border-2 border-orange-200 rounded-2xl p-8 mb-6 shadow-lg">
      <div className="text-center mb-6">
        <div className="inline-flex items-center justify-center w-16 h-16 bg-gradient-to-br from-orange-100 to-pink-100 rounded-full mb-4">
          <span className="text-3xl">üë§</span>
        </div>
        <h3 className="text-2xl font-bold text-gray-800 mb-2">
          {isEditing ? 'Actualizar tu nombre' : '¬°Casi listo! Solo falta tu nombre'}
        </h3>
        <p className="text-base text-gray-600 max-w-md mx-auto">
          {isEditing 
            ? 'Modifica tu informaci√≥n personal para mantener tus datos actualizados.'
            : <><span className="font-semibold text-orange-600">Es necesario completar tu informaci√≥n personal</span> para poder registrar tus direcciones de entrega y procesar tus pedidos.</>
          }
        </p>
      </div>
      
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="firstName" className="block text-sm font-semibold text-gray-700 mb-2">
            Nombre <span className="text-red-500">*</span>
          </label>
          <input
            type="text"
            id="firstName"
            value={firstName}
            onChange={(e) => setFirstName(e.target.value)}
            className={`w-full px-4 py-3 border-2 rounded-xl focus:ring-3 focus:ring-orange-500 focus:border-transparent transition-all ${
              errors.firstName ? 'border-red-500 bg-red-50' : 'border-gray-300 bg-white'
            }`}
            placeholder="Ej: Juan"
            disabled={isSubmitting}
            maxLength={100}
          />
          {errors.firstName && (
            <p className="text-red-500 text-sm mt-1 flex items-center">
              <span className="mr-1">‚ö†Ô∏è</span> {errors.firstName}
            </p>
          )}
        </div>
        
        <div>
          <label htmlFor="lastName" className="block text-sm font-semibold text-gray-700 mb-2">
            Apellido <span className="text-red-500">*</span>
          </label>
          <input
            type="text"
            id="lastName"
            value={lastName}
            onChange={(e) => setLastName(e.target.value)}
            className={`w-full px-4 py-3 border-2 rounded-xl focus:ring-3 focus:ring-orange-500 focus:border-transparent transition-all ${
              errors.lastName ? 'border-red-500 bg-red-50' : 'border-gray-300 bg-white'
            }`}
            placeholder="Ej: P√©rez"
            disabled={isSubmitting}
            maxLength={100}
          />
          {errors.lastName && (
            <p className="text-red-500 text-sm mt-1 flex items-center">
              <span className="mr-1">‚ö†Ô∏è</span> {errors.lastName}
            </p>
          )}
        </div>
        
        <div className="pt-4 space-y-3">
          <button
            type="submit"
            disabled={isSubmitting}
            className={`w-full px-6 py-4 font-bold text-white rounded-xl shadow-lg transform transition-all duration-200 ${
              isSubmitting
                ? 'bg-gray-400 cursor-not-allowed'
                : 'bg-gradient-to-r from-orange-500 to-pink-600 hover:shadow-xl hover:scale-105'
            }`}
          >
            {isSubmitting ? (
              <div className="flex items-center justify-center">
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2"></div>
                Guardando...
              </div>
            ) : (
              <span className="flex items-center justify-center">
                {isEditing ? 'Guardar cambios' : 'Continuar al registro de direcci√≥n'}
                <svg className="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </span>
            )}
          </button>
          
          {isEditing && onCancel && (
            <button
              type="button"
              onClick={onCancel}
              disabled={isSubmitting}
              className="w-full px-6 py-3 font-semibold text-gray-700 bg-white border-2 border-gray-300 rounded-xl hover:bg-gray-50 transition-colors"
            >
              Cancelar
            </button>
          )}
        </div>
      </form>
    </div>
  );
}

================
File: frontend-app/src/store/addressRegistrationStore.ts
================
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import type { Customer, AddressFormData } from '@/types';

interface CustomerData extends Customer {
  id: string;
}

type FormData = AddressFormData;

interface AddressRegistrationState {
  // Estado de la sesi√≥n
  customerId: string | null;
  otp: string | null;
  preOrderId: string | null;
  
  // Datos del cliente
  customer: CustomerData | null;
  
  // Estado del formulario
  formData: FormData;
  
  // Estados de UI
  isLoading: boolean;
  isValidating: boolean;
  isSaving: boolean;
  error: string | null;
  showSuccess: boolean;
  editingAddressId: string | null;
  
  // √Årea de entrega
  deliveryArea: google.maps.LatLngLiteral[] | null;
  
  // Acciones
  setSession: (customerId: string, otp: string, preOrderId?: string) => void;
  setCustomer: (customer: CustomerData) => void;
  setFormData: (data: Partial<FormData>) => void;
  updateFormField: <K extends keyof FormData>(field: K, value: FormData[K]) => void;
  setLoading: (isLoading: boolean) => void;
  setValidating: (isValidating: boolean) => void;
  setSaving: (isSaving: boolean) => void;
  setError: (error: string | null) => void;
  setShowSuccess: (show: boolean) => void;
  setEditingAddressId: (id: string | null) => void;
  setDeliveryArea: (area: google.maps.LatLngLiteral[] | null) => void;
  resetForm: () => void;
  resetAll: () => void;
}

const initialFormData: FormData = {
  name: '',
  street: '',
  number: '',
  interiorNumber: '',
  neighborhood: '',
  city: '',
  state: '',
  country: 'M√©xico',
  zipCode: '',
  deliveryInstructions: '',
  latitude: 0,
  longitude: 0,
};

export const useAddressRegistrationStore = create<AddressRegistrationState>()(
  devtools(
    persist(
      (set) => ({
        // Estado inicial
        customerId: null,
        otp: null,
        preOrderId: null,
        customer: null,
        formData: initialFormData,
        isLoading: false,
        isValidating: false,
        isSaving: false,
        error: null,
        showSuccess: false,
        editingAddressId: null,
        deliveryArea: null,
        
        // Acciones
        setSession: (customerId, otp, preOrderId) => 
          set({ customerId, otp, preOrderId }, false, 'setSession'),
        
        setCustomer: (customer) => 
          set({ customer }, false, 'setCustomer'),
        
        setFormData: (data) => 
          set((state) => ({ 
            formData: { ...state.formData, ...data } 
          }), false, 'setFormData'),
        
        updateFormField: (field, value) =>
          set((state) => ({
            formData: { ...state.formData, [field]: value }
          }), false, 'updateFormField'),
        
        setLoading: (isLoading) => 
          set({ isLoading }, false, 'setLoading'),
        
        setValidating: (isValidating) => 
          set({ isValidating }, false, 'setValidating'),
        
        setSaving: (isSaving) => 
          set({ isSaving }, false, 'setSaving'),
        
        setError: (error) => 
          set({ error }, false, 'setError'),
        
        setShowSuccess: (showSuccess) => 
          set({ showSuccess }, false, 'setShowSuccess'),
        
        setEditingAddressId: (editingAddressId) => 
          set({ editingAddressId }, false, 'setEditingAddressId'),
        
        setDeliveryArea: (deliveryArea) => 
          set({ deliveryArea }, false, 'setDeliveryArea'),
        
        resetForm: () => 
          set({ 
            formData: initialFormData, 
            editingAddressId: null,
            error: null 
          }, false, 'resetForm'),
        
        resetAll: () => 
          set({
            customerId: null,
            otp: null,
            preOrderId: null,
            customer: null,
            formData: initialFormData,
            isLoading: false,
            isValidating: false,
            isSaving: false,
            error: null,
            showSuccess: false,
            editingAddressId: null,
            deliveryArea: null,
          }, false, 'resetAll'),
      }),
      {
        name: 'address-registration-storage',
        // Solo persistir datos de sesi√≥n, no estados de UI
        partialize: (state) => ({
          customerId: state.customerId,
          otp: state.otp,
          preOrderId: state.preOrderId,
        }),
      }
    )
  )
);

================
File: backend/.env.example
================
# Base de datos local (funciona con docker-compose)
DATABASE_URL=postgresql://postgres:postgres@localhost:5433/bot_db

# ===== CONFIGURACI√ìN REQUERIDA =====
# Debes actualizar TODOS estos valores antes de ejecutar el bot

# 1. Google AI - REQUERIDO
# Obt√©n tu API Key gratis en: https://makersuite.google.com/app/apikey
GOOGLE_AI_API_KEY=tu_api_key_aqui
GEMINI_MODEL=gemini-2.5-pro
EMBEDDING_MODEL=text-embedding-004

# 2. WhatsApp Business API - REQUERIDO
# Obt√©n estos valores en: https://developers.facebook.com
# Tutorial: Ver QUICK_START.md secci√≥n "Obtener Credenciales de WhatsApp"
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=tu_phone_number_id
WHATSAPP_ACCESS_TOKEN=tu_access_token
WHATSAPP_VERIFY_TOKEN=tu_verify_token

# URLs locales
FRONTEND_BASE_URL=http://localhost:3000
NODE_ENV=development
PORT=5000

# L√≠mites de mensajes
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5

# Configuraci√≥n regional
DEFAULT_TIMEZONE=America/Mexico_City
DEFAULT_LOCALE=es-MX

# Stripe (Pagos) - OPCIONAL (dejar vac√≠o si no se usa)
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=

# =============================================
# VARIABLES M√çNIMAS REQUERIDAS:
# =============================================
# 1. DATABASE_URL - Conexi√≥n a PostgreSQL
# 2. GOOGLE_AI_API_KEY - Para Gemini AI
# 3. GEMINI_MODEL - Modelo de Gemini a usar
# 4. WHATSAPP_PHONE_NUMBER_MESSAGING_ID - ID del tel√©fono en Meta
# 5. WHATSAPP_ACCESS_TOKEN - Token de acceso de WhatsApp
# 6. WHATSAPP_VERIFY_TOKEN - Token de verificaci√≥n del webhook
# 7. FRONTEND_BASE_URL - URL del frontend para enlaces
# 8. NODE_ENV - Entorno (development/production)
# 9. PORT - Puerto del servidor
# 10. RATE_LIMIT_MAX_MESSAGES - L√≠mite de mensajes
# 11. RATE_LIMIT_TIME_WINDOW_MINUTES - Ventana de tiempo para el l√≠mite
# 12. DEFAULT_TIMEZONE - Zona horaria por defecto
# 13. DEFAULT_LOCALE - Configuraci√≥n regional por defecto
# Redis Configuration (Optional)
# Redis se usa para compartir OTPs y cach√© entre m√∫ltiples instancias
# Si no se configura, se usar√° memoria local (no escalable)
REDIS_HOST=localhost
REDIS_PORT=6380
# REDIS_PASSWORD=tu_password_de_redis

# API Key para servicios en la nube
# Clave secreta para autenticar peticiones de servicios en la nube (sincronizaci√≥n, audio, etc.)
# Genera una clave segura y mant√©nla privada
CLOUD_API_KEY=genera_una_clave_secreta_aqui

# BullMQ Worker Configuration
# N√∫mero de trabajos concurrentes que cada worker puede procesar
# Para desarrollo: 2-5 es suficiente
# Para producci√≥n: 10-20 dependiendo de recursos del servidor
BULLMQ_WORKER_CONCURRENCY=2

# N√∫mero de procesos worker a iniciar (solo para PM2 en producci√≥n)
# Para desarrollo: 1 es suficiente
# Para producci√≥n: 2-4 dependiendo de n√∫cleos CPU disponibles
NUM_WORKERS=1

================
File: backend/src/common/constants/interactiveActions.ts
================
/**
 * Constants for interactive message actions
 * These are used as prefixes or identifiers in WhatsApp interactive messages
 */
export const INTERACTIVE_ACTIONS = {
  // PreOrder actions
  PREORDER_CONFIRM: 'preorder_confirm:',
  PREORDER_DISCARD: 'preorder_discard:',
  PREORDER_CHANGE_ADDRESS: 'preorder_change_address:',
  
  // Address actions
  SELECT_ADDRESS: 'select_address_',
  CHANGE_ADDRESS: 'change_address',
  ADD_NEW_ADDRESS: 'add_new_address',
  
  // Order actions
  PAY_ONLINE: 'pay_online',
  
  // Menu and info actions
  VIEW_MENU: 'view_menu',
  RESTAURANT_INFO: 'restaurant_info',
  WAIT_TIMES: 'wait_times',
  CHATBOT_HELP: 'chatbot_help',
  CHANGE_DELIVERY_INFO: 'change_delivery_info',
} as const;

/**
 * Type-safe way to check if a string starts with an action prefix
 */
export function startsWithAction(str: string, action: string): boolean {
  return str.startsWith(action);
}

/**
 * Extract the ID from an action string
 * For example: 'select_address_123' -> '123'
 */
export function extractIdFromAction(str: string, actionPrefix: string): string {
  if (!startsWithAction(str, actionPrefix)) {
    throw new Error(`String does not start with action prefix: ${actionPrefix}`);
  }
  return str.substring(actionPrefix.length);
}

================
File: backend/src/common/types/order.types.ts
================
export interface FormattedOrder {
  id?: string;
  shiftOrderNumber?: number;
  orderType?: string;
  customerId?: string;
  phoneNumber: string;
  deliveryInfo: string;
  totalPrice: number;
  createdAt: string;
  scheduledDeliveryTime: string | null;
  estimatedDeliveryTime?: string;
  products: FormattedOrderProduct[];
}

export interface FormattedOrderProduct {
  name: string;
  quantity: number;
  price: number;
  modifiers: { name: string; price: number }[];
  pizzaCustomizations?: { 
    half: string; 
    name: string; 
    action?: string; 
    type?: string; 
    ingredients?: string;
  }[];
  comments?: string;
}

export interface OrderSummaryResult {
  formattedOrder: FormattedOrder;
  orderSummary: string;
}

================
File: backend/src/common/types/services.types.ts
================
/**
 * Service-specific types that are used across multiple services
 */

// Delivery Info types (compatible with DeliveryInfo model)
export interface DeliveryInfoInput {
  fullAddress?: string | null;
  street?: string | null;
  number?: string | null;
  interiorNumber?: string | null;
  neighborhood?: string | null;
  city?: string | null;
  state?: string | null;
  zipCode?: string | null;
  country?: string | null;
  recipientName?: string | null;
  recipientPhone?: string | null;
  deliveryInstructions?: string | null;
  latitude?: number | null;
  longitude?: number | null;
  isDefault?: boolean;
}

// AI Context types
export enum ContextType {
  NEW_ORDER = "nuevo_pedido",
  CUSTOMER_SERVICE = "servicio_cliente",
  GENERAL_INQUIRY = "consulta_general",
  MENU_INQUIRY = "consulta_menu",
  COMPLAINT = "queja",
  UNKNOWN = "desconocido"
}

// Order Management types
export interface OrderCreationResult {
  order: any;
  formattedOrder: any;
  message: string;
}

export interface PreOrderCreationResult {
  preOrderId: number;
  products: any[];
  subtotal: number;
  total: number;
  estimatedDeliveryTime: number;
}

================
File: backend/src/queues/messageQueue.ts
================
import { Queue, Worker, Job } from 'bullmq';
import IORedis from 'ioredis';
import { env } from '../common/config/envValidator';
import { redisKeys } from '../common/constants';
import logger from '../common/utils/logger';
import { processMessageJob } from '../workers/messageWorker';
import { WhatsAppMessageJob } from './types';

// Redis connection configuration
const connection = {
  host: env.REDIS_HOST || 'localhost',
  port: parseInt(env.REDIS_PORT || '6380', 10),
  password: env.REDIS_PASSWORD,
};

// Create a dedicated Redis client for locking
const redisClient = new IORedis(connection);

// Single queue for all WhatsApp messages
export const messageQueue = new Queue<WhatsAppMessageJob>('whatsapp-messages', {
  connection,
  defaultJobOptions: {
    attempts: 3,
    backoff: { type: 'exponential', delay: 5000 },
    removeOnComplete: { age: 3600, count: 1000 },
    removeOnFail: { age: 24 * 3600, count: 5000 },
  },
});

logger.info('BullMQ Message Queue initialized');

// Single worker instance that handles all jobs
let messageWorker: Worker<WhatsAppMessageJob> | null = null;

// Acquire a distributed lock for a user
async function acquireUserLock(userId: string, timeoutSeconds: number = 60): Promise<boolean> {
  const lockKey = redisKeys.userLock(userId);
  
  try {
    // SET key value NX EX seconds
    // NX: Only set if key doesn't exist
    // EX: Set expiry in seconds to prevent permanent locks
    const result = await redisClient.set(lockKey, 'processing', 'EX', timeoutSeconds, 'NX');
    return result === 'OK';
  } catch (error) {
    logger.error(`Failed to acquire lock for user ${userId}:`, error);
    return false;
  }
}

// Release the distributed lock for a user
async function releaseUserLock(userId: string): Promise<void> {
  const lockKey = redisKeys.userLock(userId);
  
  try {
    await redisClient.del(lockKey);
  } catch (error) {
    logger.error(`Failed to release lock for user ${userId}:`, error);
  }
}

export function startMessageWorker(): void {
  if (messageWorker) {
    logger.warn('Message worker already started');
    return;
  }

  const workerConcurrency = parseInt(env.BULLMQ_WORKER_CONCURRENCY || '5', 10);
  logger.info(`Starting BullMQ worker with concurrency: ${workerConcurrency}`);

  messageWorker = new Worker<WhatsAppMessageJob>(
    'whatsapp-messages',
    async (job: Job<WhatsAppMessageJob>) => {
      const userId = job.data.from;
      let lockAcquired = false;
      
      try {
        // Try to acquire lock with exponential backoff
        let attempts = 0;
        const maxAttempts = 100; // 100 * 150ms = 15 seconds max wait
        
        while (attempts < maxAttempts) {
          lockAcquired = await acquireUserLock(userId, 300); // 5 minute timeout
          
          if (lockAcquired) {
            logger.debug(`Lock acquired for user ${userId} on attempt ${attempts + 1}`);
            break;
          }
          
          // Exponential backoff: 100ms, 200ms, 400ms... up to 2 seconds
          const delay = Math.min(100 * Math.pow(2, Math.floor(attempts / 10)), 2000);
          await new Promise(resolve => setTimeout(resolve, delay));
          attempts++;
        }
        
        if (!lockAcquired) {
          throw new Error(`Failed to acquire lock for user ${userId} after ${maxAttempts} attempts`);
        }
        
        logger.info(`Processing job ${job.id} for user ${userId}`);
        
        // Process the message
        await processMessageJob(job.data);
        
        // Small delay to ensure BullMQ completes its internal operations
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } finally {
        // Always release the lock if we acquired it
        if (lockAcquired) {
          await releaseUserLock(userId);
          logger.debug(`Lock released for user ${userId}`);
        }
      }
    },
    { 
      connection, 
      concurrency: workerConcurrency,
      lockDuration: 60000, // Increase default lock duration to 60 seconds
      lockRenewTime: 20000, // Renew lock every 20 seconds
    }
  );

  // Event handlers
  messageWorker.on('completed', (job: Job<WhatsAppMessageJob>) => {
    logger.info(`Job ${job.id} for user ${job.data.from} completed successfully`);
  });

  messageWorker.on('failed', (job: Job<WhatsAppMessageJob> | undefined, err: Error) => {
    if (job) {
      logger.error(`Job ${job.id} for user ${job.data.from} failed:`, {
        error: err.message,
        stack: err.stack,
        attempts: job.attemptsMade,
      });
    } else {
      logger.error('A job failed:', { error: err.message });
    }
  });

  messageWorker.on('error', (err: Error) => {
    logger.error('Worker error:', { error: err.message, stack: err.stack });
  });

  logger.info('BullMQ Message Worker started and listening for jobs');
}

export async function stopMessageWorker(): Promise<void> {
  if (messageWorker) {
    await messageWorker.close();
    messageWorker = null;
    
    // Close Redis client
    redisClient.disconnect();
    
    logger.info('Message worker stopped');
  }
}

================
File: backend/src/services/ai/prompts/orderAgent.prompt.ts
================
/**
 * Order Agent prompt template
 * Specialized for mapping natural language orders to menu items
 */
export function getOrderAgentPrompt(relevantMenu: string): string {
  return `MAPEA LA ORDEN AL MEN√ö JSON.

MEN√ö DISPONIBLE:
${relevantMenu}
    
ESTRUCTURA DEL MEN√ö:
- id: ID del producto
- nombre: nombre del producto
- variantes: array con {id, nombre} - SI EXISTE ESTE CAMPO, DEBES SELECCIONAR UNA VARIANTE
- modificadores: grupos con opciones {id, nombre}
- personalizacionesPizza: para pizzas {id, nombre, tipo: FLAVOR|INGREDIENT}

REGLA CR√çTICA SOBRE VARIANTES:
‚ö†Ô∏è SI UN PRODUCTO TIENE EL CAMPO "variantes", ES OBLIGATORIO ESPECIFICAR variantId
- NUNCA uses solo el productId si hay variantes disponibles
- SIEMPRE selecciona la variante m√°s apropiada seg√∫n lo que pidi√≥ el cliente
- Ejemplos:
  * "papas" ‚Üí INCORRECTO: solo productId
  * "papas francesas" ‚Üí CORRECTO: productId + variantId de "Orden de Papas a la Francesa"
  * "alitas" ‚Üí INCORRECTO: solo productId  
  * "alitas BBQ" ‚Üí CORRECTO: productId + variantId de "Orden de Alitas BBQ"

PARA PIZZAS - INSTRUCCIONES DETALLADAS:

1. TIPOS DE PERSONALIZACI√ìN:
   - FLAVOR: Son sabores completos de pizza (Hawaiana, Mexicana, Pepperoni, etc.)
   - INGREDIENT: Son ingredientes individuales para agregar o quitar

2. ESTRUCTURA DE pizzaCustomizations:
   Cada personalizaci√≥n debe ser un objeto con:
   - customizationId: el ID de la personalizaci√≥n
   - half: "FULL" (completa), "HALF_1" (primera mitad), "HALF_2" (segunda mitad)
   - action: "ADD" (agregar) o "REMOVE" (quitar)

3. CASOS COMUNES:
   
   a) "Pizza Hawaiana grande":
      - Busca el FLAVOR con nombre "Hawaiana" 
      - pizzaCustomizations: [{ customizationId: "PZ-I-5", half: "FULL", action: "ADD" }]
   
   b) "Pizza mitad Hawaiana mitad Mexicana":
      - Dos FLAVORS, uno en cada mitad
      - pizzaCustomizations: [
          { customizationId: "PZ-I-5", half: "HALF_1", action: "ADD" },
          { customizationId: "PZ-I-12", half: "HALF_2", action: "ADD" }
        ]
   
   c) "Pizza Hawaiana con champi√±ones extra":
      - Un FLAVOR + un INGREDIENT adicional
      - pizzaCustomizations: [
          { customizationId: "PZ-I-5", half: "FULL", action: "ADD" },
          { customizationId: "PZ-I-22", half: "FULL", action: "ADD" }
        ]
   
   d) "Pizza Mexicana sin chile jalape√±o":
      - Un FLAVOR con un ingrediente removido
      - pizzaCustomizations: [
          { customizationId: "PZ-I-12", half: "FULL", action: "ADD" },
          { customizationId: "PZ-I-23", half: "FULL", action: "REMOVE" }
        ]
   
   e) "Pizza con pepperoni y champi√±ones" (sin sabor base):
      - Solo INGREDIENTS, sin FLAVOR
      - pizzaCustomizations: [
          { customizationId: "PZ-I-40", half: "FULL", action: "ADD" },
          { customizationId: "PZ-I-22", half: "FULL", action: "ADD" }
        ]

4. REGLAS IMPORTANTES:
   - Si mencionan un sabor conocido (Hawaiana, Mexicana, etc.), usa el FLAVOR correspondiente
   - "Extra" o "con" significa ADD un INGREDIENT
   - "Sin" significa REMOVE un INGREDIENT
   - Si no especifican mitades, usa half: "FULL"
   - Siempre usa action: "ADD" excepto cuando digan "sin"

EJECUTA map_order_items con:
- productId: usa el id del producto
- variantId: usa el id de la variante correcta (OBLIGATORIO si el producto tiene variantes)
- quantity: cantidad solicitada
- modifiers: array de IDs de modificadores (si aplica)
- pizzaCustomizations: array de objetos con la estructura explicada arriba
- orderType: USA EL TIPO DE ORDEN QUE VIENE EN EL MENSAJE (DESPU√âS DE "TIPO:")

VALIDACI√ìN ANTES DE EJECUTAR:
1. Si el producto tiene variantes, VERIFICA que est√©s incluyendo variantId
2. Si el cliente dice solo "papas" o "alitas", PREGUNTA qu√© tipo quiere
3. NUNCA ejecutes map_order_items sin variantId para productos con variantes

IMPORTANTE: NO CAMBIES EL TIPO DE ORDEN. USA EXACTAMENTE EL QUE EST√Å EN EL MENSAJE.

NO CONVERSES. SOLO MAPEA Y EJECUTA.`;
}

================
File: backend/src/services/ai/tools/handlers/resetConversationHandler.ts
================
import { ToolHandler } from '../types';
import { MessageContext } from '../../../messaging/MessageContext';
import { prisma } from '../../../../lib/prisma';
import { CONVERSATION_RESET_MESSAGE } from '../../../../common/config/predefinedMessages';
import { SyncMetadataService } from '../../../sync/SyncMetadataService';
import { TechnicalError, ErrorCode } from '../../../../common/services/errors';
import { UnifiedResponse, ResponseBuilder, ResponseType } from '../../../messaging/types/responses';
import { CONTEXT_KEYS } from '../../../../common/constants';
import logger from '../../../../common/utils/logger';

/**
 * Handles the reset_conversation function call
 * Clears chat history and resets conversation state
 */
export const handleResetConversation: ToolHandler = async (args, context?: MessageContext): Promise<UnifiedResponse> => {
  logger.debug('Resetting conversation');
  
  // Get customerId from context
  const customerId = context?.customer?.id;
  if (!customerId) {
    throw new TechnicalError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Could not get customer ID from context'
    );
  }
  
  // Reset chat history immediately
  await prisma.customer.update({
    where: { id: customerId },
    data: { 
      relevantChatHistory: JSON.stringify([]),
      fullChatHistory: JSON.stringify([]),
      lastInteraction: new Date()
    }
  });
  
  // Mark for sync
  await SyncMetadataService.markForSync('Customer', customerId, 'REMOTE');
  
  // Clear context history completely
  context?.set(CONTEXT_KEYS.RELEVANT_CHAT_HISTORY, []);
  context?.set(CONTEXT_KEYS.FULL_CHAT_HISTORY, []);
  
  // Mark to skip history update
  context?.set(CONTEXT_KEYS.SKIP_HISTORY_UPDATE, true);
  
  // Mark that conversation is being reset to avoid welcome message
  context?.set(CONTEXT_KEYS.IS_RESETTING_CONVERSATION, true);
  
  // Create and return unified response directly
  const response = ResponseBuilder.text(CONVERSATION_RESET_MESSAGE, false);
  response.metadata.type = ResponseType.CONVERSATION_RESET;
  
  return response;
};

================
File: backend/src/services/config/ConfigService.ts
================
import { prisma } from '../../lib/prisma';
import logger from '../../common/utils/logger';
import { RestaurantInfo } from '../../common/types/restaurant';

interface CachedConfig {
  restaurantInfo: RestaurantInfo;
  lastUpdated: Date;
}

/**
 * Service for managing and caching global configuration
 */
export class ConfigService {
  private static config: CachedConfig | null = null;
  private static readonly CACHE_TTL_MS = 2 * 60 * 1000; // 2 minutes cache TTL
  private static reloadInProgress = false;

  /**
   * Loads the restaurant configuration from database and caches it
   */
  static async loadConfig(): Promise<void> {
    try {
      const dbConfig = await prisma.restaurantConfig.findFirst();
      
      if (!dbConfig) {
        // Use default configuration if none exists
        logger.warn('No restaurant configuration found in database, using defaults');
        const defaultInfo: RestaurantInfo = {
          restaurantName: "Restaurante (Pendiente Sincronizaci√≥n)",
          phoneMain: "",
          phoneSecondary: "",
          address: "",
          city: "",
          state: "",
          postalCode: ""
        };
        
        this.config = {
          restaurantInfo: defaultInfo,
          lastUpdated: new Date()
        };
        return;
      }
      
      // Map database config to RestaurantInfo type
      const restaurantInfo: RestaurantInfo = {
        restaurantName: dbConfig.restaurantName || "Establecimiento",
        phoneMain: dbConfig.phoneMain || "",
        phoneSecondary: dbConfig.phoneSecondary || "",
        address: dbConfig.address || "",
        city: dbConfig.city || "",
        state: dbConfig.state || "",
        postalCode: dbConfig.postalCode || ""
      };
      
      this.config = {
        restaurantInfo,
        lastUpdated: new Date()
      };
      
      logger.info('Restaurant configuration loaded and cached successfully');
    } catch (error) {
      logger.error('Failed to load restaurant configuration:', error);
      
      // Use default configuration on error
      const defaultInfo: RestaurantInfo = {
        restaurantName: "Restaurante (Error al cargar)",
        phoneMain: "",
        phoneSecondary: "",
        address: "",
        city: "",
        state: "",
        postalCode: ""
      };
      
      this.config = {
        restaurantInfo: defaultInfo,
        lastUpdated: new Date()
      };
    }
  }

  /**
   * Gets the cached restaurant configuration
   * Auto-reloads if cache has expired
   * @throws Error if configuration cannot be loaded
   */
  static getConfig(): RestaurantInfo {
    // Check if we need to load or reload
    if (!this.config) {
      throw new Error('Configuration not loaded! Call loadConfig() first.');
    }
    
    // Check if cache has expired
    const now = new Date();
    const cacheAge = now.getTime() - this.config.lastUpdated.getTime();
    
    if (cacheAge > this.CACHE_TTL_MS) {
      logger.warn(`Configuration cache expired (age: ${Math.round(cacheAge / 1000)}s), reloading...`);
      // Return stale config but trigger async reload for next request
      this.reloadConfigAsync();
    }
    
    return this.config.restaurantInfo;
  }

  /**
   * Gets the configuration asynchronously, loading it if necessary
   * Useful for startup scenarios where config might not be loaded yet
   */
  static async getConfigAsync(): Promise<RestaurantInfo> {
    if (!this.config) {
      await this.loadConfig();
    }
    return this.getConfig();
  }

  /**
   * Forces a reload of the configuration from database
   * Useful after configuration updates
   */
  static async reloadConfig(): Promise<void> {
    logger.info('Reloading restaurant configuration...');
    await this.loadConfig();
  }

  /**
   * Reloads configuration asynchronously without blocking
   * Used for automatic cache refresh
   */
  private static async reloadConfigAsync(): Promise<void> {
    // Prevent multiple concurrent reloads
    if (this.reloadInProgress) {
      logger.debug('Configuration reload already in progress, skipping');
      return;
    }

    this.reloadInProgress = true;
    
    try {
      await this.loadConfig();
      logger.info('Configuration reloaded successfully in background');
    } catch (error) {
      logger.error('Failed to reload configuration in background:', error);
      // Don't throw - continue using stale config
    } finally {
      this.reloadInProgress = false;
    }
  }

  /**
   * Checks if configuration is loaded
   */
  static isConfigLoaded(): boolean {
    return this.config !== null;
  }

  /**
   * Gets the last update timestamp of the cached configuration
   */
  static getLastUpdated(): Date | null {
    return this.config?.lastUpdated || null;
  }

  /**
   * Gets the cache status information
   */
  static getCacheStatus(): {
    isLoaded: boolean;
    lastUpdated: Date | null;
    ageInSeconds: number | null;
    isExpired: boolean;
    ttlSeconds: number;
  } {
    if (!this.config) {
      return {
        isLoaded: false,
        lastUpdated: null,
        ageInSeconds: null,
        isExpired: false,
        ttlSeconds: this.CACHE_TTL_MS / 1000
      };
    }

    const now = new Date();
    const ageMs = now.getTime() - this.config.lastUpdated.getTime();
    
    return {
      isLoaded: true,
      lastUpdated: this.config.lastUpdated,
      ageInSeconds: Math.round(ageMs / 1000),
      isExpired: ageMs > this.CACHE_TTL_MS,
      ttlSeconds: this.CACHE_TTL_MS / 1000
    };
  }
}

================
File: backend/src/services/messaging/types/responses.ts
================
/**
 * Tipo unificado para todas las respuestas del sistema
 * Reemplaza AIResponse, MessageResponse, ResponseItem, etc.
 * 
 * Reglas de prioridad para el historial:
 * 1. Si metadata.historyMarker existe, siempre se usa ese texto para el historial relevante
 * 2. Si historyMarker no existe y metadata.isRelevant es true, se usa content.text
 * 3. Si isRelevant es false y no hay historyMarker, no se guarda en el historial relevante
 */
export interface UnifiedResponse {
  // Contenido principal
  content?: {
    text?: string;
    interactive?: any;
    urlButton?: {
      title: string;
      body: string;
      buttonText: string;
      url: string;
    };
  };
  
  // Metadatos
  metadata: {
    // Control de env√≠o
    shouldSend: boolean;
    
    // Relevancia para el historial
    isRelevant: boolean;
    
    // Tipo de respuesta
    type: ResponseType;
    
    // IDs relacionados
    preOrderId?: number;
    orderId?: number;
    
    // Marcador de historial (texto resumido para el historial)
    historyMarker?: string;
  };
  
  // Datos procesados (para pedidos)
  processedData?: {
    orderItems?: any[];
    orderType?: string; // OrderType enum as string
    warnings?: string[];
    scheduledAt?: Date;
  };
  
  // Errores
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

/**
 * Tipos de respuesta
 */
export enum ResponseType {
  // Mensajes simples
  TEXT = 'TEXT',
  INTERACTIVE = 'INTERACTIVE',
  
  // Respuestas de procesamiento
  ORDER_CONFIRMATION = 'ORDER_CONFIRMATION',
  ORDER_PROCESSING = 'ORDER_PROCESSING',
  
  // Respuestas de consulta
  MENU_INFO = 'MENU_INFO',
  WAIT_TIME_INFO = 'WAIT_TIME_INFO',
  RESTAURANT_INFO = 'RESTAURANT_INFO',
  
  // Respuestas de sistema
  ADDRESS_UPDATE = 'ADDRESS_UPDATE',
  BOT_INSTRUCTIONS = 'BOT_INSTRUCTIONS',
  CONVERSATION_RESET = 'CONVERSATION_RESET',
  
  // Errores
  ERROR = 'ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
}

/**
 * Builder para crear respuestas de forma consistente
 * 
 * Reglas importantes:
 * - Si se especifica historyMarker, siempre tiene prioridad sobre content.text para el historial
 * - isRelevant determina si content.text se guarda en el historial (cuando no hay historyMarker)
 * - Los mensajes interactivos son por defecto no relevantes (navegaci√≥n), pero se puede cambiar
 * - Use textWithHistoryMarker cuando el texto del usuario y del historial deban ser diferentes
 */
export class ResponseBuilder {
  /**
   * Crea una respuesta de texto simple
   * @param message - El mensaje de texto a enviar
   * @param isRelevant - Si el mensaje es relevante para el historial (default: true)
   */
  static text(message: string, isRelevant = true): UnifiedResponse {
    return {
      content: { text: message },
      metadata: {
        shouldSend: true,
        isRelevant,
        type: ResponseType.TEXT,
      },
    };
  }
  
  /**
   * Crea una respuesta con mensaje interactivo (botones o listas)
   * @param message - El objeto de mensaje interactivo de WhatsApp
   * @param preOrderId - ID del pre-order asociado (opcional)
   * @param isRelevant - Si el mensaje es relevante para el historial (default: false)
   */
  static interactive(message: any, preOrderId?: number, isRelevant = false): UnifiedResponse {
    return {
      content: { interactive: message },
      metadata: {
        shouldSend: true,
        isRelevant,
        type: ResponseType.INTERACTIVE,
        preOrderId,
      },
    };
  }
  
  /**
   * Crea una respuesta de procesamiento de orden (no se env√≠a a WhatsApp)
   * @param data - Datos procesados de la orden
   */
  static orderProcessing(data: any): UnifiedResponse {
    return {
      processedData: data,
      metadata: {
        shouldSend: false,
        isRelevant: true,
        type: ResponseType.ORDER_PROCESSING,
      },
    };
  }
  
  /**
   * Crea una respuesta de error
   * @param code - C√≥digo de error
   * @param message - Mensaje de error para el usuario
   */
  static error(code: string, message: string): UnifiedResponse {
    return {
      content: { text: message },
      error: { code, message },
      metadata: {
        shouldSend: true,
        isRelevant: true,
        type: ResponseType.ERROR,
      },
    };
  }
  
  /**
   * Crea una respuesta con texto diferente para el usuario y el historial
   * @param textToSend - Texto completo para enviar al usuario
   * @param textForHistory - Texto resumido/alternativo para guardar en el historial relevante
   * @param type - Tipo de respuesta (opcional, default: TEXT)
   */
  static textWithHistoryMarker(textToSend: string, textForHistory: string, type: ResponseType = ResponseType.TEXT): UnifiedResponse {
    return {
      content: { 
        text: textToSend,
      },
      metadata: {
        shouldSend: true,
        isRelevant: true, // Un marcador siempre es relevante por definici√≥n
        type,
        historyMarker: textForHistory,
      },
    };
  }
  
  /**
   * Crea una respuesta que no se env√≠a a WhatsApp pero se guarda en el historial
   * @param marker - Texto para guardar en el historial
   * @param processedData - Datos procesados opcionales
   */
  static internalMarker(marker: string, processedData?: any): UnifiedResponse {
    return {
      content: { text: marker },
      processedData,
      metadata: {
        shouldSend: false,
        isRelevant: true,
        type: ResponseType.ORDER_PROCESSING,
      },
    };
  }
  
  /**
   * Crea una respuesta con mensaje de confirmaci√≥n separado
   * @param mainMessage - Mensaje principal
   * @param confirmationMessage - Mensaje de confirmaci√≥n adicional
   */
  static withConfirmation(mainMessage: string, confirmationMessage: string): UnifiedResponse[] {
    return [
      this.text(mainMessage),
      this.text(confirmationMessage),
    ];
  }
  
  /**
   * Crea una respuesta vac√≠a (no enviar nada)
   */
  static empty(): UnifiedResponse {
    return {
      metadata: {
        shouldSend: false,
        isRelevant: false,
        type: ResponseType.TEXT,
      },
    };
  }
  
  /**
   * Crea una respuesta con bot√≥n de URL
   * @param title - T√≠tulo del mensaje
   * @param body - Cuerpo del mensaje
   * @param buttonText - Texto del bot√≥n
   * @param url - URL a abrir cuando se presiona el bot√≥n
   */
  static urlButton(title: string, body: string, buttonText: string, url: string): UnifiedResponse {
    return {
      content: {
        urlButton: { title, body, buttonText, url }
      },
      metadata: {
        shouldSend: true,
        isRelevant: true,
        type: ResponseType.ADDRESS_UPDATE, // Podr√≠amos crear un nuevo tipo URL_BUTTON
      },
    };
  }
}

================
File: backend/src/services/orders/services/ProductCalculationService.ts
================
import { prisma } from '../../../lib/prisma';
import { ValidationError, ErrorCode } from "../../../common/services/errors";
import logger from "../../../common/utils/logger";
import { BaseOrderItem, CalculatedOrderItem } from "../../../common/types";

export class ProductCalculationService {
  /**
   * Calculate items and prices for an order
   */
  static async calculateOrderItems(orderItems: BaseOrderItem[]): Promise<{
    items: CalculatedOrderItem[];
    subtotal: number;
    total: number;
  }> {
    const calculatedItems = await Promise.all(
      orderItems.map(async (item) => await this.calculateSingleItem(item))
    );

    const subtotal = calculatedItems.reduce((sum, item) => sum + item.totalPrice, 0);
    const total = subtotal; // For now, total = subtotal. Can add taxes, fees, etc. later

    return {
      items: calculatedItems,
      subtotal,
      total
    };
  }

  /**
   * Calculate a single order item
   */
  private static async calculateSingleItem(item: BaseOrderItem): Promise<CalculatedOrderItem> {
    logger.info("Processing item:", JSON.stringify(item, null, 2));

    let product, productVariant;
    let itemPrice = 0;
    
    logger.info(`Starting calculation for item with productId: ${item.productId}, variantId: ${item.productVariantId}`);

    // Get product and variant
    if (item.productId) {
      product = await prisma.product.findUnique({
        where: { id: item.productId }
      });

      if (!product) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Product not found: ${item.productId}`, { metadata: { productId: item.productId } });
      }
      
      // Validate that products with variants must have a variant selected
      if (product.hasVariants && !item.productVariantId) {
        // Get available variants for this product
        const variants = await prisma.productVariant.findMany({
          where: { 
            productId: product.id,
            isActive: true 
          },
          select: {
            id: true,
            name: true
          }
        });
        throw new ValidationError(
          ErrorCode.INVALID_PRODUCT, 
          `El producto "${product.name}" requiere seleccionar una variante`, 
          { 
            metadata: { 
              productId: item.productId,
              productName: product.name,
              validationFailure: 'MISSING_REQUIRED_VARIANT',
              availableVariants: variants,
              requiresVariant: true
            } 
          }
        );
      }
    }

    if (item.productVariantId) {
      productVariant = await prisma.productVariant.findUnique({
        where: { id: item.productVariantId },
        include: { product: true }
      });

      if (!productVariant) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Product variant not found: ${item.productVariantId}`, { metadata: { productVariantId: item.productVariantId } });
      }

      product = productVariant.product;
      itemPrice = productVariant.price;
      logger.info(`Found variant ${productVariant.name} with price: ${productVariant.price}`);
    } else if (product && product.price !== null) {
      // If no variant but product has price, use product price
      itemPrice = product.price;
      logger.info(`Using product price: ${product.price}`);
    }

    if (!product && !productVariant) {
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        'Either productId or productVariantId must be provided',
        { metadata: { item } }
      );
    }

    // Calculate modifiers
    const modifiers = await this.calculateModifiers(item.selectedModifiers || [], product?.id);
    itemPrice += modifiers.totalPrice;

    // Calculate pizza customizations and extra costs
    const { customizations, extraCost } = await this.calculatePizzaCustomizations(
      item.selectedPizzaCustomizations || [],
      product
    );
    
    // Add pizza extra cost to item price
    itemPrice += extraCost;

    // Total item price
    itemPrice = itemPrice * item.quantity;
    
    logger.info(`Final item price after quantity (${item.quantity}): ${itemPrice}`);

    // At this point, product is guaranteed to exist due to validation above
    if (!product) {
      throw new ValidationError(ErrorCode.INVALID_PRODUCT, 'Product not found');
    }

    // Build the calculated item with only necessary data
    const calculatedItem: CalculatedOrderItem = {
      productId: product.id,
      productVariantId: productVariant?.id || null,
      quantity: item.quantity,
      comments: item.comments,
      selectedModifiers: item.selectedModifiers,
      selectedPizzaCustomizations: item.selectedPizzaCustomizations,
      // Pricing information
      basePrice: productVariant?.price || product.price || 0,
      modifiersPrice: modifiers.totalPrice,
      unitPrice: (productVariant?.price || product.price || 0) + modifiers.totalPrice + extraCost,
      totalPrice: itemPrice,
      // Display information
      productName: product.name,
      variantName: productVariant?.name || null,
      // Add modifier names for display
      modifierNames: modifiers.items.map((mod: any) => mod.name),
      // Add pizza customization details for display
      pizzaCustomizationDetails: customizations.map((cust: any) => ({
        pizzaCustomizationId: cust.id,
        name: cust.name,
        type: cust.type,
        half: item.selectedPizzaCustomizations?.find(sc => sc.pizzaCustomizationId === cust.id)?.half || 'FULL',
        action: item.selectedPizzaCustomizations?.find(sc => sc.pizzaCustomizationId === cust.id)?.action || 'ADD'
      }))
    };

    return calculatedItem;
  }

  /**
   * Calculate modifiers for a product
   */
  private static async calculateModifiers(
    selectedModifierIds: string[],
    productId?: string
  ): Promise<{ items: any[]; totalPrice: number }> {
    if (!selectedModifierIds.length) {
      return { items: [], totalPrice: 0 };
    }

    const modifiers = await prisma.productModifier.findMany({
      where: { 
        id: { in: selectedModifierIds }
      },
      include: { modifierGroup: true }
    });

    // Validate all modifiers were found
    if (modifiers.length !== selectedModifierIds.length) {
      const foundIds = modifiers.map((m: any) => m.id);
      const notFoundIds = selectedModifierIds.filter(id => !foundIds.includes(id));
      
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        `Modifiers not found: ${notFoundIds.join(', ')}`,
        { metadata: { notFoundIds, productId } }
      );
    }

    // Group by modifier group and validate
    const modifiersByGroup = modifiers.reduce((acc: any, mod: any) => {
      const groupId = mod.modifierGroup.id;
      if (!acc[groupId]) {
        acc[groupId] = {
          group: mod.modifierGroup,
          modifiers: []
        };
      }
      acc[groupId].modifiers.push(mod);
      return acc;
    }, {} as Record<string, { group: any; modifiers: any[] }>);

    // Validate modifier selection rules
    for (const groupData of Object.values(modifiersByGroup)) {
      const { group, modifiers: groupModifiers } = groupData as { group: any; modifiers: any[] };
      if (group.required && groupModifiers.length === 0) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Required modifier group ${group.name} must have at least one selection`, { metadata: { modifierGroupName: group.name } });
      }

      if (!group.acceptsMultiple && groupModifiers.length > 1) {
        throw new ValidationError(ErrorCode.INVALID_PRODUCT, `Modifier group ${group.name} only accepts one selection`, { metadata: { modifierGroupName: group.name, selectedCount: groupModifiers.length } });
      }
    }

    const totalPrice = modifiers.reduce((sum: number, mod: any) => sum + mod.price, 0);

    return {
      items: modifiers,
      totalPrice
    };
  }

  /**
   * Calculate pizza customizations and extra costs
   */
  private static async calculatePizzaCustomizations(
    selectedCustomizations: Array<{
      pizzaCustomizationId: string;
      half: string;
      action: string;
    }>,
    product: any | null
  ): Promise<{ customizations: any[]; extraCost: number }> {
    if (!selectedCustomizations.length || !product?.isPizza) {
      return { customizations: [], extraCost: 0 };
    }

    // Get pizza configuration
    const pizzaConfig = await prisma.pizzaConfiguration.findUnique({
      where: { productId: product.id }
    });

    if (!pizzaConfig) {
      logger.warn(`No pizza configuration found for product ${product.id}`);
      return { customizations: [], extraCost: 0 };
    }

    const customizationIds = selectedCustomizations.map(c => c.pizzaCustomizationId);
    const customizations = await prisma.pizzaCustomization.findMany({
      where: {
        id: { in: customizationIds },
        products: { some: { id: product.id } }
      }
    });

    // Validate all customizations were found
    if (customizations.length !== customizationIds.length) {
      const foundIds = customizations.map(c => c.id);
      const notFoundIds = customizationIds.filter(id => !foundIds.includes(id));
      
      throw new ValidationError(
        ErrorCode.INVALID_PRODUCT,
        `Pizza customizations not found: ${notFoundIds.join(', ')}`,
        { metadata: { notFoundIds, productId: product.id } }
      );
    }

    // Calculate total topping value for ADD actions only
    let totalToppingValue = 0;
    const mappedCustomizations = selectedCustomizations.map(selected => {
      const customization = customizations.find(c => c.id === selected.pizzaCustomizationId);
      
      if (selected.action === 'ADD' && customization) {
        if (selected.half === 'FULL') {
          totalToppingValue += customization.toppingValue;
        } else {
          // Half pizza counts as half the topping value
          totalToppingValue += customization.toppingValue / 2;
        }
      }
      
      return {
        ...customization,
        half: selected.half,
        action: selected.action
      };
    });

    // Calculate extra cost if toppings exceed included amount
    let extraCost = 0;
    if (totalToppingValue > pizzaConfig.includedToppings) {
      const extraToppings = totalToppingValue - pizzaConfig.includedToppings;
      extraCost = extraToppings * pizzaConfig.extraToppingCost;
      logger.info(`Pizza extra cost: ${extraCost} (${extraToppings} extra toppings at ${pizzaConfig.extraToppingCost} each)`);
    }

    return {
      customizations: mappedCustomizations,
      extraCost
    };
  }
  
}

================
File: backend/src/services/payment/StripeService.ts
================
import { Request, Response } from 'express';
import Stripe from 'stripe';
import logger from '../../common/utils/logger';
import { env } from '../../common/config/envValidator';
import { ExternalServiceError, ValidationError, ErrorCode } from '../../common/services/errors';
import { prisma } from '../../lib/prisma';

/**
 * Service for handling Stripe payment operations
 */
export class StripeService {
  private static stripe: Stripe | null = null;
  private static webhookSecret: string = '';
  private static initialized = false;

  /**
   * Initialize Stripe client (lazy initialization)
   */
  private static initialize(): void {
    if (this.initialized) {
      return;
    }

    try {
      const stripeKey = env.STRIPE_SECRET_KEY;
      if (stripeKey) {
        this.stripe = new Stripe(stripeKey, {
          apiVersion: '2024-10-28.acacia'
        });
        this.webhookSecret = env.STRIPE_WEBHOOK_SECRET || '';
        logger.info('Stripe service initialized');
      } else {
        logger.warn('Stripe service not configured - missing STRIPE_SECRET_KEY');
      }
    } catch (error) {
      logger.error('Failed to initialize Stripe service:', error);
    } finally {
      this.initialized = true;
    }
  }

  /**
   * Check if Stripe is configured
   */
  static isConfigured(): boolean {
    this.initialize();
    return this.stripe !== null;
  }

  /**
   * Handle Stripe webhook
   */
  static async handleWebhook(req: Request, res: Response): Promise<void> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured'
      );
    }
    
    const sig = req.headers['stripe-signature'] as string;
    
    let event: Stripe.Event;
    
    try {
      event = this.stripe.webhooks.constructEvent(req.body, sig, this.webhookSecret);
    } catch (err: any) {
      throw new ValidationError(
        ErrorCode.WEBHOOK_VERIFICATION_FAILED,
        `Webhook signature verification failed: ${err.message}`
      );
    }
    
    // Handle the event
    switch (event.type) {
      case 'checkout.session.completed':
        const session = event.data.object as Stripe.Checkout.Session;
        await this.handleCompletedCheckout(session);
        break;
        
      case 'payment_intent.succeeded':
        const paymentIntent = event.data.object as Stripe.PaymentIntent;
        logger.info('Payment succeeded:', paymentIntent.id);
        break;
        
      default:
        logger.info(`Unhandled event type ${event.type}`);
    }
    
    res.json({ received: true });
  }

  /**
   * Handle completed checkout session
   */
  private static async handleCompletedCheckout(session: Stripe.Checkout.Session): Promise<void> {
    logger.info('Checkout session completed:', session.id);
    
    if (session.metadata?.orderId) {
      // Find existing payment record with this session ID
      const existingPayment = await prisma.payment.findFirst({
        where: {
          orderId: session.metadata.orderId,
          stripePaymentId: session.id
        }
      });
      
      if (existingPayment) {
        // Update existing payment to PAID
        await prisma.payment.update({
          where: { id: existingPayment.id },
          data: {
            status: 'PAID',
            stripePaymentId: session.payment_intent as string,
            metadata: {
              sessionId: session.id,
              customerEmail: session.customer_details?.email,
              completedAt: new Date().toISOString()
            }
          }
        });
      } else {
        // This shouldn't happen as payment should be created when session starts
        // But create it just in case
        await prisma.payment.create({
          data: {
            orderId: session.metadata.orderId,
            amount: session.amount_total! / 100, // Convert from cents
            paymentMethod: 'STRIPE',
            status: 'PAID',
            stripePaymentId: session.payment_intent as string,
            metadata: {
              sessionId: session.id,
              customerEmail: session.customer_details?.email
            }
          }
        });
      }
      
      logger.info(`Order ${session.metadata.orderId} payment recorded`);
    }
  }

  /**
   * Create a checkout session for an order
   */
  static async createCheckoutSession(
    orderId: number, 
    amount: number, 
    customerPhone: string
  ): Promise<Stripe.Checkout.Session> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured',
        { metadata: { orderId } }
      );
    }

    try {
      const session = await this.stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [{
          price_data: {
            currency: 'mxn',
            product_data: {
              name: `Orden #${orderId}`,
              description: 'Pedido de establecimiento'
            },
            unit_amount: Math.round(amount * 100) // Convert to cents
          },
          quantity: 1
        }],
        mode: 'payment',
        success_url: `${env.FRONTEND_BASE_URL}/success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${env.FRONTEND_BASE_URL}/cancel`,
        metadata: {
          orderId: orderId.toString(),
          customerPhone
        }
      });
      
      logger.info(`Created checkout session ${session.id} for order ${orderId}`);
      return session;
    } catch (error) {
      logger.error('Error creating checkout session:', error);
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Failed to create checkout session',
        { metadata: { orderId, amount } }
      );
    }
  }

  /**
   * Get checkout session by ID
   */
  static async getCheckoutSession(sessionId: string): Promise<Stripe.Checkout.Session | null> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured',
        { metadata: { sessionId } }
      );
    }

    try {
      const session = await this.stripe.checkout.sessions.retrieve(sessionId);
      return session;
    } catch (error) {
      logger.error('Error retrieving checkout session:', error);
      return null;
    }
  }

  /**
   * Cancel payment intent
   */
  static async cancelPaymentIntent(paymentIntentId: string): Promise<void> {
    this.initialize();
    
    if (!this.stripe) {
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Stripe service is not configured',
        { metadata: { paymentIntentId } }
      );
    }

    try {
      await this.stripe.paymentIntents.cancel(paymentIntentId);
      logger.info(`Cancelled payment intent ${paymentIntentId}`);
    } catch (error) {
      logger.error('Error cancelling payment intent:', error);
      throw new ExternalServiceError(
        ErrorCode.STRIPE_ERROR,
        'Failed to cancel payment intent',
        { metadata: { paymentIntentId } }
      );
    }
  }
}

================
File: backend/src/services/sync/SyncMetadataService.ts
================
import { prisma } from '../../server';
import logger from '../../common/utils/logger';

export type SyncEntityType = 'Order' | 'Customer' | 'Address' | 'Product' | 'Category';
export type ModifiedBy = 'LOCAL' | 'REMOTE';

export class SyncMetadataService {
  /**
   * Mark an entity for synchronization
   */
  static async markForSync(
    entityType: SyncEntityType,
    entityId: string,
    modifiedBy: ModifiedBy = 'REMOTE'
  ): Promise<void> {
    try {
      await prisma.syncMetadata.upsert({
        where: {
          entityType_entityId: { entityType, entityId }
        },
        create: {
          entityType,
          entityId,
          modifiedBy,
          syncPending: true
        },
        update: {
          modifiedBy,
          syncPending: true,
          syncVersion: { increment: 1 }
        }
      });
      
      logger.debug(`Marked ${entityType}:${entityId} for sync by ${modifiedBy}`);
    } catch (error) {
      logger.error(`Error marking entity for sync: ${entityType}:${entityId}`, error);
      throw error;
    }
  }

  /**
   * Mark multiple entities as synced
   */
  static async markAsSynced(
    entities: Array<{ entityType: SyncEntityType; entityId: string }>
  ): Promise<void> {
    try {
      const updates = entities.map(({ entityType, entityId }) =>
        prisma.syncMetadata.update({
          where: {
            entityType_entityId: { entityType, entityId }
          },
          data: {
            syncPending: false
          }
        })
      );
      
      await prisma.$transaction(updates);
      
      logger.debug(`Marked ${entities.length} entities as synced`);
    } catch (error) {
      logger.error('Error marking entities as synced', error);
      throw error;
    }
  }

  /**
   * Get entities pending synchronization
   */
  static async getPendingSync(
    entityType: SyncEntityType,
    limit: number = 100
  ): Promise<Array<{ entityId: string; lastModifiedAt: Date; modifiedBy: string }>> {
    const pending = await prisma.syncMetadata.findMany({
      where: {
        entityType,
        syncPending: true
      },
      orderBy: {
        lastModifiedAt: 'asc'
      },
      take: limit
    });
    
    return pending.map(p => ({
      entityId: p.entityId,
      lastModifiedAt: p.lastModifiedAt,
      modifiedBy: p.modifiedBy
    }));
  }

  /**
   * Get sync status for a specific entity
   */
  static async getSyncStatus(
    entityType: SyncEntityType,
    entityId: string
  ): Promise<{
    exists: boolean;
    syncPending: boolean;
    lastModifiedAt: Date | null;
    modifiedBy: string | null;
    syncVersion: number;
  }> {
    const metadata = await prisma.syncMetadata.findUnique({
      where: {
        entityType_entityId: { entityType, entityId }
      }
    });
    
    if (!metadata) {
      return {
        exists: false,
        syncPending: false,
        lastModifiedAt: null,
        modifiedBy: null,
        syncVersion: 0
      };
    }
    
    return {
      exists: true,
      syncPending: metadata.syncPending,
      lastModifiedAt: metadata.lastModifiedAt,
      modifiedBy: metadata.modifiedBy,
      syncVersion: metadata.syncVersion
    };
  }

  /**
   * Get entities modified since a specific date
   */
  static async getModifiedSince(
    entityType: SyncEntityType,
    since: Date,
    modifiedBy?: ModifiedBy
  ): Promise<string[]> {
    const where: any = {
      entityType,
      lastModifiedAt: { gt: since }
    };
    
    if (modifiedBy) {
      where.modifiedBy = modifiedBy;
    }
    
    const modified = await prisma.syncMetadata.findMany({
      where,
      select: {
        entityId: true
      }
    });
    
    return modified.map(m => m.entityId);
  }

  /**
   * Initialize sync metadata for existing entities
   * Used during migration from old system
   */
  static async initializeForExistingEntities(): Promise<void> {
    logger.info('Initializing sync metadata for existing entities...');
    
    // Initialize for existing customers
    const customers = await prisma.customer.findMany({
      select: { id: true }
    });
    
    for (const customer of customers) {
      await this.markForSync('Customer', customer.id, 'REMOTE');
    }
    
    // Initialize for existing orders
    const orders = await prisma.order.findMany({
      select: { id: true }
    });
    
    for (const order of orders) {
      await this.markForSync('Order', order.id, 'REMOTE');
    }
    
    // Initialize for existing addresses
    const addresses = await prisma.address.findMany({
      select: { id: true }
    });
    
    for (const address of addresses) {
      await this.markForSync('Address', address.id, 'REMOTE');
    }
    
    // Mark all as already synced (they're existing data)
    await prisma.syncMetadata.updateMany({
      data: { syncPending: false }
    });
    
    logger.info('Sync metadata initialization completed');
  }

  /**
   * Clean up orphaned sync metadata
   */
  static async cleanupOrphaned(): Promise<number> {
    // This would need to check each entity type
    // For now, just return 0
    logger.warn('Orphaned sync metadata cleanup not implemented yet');
    return 0;
  }
}

================
File: frontend-app/src/hooks/useAddressQueries.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { addressApi } from '../api/addressApi';
import type { 
  VerifyOtpParams
} from '../api/addressApi';

// Query keys
export const addressQueryKeys = {
  all: ['addresses'] as const,
  verifyOtp: (whatsappPhoneNumber: string, otp: string) => 
    ['addresses', 'verify-otp', whatsappPhoneNumber, otp] as const,
  deliveryArea: ['addresses', 'delivery-area'] as const,
};

// Queries
export const useVerifyOtp = (params: VerifyOtpParams | null) => {
  return useQuery({
    queryKey: params ? addressQueryKeys.verifyOtp(params.whatsappPhoneNumber, params.otp) : [],
    queryFn: () => params ? addressApi.verifyOtp(params) : Promise.reject('No params'),
    enabled: !!params,
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: false,
  });
};

export const useDeliveryArea = () => {
  return useQuery({
    queryKey: addressQueryKeys.deliveryArea,
    queryFn: addressApi.getDeliveryArea,
    staleTime: 30 * 60 * 1000, // 30 minutes
    retry: 2,
  });
};

// Mutations
export const useCreateAddress = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: addressApi.createAddress,
    onSuccess: (_, variables) => {
      // Invalidate the OTP verification query to refresh customer data
      queryClient.invalidateQueries({
        queryKey: addressQueryKeys.verifyOtp(variables.whatsappPhoneNumber, variables.otp),
      });
    },
  });
};

export const useUpdateAddress = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: addressApi.updateAddress,
    onSuccess: (_, variables) => {
      // Invalidate the OTP verification query to refresh customer data
      queryClient.invalidateQueries({
        queryKey: addressQueryKeys.verifyOtp(variables.whatsappPhoneNumber, variables.otp),
      });
    },
  });
};

export const useDeleteAddress = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: addressApi.deleteAddress,
    onSuccess: (_, variables) => {
      // Invalidate the OTP verification query to refresh customer data
      queryClient.invalidateQueries({
        queryKey: addressQueryKeys.verifyOtp(variables.whatsappPhoneNumber, variables.otp),
      });
    },
  });
};

export const useSetDefaultAddress = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: addressApi.setDefaultAddress,
    onSuccess: (_, variables) => {
      // Invalidate the OTP verification query to refresh customer data
      queryClient.invalidateQueries({
        queryKey: addressQueryKeys.verifyOtp(variables.whatsappPhoneNumber, variables.otp),
      });
    },
  });
};


export const useUpdateCustomerName = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: addressApi.updateCustomerName,
    onSuccess: (_, variables) => {
      // Invalidate the OTP verification query to refresh customer data
      queryClient.invalidateQueries({
        queryKey: addressQueryKeys.verifyOtp(variables.whatsappPhoneNumber, variables.otp),
      });
    },
  });
};

================
File: scripts/quick-deploy.sh
================
#!/bin/bash

# Script de despliegue r√°pido completo
# Autor: Bot Backend Deployment Script  
# Uso: Ejecutar desde un servidor Ubuntu 24.04 LTS limpio
# wget https://raw.githubusercontent.com/viefmoon/bot_backend/main/scripts/quick-deploy.sh && chmod +x quick-deploy.sh && sudo ./quick-deploy.sh

set -e

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Funci√≥n para imprimir con color
print_step() {
    echo -e "\n${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

print_header() {
    echo -e "\n${MAGENTA}==========================================${NC}"
    echo -e "${MAGENTA}$1${NC}"
    echo -e "${MAGENTA}==========================================${NC}\n"
}

# Verificar que se ejecuta como root
if [[ $EUID -ne 0 ]]; then
   print_error "Este script debe ejecutarse como root (usa sudo)"
   exit 1
fi

clear
print_header "BOT BACKEND - INSTALACI√ìN R√ÅPIDA"

# Configuraci√≥n predefinida
APP_USER="cloudbite"
GIT_REPO="https://github.com/viefmoon/bot_backend.git"
DOMAIN="cloudbiteapp.com"
SSL_EMAIL="viefmoon@gmail.com"

echo "Configuraci√≥n de despliegue:"
echo ""
echo "‚Ä¢ Usuario de aplicaci√≥n: $APP_USER"
echo "‚Ä¢ Repositorio: $GIT_REPO"
echo "‚Ä¢ Dominio: $DOMAIN"
echo "‚Ä¢ Email SSL: $SSL_EMAIL"
echo ""
read -p "¬øDeseas continuar con esta configuraci√≥n? (s/n): " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Ss]$ ]]; then
    print_error "Despliegue cancelado"
    exit 1
fi

# Paso 1: Actualizar sistema e instalar dependencias
print_header "PASO 1: INSTALANDO DEPENDENCIAS DEL SISTEMA"

# Configurar para mantener archivos de configuraci√≥n locales durante actualizaciones
export DEBIAN_FRONTEND=noninteractive

apt update
apt upgrade -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold"
apt install -y curl wget git build-essential software-properties-common

# Node.js
curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
apt-get install -y nodejs
print_success "Node.js instalado"

# PostgreSQL
sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add -
apt update
apt install -y postgresql-15 postgresql-contrib-15 postgresql-15-pgvector
print_success "PostgreSQL instalado"

# Redis
apt install -y redis-server
sed -i 's/supervised no/supervised systemd/g' /etc/redis/redis.conf
systemctl restart redis-server
systemctl enable redis-server
print_success "Redis instalado"

# PM2
npm install -g pm2
print_success "PM2 instalado"

# Nginx
apt install -y nginx
print_success "Nginx instalado"

# Certbot
apt install -y certbot python3-certbot-nginx
print_success "Certbot instalado"

# Paso 2: Crear usuario y estructura
print_header "PASO 2: CONFIGURANDO USUARIO Y PROYECTO"

# Crear usuario si no existe
if ! id "$APP_USER" &>/dev/null; then
    adduser --disabled-password --gecos "" $APP_USER
    print_success "Usuario $APP_USER creado"
else
    print_success "Usuario $APP_USER ya existe"
fi

# IMPORTANTE: Asegurar permisos correctos para el directorio home
# Esto permite que Nginx (www-data) pueda acceder a los archivos del frontend
chmod 755 /home/$APP_USER
print_success "Permisos del directorio home configurados"

# Configurar sudoers para PM2
echo "$APP_USER ALL=(ALL) NOPASSWD: /usr/bin/pm2" >> /etc/sudoers.d/pm2

# Paso 3: Configurar base de datos
print_header "PASO 3: CONFIGURANDO BASE DE DATOS"

# Generar contrase√±a segura
DB_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)
DB_USER="bot_user"
DB_NAME="bot_db"

sudo -u postgres psql <<EOF
CREATE USER $DB_USER WITH PASSWORD '$DB_PASSWORD';
CREATE DATABASE $DB_NAME OWNER $DB_USER;
\c $DB_NAME
CREATE EXTENSION IF NOT EXISTS vector;
GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;
EOF

print_success "Base de datos configurada"

# Paso 4: Clonar y configurar aplicaci√≥n
print_header "PASO 4: INSTALANDO APLICACI√ìN"

# Cambiar al usuario de la app
su - $APP_USER <<EOF
# Clonar repositorio
git clone $GIT_REPO ~/bot_backend
cd ~/bot_backend/backend

# Instalar dependencias del backend
npm install --production

# Instalar y construir frontend
cd ../frontend-app
npm install
npm run build || print_warning "Frontend build tuvo errores, pero continuando..."

# Asegurar permisos correctos para el directorio dist del frontend
chmod -R 755 dist/

# Volver al backend y crear archivo .env
cd ../backend
cat > .env <<ENV_FILE
# Base de datos
DATABASE_URL=postgresql://$DB_USER:$DB_PASSWORD@localhost:5432/$DB_NAME

# Google AI - ACTUALIZAR
GOOGLE_AI_API_KEY=ACTUALIZAR_CON_TU_API_KEY
GEMINI_MODEL=gemini-2.5-pro
EMBEDDING_MODEL=text-embedding-004

# WhatsApp Business API - ACTUALIZAR
WHATSAPP_PHONE_NUMBER_MESSAGING_ID=ACTUALIZAR_CON_TU_ID
WHATSAPP_ACCESS_TOKEN=ACTUALIZAR_CON_TU_TOKEN
WHATSAPP_VERIFY_TOKEN=ACTUALIZAR_CON_TU_VERIFY_TOKEN

# URLs de producci√≥n
FRONTEND_BASE_URL=https://$DOMAIN
NODE_ENV=production
PORT=5000

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# Workers
BULLMQ_WORKER_CONCURRENCY=10
NUM_WORKERS=2

# Cloud API
CLOUD_API_KEY=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)

# Configuraci√≥n regional
DEFAULT_TIMEZONE=America/Mexico_City
DEFAULT_LOCALE=es-MX

# Rate limiting
RATE_LIMIT_MAX_MESSAGES=30
RATE_LIMIT_TIME_WINDOW_MINUTES=5
ENV_FILE

# Generar Prisma client
npm run generate

# Compilar (permitir continuar si hay errores de tipos)
npm run build || print_warning "Build del backend tuvo errores de tipos, pero continuando..."

# Configurar PM2
pm2 startup systemd -u $APP_USER --hp /home/$APP_USER || true
EOF

print_success "Aplicaci√≥n instalada"

# Paso 5: Configurar Nginx
print_header "PASO 5: CONFIGURANDO NGINX"

cat > /etc/nginx/sites-available/bot-backend <<NGINX_CONF
server {
    listen 80;
    server_name $DOMAIN;

    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_cache_bypass \$http_upgrade;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        
        # Timeouts para WhatsApp
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    location /webhook {
        proxy_pass http://localhost:5000/webhook;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        
        proxy_buffering off;
        proxy_request_buffering off;
    }
}
NGINX_CONF

ln -sf /etc/nginx/sites-available/bot-backend /etc/nginx/sites-enabled/
nginx -t
systemctl reload nginx

print_success "Nginx configurado"

# Paso 6: Configurar SSL
print_header "PASO 6: CONFIGURANDO SSL"

certbot --nginx -d $DOMAIN --email $SSL_EMAIL --agree-tos --non-interactive

print_success "SSL configurado"

# Paso 7: Configurar firewall
print_header "PASO 7: CONFIGURANDO FIREWALL"

ufw allow 22/tcp
ufw allow 80/tcp
ufw allow 443/tcp
ufw --force enable

print_success "Firewall configurado"

# Crear script de informaci√≥n
cat > /home/$APP_USER/deployment_info.txt <<INFO
==========================================
INFORMACI√ìN DE DESPLIEGUE - BOT BACKEND
==========================================

DOMINIO: https://$DOMAIN

BASE DE DATOS:
- Usuario: $DB_USER
- Contrase√±a: $DB_PASSWORD
- Base de datos: $DB_NAME
- Connection String: postgresql://$DB_USER:$DB_PASSWORD@localhost:5432/$DB_NAME

APLICACI√ìN:
- Usuario: $APP_USER
- Directorio: /home/$APP_USER/bot_backend
- Puerto: 5000

IMPORTANTE - PR√ìXIMOS PASOS:
1. Editar /home/$APP_USER/bot_backend/backend/.env con tus credenciales reales:
   - GOOGLE_AI_API_KEY
   - WHATSAPP_PHONE_NUMBER_MESSAGING_ID
   - WHATSAPP_ACCESS_TOKEN
   - WHATSAPP_VERIFY_TOKEN

2. Ejecutar migraciones:
   su - $APP_USER
   cd ~/bot_backend/backend
   npm run migrate
   npm run seed:embeddings (opcional)

3. Iniciar la aplicaci√≥n:
   npm run pm2:start

4. Verificar logs:
   pm2 logs

COMANDOS √öTILES:
- Ver estado: pm2 status
- Reiniciar: pm2 restart all
- Ver logs: pm2 logs
- Actualizar: cd ~/bot_backend && git pull && cd backend && npm install && npm run build && pm2 reload all

==========================================
INFO

chown $APP_USER:$APP_USER /home/$APP_USER/deployment_info.txt
chmod 600 /home/$APP_USER/deployment_info.txt

# Resumen final
print_header "¬°INSTALACI√ìN COMPLETADA!"

echo -e "${GREEN}La instalaci√≥n base se ha completado exitosamente.${NC}"
echo ""
echo -e "${YELLOW}IMPORTANTE - Acciones requeridas:${NC}"
echo ""
echo "1. Con√©ctate como el usuario de la aplicaci√≥n:"
echo -e "   ${BLUE}su - $APP_USER${NC}"
echo ""
echo "2. Edita el archivo .env con tus credenciales:"
echo -e "   ${BLUE}cd ~/bot_backend/backend && nano .env${NC}"
echo ""
echo "3. Ejecuta las migraciones de base de datos:"
echo -e "   ${BLUE}npm run migrate${NC}"
echo ""
echo "4. Inicia la aplicaci√≥n:"
echo -e "   ${BLUE}npm run pm2:start${NC}"
echo ""
echo "5. Configura el webhook en Meta Business:"
echo -e "   URL: ${GREEN}https://$DOMAIN/webhook${NC}"
echo ""
echo -e "${YELLOW}La informaci√≥n de despliegue se guard√≥ en:${NC}"
echo -e "${BLUE}/home/$APP_USER/deployment_info.txt${NC}"
echo ""
echo -e "${GREEN}¬°Tu servidor est√° listo!${NC}"

================
File: backend/src/common/types/index.ts
================
/**
 * Central type export file
 * All common types should be imported from here
 */

// Order types
export * from './order.types';
export * from './order-item.types';
export * from './preorder.types';

// Menu types
export * from './menu';

// Restaurant types
export * from './restaurant';

// WhatsApp & Message types
export * from './whatsapp-messages.types';

// Response types are now in messaging/types/responses

// Agent types removed - using unified agent now

// Service types
export * from './services.types';

// Re-export commonly used Prisma types
export type {
  Customer,
  Order,
  OrderType,
  OrderStatus,
  Product,
  ProductVariant,
  Category,
  Subcategory,
  ProductModifier,
  ModifierGroup,
  PizzaCustomization,
  PizzaConfiguration,
  PizzaHalf,
  CustomizationAction,
  CustomizationType,
  PreOrder,
  RestaurantConfig,
  BusinessHours
} from '@prisma/client';

================
File: backend/src/services/messaging/pipeline/MessagePipeline.ts
================
import { IncomingMessage, MessageMiddleware, UnifiedResponse } from '../types';
import { MessageContext } from '../MessageContext';
import { RateLimitMiddleware } from '../middlewares/RateLimitMiddleware';
import { CustomerValidationMiddleware } from '../middlewares/CustomerValidationMiddleware';
import { RestaurantHoursMiddleware } from '../middlewares/RestaurantHoursMiddleware';
import { AddressRequiredMiddleware } from '../middlewares/AddressRequiredMiddleware';
import { MessageTypeMiddleware } from '../middlewares/MessageTypeMiddleware';
import { MessageProcessingMiddleware } from '../middlewares/MessageProcessingMiddleware';
import { prisma } from '../../../lib/prisma';
import { CONTEXT_KEYS } from '../../../common/constants';
import logger from '../../../common/utils/logger';
import { sendWhatsAppMessage, sendWhatsAppInteractiveMessage, sendMessageWithUrlButton } from '../../whatsapp';
import { SyncMetadataService } from '../../../services/sync/SyncMetadataService';

export class MessagePipeline {
  private middlewares: MessageMiddleware[] = [];
  
  constructor() {
    // Inicializar middlewares en orden
    this.middlewares = [
      new RateLimitMiddleware(),
      new CustomerValidationMiddleware(),
      new RestaurantHoursMiddleware(), // Verifica horarios antes de cualquier procesamiento
      new AddressRequiredMiddleware(), // Bloquea si no hay direcci√≥n
      new MessageTypeMiddleware(),
      new MessageProcessingMiddleware(), // L√≥gica principal de procesamiento
    ];
  }

  async process(message: IncomingMessage): Promise<void> {
    const context = new MessageContext(message);
    
    try {
      // Ejecutar todos los middlewares
      for (const middleware of this.middlewares) {
        await middleware.process(context);
        
        if (context.shouldStop) {
          break;
        }
      }
      
      // El procesamiento ahora se maneja por middlewares
      
      // Enviar respuestas
      await this.sendResponses(context);
      
      // Actualizar historial de chat del cliente
      await this.updateChatHistory(context);
      
    } catch (error) {
      logger.error('Error in MessagePipeline:', error);
      await this.handleError(context, error as Error);
    }
  }
  
  
  private async sendResponses(context: MessageContext): Promise<void> {
    // Enviar solo las respuestas que deben enviarse
    for (const response of context.unifiedResponses) {
      if (!response.metadata.shouldSend) continue;
      
      try {
        // Enviar bot√≥n con URL si existe
        if (response.content?.urlButton) {
          const { title, body, buttonText, url } = response.content.urlButton;
          await sendMessageWithUrlButton(
            context.message.from,
            title,
            body,
            buttonText,
            url
          );
        }
        // Enviar texto si existe
        else if (response.content?.text) {
          // La utilidad messageSender se encarga de dividir mensajes largos autom√°ticamente
          await sendWhatsAppMessage(context.message.from, response.content.text);
        }
        // Enviar mensaje interactivo si existe
        else if (response.content?.interactive) {
          await sendWhatsAppInteractiveMessage(
            context.message.from, 
            response.content.interactive
          );
        }
      } catch (error) {
        logger.error('Error sending response:', error);
      }
    }
  }
  
  private async updateChatHistory(context: MessageContext): Promise<void> {
    if (!context.customer || context.shouldStop) return;
    
    // Si se marca skipHistoryUpdate, no guardar nada en el historial
    if (context.get(CONTEXT_KEYS.SKIP_HISTORY_UPDATE)) {
      logger.debug('Skipping history update due to skipHistoryUpdate flag');
      return;
    }
    
    const fullChatHistory = context.get(CONTEXT_KEYS.FULL_CHAT_HISTORY) || [];
    let relevantChatHistory = context.get(CONTEXT_KEYS.RELEVANT_CHAT_HISTORY) || [];
    
    // Agregar mensaje del usuario al historial
    fullChatHistory.push({
      role: 'user',
      content: context.message.text?.body || '[Non-text message]',
      timestamp: new Date()
    });
    
    // Siempre agregar al historial relevante
    relevantChatHistory.push({
      role: 'user',
      content: context.message.text?.body || '[Non-text message]',
      timestamp: new Date()
    });
    
    // Agregar respuestas al historial usando la l√≥gica unificada
    for (const response of context.unifiedResponses) {
      const textContent = response.content?.text;
      const historyMarker = response.metadata.historyMarker;
      const isRelevant = response.metadata.isRelevant;
      
      // Para el historial completo, siempre usar el texto completo si existe
      if (textContent) {
        fullChatHistory.push({
          role: 'assistant',
          content: textContent,
          timestamp: new Date()
        });
      }
      
      // Para el historial relevante, aplicar las reglas de prioridad:
      // 1. Si hay historyMarker, usarlo siempre
      // 2. Si no hay historyMarker pero isRelevant es true, usar el texto
      // 3. Si isRelevant es false y no hay historyMarker, no guardar
      if (historyMarker || (isRelevant && textContent)) {
        const contentToSave = historyMarker || textContent;
        relevantChatHistory.push({
          role: 'assistant',
          content: contentToSave!,
          timestamp: new Date()
        });
      }
    }
    
    // Limitar el historial relevante a los √∫ltimos 20 mensajes antes de guardar
    if (relevantChatHistory.length > 20) {
      relevantChatHistory = relevantChatHistory.slice(-20);
    }
    
    // Actualizar cliente en la base de datos
    await prisma.customer.update({
      where: { id: context.customer.id },
      data: {
        fullChatHistory: JSON.stringify(fullChatHistory),
        relevantChatHistory: JSON.stringify(relevantChatHistory),
        lastInteraction: new Date()
      }
    });
    
    // Mark for sync
    await SyncMetadataService.markForSync('Customer', context.customer.id, 'REMOTE');
  }
  
  private async handleError(context: MessageContext, error: Error): Promise<void> {
    logger.error('Pipeline error:', error);
    
    try {
      await sendWhatsAppMessage(
        context.message.from,
        'Lo siento, ocurri√≥ un error procesando tu mensaje. Por favor intenta de nuevo.'
      );
    } catch (sendError) {
      logger.error('Error sending error message:', sendError);
    }
  }
  
  // M√©todo para agregar middlewares personalizados
  addMiddleware(middleware: MessageMiddleware, index?: number): void {
    if (index !== undefined) {
      this.middlewares.splice(index, 0, middleware);
    } else {
      this.middlewares.push(middleware);
    }
  }
  
}

================
File: backend/src/services/messaging/TextProcessingService.ts
================
import { MessageContext } from './MessageContext';
import { AgentService } from '../ai';
import { PreOrderWorkflowService } from '../orders/PreOrderWorkflowService';
import { sendWhatsAppMessage } from '../whatsapp';
import { getToolHandler } from '../ai/tools/toolHandlers';
import { ResponseBuilder, ResponseType, UnifiedResponse } from './types/responses';
import { CONTEXT_KEYS } from '../../common/constants';
import logger from '../../common/utils/logger';
import { ProcessedOrderData } from '../../common/types/preorder.types';
import { ValidationError, BusinessLogicError, TechnicalError, ErrorCode } from '../../common/services/errors';

// Type definition for content
interface Content {
  role: 'user' | 'model';
  parts: Array<{ text: string }>;
}

export class TextProcessingService {
  /**
   * Process text input through the AI agent system
   * This can be called by any strategy that needs to process text
   */
  static async processTextMessage(
    text: string,
    context: MessageContext
  ): Promise<void> {
    if (!context.customer) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer not found in context'
      );
    }

    let relevantChatHistory = context.get(CONTEXT_KEYS.RELEVANT_CHAT_HISTORY) || [];
    
    // Create a working copy that includes the current message
    const workingHistory = [...relevantChatHistory];
    workingHistory.push({ role: "user", content: text });
    
    try {
      // Process with AI - use workingHistory that includes the current message
      const messages: Content[] = workingHistory.map(
        ({ role, content }: any) => ({
          role: role === "assistant" ? "model" : role,
          parts: [{ text: content }]
        })
      );
      
      logger.debug('Calling AgentService.processMessage with messages:', messages);
      const response = await AgentService.processMessage(messages);
      logger.debug('AgentService response:', JSON.stringify(response, null, 2));
      
      // Process Gemini response and get UnifiedResponses
      const unifiedResponses = await this.processGeminiResponse(response, context);
      
      // Process unified responses
      for (const unifiedResponse of unifiedResponses) {
        // Add response to context
        context.addUnifiedResponse(unifiedResponse);
        
        // Handle special cases
        if (unifiedResponse.processedData) {
          await this.handlePreprocessedContent(context, unifiedResponse.processedData);
        }
      }
    } catch (error) {
      logger.error("Error processing text message:", error);
      const errorResponse = ResponseBuilder.error(
        'PROCESSING_ERROR',
        "Error al procesar la solicitud: " + (error as Error).message
      );
      context.addUnifiedResponse(errorResponse);
    }
  }

  private static async handlePreprocessedContent(context: MessageContext, preprocessedContent: any): Promise<void> {
    try {
      // Handle warnings
      if (preprocessedContent.warnings && preprocessedContent.warnings.length > 0) {
        const warningMessage = "üìù Observaciones:\n" + preprocessedContent.warnings.join("\n");
        await sendWhatsAppMessage(context.message.from, warningMessage);
        
        // Add observations to context so they're saved in relevant history
        const warningResponse = ResponseBuilder.text(warningMessage, true);
        warningResponse.metadata.shouldSend = false; // Already sent with sendWhatsAppMessage
        context.addUnifiedResponse(warningResponse);
      }
      
      // Prepare order data
      const orderData: ProcessedOrderData = {
        orderItems: preprocessedContent.orderItems,
        orderType: preprocessedContent.orderType,
        scheduledAt: preprocessedContent.scheduledAt,
      };
      
      // Use the PreOrderWorkflowService
      const workflowResult = await PreOrderWorkflowService.createAndNotify({
        orderData,
        customerId: context.customer!.id,
        whatsappNumber: context.message.from,
      });
      
      // Store the action token in context for potential tracking
      context.set(CONTEXT_KEYS.LAST_PREORDER_TOKEN, workflowResult.actionToken);
      
      // Mark that interactive response was already sent by the workflow
      context.set(CONTEXT_KEYS.INTERACTIVE_RESPONSE_SENT, true);
    } catch (error: any) {
      logger.error('Error creating preorder:', error);
      
      // For known business errors, use the direct message
      if (error instanceof BusinessLogicError || error instanceof ValidationError) {
        const businessErrorResponse = ResponseBuilder.error(
          error.code || 'BUSINESS_ERROR',
          error.message
        );
        context.addUnifiedResponse(businessErrorResponse);
        return;
      }
      
      // For other errors, use generic message
      const genericMessage = error instanceof TechnicalError 
        ? 'Lo siento, hubo un problema t√©cnico. Por favor intenta de nuevo m√°s tarde.'
        : 'Lo siento, hubo un error al procesar tu pedido. Por favor intenta de nuevo.';
      
      const genericErrorResponse = ResponseBuilder.error(
        'GENERIC_ERROR',
        genericMessage
      );
      context.addUnifiedResponse(genericErrorResponse);
    }
  }

  /**
   * Process Gemini API response and extract meaningful content
   * This method is public so it can be used by tool handlers that need it
   */
  public static async processGeminiResponse(response: any, context?: MessageContext): Promise<UnifiedResponse[]> {
    logger.debug('=== processGeminiResponse DEBUG ===');
    logger.debug('Response type:', typeof response);
    logger.debug('Response keys:', response ? Object.keys(response) : 'null');
    
    const responses: UnifiedResponse[] = [];
    
    // Verify valid response structure
    if (!response?.candidates?.[0]?.content?.parts) {
      logger.error('Invalid response structure from Gemini API');
      
      const errorMessage = response?.error?.message || 
                          response?.candidates?.[0]?.finishReason || 
                          "Lo siento, hubo un problema al procesar tu solicitud. Por favor intenta de nuevo.";
      
      return [ResponseBuilder.error('GEMINI_ERROR', errorMessage)];
    }
    
    const parts = response.candidates[0].content.parts;
    
    // Process each part of the response
    for (const part of parts) {
      if (part.text) {
        // Simple text response
        responses.push(ResponseBuilder.text(part.text, true));
      } else if (part.functionCall) {
        // Process function calls
        const functionResponse = await this.handleFunctionCall(
          part.functionCall.name,
          part.functionCall.args,
          context
        );
        if (functionResponse) {
          // If function returns an array (multiple messages), add all
          if (Array.isArray(functionResponse)) {
            responses.push(...functionResponse);
          } else {
            responses.push(functionResponse);
          }
        }
      }
    }
    
    logger.debug(`Total responses processed: ${responses.length}`);
    logger.debug('=== End processGeminiResponse DEBUG ===');
    
    return responses;
  }

  private static async handleFunctionCall(name: string, args: any, context?: MessageContext): Promise<UnifiedResponse | UnifiedResponse[] | null> {
    logger.debug(`=== handleFunctionCall: ${name} ===`);
    
    // Get the handler for this function
    const handler = getToolHandler(name);
    
    if (handler) {
      try {
        const result = await handler(args, context);
        logger.debug(`Handler ${name} completed successfully`);
        return result;
      } catch (error) {
        logger.error(`Error in handler ${name}:`, error);
        
        // Return a formatted error response instead of throwing
        return ResponseBuilder.error(
          'TOOL_ERROR',
          'üòî Lo siento, hubo un problema al procesar tu solicitud. Por favor, intenta de nuevo.'
        );
      }
    }
    
    logger.warn(`Unrecognized function call: ${name}`);
    return null;
  }
}

================
File: backend/src/services/sync/EmbeddingService.ts
================
import { prisma } from '../../lib/prisma';
import { GoogleGenAI } from '@google/genai';
import { env } from '../../common/config/envValidator';
import logger from '../../common/utils/logger';
import { Product } from '@prisma/client';

interface ProductWithRelations extends Product {
  subcategory: {
    name: string;
    category: {
      name: string;
    };
  };
  variants?: Array<{ name: string; isActive: boolean }>;
  pizzaCustomizations?: Array<{ name: string; type: 'FLAVOR' | 'INGREDIENT'; isActive: boolean }>;
  modifierGroups?: Array<{
    productModifiers: Array<{ name: string; isActive: boolean }>;
    isActive: boolean;
  }>;
}

/**
 * Service for managing product embeddings
 * Handles automatic generation and updates when products change
 */
export class EmbeddingService {
  private static genAI = new GoogleGenAI({ apiKey: env.GOOGLE_AI_API_KEY });
  private static embeddingModel = env.EMBEDDING_MODEL;
  private static lastSyncChecksum: string | null = null;

  /**
   * Generate embedding text for a product
   */
  private static createProductText(product: ProductWithRelations): string {
    let text = `Producto: ${product.name}. Categor√≠a: ${product.subcategory.category.name}, ${product.subcategory.name}.`;
    
    if (product.description) {
      text += ` Descripci√≥n: ${product.description}.`;
    }
    
    if (product.isPizza && product.pizzaCustomizations && product.pizzaCustomizations.length > 0) {
      const flavors = product.pizzaCustomizations
        .filter(c => c.isActive && c.type === 'FLAVOR')
        .map(c => c.name)
        .join(', ');
      const ingredients = product.pizzaCustomizations
        .filter(c => c.isActive && c.type === 'INGREDIENT')
        .map(c => c.name)
        .join(', ');
      
      if (flavors) {
        text += ` Sabores disponibles: ${flavors}.`;
      }
      if (ingredients) {
        text += ` Ingredientes adicionales: ${ingredients}.`;
      }
    }
    
    if (product.variants && product.variants.length > 0) {
      const variantNames = product.variants
        .filter(v => v.isActive)
        .map(v => v.name)
        .join(', ');
      if (variantNames) {
        text += ` Opciones o tama√±os: ${variantNames}.`;
      }
    }
    
    if (product.modifierGroups && product.modifierGroups.length > 0) {
      const modifiers = product.modifierGroups
        .filter(g => g.isActive)
        .flatMap(g => g.productModifiers || [])
        .filter(m => m.isActive)
        .map(m => m.name)
        .join(', ');
      if (modifiers) {
        text += ` Modificadores disponibles: ${modifiers}.`;
      }
    }
    
    return text;
  }

  /**
   * Generate embedding for a single product
   */
  static async generateProductEmbedding(product: ProductWithRelations): Promise<number[]> {
    const textToEmbed = this.createProductText(product);
    
    const result = await this.genAI.models.embedContent({
      model: this.embeddingModel,
      contents: textToEmbed,
      config: {
        outputDimensionality: 768  // Force 768 dimensions for compatibility with pgvector
      }
    });
    
    const embedding = result.embeddings?.[0]?.values || [];
    
    return embedding;
  }

  /**
   * Update embedding for a single product
   */
  static async updateProductEmbedding(productId: string): Promise<void> {
    try {
      const product = await prisma.product.findUnique({
        where: { id: productId },
        include: {
          subcategory: { include: { category: true } },
          variants: { where: { isActive: true } },
          pizzaCustomizations: { where: { isActive: true } },
        pizzaConfiguration: true,
          modifierGroups: {
            where: { isActive: true },
            include: {
              productModifiers: { where: { isActive: true } }
            }
          }
        }
      });

      if (!product || !product.isActive) {
        logger.warn(`Product ${productId} not found or inactive, skipping embedding generation`);
        return;
      }

      const embedding = await this.generateProductEmbedding(product as ProductWithRelations);
      
      // Update embedding in database
      await prisma.$executeRaw`
        UPDATE "Product"
        SET embedding = ${`[${embedding.join(',')}]`}::vector
        WHERE id = ${productId}
      `;
      
      logger.info(`‚úÖ Embedding updated for product: ${product.name}`);
    } catch (error) {
      logger.error(`Error updating embedding for product ${productId}:`, error);
      throw error;
    }
  }

  /**
   * Check if products have changed and need embedding updates
   */
  static async checkAndUpdateEmbeddings(): Promise<number> {
    try {
      logger.info('Checking for product changes that require embedding updates...');
      
      // Get current state checksum
      const currentChecksum = await this.calculateProductsChecksum();
      
      // Compare with last sync
      if (this.lastSyncChecksum === currentChecksum) {
        logger.info('No product changes detected, embeddings are up to date');
        return 0;
      }
      
      // Find products that need embedding updates
      const productsNeedingUpdate = await this.findProductsNeedingEmbeddings();
      
      if (productsNeedingUpdate.length === 0) {
        logger.info('All products have embeddings');
        this.lastSyncChecksum = currentChecksum;
        return 0;
      }
      
      logger.info(`Found ${productsNeedingUpdate.length} products needing embedding updates`);
      
      // Update embeddings
      let successCount = 0;
      for (const productId of productsNeedingUpdate) {
        try {
          await this.updateProductEmbedding(productId);
          successCount++;
          // Rate limiting
          await new Promise(resolve => setTimeout(resolve, 300));
        } catch (error) {
          logger.error(`Failed to update embedding for product ${productId}:`, error);
        }
      }
      
      // Update checksum
      this.lastSyncChecksum = currentChecksum;
      
      logger.info(`‚úÖ Embedding update completed: ${successCount}/${productsNeedingUpdate.length} successful`);
      return successCount;
    } catch (error) {
      logger.error('Error in checkAndUpdateEmbeddings:', error);
      throw error;
    }
  }

  /**
   * Calculate checksum of all products to detect changes
   */
  private static async calculateProductsChecksum(): Promise<string> {
    const products = await prisma.product.findMany({
      where: { isActive: true },
      select: {
        id: true,
        name: true,
        description: true,
        updatedAt: true
      },
      orderBy: { id: 'asc' }
    });
    
    // Create a simple checksum based on product data
    const dataString = products
      .map(p => `${p.id}:${p.name}:${p.description || ''}:${p.updatedAt.getTime()}`)
      .join('|');
    
    // Simple hash function
    let hash = 0;
    for (let i = 0; i < dataString.length; i++) {
      const char = dataString.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    
    return hash.toString(16);
  }

  /**
   * Find products that need embedding generation or updates
   */
  private static async findProductsNeedingEmbeddings(): Promise<string[]> {
    // Get products without embeddings
    const productsWithoutEmbeddings: { id: string }[] = await prisma.$queryRaw`
      SELECT id FROM "Product"
      WHERE "isActive" = true
      AND embedding IS NULL
    `;
    
    // Get products where updatedAt is more recent than embedding generation
    // This requires tracking embedding generation time (future enhancement)
    
    return productsWithoutEmbeddings.map(p => p.id);
  }

  /**
   * Force regenerate all embeddings (useful for algorithm updates)
   */
  static async regenerateAllEmbeddings(): Promise<void> {
    logger.info('Starting full embedding regeneration...');
    
    const products = await prisma.product.findMany({
      where: { isActive: true },
      include: {
        subcategory: { include: { category: true } },
        variants: { where: { isActive: true } },
        pizzaCustomizations: { where: { isActive: true } },
        pizzaConfiguration: true,
        modifierGroups: {
          where: { isActive: true },
          include: {
            productModifiers: { where: { isActive: true } }
          }
        }
      }
    });
    
    logger.info(`Found ${products.length} products to process`);
    
    let successCount = 0;
    let errorCount = 0;
    
    for (const product of products) {
      try {
        const embedding = await this.generateProductEmbedding(product as ProductWithRelations);
        
        await prisma.$executeRaw`
          UPDATE "Product"
          SET embedding = ${`[${embedding.join(',')}]`}::vector
          WHERE id = ${product.id}
        `;
        
        successCount++;
        logger.info(`‚úÖ Embedding saved for: ${product.name} (${successCount}/${products.length})`);
        
        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 300));
      } catch (error) {
        errorCount++;
        logger.error(`‚ùå Error with ${product.name}:`, error);
      }
    }
    
    logger.info(`
‚úÖ Regeneration completed:
   - Products processed: ${successCount}
   - Errors: ${errorCount}
   - Total: ${products.length}
    `);
  }
}

================
File: scripts/reset-database-production-safe.sh
================
#!/bin/bash

# Script SEGURO para resetear completamente la base de datos en producci√≥n
# Este script maneja las limitaciones de permisos en producci√≥n
# Autor: Bot Backend Reset Script (Production Safe)
# Uso: ./reset-database-production-safe.sh

set -e

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_step() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

print_info() {
    echo -e "${BLUE}‚Ñπ${NC} $1"
}

# Banner de advertencia
echo ""
echo "================================================"
echo -e "${RED}‚ö†Ô∏è  ADVERTENCIA - RESET COMPLETO DE BASE DE DATOS ‚ö†Ô∏è${NC}"
echo "================================================"
echo ""
echo "Este script realizar√° las siguientes acciones:"
echo "1. Detener todos los procesos PM2"
echo "2. Hacer backup de la base de datos actual"
echo "3. ELIMINAR completamente la base de datos"
echo "4. Recrear la base de datos vac√≠a"
echo "5. Ejecutar las nuevas migraciones"
echo "6. Limpiar y recompilar el proyecto"
echo "7. Reiniciar los servicios desde cero"
echo ""
echo -e "${RED}TODOS LOS DATOS SER√ÅN ELIMINADOS${NC}"
echo ""
read -p "¬øEst√°s ABSOLUTAMENTE SEGURO que quieres continuar? Escribe 'SI ESTOY SEGURO': " -r
echo

if [[ ! $REPLY == "SI ESTOY SEGURO" ]]; then
    print_error "Reset cancelado"
    exit 1
fi

# Segunda confirmaci√≥n
echo ""
echo -e "${YELLOW}Segunda confirmaci√≥n por seguridad${NC}"
read -p "¬øRealmente quieres ELIMINAR TODOS LOS DATOS? (s/n): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Ss]$ ]]; then
    print_error "Reset cancelado"
    exit 1
fi

# Verificar que estamos en el servidor correcto
if [ ! -d "$HOME/bot_backend" ]; then
    print_error "No se encontr√≥ el directorio ~/bot_backend"
    print_error "¬øEst√°s seguro que est√°s en el servidor correcto?"
    exit 1
fi

cd ~/bot_backend

# Paso 1: Detener PM2
print_step "Deteniendo todos los procesos PM2..."
pm2 stop all || true
print_success "Procesos detenidos"

# Paso 2: Backup de la base de datos actual
print_step "Creando backup de la base de datos actual..."
BACKUP_FILE="backup_before_reset_$(date +%Y%m%d_%H%M%S).sql"
cd ~/bot_backend/backend

# Obtener credenciales de la base de datos del .env
if [ -f .env ]; then
    export $(cat .env | grep -E '^DATABASE_URL=' | xargs)
    # Extraer componentes de DATABASE_URL
    DB_USER=$(echo $DATABASE_URL | sed -n 's/.*postgresql:\/\/\([^:]*\):.*/\1/p')
    DB_NAME=$(echo $DATABASE_URL | sed -n 's/.*\/\([^?]*\).*/\1/p')
    DB_HOST=$(echo $DATABASE_URL | sed -n 's/.*@\([^:]*\):.*/\1/p')
    DB_PORT=$(echo $DATABASE_URL | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
else
    print_error "No se encontr√≥ archivo .env"
    exit 1
fi

PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p') pg_dump -U $DB_USER -h $DB_HOST -p $DB_PORT $DB_NAME > ~/$BACKUP_FILE 2>/dev/null || true

if [ -f ~/$BACKUP_FILE ]; then
    print_success "Backup creado: ~/$BACKUP_FILE"
else
    print_warning "No se pudo crear el backup, pero continuando..."
fi

# Paso 3: Limpiar la base de datos completamente
print_step "Limpiando la base de datos..."

# Verificar si la base de datos existe
DB_EXISTS=$(PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p') psql -U $DB_USER -h $DB_HOST -p $DB_PORT -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME'" 2>/dev/null)

if [ "$DB_EXISTS" == "1" ]; then
    # La base de datos existe, intentar eliminarla
    print_step "Intentando eliminar la base de datos existente..."
    PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p') psql -U $DB_USER -h $DB_HOST -p $DB_PORT -d postgres -c "DROP DATABASE IF EXISTS $DB_NAME;" 2>/dev/null || {
        print_warning "No se pudo eliminar la base de datos (permisos limitados)"
        print_step "Usando m√©todo alternativo: eliminando todas las tablas..."
        
        # Asegurar permisos antes de intentar eliminar tablas
        sudo -u postgres psql << EOF
\c $DB_NAME
GRANT ALL ON SCHEMA public TO $DB_USER;
CREATE EXTENSION IF NOT EXISTS vector;
EOF
    
    # M√©todo 2: Eliminar todas las tablas manualmente
    cat > /tmp/drop_all_tables.sql << 'EOF'
DO $$ 
DECLARE
    r RECORD;
BEGIN
    -- Primero eliminar la tabla de migraciones de Prisma
    DROP TABLE IF EXISTS "_prisma_migrations" CASCADE;
    
    -- Eliminar todas las tablas en el schema public
    FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND tablename != '_prisma_migrations') LOOP
        EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
    END LOOP;
    
    -- Eliminar todas las secuencias
    FOR r IN (SELECT sequence_name FROM information_schema.sequences WHERE sequence_schema = 'public') LOOP
        EXECUTE 'DROP SEQUENCE IF EXISTS ' || quote_ident(r.sequence_name) || ' CASCADE';
    END LOOP;
    
    -- Eliminar todos los tipos enum
    FOR r IN (SELECT typname FROM pg_type WHERE typnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public') AND typtype = 'e') LOOP
        EXECUTE 'DROP TYPE IF EXISTS ' || quote_ident(r.typname) || ' CASCADE';
    END LOOP;
    
    -- Eliminar todas las funciones
    FOR r IN (SELECT proname, oidvectortypes(proargtypes) as args 
              FROM pg_proc 
              WHERE pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) LOOP
        EXECUTE 'DROP FUNCTION IF EXISTS ' || quote_ident(r.proname) || '(' || r.args || ') CASCADE';
    END LOOP;
END $$;
EOF
    
        PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p') psql -U $DB_USER -h $DB_HOST -p $DB_PORT $DB_NAME < /tmp/drop_all_tables.sql
    }
else
    print_warning "La base de datos no existe, se crear√° una nueva"
fi

print_success "Preparaci√≥n de base de datos completada"

# Paso 4: Eliminar el historial de migraciones
print_step "Eliminando historial de migraciones..."
rm -rf prisma/migrations
mkdir -p prisma/migrations
print_success "Historial de migraciones eliminado"

# Paso 5: Crear migraci√≥n inicial usando un m√©todo seguro
print_step "Preparando nueva migraci√≥n inicial..."

# Crear directorio de migraci√≥n manualmente
MIGRATION_NAME="$(date +%Y%m%d%H%M%S)_initial_migration"
MIGRATION_DIR="prisma/migrations/$MIGRATION_NAME"
mkdir -p "$MIGRATION_DIR"

# Generar SQL de migraci√≥n desde el esquema
print_step "Generando SQL de migraci√≥n desde el esquema..."
npx prisma migrate diff \
  --from-empty \
  --to-schema-datamodel prisma/schema.prisma \
  --script > "$MIGRATION_DIR/migration.sql"

# Verificar que se gener√≥ el SQL
if [ ! -s "$MIGRATION_DIR/migration.sql" ]; then
    print_error "No se pudo generar el SQL de migraci√≥n"
    exit 1
fi

print_success "SQL de migraci√≥n generado"

# Paso 6: Verificar que la base de datos existe antes de aplicar migraci√≥n
print_step "Verificando que la base de datos existe..."
DB_EXISTS=$(PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p') psql -U $DB_USER -h $DB_HOST -p $DB_PORT -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME'" 2>/dev/null)

if [ "$DB_EXISTS" != "1" ]; then
    print_warning "La base de datos no existe, intentando crearla..."
    
    # Intentar crear como el usuario normal
    PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p') psql -U $DB_USER -h $DB_HOST -p $DB_PORT -d postgres -c "CREATE DATABASE $DB_NAME;" 2>/dev/null || {
        print_error "No se pudo crear la base de datos con el usuario $DB_USER"
        print_warning "Intentando con sudo postgres..."
        
        # Intentar con sudo postgres
        sudo -u postgres psql -c "CREATE DATABASE $DB_NAME;" 2>/dev/null || {
            print_error "No se pudo crear la base de datos"
            print_error ""
            print_error "Por favor, ejecuta manualmente como administrador:"
            print_error "  sudo -u postgres psql"
            print_error "  CREATE DATABASE $DB_NAME;"
            print_error "  GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;"
            print_error "  \\q"
            print_error ""
            print_error "Luego vuelve a ejecutar este script"
            exit 1
        }
        
        # Si se cre√≥ con postgres, dar permisos completos al usuario
        sudo -u postgres psql -d $DB_NAME << EOF
-- Dar permisos completos en el esquema public
GRANT ALL ON SCHEMA public TO $DB_USER;
GRANT CREATE ON SCHEMA public TO $DB_USER;
ALTER DATABASE $DB_NAME OWNER TO $DB_USER;

-- Crear extensi√≥n vector si es necesaria
CREATE EXTENSION IF NOT EXISTS vector;
EOF
        
        print_success "Permisos configurados correctamente"
    }
    
    print_success "Base de datos creada"
fi

# Verificar y configurar permisos antes de aplicar migraci√≥n
print_step "Configurando permisos y extensiones necesarias..."

# Siempre ejecutar esto para asegurar que todo est√© configurado correctamente
sudo -u postgres psql << EOF
-- Conectar a la base de datos
\c $DB_NAME

-- Dar permisos completos al usuario
GRANT ALL ON SCHEMA public TO $DB_USER;
GRANT CREATE ON SCHEMA public TO $DB_USER;
ALTER SCHEMA public OWNER TO $DB_USER;

-- Crear extensi√≥n vector (requerida para embeddings)
CREATE EXTENSION IF NOT EXISTS vector;

-- Dar permisos de creaci√≥n de bases de datos al usuario (√∫til para futuros resets)
ALTER USER $DB_USER CREATEDB;
EOF

print_success "Permisos y extensiones configurados correctamente"

# Aplicar la migraci√≥n
print_step "Aplicando migraci√≥n inicial..."
PGPASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p') psql -U $DB_USER -h $DB_HOST -p $DB_PORT $DB_NAME < "$MIGRATION_DIR/migration.sql"

# Marcar la migraci√≥n como aplicada en Prisma
print_step "Registrando migraci√≥n en Prisma..."
npx prisma migrate resolve --applied "$MIGRATION_NAME"

print_success "Migraci√≥n aplicada y registrada"

# Paso 7: Generar cliente Prisma
print_step "Generando cliente Prisma..."
npm run generate
print_success "Cliente Prisma generado"

# Paso 8: Limpiar y recompilar el proyecto
print_step "Limpiando c√≥digo compilado anterior..."
rm -rf dist/
print_success "C√≥digo compilado eliminado"
print_info "Esto previene errores de c√≥digo obsoleto en el cache"

print_step "Recompilando proyecto TypeScript..."
npm run build
print_success "Proyecto recompilado con c√≥digo actualizado"

# Paso 9: Generar embeddings si est√° configurado
if grep -q "GOOGLE_AI_API_KEY=" .env && grep -q "^GOOGLE_AI_API_KEY=." .env; then
    print_step "Preparando generaci√≥n de embeddings..."
    print_info "Los embeddings se generar√°n autom√°ticamente despu√©s de la primera sincronizaci√≥n del men√∫"
    print_info "Tambi√©n puedes generarlos manualmente con: npm run seed:embeddings"
else
    print_warning "GOOGLE_AI_API_KEY no configurado, b√∫squeda sem√°ntica deshabilitada"
fi

# Paso 10: Detener servicios existentes completamente
print_step "Deteniendo servicios PM2 existentes..."
pm2 delete all 2>/dev/null || true
print_success "Servicios detenidos y eliminados"

# Paso 11: Iniciar servicios limpios
print_step "Iniciando servicios PM2 desde cero..."
pm2 start ecosystem.config.js
print_success "Servicios iniciados"

# Paso 12: Verificar estado
print_step "Verificando estado de la aplicaci√≥n..."
sleep 5
pm2 status

# Resumen
echo ""
echo "================================================"
echo -e "${GREEN}¬°Reset de base de datos completado!${NC}"
echo "================================================"
echo ""
echo "‚úÖ Base de datos completamente limpia"
echo "‚úÖ Nuevas migraciones aplicadas"
echo "‚úÖ Proyecto recompilado (sin c√≥digo antiguo)"
echo "‚úÖ Servicios reiniciados desde cero"
echo ""
if [ -f ~/$BACKUP_FILE ]; then
    echo -e "${YELLOW}Backup guardado en: ~/$BACKUP_FILE${NC}"
    echo ""
    echo "Para restaurar el backup:"
    echo "PGPASSWORD=\$PASSWORD psql -U $DB_USER -h $DB_HOST -p $DB_PORT $DB_NAME < ~/$BACKUP_FILE"
fi
echo ""
echo "La base de datos est√° ahora completamente vac√≠a."
echo "Necesitar√°s crear nuevos datos de prueba."
echo ""
echo "Comandos √∫tiles:"
echo "‚Ä¢ pm2 logs     - Ver logs"
echo "‚Ä¢ pm2 status   - Ver estado"
echo "‚Ä¢ pm2 monit    - Monitor en tiempo real"

================
File: backend/prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

// Enums
enum OrderType {
  DINE_IN
  TAKE_AWAY
  DELIVERY
}

enum OrderStatus {
  PENDING
  IN_PROGRESS
  IN_PREPARATION
  READY
  IN_DELIVERY
  DELIVERED
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  TRANSFER
  STRIPE
  PAYPAL
  OTHER
}

enum PizzaHalf {
  FULL
  HALF_1
  HALF_2
}

enum CustomizationAction {
  ADD
  REMOVE
}

enum CustomizationType {
  FLAVOR
  INGREDIENT
}

enum PreparationStatus {
  PENDING
  IN_PROGRESS
  READY
  DELIVERED
  CANCELLED
}

// Models
model Category {
  id           String        @id
  name         String        @unique
  description  String?
  isActive     Boolean       @default(true)
  photoId      String?
  sortOrder    Int           @default(0)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  deletedAt    DateTime?
  subcategories Subcategory[]
}

model Customer {
  id                  String               @id @default(uuid()) @db.Uuid // UUID primary key
  whatsappPhoneNumber String               @unique // WhatsApp phone number
  firstName           String?              @db.VarChar(100)
  lastName            String?              @db.VarChar(100)
  email               String?              @db.VarChar(255)
  birthDate           DateTime?            @db.Date
  fullChatHistory     Json?
  relevantChatHistory Json?
  stripeCustomerId    String?              @unique
  lastInteraction     DateTime?
  totalOrders         Int                  @default(0)
  totalSpent          Decimal              @default(0) @db.Decimal(10, 2)
  isActive            Boolean              @default(true)
  isBanned            Boolean              @default(false)
  bannedAt            DateTime?
  banReason           String?              @db.Text
  deletedAt           DateTime?            // Soft delete
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  addresses           Address[]            // One-to-Many relationship
  orders              Order[]              // One-to-Many relationship
  
  @@index([whatsappPhoneNumber])
  @@index([email])
}

// Customer addresses (1:N relationship)
// A customer can have multiple delivery addresses
model Address {
  id                String   @id @default(uuid()) @db.Uuid // UUID primary key
  customerId        String   @db.Uuid // Foreign key to Customer
  name              String   @db.VarChar(100) // e.g., "Casa", "Oficina", "Casa de mam√°"
  street            String   @db.VarChar(200)
  number            String   @db.VarChar(50)
  interiorNumber    String?  @db.VarChar(50)
  neighborhood      String?  @db.VarChar(150)
  city              String?  @db.VarChar(100)
  state             String?  @db.VarChar(100)
  zipCode           String?  @db.VarChar(10)
  country           String?  @db.VarChar(100)
  deliveryInstructions String?  @db.Text
  latitude          Decimal? @db.Decimal(10, 8)
  longitude         Decimal? @db.Decimal(11, 8)
  isDefault         Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  deletedAt         DateTime? // Soft delete
  customer          Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@index([customerId])
  @@index([zipCode])
}

model MessageLog {
  id        Int     @id @default(autoincrement())
  messageId String  @unique
  processed Boolean @default(false)
}

model ProductModifier {
  id               String             @id
  modifierGroupId  String
  name             String
  description      String?
  price            Float?
  sortOrder        Int                @default(0)
  isDefault        Boolean            @default(false)
  isActive         Boolean            @default(true)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  deletedAt        DateTime?
  modifierGroup    ModifierGroup      @relation(fields: [modifierGroupId], references: [id])
  orderItems       OrderItem[]        @relation("OrderItemProductModifiers")
}

model ModifierGroup {
  id                      String            @id
  name                    String
  description             String?
  minSelections           Int               @default(0)
  maxSelections           Int               @default(1)
  isRequired              Boolean           @default(false)
  allowMultipleSelections Boolean           @default(false)
  isActive                Boolean           @default(true)
  sortOrder               Int               @default(0)
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt
  deletedAt               DateTime?
  products                Product[]         @relation("ProductModifierGroups")
  productModifiers        ProductModifier[]
}

model Order {
  id                   String            @id @default(uuid()) @db.Uuid
  shiftOrderNumber     Int?
  orderType            OrderType
  orderStatus          OrderStatus       @default(PENDING)
  subtotal             Float             @default(0)
  total                Float             @default(0)
  customerId           String            @db.Uuid
  estimatedDeliveryTime DateTime?
  scheduledAt          DateTime?
  notes                String?
  isFromWhatsApp       Boolean           @default(true)
  finalizedAt          DateTime?         // When order was marked as completed/delivered
  // Additional relations for local backend compatibility
  shiftId              String?           @db.Uuid
  userId               String?           @db.Uuid
  tableId              String?           @db.Uuid
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  deletedAt            DateTime?
  // Relations
  orderItems           OrderItem[]
  deliveryInfo         DeliveryInfo?
  customer             Customer          @relation(fields: [customerId], references: [id])
  payments             Payment[]
  ticketImpressions    TicketImpression[]
  adjustments          Adjustment[]
  shift                Shift?            @relation(fields: [shiftId], references: [id])
  table                Table?            @relation(fields: [tableId], references: [id])
  user                 User?             @relation(fields: [userId], references: [id])
  
  @@index([shiftId])
  @@index([tableId])
  @@index([userId])
}

// Order's delivery address (snapshot at order time)
// This is a copy of the customer's address at the time of order creation
// Preserves historical data even if customer changes their address later
model DeliveryInfo {
  id                    String    @id @default(uuid()) @db.Uuid
  orderId               String?   @unique @db.Uuid
  preOrderId            Int?      @unique
  name                  String?   @db.VarChar(100) // Address name like "Casa", "Oficina"
  fullAddress           String?   @db.Text // Full address for phone orders
  street                String?   @db.VarChar(200)
  number                String?   @db.VarChar(50)
  interiorNumber        String?   @db.VarChar(50)
  neighborhood          String?   @db.VarChar(150)
  city                  String?   @db.VarChar(100)
  state                 String?   @db.VarChar(100)
  zipCode               String?   @db.VarChar(10)
  country               String?   @db.VarChar(100)
  recipientName         String?   @db.VarChar(255) // Recipient name
  recipientPhone        String?   @db.VarChar(50) // Recipient phone
  deliveryInstructions  String?   @db.Text // Delivery instructions
  latitude              Decimal?  @db.Decimal(10, 8)
  longitude             Decimal?  @db.Decimal(11, 8)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  order                 Order?    @relation(fields: [orderId], references: [id])
  preOrder              PreOrder? @relation(fields: [preOrderId], references: [id])
}

model OrderItem {
  id                    String                     @id @default(uuid()) @db.Uuid
  orderId               String?                    @db.Uuid
  preOrderId            Int?
  productId             String
  productVariantId      String?
  basePrice             Float
  finalPrice            Float
  preparationStatus     PreparationStatus          @default(PENDING)
  statusChangedAt       DateTime                   @default(now())
  preparationNotes      String?
  createdAt             DateTime                   @default(now())
  updatedAt             DateTime                   @updatedAt
  deletedAt             DateTime?
  order                 Order?                     @relation(fields: [orderId], references: [id])
  preOrder              PreOrder?                  @relation(fields: [preOrderId], references: [id])
  product               Product                    @relation(fields: [productId], references: [id])
  productVariant        ProductVariant?            @relation(fields: [productVariantId], references: [id])
  productModifiers      ProductModifier[]          @relation("OrderItemProductModifiers")
  selectedPizzaCustomizations SelectedPizzaCustomization[]
  adjustments           Adjustment[]
  
  @@index([orderId])
  @@index([preOrderId])
}

// Nueva estructura para personalizaci√≥n de pizzas
model PizzaCustomization {
  id                    String                       @id
  name                  String                       // Nombre: "Hawaiana", "Pepperoni", "Champi√±ones"
  type                  CustomizationType            // FLAVOR | INGREDIENT
  ingredients           String?                      // Para FLAVOR: lista de ingredientes
  toppingValue          Int                          @default(1) // Cu√°nto cuenta para el l√≠mite
  isActive              Boolean                      @default(true)
  sortOrder             Int                          @default(0)
  createdAt             DateTime                     @default(now())
  updatedAt             DateTime                     @updatedAt
  deletedAt             DateTime?
  products              Product[]                    @relation("ProductPizzaCustomizations")
  selectedPizzaCustomizations SelectedPizzaCustomization[]
}

// Configuraci√≥n espec√≠fica para pizzas
model PizzaConfiguration {
  id                    String   @id @default(uuid()) @db.Uuid
  productId             String   @unique
  product               Product  @relation(fields: [productId], references: [id])
  includedToppings      Int      @default(4)      // Valor de toppings incluidos en precio base
  extraToppingCost      Float    @default(20)     // Costo por topping adicional
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  deletedAt             DateTime?
}

model PreOrder {
  id                    Int                @id @default(autoincrement())
  orderType             OrderType
  estimatedDeliveryTime Int                @default(0)
  scheduledAt           DateTime?
  notes                 String?
  subtotal              Float              @default(0)
  total                 Float              @default(0)
  whatsappPhoneNumber   String             // Store WhatsApp phone number instead of customerId
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  orderItems            OrderItem[]
  deliveryInfo          DeliveryInfo?
  adjustments           Adjustment[]
  
  @@index([whatsappPhoneNumber])
}

model Product {
  id                   String              @id
  name                 String
  description          String?
  price                Float?
  hasVariants          Boolean             @default(false)
  isActive             Boolean             @default(true)
  isPizza              Boolean             @default(false)
  subcategoryId        String
  preparationScreenId  String?
  photoId              String?
  estimatedPrepTime    Int                 @default(0)
  sortOrder            Int                 @default(0)
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  deletedAt            DateTime?
  // Embedding para b√∫squeda sem√°ntica (modelo text-embedding-004 usa 768 dimensiones)
  embedding            Unsupported("vector(768)")?
  subcategory          Subcategory         @relation(fields: [subcategoryId], references: [id])
  variants             ProductVariant[]
  modifierGroups       ModifierGroup[]     @relation("ProductModifierGroups")
  pizzaConfiguration   PizzaConfiguration?
  pizzaCustomizations  PizzaCustomization[] @relation("ProductPizzaCustomizations")
  orderItems           OrderItem[]
}

model ProductVariant {
  id          String      @id
  productId   String
  name        String
  price       Float
  isActive    Boolean     @default(true)
  sortOrder   Int         @default(0)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  deletedAt   DateTime?
  product     Product     @relation(fields: [productId], references: [id])
  orderItems  OrderItem[]
}

model RestaurantConfig {
  id                    Int                @id @default(autoincrement())
  // Informaci√≥n b√°sica del restaurante
  restaurantName        String             @default("La Le√±a") // Nombre del restaurante
  phoneMain             String?            // Tel√©fono principal
  phoneSecondary        String?            // Tel√©fono secundario/m√≥vil
  address               String?            // Direcci√≥n completa
  city                  String?            // Ciudad
  state                 String?            // Estado
  postalCode            String?            // C√≥digo postal
  country               String?            // Pa√≠s
  
  // Configuraci√≥n de operaci√≥n
  acceptingOrders       Boolean            @default(true)
  estimatedPickupTime   Int                @default(20) // Tiempo estimado de recolecci√≥n en minutos
  estimatedDeliveryTime Int                @default(40) // Tiempo estimado de entrega a domicilio en minutos
  openingGracePeriod    Int                @default(30) // Minutos despu√©s de abrir antes de aceptar pedidos
  closingGracePeriod    Int                @default(30) // Minutos antes de cerrar para dejar de aceptar pedidos
  timeZone              String             @default("America/Mexico_City") // Zona horaria del restaurante
  businessHours         BusinessHours[]
  
  // Configuraci√≥n de delivery
  deliveryCoverageArea  Json?              // Pol√≠gono de cobertura - Array de objetos {lat: number, lng: number}
}

model BusinessHours {
  id                 Int              @id @default(autoincrement())
  dayOfWeek          Int              // 0 = Domingo, 1 = Lunes, ... 6 = S√°bado
  openingTime        String?          // Hora de apertura en formato HH:mm (null = cerrado)
  closingTime        String?          // Hora de cierre en formato HH:mm (null = cerrado)
  isClosed           Boolean          @default(false) // true si el restaurante est√° cerrado ese d√≠a
  restaurantConfigId Int
  restaurantConfig   RestaurantConfig @relation(fields: [restaurantConfigId], references: [id])
  
  @@unique([restaurantConfigId, dayOfWeek]) // Un solo horario por d√≠a
}


model SelectedPizzaCustomization {
  id                    String               @id @default(uuid()) @db.Uuid
  orderItemId           String               @db.Uuid
  pizzaCustomizationId  String
  half                  PizzaHalf            @default(FULL)
  action                CustomizationAction  @default(ADD)
  orderItem             OrderItem            @relation(fields: [orderItemId], references: [id])
  pizzaCustomization    PizzaCustomization   @relation(fields: [pizzaCustomizationId], references: [id])
  
  @@unique([orderItemId, pizzaCustomizationId, half, action])
}

model Subcategory {
  id          String    @id
  categoryId  String
  name        String    @unique
  description String?
  isActive    Boolean   @default(true)
  photoId     String?
  sortOrder   Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  category    Category  @relation(fields: [categoryId], references: [id])
  products    Product[]
}

// Sync tracking between local and cloud backends
model SyncLog {
  id              String    @id @default(uuid())
  syncType        String    // MENU_PULL | ORDERS_PUSH | CUSTOMERS_SYNC
  recordsAffected Int       @default(0)
  status          String    // SUCCESS | FAILED
  error           String?   @db.Text
  startedAt       DateTime  @default(now())
  completedAt     DateTime?
  
  @@index([syncType])
  @@index([status])
}

// Payment tracking for orders
model Payment {
  id            String         @id @default(uuid()) @db.Uuid
  orderId       String         @db.Uuid
  paymentMethod PaymentMethod  @default(CASH)
  amount        Decimal        @db.Decimal(10, 2)
  status        PaymentStatus  @default(PENDING)
  stripePaymentId String?      // Stripe payment intent ID
  metadata      Json?          // Additional payment metadata
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  deletedAt     DateTime?
  order         Order          @relation(fields: [orderId], references: [id])
  
  @@index([orderId])
  @@index([status])
}

// Placeholder models for local backend compatibility
// These models are defined but may not be actively used in the WhatsApp bot context

model Shift {
  id            String         @id @default(uuid()) @db.Uuid
  shiftDate     DateTime       @db.Date
  shiftNumber   Int            @default(1)    // Multiple shifts per day (1, 2, 3...)
  startTime     DateTime       @default(now())
  endTime       DateTime?
  orderCounter  Int            @default(0)    // Count of orders in this shift
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  orders        Order[]
  
  @@unique([shiftDate, shiftNumber])
  @@index([shiftDate])
  @@index([startTime])
}

model Table {
  id            String         @id @default(uuid()) @db.Uuid
  tableNumber   String         @unique
  capacity      Int            @default(4)
  isActive      Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  orders        Order[]
}

model User {
  id            String         @id @default(uuid()) @db.Uuid
  username      String         @unique
  email         String?        @unique
  firstName     String?
  lastName      String?
  isActive      Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  deletedAt     DateTime?
  orders        Order[]
}

model TicketImpression {
  id            String         @id @default(uuid()) @db.Uuid
  orderId       String         @db.Uuid
  printedAt     DateTime       @default(now())
  printerName   String?
  order         Order          @relation(fields: [orderId], references: [id])
  
  @@index([orderId])
}

model Adjustment {
  id            String         @id @default(uuid()) @db.Uuid
  orderId       String?        @db.Uuid
  preOrderId    Int?
  orderItemId   String?        @db.Uuid
  type          String         // e.g., "discount", "surcharge", "tip"
  amount        Decimal        @db.Decimal(10, 2)
  reason        String?
  appliedBy     String?        // User who applied the adjustment
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  deletedAt     DateTime?
  order         Order?         @relation(fields: [orderId], references: [id])
  preOrder      PreOrder?      @relation(fields: [preOrderId], references: [id])
  orderItem     OrderItem?     @relation(fields: [orderItemId], references: [id])
  
  @@index([orderId])
  @@index([preOrderId])
  @@index([orderItemId])
}


// Sync metadata for all entities
model SyncMetadata {
  id              String    @id @default(uuid())
  entityType      String    // Customer | Order | Address | Product | etc
  entityId        String    // UUID of the entity
  lastModifiedAt  DateTime  @updatedAt
  modifiedBy      String    @default("REMOTE") // LOCAL | REMOTE
  syncPending     Boolean   @default(false)
  syncVersion     Int       @default(1)
  metadata        Json?     // Additional sync data if needed
  createdAt       DateTime  @default(now())
  
  @@unique([entityType, entityId])
  @@index([syncPending, entityType])
  @@index([lastModifiedAt])
  @@index([entityId])
}

================
File: backend/src/common/config/envValidator.ts
================
import dotenv from 'dotenv';
import logger from '../utils/logger';
import { ValidationError, ErrorCode } from '../services/errors';

dotenv.config();

interface EnvironmentVariables {
  // Required variables
  DATABASE_URL: string;
  GOOGLE_AI_API_KEY: string;
  WHATSAPP_PHONE_NUMBER_MESSAGING_ID: string;
  WHATSAPP_ACCESS_TOKEN: string;
  WHATSAPP_VERIFY_TOKEN: string;
  FRONTEND_BASE_URL: string;
  GEMINI_MODEL: string;
  EMBEDDING_MODEL: string;
  
  // Optional variables
  STRIPE_SECRET_KEY?: string;
  STRIPE_WEBHOOK_SECRET?: string;
  NODE_ENV: string;
  PORT: string;
  RATE_LIMIT_MAX_MESSAGES: string;
  RATE_LIMIT_TIME_WINDOW_MINUTES: string;
  DEFAULT_TIMEZONE: string;
  DEFAULT_LOCALE: string;
  REDIS_HOST?: string;
  REDIS_PORT?: string;
  REDIS_PASSWORD?: string;
  CLOUD_API_KEY?: string;
  BULLMQ_WORKER_CONCURRENCY?: string;
  NUM_WORKERS?: string;
}

class EnvironmentValidator {
  private requiredVars: (keyof EnvironmentVariables)[] = [
    'DATABASE_URL',
    'GOOGLE_AI_API_KEY',
    'WHATSAPP_PHONE_NUMBER_MESSAGING_ID',
    'WHATSAPP_ACCESS_TOKEN',
    'WHATSAPP_VERIFY_TOKEN',
    'FRONTEND_BASE_URL',
    'GEMINI_MODEL',
    'NODE_ENV',
    'PORT',
    'RATE_LIMIT_MAX_MESSAGES',
    'RATE_LIMIT_TIME_WINDOW_MINUTES',
    'DEFAULT_TIMEZONE',
    'DEFAULT_LOCALE'
  ];

  validate(): void {
    logger.info('Starting environment validation...');
    const missingVars: string[] = [];
    
    for (const varName of this.requiredVars) {
      if (!process.env[varName]) {
        missingVars.push(varName);
      } else {
        logger.debug(`Environment variable ${varName}: ${varName.includes('KEY') || varName.includes('TOKEN') ? '[REDACTED]' : process.env[varName]}`);
      }
    }
    
    if (missingVars.length > 0) {
      const errorMessage = `Missing required environment variables: ${missingVars.join(', ')}`;
      logger.error(errorMessage);
      throw new ValidationError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        errorMessage,
        { metadata: { missingVars } }
      );
    }
    
    // Validate specific formats
    this.validateDatabaseUrl();
    this.validateUrl('FRONTEND_BASE_URL');
    
    // Log optional variables status
    if (process.env.STRIPE_SECRET_KEY) {
      logger.info('Stripe payment integration is enabled');
    } else {
      logger.warn('Stripe payment integration is disabled (STRIPE_SECRET_KEY not set)');
    }
    
    logger.info('Environment variables validated successfully');
  }
  
  private validateDatabaseUrl(): void {
    const dbUrl = process.env.DATABASE_URL;
    if (!dbUrl?.startsWith('postgresql://')) {
      throw new ValidationError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        'DATABASE_URL must be a valid PostgreSQL connection string',
        { metadata: { providedUrl: dbUrl } }
      );
    }
  }
  
  
  private validateUrl(varName: string): void {
    const url = process.env[varName];
    try {
      if (url) {
        new URL(url);
      }
    } catch {
      throw new ValidationError(
        ErrorCode.MISSING_REQUIRED_FIELD,
        `${varName} must be a valid URL`,
        { metadata: { varName, providedUrl: url } }
      );
    }
  }
  
  getEnv(): EnvironmentVariables {
    return {
      DATABASE_URL: process.env.DATABASE_URL!,
      GOOGLE_AI_API_KEY: process.env.GOOGLE_AI_API_KEY!,
      WHATSAPP_PHONE_NUMBER_MESSAGING_ID: process.env.WHATSAPP_PHONE_NUMBER_MESSAGING_ID!,
      WHATSAPP_ACCESS_TOKEN: process.env.WHATSAPP_ACCESS_TOKEN!,
      WHATSAPP_VERIFY_TOKEN: process.env.WHATSAPP_VERIFY_TOKEN!,
      FRONTEND_BASE_URL: process.env.FRONTEND_BASE_URL!,
      GEMINI_MODEL: process.env.GEMINI_MODEL!,
      EMBEDDING_MODEL: process.env.EMBEDDING_MODEL || 'text-embedding-004',
      STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
      STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
      NODE_ENV: process.env.NODE_ENV!,
      PORT: process.env.PORT!,
      RATE_LIMIT_MAX_MESSAGES: process.env.RATE_LIMIT_MAX_MESSAGES!,
      RATE_LIMIT_TIME_WINDOW_MINUTES: process.env.RATE_LIMIT_TIME_WINDOW_MINUTES!,
      DEFAULT_TIMEZONE: process.env.DEFAULT_TIMEZONE!,
      DEFAULT_LOCALE: process.env.DEFAULT_LOCALE!,
      REDIS_HOST: process.env.REDIS_HOST,
      REDIS_PORT: process.env.REDIS_PORT,
      REDIS_PASSWORD: process.env.REDIS_PASSWORD,
      CLOUD_API_KEY: process.env.CLOUD_API_KEY,
      BULLMQ_WORKER_CONCURRENCY: process.env.BULLMQ_WORKER_CONCURRENCY,
      NUM_WORKERS: process.env.NUM_WORKERS
    };
  }
}

export const envValidator = new EnvironmentValidator();
export const env = envValidator.getEnv();

================
File: backend/src/services/ai/MenuSearchService.ts
================
import logger from '../../common/utils/logger';
import { prisma } from '../../lib/prisma';
import { Prisma } from '@prisma/client';
import { GoogleGenAI } from '@google/genai';
import { env } from '../../common/config/envValidator';
import { TechnicalError, ErrorCode } from '../../common/services/errors';

/**
 * Service for searching and matching menu items based on natural language input
 * Uses semantic search with Google embeddings and pgvector
 */
export class MenuSearchService {
  private static genAI = new GoogleGenAI({ apiKey: env.GOOGLE_AI_API_KEY });

  /**
   * Gets relevant menu items based on keywords using semantic search
   * @param itemsSummary Natural language description of items
   * @returns JSON string of relevant menu items with their full structure
   */
  static async getRelevantMenu(itemsSummary: string): Promise<string> {
    try {
      // 1. Generate embedding for user query
      const embeddingResponse = await this.genAI.models.embedContent({
        model: env.EMBEDDING_MODEL,
        contents: itemsSummary,
        config: {
          outputDimensionality: 768  // Force 768 dimensions for compatibility with pgvector
        }
      });
      const queryEmbedding = embeddingResponse.embeddings?.[0]?.values || [];
      
      if (queryEmbedding.length === 0) {
        logger.error('Failed to generate embedding for query');
        throw new TechnicalError(
          ErrorCode.EMBEDDING_GENERATION_FAILED,
          'Failed to generate embedding for menu search query',
          { query: itemsSummary }
        );
      }

      // 2. Search database for most similar products using pgvector
      let relevantProductIds: string[] = [];

      // Use pgvector for efficient similarity search with threshold
      try {
        // First, get products with similarity scores
        // Use Prisma.sql to safely build the query with proper parameterization
        const embeddingVector = `[${queryEmbedding.join(',')}]`;
        const relevantProductsResult: { id: string, distance: number }[] = await prisma.$queryRaw`
          SELECT id, 
                 (embedding <=> ${Prisma.sql`${embeddingVector}::vector`}) as distance
          FROM "Product"
          WHERE embedding IS NOT NULL
          ORDER BY distance
          LIMIT 20
        `;
        
        // Filter by similarity threshold (lower distance = more similar)
        // Based on testing: 0.0-0.3 = very similar, 0.3-0.4 = somewhat similar, >0.4 = different
        const SIMILARITY_THRESHOLD = 0.4; // Only include products with strong similarity
        
        const filteredProducts = relevantProductsResult.filter(p => p.distance < SIMILARITY_THRESHOLD);
        
        // If no products meet the strict threshold, but the top result is reasonably close, include it
        if (filteredProducts.length === 0 && relevantProductsResult.length > 0 && relevantProductsResult[0].distance < 0.45) {
          filteredProducts.push(relevantProductsResult[0]);
          // Including top match even though it's slightly above threshold
        }
        
        relevantProductIds = filteredProducts.map(p => p.id);
      } catch (error) {
        logger.error('Error in vector search:', error);
        return "[]";
      }

      if (relevantProductIds.length === 0) {
        logger.warn('No relevant products found via vector search within threshold');
        return "[]";
      }

      // 3. Get full product details
      const products = await prisma.product.findMany({
        where: {
          id: { in: relevantProductIds },
          isActive: true,
        },
        include: {
          subcategory: { include: { category: true } },
          variants: { where: { isActive: true } },
          modifierGroups: {
            where: { isActive: true },
            include: {
              productModifiers: { where: { isActive: true } },
            },
          },
          pizzaCustomizations: { where: { isActive: true } },
        },
      });

      // 4. Sort products by the original order from search
      const sortedProducts = relevantProductIds
        .map(id => products.find(p => p.id === id))
        .filter(Boolean);

      // 5. Build menu structure
      const menuStructure = this.buildMenuStructure(sortedProducts as any[]);
      
      logger.info(`MenuSearchService: Returning ${menuStructure.length} relevant products for query "${itemsSummary}"`);
      // Log only product names for debugging, not full structure
      if (menuStructure.length > 0) {
        const productNames = menuStructure.map((p: any) => p.nombre).join(', ');
        logger.info(`MenuSearchService: Products found: ${productNames}`);
      } else {
        logger.warn(`MenuSearchService: No relevant products found for query "${itemsSummary}"`);
      }
      
      return JSON.stringify(menuStructure);
    } catch (error) {
      logger.error('Error in vector search:', error);
      return "[]";
    }
  }


  /**
   * Builds the menu structure for AI consumption
   * Only includes necessary information for order mapping (no prices needed at this stage)
   */
  private static buildMenuStructure(products: any[]): any[] {
    return products.map(product => {
      const item: any = {
        id: product.id,
        nombre: product.name,
      };
      
      // Include variants with IDs and names only (no prices)
      if (product.variants?.length > 0) {
        item.variantes = product.variants.map((v: any) => ({
          id: v.id,
          nombre: v.name
        }));
      }
      
      // Include modifiers if they exist (simplified)
      if (product.modifierGroups?.length > 0) {
        item.modificadores = product.modifierGroups
          .filter((g: any) => g.productModifiers?.length > 0)
          .map((group: any) => ({
            grupo: group.name,
            opciones: group.productModifiers.map((m: any) => ({
              id: m.id,
              nombre: m.name
            }))
          }));
      }
      
      // Include pizza customizations if it's a pizza
      if (product.isPizza && product.pizzaCustomizations?.length > 0) {
        item.personalizacionesPizza = product.pizzaCustomizations.map((c: any) => ({
          id: c.id,
          nombre: c.name,
          tipo: c.type
        }));
      }
      
      return item;
    });
  }
}

================
File: backend/src/services/orders/services/OrderFormattingService.ts
================
import { FormattedOrder, FormattedOrderProduct } from "../../../common/types/order.types";
import { env } from "../../../common/config/envValidator";
import { PizzaHalf, CustomizationAction, CustomizationType } from "@prisma/client";
import { ConfigService } from "../../config/ConfigService";

export class OrderFormattingService {
  /**
   * Format an order for WhatsApp message display
   */
  static formatOrderForWhatsApp(order: any, customerId: string): FormattedOrder {
    const orderType = order.orderType;
    let deliveryInfo = "";

    // Format delivery information
    if (orderType === "DELIVERY" && order.deliveryInfo) {
      const info = order.deliveryInfo;
      
      // Use full address if available (for phone orders)
      if (info.fullAddress) {
        deliveryInfo = info.fullAddress;
      } else {
        const parts = [];
        // Combine street, number, and interior number
        let fullAddress = info.street || "";
        if (info.number) {
          fullAddress += ` ${info.number}`;
        }
        if (info.interiorNumber) {
          fullAddress += ` Int. ${info.interiorNumber}`;
        }
        if (fullAddress.trim()) parts.push(fullAddress.trim());
        if (info.neighborhood) parts.push(info.neighborhood);
        if (info.city) parts.push(info.city);
        if (info.deliveryInstructions) parts.push(`(${info.deliveryInstructions})`);
        deliveryInfo = parts.join(", ");
      }
      
      // Add recipient info if different from customer
      if (info.recipientName) {
        deliveryInfo += ` - Para: ${info.recipientName}`;
      }
      if (info.recipientPhone) {
        deliveryInfo += ` Tel: ${info.recipientPhone}`;
      }
    } else if (orderType === "TAKE_AWAY" && order.deliveryInfo?.recipientName) {
      deliveryInfo = `Recoger√°: ${order.deliveryInfo.recipientName}`;
      if (order.deliveryInfo.recipientPhone) {
        deliveryInfo += ` - Tel: ${order.deliveryInfo.recipientPhone}`;
      }
    }

    // Group items by product and variant
    const itemGroups: { [key: string]: any[] } = {};
    
    // Group items by product and variant
    order.orderItems?.forEach((item: any) => {
      const key = `${item.productId}_${item.productVariantId || 'null'}`;
      if (!itemGroups[key]) {
        itemGroups[key] = [];
      }
      itemGroups[key].push(item);
    });
    
    const products = Object.values(itemGroups).map((items: any[]) => {
      const item = items[0]; // Take first item as reference
      const productName = item.product?.name || item.productName || "Producto";
      const variantName = item.productVariant?.name || item.variantName || "";
      // When product has variants, show only the variant name
      const name = variantName || productName;
      
      // Calculate total for all items in this group
      const quantity = items.length;
      const unitPrice = item.finalPrice || item.basePrice || 0;
      const groupTotalPrice = unitPrice * quantity;
      
      // Modifiers are already included in finalPrice during order creation
      const modifiers = item.productModifiers?.map((mod: any) => ({
        name: mod.name || "Modificador",
        price: mod.price || 0,
      })) || [];

      // Map pizza customizations from first item (they should be the same)
      const pizzaCustomizations = item.selectedPizzaCustomizations?.map((selectedCust: any) => ({
        half: selectedCust.half as string,
        name: selectedCust.pizzaCustomization?.name || "Personalizaci√≥n",
        action: selectedCust.action,
        type: selectedCust.pizzaCustomization?.type || "INGREDIENT",
        ingredients: selectedCust.pizzaCustomization?.ingredients,
      })) || [];

      return {
        name: name,
        quantity: quantity,
        price: groupTotalPrice,
        modifiers: modifiers,
        pizzaCustomizations: pizzaCustomizations?.length > 0 ? pizzaCustomizations : undefined,
        comments: item.comments,
      };
    });

    // Format dates
    const createdAt = order.createdAt.toLocaleString(env.DEFAULT_LOCALE, {
      timeZone: env.DEFAULT_TIMEZONE,
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });

    const scheduledDelivery = order.scheduledAt
      ? order.scheduledAt.toLocaleString(env.DEFAULT_LOCALE, {
          timeZone: env.DEFAULT_TIMEZONE,
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        })
      : null;

    // Use the total from order directly
    const totalPrice = order.total || 0;

    return {
      id: order.id,
      shiftOrderNumber: order.shiftOrderNumber,
      orderType: order.orderType,
      customerId: order.customerId,
      phoneNumber: order.customer?.whatsappPhoneNumber || customerId,
      deliveryInfo: deliveryInfo,
      totalPrice: totalPrice,
      createdAt: createdAt,
      scheduledDeliveryTime: scheduledDelivery,
      estimatedDeliveryTime: order.estimatedDeliveryTime 
        ? new Date(order.estimatedDeliveryTime).toLocaleString('es-MX', {
            timeZone: 'America/Mexico_City',
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          })
        : undefined,
      products: products,
    };
  }

  /**
   * Generate order confirmation message
   */
  static async generateConfirmationMessage(order: any, formattedOrder: FormattedOrder): Promise<string> {
    const orderTypeText = order.orderType === "DELIVERY" ? "A domicilio" : 
                         order.orderType === "TAKE_AWAY" ? "Para llevar" : "Para comer aqu√≠";
    
    const config = await ConfigService.getConfig();
    
    let message = `üéâ *¬°Tu orden ha sido creada exitosamente!* üéâ\n\n`;
    message += `üìû *Tel√©fono:* ${formattedOrder.phoneNumber}\n`;
    message += `üìÖ *Fecha de creaci√≥n:* ${formattedOrder.createdAt}\n`;
    message += `üöö *Informaci√≥n de entrega:* ${orderTypeText} - ${formattedOrder.deliveryInfo}\n`;
    
    if (formattedOrder.estimatedDeliveryTime) {
      message += `‚è±Ô∏è *Hora estimada de entrega:* ${formattedOrder.estimatedDeliveryTime}\n`;
    }

    if (formattedOrder.scheduledDeliveryTime) {
      message += `üìÖ *Entrega programada:* ${formattedOrder.scheduledDeliveryTime}\n`;
    }

    message += `\nüõí *Productos:*\n`;
    formattedOrder.products.forEach((product) => {
      message += this.formatProduct(product);
    });

    message += `\nüí∞ *Total: $${formattedOrder.totalPrice}*\n\n`;
    message += `üì© Te notificaremos cuando tu pedido sea aceptado.\n\n`;
    
    // Add restaurant contact info
    message += `üìû *¬øNecesitas hacer cambios?*\n`;
    message += `Comun√≠cate directamente con el restaurante:\n`;
    if (config.phoneMain) {
      message += `üì± ${config.phoneMain}\n`;
    }
    if (config.phoneSecondary) {
      message += `üì± ${config.phoneSecondary}\n`;
    }
    
    message += `\n¬°Gracias por tu preferencia! üôè`;

    return message;
  }

  /**
   * Format a single product for display
   */
  private static formatProduct(product: FormattedOrderProduct): string {
    let summary = `- *${product.quantity}x ${product.name}*: $${product.price}\n`;

    if (product.pizzaCustomizations && product.pizzaCustomizations.length > 0) {
      summary += this.formatPizzaCustomizations(product.pizzaCustomizations);
    }

    if (product.modifiers.length > 0) {
      summary += `  üî∏ Modificadores: ${product.modifiers
        .map((mod: any) => mod.name)
        .join(", ")}\n`;
    }

    if (product.comments) {
      summary += `  üí¨ Comentarios: ${product.comments}\n`;
    }

    return summary;
  }

  /**
   * Format pizza customizations for display
   */
  private static formatPizzaCustomizations(customizations: any[]): string {
    const addCustomizations = customizations.filter((c: any) => c.action === CustomizationAction.ADD);
    const removeCustomizations = customizations.filter((c: any) => c.action === CustomizationAction.REMOVE);
    
    let result = "";
    
    // Group by type and half
    const flavors = {
      HALF_1: addCustomizations.filter(c => c.type === CustomizationType.FLAVOR && c.half === PizzaHalf.HALF_1),
      HALF_2: addCustomizations.filter(c => c.type === CustomizationType.FLAVOR && c.half === PizzaHalf.HALF_2),
      FULL: addCustomizations.filter(c => c.type === CustomizationType.FLAVOR && c.half === PizzaHalf.FULL)
    };
    
    const ingredients = {
      HALF_1: addCustomizations.filter(c => c.type === CustomizationType.INGREDIENT && c.half === PizzaHalf.HALF_1),
      HALF_2: addCustomizations.filter(c => c.type === CustomizationType.INGREDIENT && c.half === PizzaHalf.HALF_2),
      FULL: addCustomizations.filter(c => c.type === CustomizationType.INGREDIENT && c.half === PizzaHalf.FULL)
    };
    
    const removed = {
      HALF_1: removeCustomizations.filter(c => c.half === PizzaHalf.HALF_1),
      HALF_2: removeCustomizations.filter(c => c.half === PizzaHalf.HALF_2),
      FULL: removeCustomizations.filter(c => c.half === PizzaHalf.FULL)
    };
    
    // Format full pizza
    if (flavors.FULL.length > 0 || ingredients.FULL.length > 0 || removed.FULL.length > 0) {
      const parts = [];
      if (flavors.FULL.length > 0) {
        parts.push(flavors.FULL.map(f => f.name).join(", "));
      }
      if (ingredients.FULL.length > 0) {
        parts.push(`con: ${ingredients.FULL.map(i => i.name).join(", ")}`);
      }
      if (removed.FULL.length > 0) {
        parts.push(`sin: ${removed.FULL.map(r => r.name).join(", ")}`);
      }
      result += `  üî∏ ${parts.join(" - ")}\n`;
    }
    
    // Format half pizzas
    const hasHalf1 = flavors.HALF_1.length > 0 || ingredients.HALF_1.length > 0 || removed.HALF_1.length > 0;
    const hasHalf2 = flavors.HALF_2.length > 0 || ingredients.HALF_2.length > 0 || removed.HALF_2.length > 0;
    
    if (hasHalf1 && hasHalf2) {
      const half1Parts = [];
      const half2Parts = [];
      
      // Build half 1
      if (flavors.HALF_1.length > 0) {
        half1Parts.push(flavors.HALF_1.map(f => f.name).join(", "));
      }
      if (ingredients.HALF_1.length > 0) {
        half1Parts.push(`con: ${ingredients.HALF_1.map(i => i.name).join(", ")}`);
      }
      if (removed.HALF_1.length > 0) {
        half1Parts.push(`sin: ${removed.HALF_1.map(r => r.name).join(", ")}`);
      }
      
      // Build half 2
      if (flavors.HALF_2.length > 0) {
        half2Parts.push(flavors.HALF_2.map(f => f.name).join(", "));
      }
      if (ingredients.HALF_2.length > 0) {
        half2Parts.push(`con: ${ingredients.HALF_2.map(i => i.name).join(", ")}`);
      }
      if (removed.HALF_2.length > 0) {
        half2Parts.push(`sin: ${removed.HALF_2.map(r => r.name).join(", ")}`);
      }
      
      result += `  üî∏ (${half1Parts.join(" ")} / ${half2Parts.join(" ")})\n`;
    }
    
    return result;
  }
}

================
File: backend/package.json
================
{
  "name": "backend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "ts-node --transpile-only src/server.ts",
    "dev:worker": "ts-node --transpile-only src/run-workers.ts",
    "dev:all": "cd .. && ./dev.sh",
    "dev:frontend": "cd .. && ./dev-frontend.sh",
    "build": "tsc",
    "start": "node dist/server.js",
    "start:worker": "node dist/run-workers.js",
    "start:prod": "node dist/server.js",
    "migrate": "prisma migrate deploy",
    "migrate:dev": "prisma migrate dev",
    "generate": "prisma generate",
    "studio": "prisma studio",
    "seed:embeddings": "node scripts/generate-embeddings.js",
    "reset-db": "./scripts/reset-db.sh",
    "postinstall": "prisma generate",
    "pm2:start": "npm run build && pm2 start ecosystem.config.js",
    "pm2:stop": "pm2 stop ecosystem.config.js",
    "pm2:delete": "pm2 delete ecosystem.config.js",
    "pm2:reload": "pm2 reload ecosystem.config.js",
    "pm2:logs": "pm2 logs",
    "pm2:monit": "pm2 monit"
  },
  "dependencies": {
    "@google/genai": "^1.5.1",
    "@prisma/client": "^6.9.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "@types/ioredis": "^4.28.10",
    "@types/multer": "^1.4.13",
    "axios": "^1.7.7",
    "bullmq": "^5.56.4",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^4.21.2",
    "ioredis": "^5.6.1",
    "moment": "^2.30.1",
    "moment-timezone": "^0.5.45",
    "multer": "^2.0.1",
    "pg": "^8.13.0",
    "prisma": "^6.9.0",
    "reflect-metadata": "^0.2.2",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "stripe": "^17.3.1",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@types/axios": "^0.14.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^24.0.15",
    "@types/supertest": "^6.0.3",
    "jest": "^30.0.4",
    "supertest": "^7.1.3",
    "ts-jest": "^29.4.0",
    "ts-node": "^10.9.2"
  }
}

================
File: backend/src/api/audio/audioHealth.controller.ts
================
import { Request, Response } from 'express';
import { GeminiService } from '../../services/ai/GeminiService';
import { prisma } from '../../lib/prisma';
import logger from '../../common/utils/logger';

interface HealthCheckResponse {
  status: 'ok' | 'error';
  message: string;
  timestamp: string;
  services: {
    server: 'healthy' | 'unhealthy';
    database: 'connected' | 'disconnected';
    ai: 'connected' | 'disconnected';
    embeddings: 'available' | 'unavailable';
  };
}

export class AudioHealthController {
  static async checkHealth(req: Request, res: Response): Promise<void> {
    const startTime = Date.now();
    const services: HealthCheckResponse['services'] = {
      server: 'healthy',
      database: 'disconnected',
      ai: 'disconnected',
      embeddings: 'unavailable'
    };

    try {
      // Check database connection
      try {
        await prisma.$queryRaw`SELECT 1`;
        services.database = 'connected';
        logger.debug('Health check: Database connected');
      } catch (error) {
        logger.error('Health check: Database connection failed', { error });
      }

      // Check AI service (Gemini)
      try {
        // Simple test to verify Gemini is accessible
        const testPrompt = 'Hello';
        const response = await Promise.race([
          GeminiService.generateContentWithHistory(
            [{ role: 'user', parts: [{ text: testPrompt }] }],
            'You are a health check bot. Reply with "ok".',
            []
          ),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('AI service timeout')), 3000)
          )
        ]);
        
        if (response) {
          services.ai = 'connected';
          logger.debug('Health check: AI service connected');
        }
      } catch (error) {
        logger.error('Health check: AI service connection failed', { error });
      }

      // Check embeddings availability
      try {
        // Check if embeddings table has data using raw SQL
        const result = await prisma.$queryRaw<{ count: bigint }[]>`
          SELECT COUNT(*) as count 
          FROM "Product" 
          WHERE embedding IS NOT NULL
        `;
        
        const embeddingsCount = Number(result[0]?.count || 0);
        
        if (embeddingsCount > 0) {
          services.embeddings = 'available';
          logger.debug('Health check: Embeddings available', { count: embeddingsCount });
        }
      } catch (error) {
        logger.error('Health check: Embeddings check failed', { error });
      }

      // Determine overall status
      const allServicesHealthy = 
        services.database === 'connected' && 
        services.ai === 'connected' &&
        services.embeddings === 'available';

      const status: HealthCheckResponse['status'] = allServicesHealthy ? 'ok' : 'error';
      const message = allServicesHealthy 
        ? 'Audio processing service is healthy'
        : `Service degraded: ${Object.entries(services)
            .filter(([_, status]) => status !== 'connected' && status !== 'healthy' && status !== 'available')
            .map(([service]) => service)
            .join(', ')} not available`;

      const responseTime = Date.now() - startTime;
      logger.info('Health check completed', { 
        status, 
        services, 
        responseTime 
      });

      const response: HealthCheckResponse = {
        status,
        message,
        timestamp: new Date().toISOString(),
        services
      };

      res.status(status === 'ok' ? 200 : 503).json(response);
    } catch (error) {
      logger.error('Health check failed with unexpected error', { error });
      
      const response: HealthCheckResponse = {
        status: 'error',
        message: 'Health check failed',
        timestamp: new Date().toISOString(),
        services
      };
      
      res.status(503).json(response);
    }
  }
}

================
File: backend/src/common/services/errors/types.ts
================
export enum ErrorType {
  BUSINESS_LOGIC = 'BUSINESS_LOGIC',
  VALIDATION = 'VALIDATION',
  TECHNICAL = 'TECHNICAL',
  EXTERNAL_SERVICE = 'EXTERNAL_SERVICE',
  RATE_LIMIT = 'RATE_LIMIT',
  NOT_FOUND = 'NOT_FOUND'
}

export enum ErrorCode {
  // Business Logic
  ORDER_NOT_FOUND = 'BL001',
  RESTAURANT_CLOSED = 'BL004',
  NOT_ACCEPTING_ORDERS = 'BL005',
  PAYMENT_LINK_EXISTS = 'BL006',
  CUSTOMER_NOT_FOUND = 'BL007',
  USER_BANNED = 'BL008',
  NO_PRODUCTS_FOUND = 'BL009',
  EMPTY_ORDER = 'BL010',
  
  // Validation
  INVALID_PRODUCT = 'VAL001',
  MISSING_DELIVERY_INFO = 'VAL002',
  INVALID_SCHEDULE_TIME = 'VAL003',
  MISSING_REQUIRED_FIELD = 'VAL004',
  INVALID_OTP = 'VAL006',
  INVALID_TOKEN = 'VAL007',
  FILE_TOO_LARGE = 'VAL009',
  WEBHOOK_VERIFICATION_FAILED = 'VAL010',
  
  // Not Found
  ADDRESS_NOT_FOUND = 'NF001',
  
  // Validation - Address
  ADDRESS_OUTSIDE_COVERAGE = 'VAL008',
  
  // Technical
  DATABASE_ERROR = 'TECH001',
  WHATSAPP_API_ERROR = 'TECH002',
  PAYMENT_PROCESSING_ERROR = 'TECH003',
  AI_SERVICE_ERROR = 'TECH004',
  TRANSCRIPTION_ERROR = 'TECH005',
  AUTHENTICATION_REQUIRED = 'TECH006',
  INVALID_CREDENTIALS = 'TECH007',
  EMBEDDING_GENERATION_FAILED = 'TECH008',
  AI_PROCESSING_ERROR = 'TECH009',
  
  // External Service
  STRIPE_ERROR = 'EXT001',
  GEMINI_ERROR = 'EXT002',
  WHATSAPP_ERROR = 'EXT003',
  
  // Rate Limit
  RATE_LIMIT_EXCEEDED = 'RL001'
}

export interface ErrorContext {
  userId?: string;
  customerId?: string;
  orderId?: number | string; // Support both numeric and UUID order IDs
  operation?: string;
  metadata?: Record<string, any>;
  [key: string]: any; // Allow additional properties
}

export interface ErrorResponse {
  userMessage: string;
  logMessage: string;
  errorCode: ErrorCode;
  errorType: ErrorType;
  shouldNotifyUser: boolean;
  context?: ErrorContext;
}

================
File: backend/src/services/orders/services/DeliveryInfoService.ts
================
import { prisma } from '../../../lib/prisma';
import { ValidationError, ErrorCode, NotFoundError } from "../../../common/services/errors";
import logger from "../../../common/utils/logger";
import { DeliveryInfoInput } from "../../../common/types";
import { Address, Prisma, OrderType } from "@prisma/client";
import { SyncMetadataService } from "../../sync/SyncMetadataService";

export class DeliveryInfoService {
  /**
   * Obtener o crear informaci√≥n de entrega para una orden
   */
  static async getOrCreateDeliveryInfo(
    orderType: OrderType,
    customerId: string,
    deliveryInfoInput?: DeliveryInfoInput,
    customerData?: { firstName?: string | null, lastName?: string | null, whatsappPhoneNumber: string }
  ): Promise<any> {
    // Obtener la direcci√≥n predeterminada del cliente o la primera direcci√≥n activa
    const customerAddress = await prisma.address.findFirst({
      where: { 
        customerId,
        deletedAt: null
      },
      orderBy: [
        { isDefault: 'desc' },
        { createdAt: 'desc' }
      ]
    });

    if (!customerAddress) {
      throw new ValidationError(
        ErrorCode.MISSING_DELIVERY_INFO,
        'Customer has no active addresses',
        { metadata: { customerId } }
      );
    }

    // Construir datos de informaci√≥n de entrega basados en el tipo de orden
    let deliveryInfoData: any = {};

    if (orderType === OrderType.DELIVERY) {
      // Copiar todos los campos de direcci√≥n desde la direcci√≥n del cliente
      // Esto crea una instant√°nea de la direcci√≥n en el momento de la orden
      deliveryInfoData = {
        street: deliveryInfoInput?.street || customerAddress.street,
        number: customerAddress.number,
        interiorNumber: customerAddress.interiorNumber,
        neighborhood: deliveryInfoInput?.neighborhood || customerAddress.neighborhood,
        zipCode: deliveryInfoInput?.zipCode || customerAddress.zipCode,
        city: deliveryInfoInput?.city || customerAddress.city,
        state: deliveryInfoInput?.state || customerAddress.state,
        country: deliveryInfoInput?.country || customerAddress.country,
        latitude: deliveryInfoInput?.latitude || customerAddress.latitude?.toNumber(),
        longitude: deliveryInfoInput?.longitude || customerAddress.longitude?.toNumber(),
        deliveryInstructions: deliveryInfoInput?.deliveryInstructions || customerAddress.deliveryInstructions,
        recipientName: deliveryInfoInput?.recipientName || 
          (customerData ? `${customerData.firstName || ''} ${customerData.lastName || ''}`.trim() || null : null),
        recipientPhone: deliveryInfoInput?.recipientPhone || customerData?.whatsappPhoneNumber,
      };

      // Validar campos requeridos para entrega
      if (!deliveryInfoData.street || !deliveryInfoData.number) {
        throw new ValidationError(
          ErrorCode.MISSING_DELIVERY_INFO,
          'Street address and number are required for delivery orders',
          { metadata: { customerId, orderType } }
        );
      }
    } else if (orderType === OrderType.TAKE_AWAY) {
      // Para √≥rdenes de recogida, guardar quien recoger√° la orden
      deliveryInfoData = {
        recipientName: deliveryInfoInput?.recipientName || 
          (customerData ? `${customerData.firstName || ''} ${customerData.lastName || ''}`.trim() || null : null),
        recipientPhone: deliveryInfoInput?.recipientPhone || customerData?.whatsappPhoneNumber,
      };
    }

    // Crear una copia de informaci√≥n de entrega para esta orden espec√≠fica
    // Esto preserva la direcci√≥n en el momento de creaci√≥n de la orden
    const deliveryInfo = await prisma.deliveryInfo.create({
      data: deliveryInfoData
    });

    logger.info(`Created delivery info ${deliveryInfo.id} from customer address`);
    return deliveryInfo;
  }



  /**
   * Crear direcci√≥n del cliente
   */
  static async createCustomerAddress(
    data: Prisma.AddressCreateInput
  ): Promise<Address> {
    try {
      // Si esta es la primera direcci√≥n, hacerla predeterminada
      const existingAddresses = await prisma.address.count({
        where: { 
          customerId: data.customer.connect?.id || data.customer.connectOrCreate?.where.id,
          deletedAt: null
        }
      });
      
      const addressData = {
        ...data,
        isDefault: existingAddresses === 0 ? true : (data.isDefault || false)
      };
      
      // Si se establece como predeterminada, desmarcar otras predeterminadas
      if (addressData.isDefault) {
        await prisma.address.updateMany({
          where: { 
            customerId: data.customer.connect?.id || data.customer.connectOrCreate?.where.id,
            isDefault: true
          },
          data: { isDefault: false }
        });
      }
      
      const address = await prisma.address.create({
        data: addressData
      });
      
      // Mark for sync
      await SyncMetadataService.markForSync('Address', address.id, 'REMOTE');
      
      logger.info(`Created customer address ${address.id} for customer ${address.customerId}`);
      return address;
    } catch (error) {
      logger.error('Error creating customer address:', error);
      throw new ValidationError(ErrorCode.DATABASE_ERROR, 'Failed to create customer address', { metadata: { error: error instanceof Error ? error.message : 'Unknown error' } });
    }
  }

  /**
   * Actualizar direcci√≥n del cliente
   */
  static async updateCustomerAddress(
    addressId: string,
    data: Prisma.AddressUpdateInput
  ): Promise<Address> {
    try {
      const deliveryInfo = await prisma.address.update({
        where: { id: addressId },
        data
      });
      
      // Mark for sync
      await SyncMetadataService.markForSync('Address', addressId, 'REMOTE');
      
      logger.info(`Updated address ${addressId}`);
      return deliveryInfo;
    } catch (error: any) {
      if (error.code === 'P2025') {
        throw new NotFoundError(
          ErrorCode.ORDER_NOT_FOUND,
          'Address not found',
          { metadata: { addressId } }
        );
      }
      
      logger.error('Error updating customer address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to update customer address',
        { metadata: { addressId } }
      );
    }
  }


  /**
   * Obtener todas las direcciones del cliente
   */
  static async getCustomerAddresses(
    customerId: string,
    includeInactive: boolean = false
  ): Promise<Address[]> {
    try {
      const addresses = await prisma.address.findMany({
        where: { 
          customerId,
          ...(includeInactive ? {} : { deletedAt: null })
        },
        orderBy: [
          { isDefault: 'desc' },
          { createdAt: 'desc' }
        ]
      });
      
      return addresses;
    } catch (error) {
      logger.error('Error fetching customer addresses:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to fetch customer addresses',
        { metadata: { customerId } }
      );
    }
  }

  /**
   * Obtener la direcci√≥n predeterminada del cliente
   */
  static async getCustomerDefaultAddress(
    customerId: string
  ): Promise<Address | null> {
    try {
      const address = await prisma.address.findFirst({
        where: { 
          customerId,
          isDefault: true,
          deletedAt: null
        }
      });
      
      if (!address) {
        // Si no hay predeterminada, obtener la primera direcci√≥n activa
        const firstAddress = await prisma.address.findFirst({
          where: { 
            customerId,
            deletedAt: null
          },
          orderBy: { createdAt: 'desc' }
        });
        
        return firstAddress;
      }
      
      return address;
    } catch (error) {
      logger.error('Error fetching default address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to fetch default address',
        { metadata: { customerId } }
      );
    }
  }

  /**
   * Establecer direcci√≥n como predeterminada
   */
  static async setDefaultAddress(
    addressId: string,
    customerId?: string
  ): Promise<Address> {
    try {
      // Get the address first to verify it exists and get customerId if not provided
      const address = await prisma.address.findUnique({
        where: { id: addressId },
        select: { customerId: true }
      });
      
      if (!address) {
        throw new NotFoundError(
          ErrorCode.ADDRESS_NOT_FOUND,
          'Address not found',
          { metadata: { addressId } }
        );
      }
      
      // Use provided customerId or the one from the address
      const actualCustomerId = customerId || address.customerId;
      
      // Verify ownership if customerId was provided
      if (customerId && address.customerId !== customerId) {
        throw new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          'Address does not belong to customer',
          { metadata: { addressId, customerId } }
        );
      }
      
      // Desmarcar otras predeterminadas
      const previousDefaults = await prisma.address.findMany({
        where: { 
          customerId: actualCustomerId,
          isDefault: true
        },
        select: { id: true }
      });
      
      await prisma.address.updateMany({
        where: { 
          customerId: actualCustomerId,
          isDefault: true
        },
        data: { isDefault: false }
      });
      
      // Mark previous defaults for sync
      for (const prevDefault of previousDefaults) {
        await SyncMetadataService.markForSync('Address', prevDefault.id, 'REMOTE');
      }
      
      // Establecer esta como predeterminada
      const updatedAddress = await prisma.address.update({
        where: { id: addressId },
        data: { isDefault: true }
      });
      
      // Mark new default for sync
      await SyncMetadataService.markForSync('Address', addressId, 'REMOTE');
      
      logger.info(`Set address ${addressId} as default for customer ${actualCustomerId}`);
      return updatedAddress;
    } catch (error) {
      if (error instanceof NotFoundError || error instanceof ValidationError) {
        throw error;
      }
      
      logger.error('Error setting default address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to set default address',
        { metadata: { addressId } }
      );
    }
  }

  /**
   * Eliminaci√≥n suave de direcci√≥n
   */
  static async deleteCustomerAddress(
    addressId: string,
    customerId?: string
  ): Promise<void> {
    try {
      // Get the address to verify ownership
      const address = await prisma.address.findUnique({
        where: { id: addressId }
      });
      
      if (!address) {
        throw new NotFoundError(
          ErrorCode.ADDRESS_NOT_FOUND,
          'Address not found',
          { metadata: { addressId } }
        );
      }
      
      // Verify ownership if customerId was provided
      if (customerId && address.customerId !== customerId) {
        throw new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          'Address does not belong to customer',
          { metadata: { addressId, customerId } }
        );
      }
      
      // Eliminaci√≥n suave
      await prisma.address.update({
        where: { id: addressId },
        data: { 
          deletedAt: new Date()
        }
      });
      
      // Mark for sync
      await SyncMetadataService.markForSync('Address', addressId, 'REMOTE');
      
      // Si era predeterminada, establecer otra como predeterminada
      if (address.isDefault) {
        const nextDefault = await prisma.address.findFirst({
          where: { 
            customerId: address.customerId,
            deletedAt: null,
            id: { not: addressId }
          },
          orderBy: { createdAt: 'desc' }
        });
        
        if (nextDefault) {
          await this.setDefaultAddress(nextDefault.id, address.customerId);
        }
      }
      
      logger.info(`Soft deleted address ${addressId} for customer ${address.customerId}`);
    } catch (error) {
      if (error instanceof NotFoundError || error instanceof ValidationError) {
        throw error;
      }
      
      logger.error('Error deleting address:', error);
      throw new ValidationError(
        ErrorCode.DATABASE_ERROR,
        'Failed to delete address',
        { metadata: { addressId } }
      );
    }
  }
}

================
File: backend/src/whatsapp/handlers/orders/orderFormatters.ts
================
// En: backend/src/whatsapp/handlers/orders/orderFormatters.ts

import { env } from '../../../common/config/envValidator';
import { CalculatedOrderItem } from '../../../common/types';

/**
 * Formatea las personalizaciones de una pizza de manera legible.
 * Esta funci√≥n es ahora la √öNICA responsable de formatear pizzas.
 * @param customizations - Array de `pizzaCustomizationDetails` del `CalculatedOrderItem`.
 * @returns Un string formateado que describe las personalizaciones.
 */
function formatPizzaCustomizations(customizations: CalculatedOrderItem['pizzaCustomizationDetails']): string {
  if (!customizations || customizations.length === 0) {
    return '';
  }

  // Agrupar personalizaciones por mitad (FULL, HALF_1, HALF_2)
  const groups = customizations.reduce((acc, cust) => {
    acc[cust.half] = acc[cust.half] || [];
    acc[cust.half].push(cust);
    return acc;
  }, {} as Record<string, typeof customizations>);

  // Funci√≥n auxiliar para formatear una mitad
  const formatHalf = (halfCustoms: typeof customizations): string => {
    const flavors = halfCustoms.filter(c => c.type === 'FLAVOR' && c.action === 'ADD').map(c => c.name);
    const ingredients = halfCustoms.filter(c => c.type === 'INGREDIENT' && c.action === 'ADD').map(c => c.name);
    const removed = halfCustoms.filter(c => c.action === 'REMOVE').map(c => c.name);

    let parts: string[] = [];
    if (flavors.length > 0) parts.push(flavors.join(', '));
    if (ingredients.length > 0) parts.push(`con: ${ingredients.join(', ')}`);
    if (removed.length > 0) parts.push(`sin: ${removed.join(', ')}`);
    
    return parts.join(' - ');
  };

  const fullPizzaText = groups['FULL'] ? formatHalf(groups['FULL']) : '';
  const half1Text = groups['HALF_1'] ? formatHalf(groups['HALF_1']) : '';
  const half2Text = groups['HALF_2'] ? formatHalf(groups['HALF_2']) : '';

  let result = '';
  if (fullPizzaText) {
    result += `  ${fullPizzaText}\n`;
  }
  if (half1Text && half2Text) {
    result += `  (Mitad: ${half1Text} / Mitad: ${half2Text})\n`;
  } else if (half1Text) {
    result += `  (Mitad: ${half1Text})\n`;
  } else if (half2Text) {
    result += `  (Mitad: ${half2Text})\n`;
  }

  return result;
}

/**
 * Genera el resumen para un √∫nico producto del pedido.
 * Ahora espera un objeto `CalculatedOrderItem` bien definido.
 */
export function generateProductSummary(item: CalculatedOrderItem): string {
  // El nombre a mostrar es la variante si existe, si no, el producto principal.
  const displayName = item.variantName || item.productName;
  
  // La cantidad ahora se maneja en el objeto principal.
  let summary = `‚Ä¢ *${item.quantity}x ${displayName}* - $${item.totalPrice}\n`;

  // A√±adir modificadores si existen.
  if (item.modifierNames && item.modifierNames.length > 0) {
    summary += `  ${item.modifierNames.join(", ")}\n`;
  }

  // A√±adir personalizaciones de pizza si existen.
  if (item.pizzaCustomizationDetails && item.pizzaCustomizationDetails.length > 0) {
    summary += formatPizzaCustomizations(item.pizzaCustomizationDetails);
  }

  // A√±adir comentarios si existen.
  if (item.comments) {
    summary += `  Nota: ${item.comments}\n`;
  }

  return summary;
}

/**
 * Genera el resumen completo de un pedido para enviar por WhatsApp.
 */
export function generateOrderSummary(order: {
  orderType: string;
  deliveryInfo?: any;
  items: CalculatedOrderItem[];
  total: number;
  estimatedDeliveryTime?: number;
  scheduledAt?: Date;
}): string {
  const orderType = (order.orderType || '').toString().toLowerCase();
  const deliveryTypeText = orderType === "delivery" ? "Entrega a domicilio" : "Recolecci√≥n";

  let message = `üìã *Resumen de tu pedido:*\n\n`;
  message += `üì¶ *Tipo de orden:* ${deliveryTypeText}\n\n`;

  if (orderType === "delivery" && order.deliveryInfo) {
    const info = order.deliveryInfo;
    message += `üìç *Direcci√≥n de entrega:*\n`;
    if (info.name) message += `*${info.name}*\n`;
    message += `${info.street} ${info.number || ''}${info.interiorNumber ? ` Int. ${info.interiorNumber}` : ''}\n`;
    if (info.neighborhood) message += `Col. ${info.neighborhood}\n`;
    if (info.deliveryInstructions) message += `Ref: ${info.deliveryInstructions}\n`;
    message += "\n";
  }

  message += `üõí *Productos:*\n`;
  order.items.forEach(item => {
    // Aqu√≠ es importante asegurarse de que el `item` que se pasa
    // tenga la estructura de `CalculatedOrderItem`.
    message += generateProductSummary(item);
  });

  message += `\nüí∞ *Total: $${order.total.toFixed(2)}*\n`;

  if (order.estimatedDeliveryTime) {
    message += `\n‚è±Ô∏è *Tiempo estimado:* ${order.estimatedDeliveryTime} minutos\n`;
  }

  if (order.scheduledAt) {
    const date = new Date(order.scheduledAt);
    const formattedTime = date.toLocaleTimeString(env.DEFAULT_LOCALE, {
      hour: "2-digit",
      minute: "2-digit",
    });
    message += `\n‚è∞ *Programado para:* Hoy a las ${formattedTime}\n`;
  }

  message += `\nüìù Por favor, confirma si tu pedido es correcto.`;
  
  return message;
}

================
File: COMPLETE_DIGITALOCEAN_DEPLOY.md
================
# üöÄ Gu√≠a de Despliegue en DigitalOcean - cloudbiteapp.com

Esta gu√≠a te llevar√° desde cero hasta tener tu Bot Backend y Frontend funcionando en producci√≥n.

## üìã Tabla de Contenidos

1. [Crear Droplet en DigitalOcean](#1-crear-droplet-en-digitalocean)
2. [Configuraci√≥n DNS](#2-configuraci√≥n-dns)
3. [Acceso Inicial al Servidor](#3-acceso-inicial-al-servidor)
4. [Instalaci√≥n Autom√°tica](#4-instalaci√≥n-autom√°tica)
5. [Configuraci√≥n Post-Instalaci√≥n](#5-configuraci√≥n-post-instalaci√≥n)
6. [Verificaci√≥n y Pruebas](#6-verificaci√≥n-y-pruebas)
7. [Mantenimiento](#7-mantenimiento)

---

## 1. Crear Droplet en DigitalOcean

### üì¶ Especificaciones Recomendadas

1. **Inicia sesi√≥n** en [DigitalOcean](https://www.digitalocean.com)

2. **Crea un nuevo Droplet** con estas especificaciones:
   - **Imagen**: Ubuntu 24.04 (LTS) x64
   - **Plan**: 
     - M√≠nimo: Basic - Regular Intel - $24/mes (4GB RAM, 2 vCPUs)
     - Recomendado: Basic - Regular Intel - $48/mes (8GB RAM, 4 vCPUs)
   - **Datacenter**: El m√°s cercano a tus usuarios
   - **Autenticaci√≥n**: SSH Keys (recomendado) o Password
   - **Hostname**: `bot-cloudbite`

3. **Opciones adicionales** (recomendadas):
   - ‚úÖ IPv6
   - ‚úÖ Monitoring
   - ‚úÖ Backups (+20% del costo mensual)

4. **Crea el Droplet** y espera ~1 minuto

---

## 2. Configuraci√≥n DNS

### üåê En DigitalOcean

> **Importante**: La configuraci√≥n de dominios NO se hace desde la p√°gina del Droplet

1. **Acceder a la secci√≥n de dominios:**
   - En el panel lateral izquierdo, haz clic en **"Networking"**
   - Luego selecciona **"Domains"** en la parte superior
   - O accede directamente a: `https://cloud.digitalocean.com/networking/domains`

2. **Agregar tu dominio:**
   - Haz clic en el bot√≥n **"Add Domain"**
   - Ingresa: `cloudbiteapp.com`
   - Selecciona tu droplet de la lista desplegable (aparecer√° con su IP)
   - Haz clic en **"Add Domain"**

3. **Registros DNS creados autom√°ticamente:**
   ```
   Tipo    Hostname    Value               TTL
   A       @          [IP-DEL-DROPLET]    3600
   A       www        [IP-DEL-DROPLET]    3600
   NS      @          ns1.digitalocean.com
   NS      @          ns2.digitalocean.com
   NS      @          ns3.digitalocean.com
   ```

### üåê En Namecheap (tu registrador de dominio)

1. **Inicia sesi√≥n** en tu cuenta de [Namecheap](https://www.namecheap.com)

2. **Accede a la gesti√≥n del dominio:**
   - En el Dashboard, busca `cloudbiteapp.com`
   - Haz clic en el bot√≥n **"MANAGE"** al lado del dominio

3. **Cambiar los nameservers:**
   - En la pesta√±a **"Domain"**
   - Busca la secci√≥n **"NAMESERVERS"**
   - Selecciona **"Custom DNS"** del men√∫ desplegable
   - Ingresa los nameservers de DigitalOcean:
     ```
     ns1.digitalocean.com
     ns2.digitalocean.com
     ns3.digitalocean.com
     ```
   - Haz clic en el ‚úì (check verde) para guardar

4. **Verificar el cambio:**
   - Deber√≠as ver un mensaje de confirmaci√≥n
   - Los nameservers ahora mostrar√°n los de DigitalOcean

> ‚è±Ô∏è **Nota**: Los cambios DNS pueden tardar hasta 48 horas en propagarse, aunque normalmente toman 15-30 minutos. Puedes verificar la propagaci√≥n en [whatsmydns.net](https://www.whatsmydns.net/)

---

## 3. Acceso Inicial al Servidor

### üîê Conexi√≥n SSH

**Windows (PowerShell/Terminal):**
```bash
ssh root@[IP-DEL-DROPLET]
```

**Mac/Linux:**
```bash
ssh root@[IP-DEL-DROPLET]
```

Si usaste contrase√±a, te la pedir√°. Si usaste SSH key, conectar√° autom√°ticamente.

### üõ°Ô∏è Seguridad Inicial (Opcional pero Recomendado)

```bash
# Cambiar contrase√±a root
passwd

# Crear usuario no-root (mismo nombre que el dominio para consistencia)
adduser cloudbite
usermod -aG sudo cloudbite

# Copiar SSH keys al nuevo usuario
rsync --archive --chown=cloudbite:cloudbite ~/.ssh /home/cloudbite
```

---

## 4. Instalaci√≥n Autom√°tica

### üéØ Opci√≥n A: Script Todo-en-Uno (Recomendado)

Ejecuta este comando √∫nico que instalar√° todo autom√°ticamente:

```bash
wget https://raw.githubusercontent.com/viefmoon/bot_backend/main/scripts/quick-deploy.sh && chmod +x quick-deploy.sh && sudo ./quick-deploy.sh
```

> **Nota**: Si durante la actualizaci√≥n del sistema aparece un di√°logo sobre `/etc/ssh/sshd_config`, selecciona **"keep the local version currently installed"** (mantener versi√≥n local)

El script autom√°ticamente:
- ‚úÖ Actualiza el sistema
- ‚úÖ Instala Node.js 20, PostgreSQL 15, Redis, Nginx
- ‚úÖ Configura la base de datos con pgvector
- ‚úÖ Clona tu repositorio
- ‚úÖ Instala dependencias del backend y frontend
- ‚úÖ Construye el frontend React para producci√≥n
- ‚úÖ Configura SSL con Let's Encrypt
- ‚úÖ Configura Nginx para servir frontend y API
- ‚úÖ Prepara PM2 para gesti√≥n de procesos

### üéØ Opci√≥n B: Instalaci√≥n Manual Paso a Paso

Si prefieres ver qu√© hace cada paso:

```bash
# 1. Instalar dependencias del sistema
wget https://raw.githubusercontent.com/viefmoon/bot_backend/main/scripts/install-dependencies.sh
chmod +x install-dependencies.sh
sudo ./install-dependencies.sh

# 2. Configurar base de datos
wget https://raw.githubusercontent.com/viefmoon/bot_backend/main/scripts/setup-database.sh
chmod +x setup-database.sh
sudo ./setup-database.sh

# 3. Cambiar al usuario de la aplicaci√≥n
su - cloudbite

# 4. Clonar y configurar aplicaci√≥n
git clone https://github.com/viefmoon/bot_backend.git
cd bot_backend
./scripts/setup-app.sh

# 5. Configurar Nginx + SSL
exit  # Volver a root
cd /home/cloudbite/bot_backend
sudo ./scripts/configure-nginx-ssl.sh
```

---

## 5. Configuraci√≥n Post-Instalaci√≥n

### üîß Configurar Variables de Entorno

1. **Cambiar al usuario de la aplicaci√≥n:**
   ```bash
   su - cloudbite
   ```

2. **Editar el archivo .env:**
   ```bash
   cd ~/bot_backend/backend
   nano .env
   ```

3. **Actualizar estas variables con tus valores reales:**

   ```env
   # Google AI - REQUERIDO
   GOOGLE_AI_API_KEY=tu_api_key_de_google_ai
   
   # WhatsApp Business API - REQUERIDO
   WHATSAPP_PHONE_NUMBER_MESSAGING_ID=tu_phone_number_id
   WHATSAPP_ACCESS_TOKEN=tu_access_token_de_whatsapp
   WHATSAPP_VERIFY_TOKEN=un_token_secreto_que_tu_elijas
   
   # Opcional: Stripe (si usas pagos)
   STRIPE_SECRET_KEY=tu_stripe_secret_key
   STRIPE_WEBHOOK_SECRET=tu_stripe_webhook_secret
   ```

   > üí° **Tip**: Presiona `Ctrl+O` para guardar, `Enter` para confirmar, `Ctrl+X` para salir

### üìä Ejecutar Migraciones de Base de Datos

```bash
# Aseg√∫rate de estar en el directorio backend
cd ~/bot_backend/backend

# Ejecutar migraciones
npm run migrate

# Generar embeddings para b√∫squeda sem√°ntica (recomendado)
npm run seed:embeddings
```

### üöÄ Iniciar la Aplicaci√≥n

```bash
# Iniciar con PM2
npm run pm2:start

# Verificar que est√© ejecut√°ndose
pm2 status
```

Deber√≠as ver algo as√≠:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ id  ‚îÇ name               ‚îÇ namespace   ‚îÇ version ‚îÇ mode    ‚îÇ pid      ‚îÇ uptime ‚îÇ ‚Ü∫    ‚îÇ status    ‚îÇ cpu      ‚îÇ mem      ‚îÇ user     ‚îÇ watching ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0   ‚îÇ bot-backend-api    ‚îÇ default     ‚îÇ 1.0.0   ‚îÇ fork    ‚îÇ 12345    ‚îÇ 0s     ‚îÇ 0    ‚îÇ online    ‚îÇ 0%       ‚îÇ 45.2mb   ‚îÇ appuser  ‚îÇ disabled ‚îÇ
‚îÇ 1   ‚îÇ bot-backend-worker ‚îÇ default     ‚îÇ 1.0.0   ‚îÇ cluster ‚îÇ 12346    ‚îÇ 0s     ‚îÇ 0    ‚îÇ online    ‚îÇ 0%       ‚îÇ 42.1mb   ‚îÇ appuser  ‚îÇ disabled ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 6. Verificaci√≥n y Pruebas

### ‚úÖ Verificar Estado del Sistema

```bash
cd ~/bot_backend
./scripts/health-check.sh
```

### üåê Probar la API y Frontend

1. **API Backend:**
   ```bash
   curl http://localhost:5000/backend
   ```
   - Tambi√©n visita: https://cloudbiteapp.com/api/backend
   - Deber√≠as ver: `{"message":"Bot Backend API is running","version":"2.0.0","timestamp":"..."}`

2. **Frontend React:**
   - Visita: https://cloudbiteapp.com
   - Deber√≠as ver tu aplicaci√≥n React funcionando

3. **WebSocket (Socket.IO):**
   ```bash
   curl https://cloudbiteapp.com/socket.io/\?EIO\=4\&transport\=polling
   ```
   - Deber√≠as ver una respuesta JSON con `sid` y configuraci√≥n de Socket.IO

### üì± Configurar WhatsApp Webhook

1. Ve a [Meta for Developers](https://developers.facebook.com)
2. Selecciona tu app de WhatsApp
3. En **Configuration** ‚Üí **Webhooks**:
   - **Callback URL**: `https://cloudbiteapp.com/api/backend/webhook`
   - **Verify Token**: El valor que pusiste en `WHATSAPP_VERIFY_TOKEN`
4. Suscr√≠bete a los eventos: `messages`

### üìä Monitorear Logs

```bash
# Ver todos los logs
pm2 logs

# Ver logs de la API
pm2 logs bot-backend-api

# Ver logs del worker
pm2 logs bot-backend-worker

# Monitoreo en tiempo real
pm2 monit
```

---

## 7. Mantenimiento

### üîÑ Actualizar la Aplicaci√≥n

```bash
cd ~/bot_backend
./scripts/update-app.sh
```

### üìä Comandos √ötiles de PM2

```bash
# Estado de procesos
pm2 status

# Reiniciar todo
pm2 restart all

# Detener todo
pm2 stop all

# Recargar sin downtime
pm2 reload all

# Ver uso de CPU/Memoria
pm2 monit
```

### ‚ö†Ô∏è Actualizar Variables de Entorno (.env)

**IMPORTANTE**: Si modificas el archivo `.env`, el comando `pm2 reload` NO actualiza las variables de entorno. Debes hacer un reinicio completo:

```bash
# 1. Editar el archivo .env
cd ~/bot_backend/backend
nano .env

# 2. Detener y eliminar los procesos actuales
pm2 delete all

# 3. Iniciar nuevamente con las nuevas variables
pm2 start ecosystem.config.js

# 4. Verificar que las variables se actualizaron (ejemplo con GOOGLE_AI_API_KEY)
pm2 env 0 | grep GOOGLE_AI_API_KEY
```

**Alternativa m√°s r√°pida:**
```bash
# Detener todos los procesos
pm2 stop all

# Iniciarlos de nuevo (esto recarga el .env)
pm2 start ecosystem.config.js

# Verificar
pm2 status
```

### üóÑÔ∏è Backup de Base de Datos

```bash
# Backup manual
pg_dump -U bot_user bot_db > backup_$(date +%Y%m%d_%H%M%S).sql

# Restaurar backup
psql -U bot_user bot_db < backup_20240101_120000.sql
```

### üîí Renovar SSL (Autom√°tico)

El certificado SSL se renueva autom√°ticamente. Para verificar:

```bash
sudo certbot certificates
```

Para renovar manualmente:

```bash
sudo certbot renew
sudo systemctl reload nginx
```

---

## üÜò Soluci√≥n de Problemas Comunes

### ‚ùå La API no responde

```bash
# Verificar logs
pm2 logs --lines 100

# Reiniciar servicios
pm2 restart all

# Verificar puerto
sudo netstat -tlnp | grep 5000
```

### ‚ùå Error de conexi√≥n a PostgreSQL

```bash
# Verificar estado
sudo systemctl status postgresql

# Ver logs
sudo tail -f /var/log/postgresql/postgresql-*.log

# Reiniciar
sudo systemctl restart postgresql
```

### ‚ùå Error de Redis

```bash
# Verificar estado
sudo systemctl status redis-server

# Test conexi√≥n
redis-cli ping

# Reiniciar
sudo systemctl restart redis-server
```

### ‚ùå Nginx no funciona

```bash
# Verificar configuraci√≥n
sudo nginx -t

# Ver logs de error
sudo tail -f /var/log/nginx/error.log

# Reiniciar
sudo systemctl restart nginx
```

### ‚ùå Error 500 o "Permission denied" en el frontend

Si ves errores como `stat() failed (13: Permission denied)` en los logs de Nginx:

```bash
# El problema es que el directorio home no tiene permisos para www-data
# Soluci√≥n:
chmod 755 /home/cloudbite
chmod 755 /home/cloudbite/bot_backend
chmod 755 /home/cloudbite/bot_backend/frontend-app
chmod -R 755 /home/cloudbite/bot_backend/frontend-app/dist

# Verificar que www-data puede acceder
sudo -u www-data ls /home/cloudbite/bot_backend/frontend-app/dist/

# Recargar Nginx
sudo nginx -s reload
```

**Nota**: Este problema ya est√° prevenido en los scripts de instalaci√≥n actualizados.

---

## üìû Informaci√≥n de Contacto

- **Dominio**: https://cloudbiteapp.com
- **Email**: viefmoon@gmail.com
- **Repositorio**: https://github.com/viefmoon/bot_backend

---

## üéâ ¬°Felicidades!

Tu Bot Backend est√° ahora funcionando en producci√≥n. 

### Pr√≥ximos pasos recomendados:

1. **Configura alertas** en DigitalOcean para monitorear CPU/RAM
2. **Activa backups autom√°ticos** en el panel de DigitalOcean
3. **Configura un firewall** adicional si manejas datos sensibles
4. **Prueba el webhook** enviando un mensaje de WhatsApp

### Comandos de verificaci√≥n final:

```bash
# Todo en una vista
echo "=== ESTADO DEL SISTEMA ==="
pm2 status
echo -e "\n=== HEALTH CHECK ==="
curl -s http://localhost:5000/backend | jq
echo -e "\n=== √öLTIMOS LOGS ==="
pm2 logs --nostream --lines 5
echo -e "\n=== URL DE TU BOT ==="
echo "https://cloudbiteapp.com"
```

### üîå Conexi√≥n WebSocket para Sincronizaci√≥n

Para conectarte al WebSocket de sincronizaci√≥n:

**URL del WebSocket:**
```
wss://cloudbiteapp.com/socket.io/
```

**Ejemplo con Socket.IO Client (JavaScript):**
```javascript
const socket = io('https://cloudbiteapp.com', {
  path: '/socket.io/',
  transports: ['websocket', 'polling']
});

socket.on('connect', () => {
  console.log('Conectado al WebSocket');
});

socket.on('sync:update', (data) => {
  console.log('Actualizaci√≥n de sincronizaci√≥n:', data);
});
```

**Verificar conexi√≥n:**
```bash
curl https://cloudbiteapp.com/socket.io/\?EIO\=4\&transport\=polling
```

¬°Tu bot est√° listo para recibir mensajes! üöÄ

================
File: frontend-app/src/api/addressApi.ts
================
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_BACKEND_BASE_URL || 'http://localhost:5000';

export interface VerifyOtpParams {
  whatsappPhoneNumber: string;
  otp: string;
}

export interface CreateAddressParams {
  whatsappPhoneNumber: string;
  otp: string;
  address: {
    name: string;
    street: string;
    number: string;
    interiorNumber?: string;
    neighborhood?: string;
    city: string;
    state: string;
    country: string;
    zipCode?: string;
    deliveryInstructions?: string;
    latitude: number;
    longitude: number;
  };
}

export interface UpdateAddressParams extends CreateAddressParams {
  addressId: string;
}

export interface DeleteAddressParams {
  addressId: string;
  whatsappPhoneNumber: string;
  otp: string;
}

export interface SetDefaultAddressParams {
  addressId: string;
  whatsappPhoneNumber: string;
  otp: string;
}

export interface UpdateCustomerNameParams {
  whatsappPhoneNumber: string;
  otp: string;
  firstName: string;
  lastName: string;
}

// API client instance
export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// API functions
export const addressApi = {
  verifyOtp: async (params: VerifyOtpParams) => {
    const { data } = await apiClient.post('/backend/address-registration/verify-otp', params);
    return data;
  },

  createAddress: async (params: CreateAddressParams & { preOrderId?: string }) => {
    const { preOrderId, ...addressData } = params;
    
    const bodyParams = preOrderId 
      ? { ...addressData, preOrderId }
      : addressData;
    
    const { data } = await apiClient.post('/backend/address-registration/create', bodyParams);
    return data;
  },

  updateAddress: async ({ addressId, ...params }: UpdateAddressParams) => {
    const { data } = await apiClient.put(`/backend/address-registration/${addressId}`, params);
    return data;
  },

  deleteAddress: async ({ addressId, ...params }: DeleteAddressParams) => {
    const { data } = await apiClient.delete(`/backend/address-registration/${addressId}`, {
      data: params,
    });
    return data;
  },

  setDefaultAddress: async ({ addressId, ...params }: SetDefaultAddressParams) => {
    const { data } = await apiClient.put(`/backend/address-registration/${addressId}/default`, params);
    return data;
  },

  getDeliveryArea: async () => {
    const { data } = await apiClient.get('/backend/address-registration/delivery-area');
    return data;
  },


  // Update customer name
  updateCustomerName: async (params: UpdateCustomerNameParams) => {
    const { data } = await apiClient.put('/backend/address-registration/update-customer-name', params);
    return data;
  },
};

================
File: scripts/configure-nginx-ssl.sh
================
#!/bin/bash

# Script para configurar Nginx con SSL
# Autor: Bot Backend Deployment Script
# Uso: sudo ./configure-nginx-ssl.sh

set -e

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_step() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

# Verificar root
if [[ $EUID -ne 0 ]]; then
   print_error "Este script debe ejecutarse como root (usa sudo)"
   exit 1
fi

# Configuraci√≥n predefinida
DOMAIN="cloudbiteapp.com"
EMAIL="viefmoon@gmail.com"
BACKEND_PORT="5000"

echo "Configuraci√≥n:"
echo "‚Ä¢ Dominio: $DOMAIN"
echo "‚Ä¢ Email SSL: $EMAIL"
echo "‚Ä¢ Puerto Backend: $BACKEND_PORT"
echo ""
read -p "¬øContinuar con esta configuraci√≥n? (s/n): " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Ss]$ ]]; then
    print_error "Configuraci√≥n cancelada"
    exit 1
fi

# Primero crear configuraci√≥n temporal para obtener SSL
print_step "Creando configuraci√≥n temporal de Nginx para SSL..."

cat > /etc/nginx/sites-available/bot-backend-temp <<EOF
server {
    listen 80;
    listen [::]:80;
    server_name $DOMAIN;
    
    # Permitir validaci√≥n de Let's Encrypt
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }
    
    # Redirigir todo lo dem√°s a HTTPS (despu√©s de obtener SSL)
    location / {
        return 444;
    }
}
EOF

# Activar configuraci√≥n temporal
ln -sf /etc/nginx/sites-available/bot-backend-temp /etc/nginx/sites-enabled/
rm -f /etc/nginx/sites-enabled/default
rm -f /etc/nginx/sites-enabled/bot-backend

# Verificar y recargar Nginx
nginx -t
systemctl reload nginx

print_success "Configuraci√≥n temporal creada"

# Obtener certificado SSL
print_step "Obteniendo certificado SSL con Let's Encrypt..."

# Crear directorio para validaci√≥n
mkdir -p /var/www/html

# Obtener certificado
certbot certonly --webroot -w /var/www/html -d $DOMAIN --email $EMAIL --agree-tos --non-interactive

if [ $? -ne 0 ]; then
    print_error "Error al obtener certificado SSL"
    print_warning "Verifica que el dominio $DOMAIN apunte a este servidor"
    exit 1
fi

print_success "Certificado SSL obtenido exitosamente"

# Ahora crear la configuraci√≥n completa con SSL
print_step "Creando configuraci√≥n final de Nginx con SSL..."

cat > /etc/nginx/sites-available/bot-backend <<EOF
# Redirigir HTTP a HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name $DOMAIN;
    
    # Permitir validaci√≥n de Let's Encrypt
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }
    
    # Redirigir todo lo dem√°s a HTTPS
    location / {
        return 301 https://\$server_name\$request_uri;
    }
}

# Configuraci√≥n HTTPS
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name $DOMAIN;

    # SSL - se configurar√° autom√°ticamente con certbot
    ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
    
    # Configuraci√≥n SSL moderna
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    ssl_trusted_certificate /etc/letsencrypt/live/$DOMAIN/chain.pem;
    
    # Configuraci√≥n de seguridad
    add_header Strict-Transport-Security "max-age=63072000" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Logs
    access_log /var/log/nginx/bot-backend-access.log;
    error_log /var/log/nginx/bot-backend-error.log;
    
    # Tama√±o m√°ximo del body (para archivos de audio, im√°genes, etc.)
    client_max_body_size 25M;
    
    # Servir el frontend React
    location / {
        root /home/cloudbite/bot_backend/frontend-app/dist;
        try_files \$uri \$uri/ /index.html;
        
        # Cache para assets est√°ticos
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
    
    # API Backend
    location /api/ {
        # Reescribir /api/xxx a /xxx para el backend
        rewrite ^/api/(.*)\$ /\$1 break;
        
        proxy_pass http://localhost:$BACKEND_PORT;
        proxy_http_version 1.1;
        
        # Headers importantes
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$server_name;
        
        # Timeouts para manejar conexiones largas
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # WebSocket support
        proxy_cache_bypass \$http_upgrade;
    }
    
    # Backend routes (address-registration, address-selection, etc)
    location /backend/ {
        proxy_pass http://localhost:$BACKEND_PORT/backend/;
        proxy_http_version 1.1;
        
        # Headers importantes
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # Configuraci√≥n espec√≠fica para el webhook de WhatsApp
    location /api/webhook {
        proxy_pass http://localhost:$BACKEND_PORT/webhook;
        proxy_http_version 1.1;
        
        # Headers
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        
        # Importante para WhatsApp
        proxy_buffering off;
        proxy_request_buffering off;
        
        # Timeouts espec√≠ficos para webhook
        proxy_connect_timeout 90s;
        proxy_send_timeout 90s;
        proxy_read_timeout 90s;
    }
    
    # Health check endpoint
    location /health {
        proxy_pass http://localhost:$BACKEND_PORT/health;
        proxy_http_version 1.1;
        access_log off;
    }
    
    # Socket.IO WebSocket support
    location /socket.io/ {
        proxy_pass http://localhost:$BACKEND_PORT/socket.io/;
        proxy_http_version 1.1;
        
        # WebSocket headers
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        
        # Socket.IO specific
        proxy_buffering off;
        proxy_cache_bypass \$http_upgrade;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
EOF

print_success "Configuraci√≥n de Nginx creada"

# Asegurar permisos correctos para los directorios
print_step "Verificando permisos de directorios..."
chmod 755 /home/$APP_USER
chmod 755 /home/$APP_USER/bot_backend
chmod 755 /home/$APP_USER/bot_backend/frontend-app
[ -d "/home/$APP_USER/bot_backend/frontend-app/dist" ] && chmod -R 755 /home/$APP_USER/bot_backend/frontend-app/dist
print_success "Permisos verificados"

# Desactivar configuraci√≥n temporal y activar la final
print_step "Activando configuraci√≥n final..."

rm -f /etc/nginx/sites-enabled/bot-backend-temp
ln -sf /etc/nginx/sites-available/bot-backend /etc/nginx/sites-enabled/

# Verificar configuraci√≥n final
nginx -t

if [ $? -ne 0 ]; then
    print_error "Error en la configuraci√≥n de Nginx"
    exit 1
fi

# Recargar Nginx con la configuraci√≥n completa
systemctl reload nginx
print_success "Nginx configurado con SSL"

# Configurar renovaci√≥n autom√°tica
print_step "Configurando renovaci√≥n autom√°tica de SSL..."

# Crear directorio si no existe
mkdir -p /etc/letsencrypt/renewal-hooks/deploy/

# Crear script de renovaci√≥n
cat > /etc/letsencrypt/renewal-hooks/deploy/reload-nginx.sh <<'RENEW'
#!/bin/bash
systemctl reload nginx
RENEW

chmod +x /etc/letsencrypt/renewal-hooks/deploy/reload-nginx.sh

# Test renovaci√≥n
certbot renew --dry-run

if [ $? -eq 0 ]; then
    print_success "Renovaci√≥n autom√°tica configurada"
else
    print_warning "Renovaci√≥n autom√°tica puede tener problemas, verifica manualmente"
fi

# Crear archivo de informaci√≥n
cat > ~/nginx_ssl_info.txt <<INFO
=====================================
NGINX Y SSL CONFIGURADOS
=====================================

Dominio: https://$DOMAIN
Backend: http://localhost:$BACKEND_PORT

Archivos de configuraci√≥n:
- Nginx: /etc/nginx/sites-available/bot-backend
- SSL: /etc/letsencrypt/live/$DOMAIN/

Logs:
- Access: /var/log/nginx/bot-backend-access.log
- Error: /var/log/nginx/bot-backend-error.log

Comandos √∫tiles:
- Test config: nginx -t
- Recargar: systemctl reload nginx
- Ver logs: tail -f /var/log/nginx/bot-backend-*.log
- Renovar SSL: certbot renew

Webhook URL para WhatsApp:
https://$DOMAIN/api/backend/webhook

=====================================
INFO

chmod 600 ~/nginx_ssl_info.txt
print_success "Informaci√≥n guardada en ~/nginx_ssl_info.txt"

echo ""
print_success "¬°Configuraci√≥n completada!"
echo ""
echo "Tu aplicaci√≥n est√° disponible en:"
echo "Frontend: ${GREEN}https://$DOMAIN${NC}"
echo "API: ${GREEN}https://$DOMAIN/api/backend${NC}"
echo ""
echo "Webhook URL para WhatsApp: ${GREEN}https://$DOMAIN/api/backend/webhook${NC}"
echo ""
print_warning "Aseg√∫rate de que la aplicaci√≥n est√© ejecut√°ndose en el puerto $BACKEND_PORT"

================
File: backend/src/common/services/errors/errorMessages.ts
================
import { ErrorCode } from './types';

interface ErrorMessageConfig {
  user: string;
  log: string;
}

export const ERROR_MESSAGES: Record<ErrorCode, ErrorMessageConfig> = {
  // Business Logic Errors
  [ErrorCode.ORDER_NOT_FOUND]: {
    user: "‚ùå Lo siento, no se pudo encontrar tu orden. üîç",
    log: "Order not found"
  },
  [ErrorCode.RESTAURANT_CLOSED]: {
    user: "üö´ Lo sentimos, estamos cerrados en este momento. üò¥",
    log: "Restaurant is closed"
  },
  [ErrorCode.NOT_ACCEPTING_ORDERS]: {
    user: "üö´üçΩÔ∏è Lo sentimos, no estamos aceptando pedidos en este momento. üòî",
    log: "Restaurant not accepting orders"
  },
  [ErrorCode.PAYMENT_LINK_EXISTS]: {
    user: "‚ö†Ô∏è Ya existe un enlace de pago activo para esta orden.",
    log: "Payment link already exists"
  },
  [ErrorCode.CUSTOMER_NOT_FOUND]: {
    user: "‚ùå No se encontr√≥ informaci√≥n del cliente.",
    log: "Customer not found"
  },
  [ErrorCode.USER_BANNED]: {
    user: "üö´ Tu cuenta ha sido suspendida.",
    log: "User is banned"
  },
  [ErrorCode.NO_PRODUCTS_FOUND]: {
    user: "‚ùå No encontr√© productos que coincidan con tu pedido. Por favor intenta de nuevo.",
    log: "No products found matching search"
  },
  [ErrorCode.EMPTY_ORDER]: {
    user: "‚ùå No pude identificar productos v√°lidos en tu pedido. Por favor intenta de nuevo.",
    log: "Empty order - no valid items identified"
  },
  
  // Validation Errors
  [ErrorCode.INVALID_PRODUCT]: {
    user: "‚ùå Uno o m√°s productos no son v√°lidos. Por favor, verifica tu pedido.",
    log: "Invalid product ID or configuration"
  },
  [ErrorCode.MISSING_DELIVERY_INFO]: {
    user: "üìç No encontramos tu informaci√≥n de entrega. Por favor, reg√≠strala primero.",
    log: "Missing delivery information"
  },
  [ErrorCode.INVALID_SCHEDULE_TIME]: {
    user: "‚è∞ El horario seleccionado no es v√°lido. Por favor, elige otro horario.",
    log: "Invalid scheduled delivery time"
  },
  [ErrorCode.MISSING_REQUIRED_FIELD]: {
    user: "‚ùå Falta informaci√≥n requerida. Por favor, completa todos los campos.",
    log: "Missing required field"
  },
  [ErrorCode.INVALID_OTP]: {
    user: "‚ùå El c√≥digo OTP es inv√°lido o ha expirado. Por favor, solicita uno nuevo.",
    log: "Invalid or expired OTP"
  },
  [ErrorCode.INVALID_TOKEN]: {
    user: "‚è∞ Esta orden ha expirado o ya no est√° disponible.\n\nüîÑ Tu historial ha sido reiniciado. Puedes realizar un nuevo pedido escribiendo lo que deseas ordenar.",
    log: "Invalid or expired action token"
  },
  [ErrorCode.ADDRESS_OUTSIDE_COVERAGE]: {
    user: "üìç La direcci√≥n seleccionada est√° fuera de nuestra √°rea de cobertura. Por favor, selecciona una direcci√≥n dentro de la zona de entrega.",
    log: "Address outside delivery coverage area"
  },
  [ErrorCode.FILE_TOO_LARGE]: {
    user: "‚ùå El archivo es demasiado grande. Por favor env√≠a un archivo m√°s peque√±o.",
    log: "File size exceeds maximum allowed"
  },
  [ErrorCode.WEBHOOK_VERIFICATION_FAILED]: {
    user: "‚ùå Error de verificaci√≥n del webhook.",
    log: "Webhook signature verification failed"
  },
  
  // Not Found Errors
  [ErrorCode.ADDRESS_NOT_FOUND]: {
    user: "üìç No se encontr√≥ la direcci√≥n solicitada.",
    log: "Address not found"
  },
  
  // Technical Errors
  [ErrorCode.DATABASE_ERROR]: {
    user: "üîß Hubo un problema t√©cnico. Por favor, intenta de nuevo m√°s tarde.",
    log: "Database operation failed"
  },
  [ErrorCode.WHATSAPP_API_ERROR]: {
    user: "üì± Hubo un problema al enviar el mensaje. Por favor, intenta de nuevo.",
    log: "WhatsApp API error"
  },
  [ErrorCode.PAYMENT_PROCESSING_ERROR]: {
    user: "üí≥ Hubo un problema al procesar el pago. Por favor, intenta de nuevo.",
    log: "Payment processing error"
  },
  [ErrorCode.AI_SERVICE_ERROR]: {
    user: "ü§ñ Hubo un problema al procesar tu solicitud. Por favor, intenta de nuevo.",
    log: "AI service error"
  },
  [ErrorCode.TRANSCRIPTION_ERROR]: {
    user: "üé§ Hubo un problema al procesar tu mensaje de audio. Por favor, intenta nuevamente o env√≠a un mensaje de texto.",
    log: "Audio transcription failed"
  },
  
  // External Service Errors
  [ErrorCode.STRIPE_ERROR]: {
    user: "üí≥ El servicio de pagos no est√° disponible temporalmente. Por favor, intenta m√°s tarde.",
    log: "Stripe service error"
  },
  [ErrorCode.GEMINI_ERROR]: {
    user: "ü§ñ El asistente no est√° disponible temporalmente. Por favor, intenta m√°s tarde.",
    log: "Gemini AI service error"
  },
  [ErrorCode.WHATSAPP_ERROR]: {
    user: "üì± Error en el servicio de WhatsApp. Por favor, intenta m√°s tarde.",
    log: "WhatsApp service error"
  },
  
  // Rate Limit
  [ErrorCode.RATE_LIMIT_EXCEEDED]: {
    user: "‚è≥ Has alcanzado el l√≠mite de mensajes. Por favor espera unos minutos antes de enviar m√°s mensajes.",
    log: "Rate limit exceeded"
  },
  
  [ErrorCode.AUTHENTICATION_REQUIRED]: {
    user: 'Authentication required',
    log: 'Missing authentication credentials'
  },
  
  [ErrorCode.INVALID_CREDENTIALS]: {
    user: 'Invalid credentials',
    log: 'Invalid or expired authentication credentials'
  },
  
  [ErrorCode.EMBEDDING_GENERATION_FAILED]: {
    user: 'ü§ñ Hubo un problema al procesar tu b√∫squeda. Por favor, intenta de nuevo.',
    log: 'Failed to generate embedding for search query'
  },
  
  [ErrorCode.AI_PROCESSING_ERROR]: {
    user: 'ü§ñ No se pudo procesar tu pedido. Por favor intenta de nuevo.',
    log: 'AI processing failed'
  }
};

================
File: backend/src/services/ai/tools/handlers/sendMenuHandler.ts
================
import { ToolHandler } from '../types';
import { ProductService } from '../../../products/ProductService';
import { MessageSplitter } from '../../../../common/utils/messageSplitter';
import { UnifiedResponse, ResponseBuilder, ResponseType } from '../../../messaging/types/responses';

/**
 * Core logic for sending menu - can be used by both AI tools and interactive handlers
 */
export async function getMenuResponses(): Promise<UnifiedResponse | UnifiedResponse[]> {
  const menuText = await ProductService.getMenuForWhatsApp();
  
  // If menu is too long, split it into parts
  const maxLength = 4000; // Reduced to ensure safety margin for WhatsApp's 4096 limit
  
  if (menuText.length > maxLength) {
    const parts = MessageSplitter.splitMenu(menuText, maxLength);
    
    // Return multiple responses
    return parts.map((part, index) => {
      if (index === parts.length - 1) {
        // Last part gets the history marker
        return ResponseBuilder.textWithHistoryMarker(part, "MEN√ö ENVIADO", ResponseType.MENU_INFO);
      } else {
        // Other parts are not relevant for history
        const response = ResponseBuilder.text(part, false);
        response.metadata.type = ResponseType.MENU_INFO;
        return response;
      }
    });
  } else {
    return ResponseBuilder.textWithHistoryMarker(menuText, "MEN√ö ENVIADO", ResponseType.MENU_INFO);
  }
}

/**
 * Handles the send_menu function call for AI tools
 */
export const handleSendMenu: ToolHandler = async (): Promise<UnifiedResponse | UnifiedResponse[]> => {
  return getMenuResponses();
};

================
File: backend/src/services/orders/OrderService.ts
================
import { prisma } from '../../lib/prisma';
import { PizzaHalf, CustomizationAction } from '@prisma/client';
import { CreateOrderDto } from '../../dto/order';
import logger from '../../common/utils/logger';
import { NotFoundError, ErrorCode } from '../../common/services/errors';
import { SyncMetadataService } from '../sync/SyncMetadataService';

export class OrderService {
  static async create(createOrderDto: CreateOrderDto) {
    try {
      // Get customer by WhatsApp phone number
      const customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber: createOrderDto.whatsappPhoneNumber }
      });
      
      if (!customer) {
        throw new NotFoundError(
          ErrorCode.CUSTOMER_NOT_FOUND,
          'Customer not found',
          { whatsappPhoneNumber: createOrderDto.whatsappPhoneNumber }
        );
      }
      
      // Get restaurant config for estimated times
      const config = await prisma.restaurantConfig.findFirst();
      const estimatedMinutes = createOrderDto.orderType === 'DELIVERY' 
        ? (config?.estimatedDeliveryTime || 40)
        : (config?.estimatedPickupTime || 20);
      
      // Calculate estimated delivery time as a DateTime
      const now = new Date();
      const estimatedDeliveryTime = new Date(now.getTime() + estimatedMinutes * 60 * 1000);
      
      // Initialize totals - use provided values if available, otherwise will be calculated
      let subtotal = createOrderDto.subtotal || 0;
      let total = createOrderDto.total || 0;
      const hasProvidedTotals = createOrderDto.subtotal !== undefined && createOrderDto.total !== undefined;
      
      // Use Prisma transaction for atomic operations
      const order = await prisma.$transaction(async (tx) => {
        // Create the order without shiftOrderNumber (will be assigned during sync)
        const newOrder = await tx.order.create({
          data: {
            orderType: createOrderDto.orderType as "DINE_IN" | "TAKE_AWAY" | "DELIVERY",
            customerId: customer.id,
            scheduledAt: createOrderDto.scheduledAt ? new Date(createOrderDto.scheduledAt) : null,
            orderStatus: 'PENDING',
            subtotal,
            total,
            estimatedDeliveryTime,
            isFromWhatsApp: true,
            createdAt: new Date(),
            updatedAt: new Date()
          }
        });
        
        // Create order items if provided
        if (createOrderDto.orderItems && createOrderDto.orderItems.length > 0) {
          await Promise.all(
            createOrderDto.orderItems.map(async (item) => {
              // Validate productId exists
              if (!item.productId) {
                throw new NotFoundError(
                  ErrorCode.MISSING_REQUIRED_FIELD,
                  'Product ID is required for each order item',
                  { metadata: { item } }
                );
              }
              
              // Get product and variant info to calculate price
              const product = await tx.product.findUnique({
                where: { id: item.productId },
                include: { variants: true }
              });
              
              if (!product) {
                throw new NotFoundError(
                  ErrorCode.INVALID_PRODUCT,
                  `Product ${item.productId} not found`,
                  { metadata: { productId: item.productId } }
                );
              }
              
              // Calculate base price
              let itemPrice = 0;
              if (item.productVariantId) {
                const variant = product.variants.find(v => v.id === item.productVariantId);
                if (variant) {
                  itemPrice = variant.price;
                }
              } else if (product.price !== null) {
                itemPrice = product.price;
              }
              
              // First calculate total price including modifiers
              let modifierIds: string[] = [];
              if (item.selectedModifiers && item.selectedModifiers.length > 0) {
                modifierIds = item.selectedModifiers; // Now directly an array of strings
                
                // Get modifier prices
                const modifiers = await tx.productModifier.findMany({
                  where: { id: { in: modifierIds } }
                });
                
                // Add modifier prices to item price
                for (const modifier of modifiers) {
                  itemPrice += modifier.price || 0;
                }
              }
              
              // Crear items individuales seg√∫n la cantidad
              const quantity = item.quantity || 1;
              const orderItems = [];
              
              for (let i = 0; i < quantity; i++) {
                const orderItem = await tx.orderItem.create({
                  data: {
                    orderId: newOrder.id,
                    productId: item.productId,
                    productVariantId: item.productVariantId,
                    basePrice: itemPrice,
                    finalPrice: itemPrice,
                    productModifiers: modifierIds.length > 0 ? {
                      connect: modifierIds.map(id => ({ id }))
                    } : undefined
                  }
                });
                orderItems.push(orderItem);
              }
              
              // Create selected pizza customizations for each order item if provided
              if (item.selectedPizzaCustomizations && item.selectedPizzaCustomizations.length > 0) {
                for (const orderItem of orderItems) {
                  await Promise.all(
                    item.selectedPizzaCustomizations.map(customization =>
                      tx.selectedPizzaCustomization.create({
                        data: {
                          orderItemId: orderItem.id,
                          pizzaCustomizationId: customization.pizzaCustomizationId,
                          half: customization.half as PizzaHalf,
                          action: customization.action as CustomizationAction
                        }
                      })
                    )
                  );
                }
              }
              
              // Calculate total price for all items of this type only if totals weren't provided
              if (!hasProvidedTotals) {
                const itemTotal = itemPrice * quantity;
                subtotal += itemTotal;
              }
              
              return orderItems;
            })
          );
        }
        
        // Create delivery info if provided
        if (createOrderDto.deliveryInfo) {
          await tx.deliveryInfo.create({
            data: {
              ...createOrderDto.deliveryInfo,
              orderId: newOrder.id,
            }
          });
        }
        
        // Calculate total only if not provided (for now, total = subtotal, but can add taxes, delivery fees, etc. later)
        if (!hasProvidedTotals) {
          total = subtotal;
        }
        
        // Update order with calculated totals
        const updatedOrder = await tx.order.update({
          where: { id: newOrder.id },
          data: { subtotal, total }
        });
        
        // Mark order for sync within the transaction to ensure consistency
        await SyncMetadataService.markForSync('Order', updatedOrder.id, 'REMOTE');
        
        return updatedOrder;
      });
      
      return order;
    } catch (error) {
      logger.error('Error creating order:', error);
      throw error;
    }
  }

}

================
File: backend/src/services/orders/PreOrderService.ts
================
import { prisma } from '../../lib/prisma';
import logger from "../../common/utils/logger";
import { SchedulingService } from "./services/SchedulingService";
import { ProductCalculationService } from "./services/ProductCalculationService";
import { DeliveryInfoService } from "./services/DeliveryInfoService";
import { RestaurantService } from "../restaurant/RestaurantService";
import { OrderType } from "@prisma/client";
import { ValidationError, ErrorCode } from "../../common/services/errors";
import { BaseOrderItem, DeliveryInfoInput } from "../../common/types";

export class PreOrderService {
  /**
   * Create a preorder with selected products
   */
  async createPreOrder(orderData: {
    orderItems: BaseOrderItem[];
    whatsappPhoneNumber: string;
    orderType: OrderType;
    scheduledAt?: string | Date;
    deliveryInfo?: DeliveryInfoInput;
  }) {
    const { orderItems, whatsappPhoneNumber, orderType, scheduledAt, deliveryInfo: inputDeliveryInfo } = orderData;

    logger.info(`Starting createPreOrder for ${whatsappPhoneNumber}`, {
      orderType,
      itemCount: orderItems.length,
      scheduledAt,
      items: JSON.stringify(orderItems)
    });

    try {
      // Validar que haya al menos un producto
      if (!orderItems || orderItems.length === 0) {
        throw new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          'No se puede crear una orden sin productos',
          {
            metadata: {
              validationFailure: 'EMPTY_ORDER',
              message: 'Debes agregar al menos un producto a tu pedido'
            }
          }
        );
      }
      
      // Get restaurant config
      const config = await RestaurantService.getConfig();
      
      // Calculate estimated time based on order type
      const estimatedDeliveryTime = orderType === 'DELIVERY' 
        ? config.estimatedDeliveryTime 
        : config.estimatedPickupTime;

      // Validate scheduled time if provided
      const validatedScheduledTime = await SchedulingService.validateScheduledTime(
        scheduledAt,
        orderType
      );

      // Get customerId from whatsapp phone number for delivery info
      const customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber }
      });
      
      // Get or create delivery info
      let deliveryInfoId = null;
      if (customer && (orderType === 'DELIVERY' || orderType === 'TAKE_AWAY')) {
        const deliveryInfo = await DeliveryInfoService.getOrCreateDeliveryInfo(
          orderType,  // Pass the enum directly
          customer.id,
          inputDeliveryInfo,
          customer
        );
        deliveryInfoId = deliveryInfo.id;
      }

      // Calculate items and totals
      const { items: calculatedItems, subtotal, total } = await ProductCalculationService.calculateOrderItems(
        orderItems
      );

      // Create pre-order data
      const preOrderData: any = {
        whatsappPhoneNumber,
        orderType,
        estimatedDeliveryTime,
      };
      
      // Only add scheduledAt if it exists and is valid
      if (validatedScheduledTime) {
        preOrderData.scheduledAt = validatedScheduledTime;
      }
      
      logger.info('Creating pre-order with data:', {
        whatsappPhoneNumber: preOrderData.whatsappPhoneNumber,
        orderType: preOrderData.orderType,
        scheduledAt: preOrderData.scheduledAt,
        itemCount: calculatedItems.length,
        subtotal,
        total
      });
      
      // Create pre-order with related order items and calculated totals
      const preOrder = await prisma.preOrder.create({
        data: {
          ...preOrderData,
          subtotal,
          total,
          ...(deliveryInfoId ? { deliveryInfo: { connect: { id: deliveryInfoId } } } : {}),
          orderItems: {
            create: calculatedItems.map(item => ({
              productId: item.productId,
              productVariantId: item.productVariantId,
              basePrice: item.basePrice,
              finalPrice: item.totalPrice,
              productModifiers: item.selectedModifiers && item.selectedModifiers.length > 0 ? {
                connect: item.selectedModifiers.map(modId => ({ id: modId }))
              } : undefined,
              selectedPizzaCustomizations: item.selectedPizzaCustomizations && item.selectedPizzaCustomizations.length > 0 ? {
                create: item.selectedPizzaCustomizations.map(customization => ({
                  pizzaCustomizationId: customization.pizzaCustomizationId,
                  half: customization.half,
                  action: customization.action
                }))
              } : undefined
            }))
          }
        },
        include: {
          orderItems: {
            include: {
              product: true,
              productVariant: true,
              productModifiers: true,
              selectedPizzaCustomizations: {
                include: {
                  pizzaCustomization: true
                }
              }
            }
          },
          deliveryInfo: true
        }
      });

      logger.info(`Created pre-order ${preOrder.id} for phone ${whatsappPhoneNumber}`, {
        preOrderId: preOrder.id,
        createdAt: preOrder.createdAt
      });

      // Delivery info is now attached to the preOrder
      const deliveryInfo = preOrder.deliveryInfo;

      // Format order items from the created preOrder
      const formattedItems = preOrder.orderItems.map(item => ({
        ...item,
        productName: item.product.name,
        variantName: item.productVariant?.name,
        modifierNames: item.productModifiers.map(m => m.name),
        pizzaCustomizationDetails: item.selectedPizzaCustomizations.map(sc => ({
          pizzaCustomizationId: sc.pizzaCustomizationId,
          name: sc.pizzaCustomization.name,
          type: sc.pizzaCustomization.type,
          half: sc.half,
          action: sc.action
        })),
        quantity: 1, // Quantity is always 1 per item in our current model
        totalPrice: item.finalPrice
      }));

      return {
        preOrderId: preOrder.id,
        orderType,
        items: formattedItems,
        subtotal: preOrder.subtotal,
        total: preOrder.total,
        deliveryInfo,
        scheduledAt: validatedScheduledTime,
        estimatedDeliveryTime: estimatedDeliveryTime,
      };
    } catch (error) {
      logger.error("Error in createPreOrder:", error);
      throw error;
    }
  }


}

================
File: backend/src/services/messaging/strategies/TextMessageStrategy.ts
================
import { MessageStrategy } from './MessageStrategy';
import { MessageContext } from '../MessageContext';
import { TextProcessingService } from '../TextProcessingService';
import { ResponseBuilder, ResponseType } from '../types/responses';
import logger from '../../../common/utils/logger';

export class TextMessageStrategy extends MessageStrategy {
  name = 'TextMessageStrategy';
  
  canHandle(context: MessageContext): boolean {
    return context.message.type === 'text';
  }
  
  async execute(context: MessageContext): Promise<void> {
    if (!context.message.text?.body || !context.customer) return;
    
    const text = context.message.text.body;
    
    try {
      // Delegate text processing to the shared service
      await TextProcessingService.processTextMessage(text, context);
    } catch (error) {
      logger.error("Error in TextMessageStrategy:", error);
      
      // Use UnifiedResponse for error handling
      const errorResponse = ResponseBuilder.error(
        'PROCESSING_ERROR',
        "Error al procesar la solicitud: " + (error as Error).message
      );
      context.addUnifiedResponse(errorResponse);
    }
  }
}

================
File: CLAUDE.md
================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## First Time Setup

**IMPORTANT**: Before running the development scripts for the first time, you need to set up the database:

```bash
# 1. Start Docker containers
docker compose up -d

# 2. Wait a few seconds for PostgreSQL to be ready

# 3. Run database migrations (creates all tables)
cd backend && npm run migrate:dev

# 4. Now you can run the development script
start-dev.bat       # Windows
./start-dev.sh      # Linux/Mac
```

## Commands

### Development
```bash
# Start everything (Docker + Backend API + Worker + Frontend)
./start-dev.sh      # Linux/Mac
start-dev.bat       # Windows

# This script:
# - Cleans up ports and Docker containers
# - Starts PostgreSQL and Redis via Docker
# - Installs dependencies if needed
# - Runs database migrations (ONLY if migrations already exist)
# - Starts Backend API (port 5000)
# - Starts BullMQ Worker for async processing
# - Starts Frontend (port 3000) if present

# Clean up stuck ports manually if needed
./cleanup-ports.sh

# Or run services manually:
cd backend && npm run dev         # Terminal 1: API Server
cd backend && npm run dev:worker  # Terminal 2: Message Worker
cd frontend-app && npm run dev    # Terminal 3: Frontend (optional)
```

### Database Management
```bash
cd backend
npm run generate      # Generate Prisma client after schema changes
npm run migrate:dev   # Create and apply migrations in development
npm run migrate       # Apply migrations in production
npm run studio        # Open Prisma Studio to view/edit database
npm run seed:embeddings  # Generate embeddings for semantic search
```

**Important Notes about Migrations**:
- Migrations are NOT automatic - you must run them manually
- First time setup: Always run `npm run migrate:dev` to create initial tables
- After schema changes: Run `npm run migrate:dev` to update database structure
- The `start-dev.bat` script runs `migrate deploy` which only applies existing migrations, it does NOT create new ones

### Build & Production
```bash
npm run build         # Build both backend and frontend
npm run start         # Build and start both services

# Backend only
cd backend && npm run build && npm run start

# Frontend only  
cd frontend-app && npm run build && npm run preview
```

### Linting & Type Checking
```bash
cd frontend-app && npm run lint    # ESLint for frontend
cd backend && npm run build        # TypeScript compilation checks
```

### Testing WhatsApp Locally
```bash
# 1. Start the backend
./start-dev.sh      # Linux/Mac
start-dev.bat       # Windows

# 2. In another terminal, expose webhook with ngrok
ngrok http 5000

# 3. Update webhook URL in Meta Business dashboard to:
# https://[your-ngrok-id].ngrok.io/backend/webhook
```

### Production PM2 - Update Environment Variables
**Important**: `pm2 reload` does NOT update environment variables from .env file. You must restart:
```bash
# Edit .env file
cd backend && nano .env

# Option 1: Delete and start fresh (recommended)
pm2 delete all
pm2 start ecosystem.config.js

# Option 2: Stop and start
pm2 stop all
pm2 start ecosystem.config.js

# Verify the change
pm2 env 0 | grep YOUR_VARIABLE_NAME
```

## Architecture Overview

This is a WhatsApp restaurant ordering bot with AI-powered natural language processing.

### Message Processing Pipeline

WhatsApp messages now flow through an asynchronous queue-based system using BullMQ:

```
Webhook Entry (/backend/webhook)
    ‚Üì
WhatsAppService.handleWebhook()
    ‚Üì
Enqueue message to BullMQ (immediate 200 OK response)
    ‚Üì
BullMQ Worker (separate process)
    ‚Üì
MessageProcessor.processWithPipeline()
    ‚Üì
Middleware Pipeline:
    1. RateLimitMiddleware (configurable limits)
    2. CustomerValidationMiddleware (creates/validates customers, loads chat history)
    3. RestaurantHoursMiddleware (checks if restaurant is open)
    4. AddressRequiredMiddleware (blocks until address registered)
    5. MessageTypeMiddleware (routes to appropriate strategy)
    6. MessageProcessingMiddleware (strategy pattern):
        - AudioMessageStrategy (transcribes with Gemini)
        - InteractiveMessageStrategy (button/list responses)
        - TextMessageStrategy (AI agent processing)
```

**Key Benefits of Async Processing**:
- Webhook responds immediately (prevents WhatsApp timeouts)
- Messages from same user processed sequentially (prevents race conditions)
- Messages from different users processed in parallel
- Automatic retry on failures with exponential backoff
- Scalable: can run multiple worker processes

**Sequential Processing Implementation**:
- Uses Redis-based distributed locking to ensure messages from the same user are processed one at a time
- Works correctly with multiple worker processes (PM2 cluster mode)
- Lock automatically expires after 5 minutes to prevent permanent blocks
- Exponential backoff when waiting for locks

### AI Agent Architecture

**Two-Agent System**:

1. **General Agent** (`AgentService.processMessage`)
   - Detects user intent and routes appropriately
   - Function tools available:
     - `send_menu`: Display full restaurant menu
     - `get_business_hours`: Restaurant info and hours
     - `prepare_order_context`: Initiate order processing
     - `generate_address_update_link`: OTP-secured address update
     - `send_bot_instructions`: Help messages
     - `reset_conversation`: Clear chat history
   - Always asks for order type (delivery/takeaway) before processing

2. **Order Agent** (`AgentService.processOrderMapping`)
   - Specialized for mapping natural language to menu items
   - Uses semantic similarity matching with pgvector
   - Executes `map_order_items` function
   - Creates structured order data from conversational input

**Semantic Search Setup**:
- Run `npm run seed:embeddings` to generate embeddings for all products
- Uses Google's text-embedding-004 model (768 dimensions)
- Production: Enable pgvector extension in PostgreSQL
- Development: Uses Docker image with pgvector extension enabled
- Important: Embeddings must be generated before search will work

### Service Architecture

**Stateless Services Pattern**: All services use static methods
- Import `prisma` from server.ts for database access
- Services organized by domain in `/backend/src/services/[domain]/`
- Example:
  ```typescript
  export class OrderService {
    static async createOrder(data: CreateOrderData): Promise<Order> {
      // Implementation
    }
  }
  ```

**Configuration Management**:
- `ConfigService`: Loads and caches restaurant configuration with auto-reload
- Cache TTL: 2 minutes (auto-reloads when expired)
- All predefined messages now accept configuration as parameter

### Error Handling Architecture

**Unified Error Handling Approach**:

1. **For HTTP Routes**: Use `asyncHandler` wrapper
   ```typescript
   router.post('/route', asyncHandler(async (req, res) => {
     throw new BusinessLogicError(ErrorCode.CUSTOMER_NOT_FOUND, 'Customer not found');
   }));
   ```

2. **For WhatsApp Handlers**: Use `handleWhatsAppError` or `wrapWhatsAppHandler`
   ```typescript
   export const handler = wrapWhatsAppHandler(async (from: string) => {
     // Handler logic - throw errors directly
   }, 'handlerName');
   ```

3. **For AI Tool Handlers**: Throw errors directly, caught by TextProcessingService
   ```typescript
   export const handleTool: ToolHandler = async () => {
     // No try-catch needed - errors propagate up
     const result = await someOperation();
     return { text: result, isRelevant: true };
   };
   ```

**Custom Error Types**:
- `BusinessLogicError` ‚Üí 409 Conflict
- `ValidationError` ‚Üí 400 Bad Request
- `TechnicalError` ‚Üí 500 Internal Server Error
- `ExternalServiceError` ‚Üí 502 Bad Gateway
- `RateLimitError` ‚Üí 429 Too Many Requests
- `NotFoundError` ‚Üí 404 Not Found

**Special Cases with Silent Fallback**:
- `RedisService`: Returns null/false on failure (app works without Redis)
- `OTPService`: Falls back to memory store if Redis unavailable
- `RestaurantService`: Returns default config on database errors

### Key Business Logic

1. **Address Requirement**: Customers MUST have a registered address before any conversation
   - Enforced by `AddressRequiredMiddleware`
   - Generates OTP and sends registration link
   - Blocks all other interactions until completed

2. **Order Flow**:
   - User message ‚Üí AI extracts items ‚Üí Creates PreOrder
   - Shows summary with confirm/discard buttons
   - Confirmation converts PreOrder to Order
   - Shift order numbers assigned during sync (not at creation)

3. **Message History Management**:
   - Full history stored for context
   - Relevant history (last 20 messages) for AI processing
   - Automatic cleanup of duplicate consecutive messages
   - History markers for important events (resets, orders)

### Authentication & Security

**OTP Authentication Middleware** (`/backend/src/common/middlewares/otp.middleware.ts`):
```typescript
router.post('/protected-route',
  validationMiddleware(YourDto),
  otpAuthMiddleware, // Handles OTP verification
  asyncHandler(async (req: AuthenticatedRequest, res) => {
    const customer = req.customer; // Already validated
  })
);
```

### Type System

- Centralized types in `/backend/src/common/types/`
- DTOs organized by domain in `/backend/src/dto/[domain]/`
- Always import from the domain index.ts
- Never import directly from Prisma client

### Important Implementation Details

1. **Message Splitting**: Automatic splitting at 4000 chars
2. **WhatsApp Message Types**:
   - Text: Processed through AI agents
   - Audio: Transcribed then processed as text
   - Interactive: Direct action handlers (bypasses AI)
3. **Response Accumulation**: Context collects all responses during pipeline
4. **Idempotency**: Message log prevents duplicate processing

## Environment Variables

Required (see `.env.example` for full list):
- `DATABASE_URL`: PostgreSQL connection (local uses port 5433 to avoid conflicts)
- `GOOGLE_AI_API_KEY`: Google AI API key for Gemini
- `GEMINI_MODEL`: Model version (default: gemini-2.5-pro)
- `WHATSAPP_PHONE_NUMBER_MESSAGING_ID`: Meta phone number ID
- `WHATSAPP_ACCESS_TOKEN`: WhatsApp API access token
- `WHATSAPP_VERIFY_TOKEN`: Webhook verification token
- `FRONTEND_BASE_URL`: Frontend URL for address collection
- `CLOUD_API_KEY`: API key for cloud sync operations

## Deployment

Railway deployment:
```bash
# Build command
cd backend && npm install && npm run build

# Start command  
cd backend && npm run migrate && npm start
```

### Production with PM2

The recommended way to run in production is using PM2 for process management:

```bash
# Install PM2 globally
npm install pm2 -g

# Configure workers via .env
BULLMQ_WORKER_CONCURRENCY=10  # Jobs per worker process
NUM_WORKERS=4                  # Number of worker processes

# Start all services with PM2
cd backend && npm run pm2:start

# Other PM2 commands
npm run pm2:stop      # Stop all services
npm run pm2:reload    # Reload with zero downtime
npm run pm2:logs      # View logs
npm run pm2:monit     # Monitor processes
```

**Scaling Strategy**:
- `BULLMQ_WORKER_CONCURRENCY`: Controls concurrent jobs per worker (I/O bound tasks)
- `NUM_WORKERS`: Controls number of worker processes (CPU bound scaling)
- Total capacity = NUM_WORKERS √ó BULLMQ_WORKER_CONCURRENCY
- **Important**: The implementation uses Redis-based distributed locking to ensure sequential processing per user across all worker processes

For manual deployment:
- Deploy API server and worker as separate services
- Both share same Redis instance for BullMQ
- Set concurrency in worker based on available resources

Auto-deploys on push to connected repository.

### Semantic Search in Production
- pgvector is configured automatically in both local and production
- Embeddings are generated automatically on server startup if needed
- Production: Execute `backend/scripts/production-pgvector-setup.sql` if pgvector extension is not available

## Local Development Setup

- **PostgreSQL**: Runs on port 5433 (via Docker)
- **Redis**: Runs on port 6380 (via Docker, optional for OTP/cache)
- **Docker Compose**: Manages local database and cache services
- Backend port is 5000 (not 3001 as sometimes referenced)
- Use `start-dev.sh` (Linux/Mac) or `start-dev.bat` (Windows) to ensure Docker containers are running

================
File: backend/src/server.ts
================
import 'reflect-metadata';
import express, { Request, Response } from 'express';
import cors from 'cors';
import webhookRoutes from './routes/webhook';
import syncRoutes from './routes/sync';
import addressRegistrationRoutes from './routes/address-registration';
import logger from './common/utils/logger';
import { OTPService } from './services/security/OTPService';
import { PreOrderService } from './services/orders/PreOrderService';
import { WhatsAppService } from './services/whatsapp';
import { DeliveryInfoService } from './services/orders/services/DeliveryInfoService';
import { envValidator, env } from './common/config/envValidator';
import { globalErrorHandler, asyncHandler } from './common/middlewares/errorHandler';
import { validationMiddleware, queryValidationMiddleware } from './common/middlewares/validation.middleware';
import { VerifyOtpDto, InvalidateOtpDto } from './dto/auth';
import { AddressDto, GetAddressesQueryDto, UpdateAddressDto } from './dto/address';
import { SendMessageDto } from './dto/whatsapp';
import { CreateOrderDto } from './dto/order';
import { ConfigService } from './services/config/ConfigService';
import { prisma } from './lib/prisma';

// Validate environment variables
try {
  envValidator.validate();
} catch (error) {
  logger.error('Environment validation failed:', error);
  process.exit(1);
}

// Initialize Express app
const app: express.Application = express();

// Configure CORS
app.use(cors({
  origin: [
    'https://pizzatototlan.store',
    'http://localhost:3000',
    env.FRONTEND_BASE_URL
  ].filter(Boolean),
  credentials: true,
}));

// Middleware for parsing JSON (except for webhook route)
app.use((req, res, next) => {
  if (req.path === '/api/webhook' && req.method === 'POST') {
    // Skip JSON parsing for webhook verification
    next();
  } else {
    express.json()(req, res, next);
  }
});

// Health check endpoint
app.get('/backend', (_, res) => {
  res.json({ 
    message: 'Bot Backend API is running',
    version: '2.0.0',
    timestamp: new Date().toISOString()
  });
});

// Routes
app.use('/api/webhook', webhookRoutes);
app.use('/api/sync', syncRoutes);
app.use('/backend/address-registration', addressRegistrationRoutes);

// Import and use audio routes
import audioOrderRoutes from './api/audio/audioOrder.routes';
app.use('/api/v1/audio', audioOrderRoutes);

// OTP endpoints
app.post('/backend/otp/verify',
  validationMiddleware(VerifyOtpDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { whatsappPhoneNumber, otp } = req.body as VerifyOtpDto;
    const isValid = await OTPService.verifyOTP(whatsappPhoneNumber, otp);
    res.json({ valid: isValid });
  }));

app.post('/backend/otp/invalidate',
  validationMiddleware(InvalidateOtpDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { whatsappPhoneNumber } = req.body as InvalidateOtpDto;
    await OTPService.invalidateOTP(whatsappPhoneNumber);
    res.json({ success: true });
  }));

// Customer addresses endpoints
app.post('/backend/customer/:customerId/addresses',
  validationMiddleware(AddressDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { customerId } = req.params;
    const addressData = {
      ...req.body as AddressDto,
      customer: { connect: { id: customerId } }
    };
  const address = await DeliveryInfoService.createCustomerAddress(addressData);
  res.json(address);
}));

app.get('/backend/customer/:customerId/addresses',
  queryValidationMiddleware(GetAddressesQueryDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { customerId } = req.params;
    const { includeInactive } = req.query as unknown as GetAddressesQueryDto;
  const addresses = await DeliveryInfoService.getCustomerAddresses(customerId, includeInactive);
  res.json(addresses);
}));

app.get('/backend/customer/:customerId/addresses/default', asyncHandler(async (req: Request, res: Response) => {
  const { customerId } = req.params;
  const { NotFoundError, ErrorCode } = await import('./common/services/errors');
  const address = await DeliveryInfoService.getCustomerDefaultAddress(customerId);
  if (!address) {
    throw new NotFoundError(
      ErrorCode.ADDRESS_NOT_FOUND,
      'No default address found',
      { customerId }
    );
  }
  res.json(address);
}));

app.put('/backend/addresses/:addressId',
  validationMiddleware(UpdateAddressDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { addressId } = req.params;
    const address = await DeliveryInfoService.updateCustomerAddress(
      addressId,
      req.body as UpdateAddressDto
    );
  res.json(address);
}));

app.put('/backend/addresses/:addressId/set-default',
  asyncHandler(async (req: Request, res: Response) => {
    const { addressId } = req.params;
    
    // Get the address to find the customerId
    const existingAddress = await prisma.address.findUnique({
      where: { id: addressId },
      select: { customerId: true }
    });
    
    if (!existingAddress) {
      const { NotFoundError, ErrorCode } = await import('./common/services/errors');
      throw new NotFoundError(
        ErrorCode.ADDRESS_NOT_FOUND,
        'Address not found',
        { addressId }
      );
    }
    
    const address = await DeliveryInfoService.setDefaultAddress(addressId, existingAddress.customerId);
    res.json(address);
  }));

app.delete('/backend/addresses/:addressId',
  asyncHandler(async (req: Request, res: Response) => {
    const { addressId } = req.params;
    
    // Get the address to find the customerId
    const existingAddress = await prisma.address.findUnique({
      where: { id: addressId },
      select: { customerId: true }
    });
    
    if (!existingAddress) {
      const { NotFoundError, ErrorCode } = await import('./common/services/errors');
      throw new NotFoundError(
        ErrorCode.ADDRESS_NOT_FOUND,
        'Address not found',
        { addressId }
      );
    }
    
    await DeliveryInfoService.deleteCustomerAddress(addressId, existingAddress.customerId);
    res.json({ success: true });
  }));

// Pre-orders endpoint
app.post('/backend/pre-orders/create',
  validationMiddleware(CreateOrderDto),
  asyncHandler(async (req: Request, res: Response) => {
    const preOrderService = new PreOrderService();
    const dto = req.body as CreateOrderDto;
    
    // Transform DTO to match PreOrderService expectations
    const orderData = {
      orderItems: dto.orderItems.map(item => ({
        productId: item.productId,
        productVariantId: item.productVariantId || null,
        quantity: item.quantity,
        comments: item.comments,
        selectedModifiers: item.selectedModifiers,
        selectedPizzaCustomizations: item.selectedPizzaCustomizations.map(pc => ({
          pizzaCustomizationId: pc.pizzaCustomizationId,
          half: pc.half as "FULL" | "HALF_1" | "HALF_2",
          action: pc.action as "ADD" | "REMOVE"
        }))
      })),
      whatsappPhoneNumber: dto.whatsappPhoneNumber,
      orderType: dto.orderType,
      scheduledAt: dto.scheduledAt,
      deliveryInfo: dto.deliveryInfo
    };
    
    const result = await preOrderService.createPreOrder(orderData);
  res.status(200).json(result);
}));

// WhatsApp send message endpoint
app.post('/backend/whatsapp/send-message',
  validationMiddleware(SendMessageDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { to, message } = req.body as SendMessageDto;
  const result = await WhatsAppService.sendMessage(to, message);
  res.json(result);
}));

// Global error handling middleware (must be last)
app.use(globalErrorHandler);

// Start server
const PORT = parseInt(env.PORT, 10);
let preOrderCleanupInterval: NodeJS.Timeout;

async function startServer() {
  try {
    // Test database connection
    await prisma.$connect();
    logger.info('Database connected successfully');
    
    // Load restaurant configuration
    await ConfigService.loadConfig();
    logger.info('Restaurant configuration loaded');
    
    // Connect to Redis
    const { redisService } = await import('./services/redis/RedisService');
    await redisService.connect();
    
    // Start OTP cleanup interval
    OTPService.startOTPCleanup();
    
    // Start PreOrder cleanup interval
    const { PreOrderWorkflowService } = await import('./services/orders/PreOrderWorkflowService');
    preOrderCleanupInterval = setInterval(async () => {
      await PreOrderWorkflowService.cleanupExpiredPreOrders();
    }, 5 * 60 * 1000); // Run every 5 minutes
    logger.info('PreOrder cleanup interval started');
    
    // Initialize embeddings on startup
    const { initializeEmbeddings } = await import('./startup/embeddingInitializer');
    await initializeEmbeddings();
    
    const server = app.listen(PORT, () => {
      logger.info(`Server is running on port ${PORT}`);
    });
    
    // Initialize WebSocket for sync notifications
    const io = await import('socket.io');
    const socketServer = new io.Server(server, {
      cors: {
        origin: '*', // Configure this properly in production
        methods: ['GET', 'POST']
      },
      path: '/socket.io/'
    });
    
    const { SyncNotificationService } = await import('./services/sync/SyncNotificationService');
    SyncNotificationService.initialize(socketServer);
    logger.info('WebSocket server initialized for sync notifications');
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on('SIGINT', async () => {
  logger.info('Shutting down server...');
  OTPService.stopOTPCleanup();
  if (preOrderCleanupInterval) {
    clearInterval(preOrderCleanupInterval);
  }
  const { redisService } = await import('./services/redis/RedisService');
  await redisService.disconnect();
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('Shutting down server...');
  OTPService.stopOTPCleanup();
  if (preOrderCleanupInterval) {
    clearInterval(preOrderCleanupInterval);
  }
  const { redisService } = await import('./services/redis/RedisService');
  await redisService.disconnect();
  await prisma.$disconnect();
  process.exit(0);
});

startServer();

export { app, prisma };

================
File: backend/src/services/orders/services/OrderManagementService.ts
================
import { prisma } from '../../../lib/prisma';
import { Order, OrderStatus } from "@prisma/client";
import logger from "../../../common/utils/logger";
import { BusinessLogicError, ErrorCode } from "../../../common/services/errors";
import { OrderService } from "../OrderService";
import { CreateOrderDto } from '../../../dto/order';
import { sendWhatsAppMessage, WhatsAppService } from "../../whatsapp";
import { OrderFormattingService } from "./OrderFormattingService";
import { SyncMetadataService } from "../../sync/SyncMetadataService";

export class OrderManagementService {
  async confirmPreOrder(preOrderId: number): Promise<Order> {
    const preOrder = await prisma.preOrder.findUnique({
      where: { id: preOrderId },
      include: {
        deliveryInfo: true,
        orderItems: {
          include: {
            product: true,
            productVariant: true,
            productModifiers: true,
            selectedPizzaCustomizations: {
              include: {
                pizzaCustomization: true
              }
            }
          }
        }
      },
    });

    if (!preOrder) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'PreOrder not found',
        { metadata: { preOrderId } }
      );
    }

    const orderItems = preOrder.orderItems.map(item => ({
      productId: item.productId,
      productVariantId: item.productVariantId,
      selectedModifiers: item.productModifiers.map(m => m.id),
      selectedPizzaCustomizations: item.selectedPizzaCustomizations.map(sc => ({
        pizzaCustomizationId: sc.pizzaCustomizationId,
        half: sc.half,
        action: sc.action
      })),
      quantity: 1
    }));

    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: preOrder.whatsappPhoneNumber }
    });

    if (!customer) {
      throw new BusinessLogicError(
        ErrorCode.CUSTOMER_NOT_FOUND,
        'Customer not found for this phone number',
        { metadata: { whatsappPhoneNumber: preOrder.whatsappPhoneNumber } }
      );
    }

    // Usar el deliveryInfo del preOrder si existe
    let deliveryInfo = undefined;
    if (preOrder.deliveryInfo) {
      const info = preOrder.deliveryInfo;
      deliveryInfo = {
        fullAddress: info.fullAddress || undefined,
        street: info.street || undefined,
        number: info.number || undefined,
        interiorNumber: info.interiorNumber || undefined,
        neighborhood: info.neighborhood || undefined,
        zipCode: info.zipCode || undefined,
        city: info.city || undefined,
        state: info.state || undefined,
        country: info.country || undefined,
        latitude: info.latitude ? info.latitude.toNumber() : undefined,
        longitude: info.longitude ? info.longitude.toNumber() : undefined,
        recipientName: info.recipientName || undefined,
        recipientPhone: info.recipientPhone || undefined,
        deliveryInstructions: info.deliveryInstructions || undefined,
      };
    }

    const orderItemsDto = orderItems.map(item => ({
      productId: item.productId,
      productVariantId: item.productVariantId || undefined,
      quantity: item.quantity,
      comments: undefined,
      selectedModifiers: item.selectedModifiers || [],
      selectedPizzaCustomizations: (item.selectedPizzaCustomizations || []).map(pc => ({
        pizzaCustomizationId: pc.pizzaCustomizationId,
        half: pc.half,
        action: pc.action
      }))
    }));

    const orderData: CreateOrderDto = {
      orderItems: orderItemsDto,
      whatsappPhoneNumber: customer.whatsappPhoneNumber,
      orderType: preOrder.orderType,
      scheduledAt: preOrder.scheduledAt ? preOrder.scheduledAt.toISOString() : undefined,
      subtotal: preOrder.subtotal,
      total: preOrder.total,
      ...(deliveryInfo ? { deliveryInfo: deliveryInfo } : {}),
    };

    const order = await OrderService.create(orderData);

    await prisma.preOrder.delete({ where: { id: preOrderId } });

    logger.info(`PreOrder ${preOrderId} converted to Order ${order.id}`);
    
    await SyncMetadataService.markForSync('Order', order.id, 'REMOTE');
    
    try {
      const { SyncNotificationService } = await import('../../sync/SyncNotificationService');
      await SyncNotificationService.notifyNewOrder(order.id);
    } catch (error) {
      logger.warn('Could not notify sync service about new order:', error);
    }
    
    return order;
  }


  async discardPreOrder(preOrderId: number): Promise<void> {
    const preOrder = await prisma.preOrder.findUnique({
      where: { id: preOrderId },
    });

    if (!preOrder) {
      throw new BusinessLogicError(
        ErrorCode.ORDER_NOT_FOUND,
        'PreOrder not found',
        { metadata: { preOrderId } }
      );
    }

    await prisma.preOrder.delete({
      where: { id: preOrderId },
    });

    logger.info(`PreOrder ${preOrderId} discarded successfully`);
  }

  async sendOrderConfirmation(
    whatsappNumber: string,
    orderId: string,
    _action: "confirmed" | "cancelled" | "modified" = "confirmed"
  ): Promise<void> {
    try {
      const fullOrder = await prisma.order.findUnique({
        where: { id: orderId },
        include: {
          customer: true,
          orderItems: {
            include: {
              product: true,
              productVariant: true,
              productModifiers: true,
              selectedPizzaCustomizations: {
                include: { pizzaCustomization: true },
              },
            },
          },
          deliveryInfo: true,
        },
      });

      if (!fullOrder) {
        throw new BusinessLogicError(
          ErrorCode.ORDER_NOT_FOUND,
          'Order not found for confirmation',
          { metadata: { orderId } }
        );
      }


      const formattedOrder = OrderFormattingService.formatOrderForWhatsApp(fullOrder, whatsappNumber);
      const orderSummary = await OrderFormattingService.generateConfirmationMessage(fullOrder, formattedOrder);
      
      if (fullOrder.orderStatus === "PENDING" || fullOrder.orderStatus === "IN_PROGRESS") {
        const message = {
          type: "button",
          header: {
            type: "text",
            text: "‚úÖ Orden Confirmada",
          },
          body: {
            text: orderSummary,
          },
          action: {
            buttons: [
              {
                type: "reply",
                reply: {
                  id: `pay_online:${fullOrder.id}`,
                  title: "üí≥ Pagar en l√≠nea",
                },
              },
            ],
          },
        };

        await WhatsAppService.sendInteractiveMessage(whatsappNumber, message);
      } else {
        await sendWhatsAppMessage(whatsappNumber, orderSummary);
      }
    } catch (error) {
      logger.error('Error sending order confirmation:', error);
      throw error;
    }
  }

  // Removed _sendOrderActionButtons - functionality integrated into sendOrderConfirmation
}

================
File: backend/src/services/sync/UnifiedSyncService.ts
================
import { prisma } from '../../server';
import logger from '../../common/utils/logger';
import { SyncMetadataService } from './SyncMetadataService';
import { EmbeddingManager } from './EmbeddingManager';

interface PullChangesResponse {
  pending_orders: any[];
  updated_customers: any[];
}

interface LocalSystemResponse {
  statusCode?: number;
  message?: string;
  menu?: {
    categories: any[];
    lastUpdated: string;
  };
  config?: {
    restaurantConfig: any;
    businessHours: any[];
    lastUpdated: string;
  };
  // Direct structure from local system (alternative format)
  restaurantConfig?: any;
  businessHours?: any[];
  categories?: any[];
  timestamp?: string;
  lastUpdated?: string;
}

export class UnifiedSyncService {
  /**
   * Process restaurant data pushed from local system
   */
  static async processRestaurantDataPush(data: LocalSystemResponse): Promise<boolean> {
    logger.info('Processing restaurant data push', {
      hasDirectConfig: !!data.restaurantConfig,
      hasDirectBusinessHours: !!data.businessHours,
      hasNestedConfig: !!data.config,
      hasMenu: !!data.menu || !!data.categories,
      // Restaurant config details
      restaurantName: data.restaurantConfig?.restaurantName || data.config?.restaurantConfig?.restaurantName,
      phoneMain: data.restaurantConfig?.phoneMain || data.config?.restaurantConfig?.phoneMain,
      // Business hours - check nested in restaurantConfig too
      businessHoursCount: data.businessHours?.length || 
                         data.config?.businessHours?.length || 
                         data.restaurantConfig?.businessHours?.length ||
                         data.config?.restaurantConfig?.businessHours?.length || 0,
      // Menu details
      categoriesCount: data.categories?.length || data.menu?.categories?.length || 0,
      allCategoryNames: (data.categories || data.menu?.categories || []).map((c: any) => c.name)
    });
    
    try {
      // Normalize the data structure to handle both formats
      const normalizedData: LocalSystemResponse = {
        ...data
      };
      
      // If data comes with direct structure, normalize it
      if (!normalizedData.config && (data.restaurantConfig || data.businessHours)) {
        // Extract businessHours from restaurantConfig if nested there
        const businessHours = data.businessHours || data.restaurantConfig?.businessHours || [];
        
        normalizedData.config = {
          restaurantConfig: data.restaurantConfig,
          businessHours: businessHours,
          lastUpdated: data.lastUpdated || new Date().toISOString()
        };
      }
      
      if (!normalizedData.menu && data.categories) {
        normalizedData.menu = {
          categories: data.categories,
          lastUpdated: data.lastUpdated || new Date().toISOString()
        };
      }
      
      // Check if data has changed
      const existingConfig = await prisma.restaurantConfig.findFirst();
      const existingMenu = await prisma.category.findMany();
      
      // Simple change detection
      const configData = normalizedData.config?.restaurantConfig;
      const categoriesData = normalizedData.menu?.categories;
      
      const configChanged = !existingConfig || JSON.stringify(existingConfig) !== JSON.stringify(configData);
      const menuChanged = !categoriesData || existingMenu.length !== categoriesData.length;
      
      if (!configChanged && !menuChanged) {
        logger.info('No changes detected in restaurant data');
        return false;
      }
      
      // Process the data
      await this.processRestaurantData(normalizedData);
      logger.info('Restaurant data processed successfully');
      return true;
    } catch (error) {
      logger.error('Error processing restaurant data push:', error);
      throw error;
    }
  }

  /**
   * Pull all pending changes without token complexity
   */
  static async pullChanges(): Promise<PullChangesResponse> {
    logger.info('UnifiedSync: Pull changes requested');
    
    // Get pending items
    const pendingOrders = await SyncMetadataService.getPendingSync('Order');
    const pendingCustomers = await SyncMetadataService.getPendingSync('Customer');
    
    const orderIds = pendingOrders.map(p => p.entityId);
    const customerIds = pendingCustomers.map(p => p.entityId);
    
    // Fetch full order data
    const orders = await this.fetchPendingOrders(orderIds);
    
    // Fetch full customer data  
    const customers = await this.fetchPendingCustomers(customerIds);
    
    logger.info('UnifiedSync: Prepared changes', {
      orderCount: orders.length,
      customerCount: customers.length
    });
    
    return {
      pending_orders: orders,
      updated_customers: customers
    };
  }

  /**
   * Fetch pending orders with full data
   */
  private static async fetchPendingOrders(orderIds: string[]): Promise<any[]> {
    if (orderIds.length === 0) {
      return [];
    }
    
    const orders = await prisma.order.findMany({
      where: {
        id: { in: orderIds },
        isFromWhatsApp: true
      },
      include: {
        customer: true,
        orderItems: {
          include: {
            product: true,
            productVariant: true,
            productModifiers: true,
            selectedPizzaCustomizations: {
              include: {
                pizzaCustomization: true
              }
            }
          }
        },
        deliveryInfo: true,
        payments: true
      },
      orderBy: { createdAt: 'asc' }
    });
    
    // Transform to expected format
    return orders.map(order => ({
      id: order.id,
      shiftOrderNumber: order.shiftOrderNumber,
      orderType: order.orderType,
      orderStatus: order.orderStatus,
      subtotal: order.subtotal,
      total: order.total,
      customerId: order.customerId,
      estimatedDeliveryTime: order.estimatedDeliveryTime?.toISOString() || null,
      scheduledAt: order.scheduledAt?.toISOString() || null,
      notes: order.notes || null,
      isFromWhatsApp: order.isFromWhatsApp,
      finalizedAt: order.finalizedAt?.toISOString() || null,
      shiftId: order.shiftId || null,
      userId: order.userId || null,
      tableId: order.tableId || null,
      customer: {
        id: order.customer.id,
        whatsappPhoneNumber: order.customer.whatsappPhoneNumber,
        firstName: order.customer.firstName || null,
        lastName: order.customer.lastName || null,
        email: order.customer.email || null,
        birthDate: order.customer.birthDate?.toISOString() || null,
        stripeCustomerId: order.customer.stripeCustomerId || null,
        lastInteraction: order.customer.lastInteraction?.toISOString() || null,
        totalOrders: order.customer.totalOrders,
        totalSpent: order.customer.totalSpent.toNumber(),
        isActive: order.customer.isActive,
        isBanned: order.customer.isBanned,
        bannedAt: order.customer.bannedAt?.toISOString() || null,
        banReason: order.customer.banReason || null,
        createdAt: order.customer.createdAt.toISOString(),
        updatedAt: order.customer.updatedAt.toISOString()
      },
      orderItems: order.orderItems.map(item => ({
        id: item.id,
        orderId: item.orderId,
        productId: item.productId,
        productVariantId: item.productVariantId,
        basePrice: item.basePrice,
        finalPrice: item.finalPrice,
        preparationStatus: item.preparationStatus,
        statusChangedAt: item.statusChangedAt.toISOString(),
        preparationNotes: item.preparationNotes || null,
        createdAt: item.createdAt.toISOString(),
        updatedAt: item.updatedAt.toISOString(),
        product: {
          id: item.product.id,
          name: item.product.name
        },
        productVariant: item.productVariant ? {
          id: item.productVariant.id,
          name: item.productVariant.name
        } : null,
        productModifiers: item.productModifiers.map(mod => ({
          id: mod.id,
          name: mod.name,
          price: mod.price || 0
        })),
        selectedPizzaCustomizations: item.selectedPizzaCustomizations.map(customization => ({
          id: customization.id,
          orderItemId: customization.orderItemId,
          pizzaCustomizationId: customization.pizzaCustomizationId,
          half: customization.half,
          action: customization.action,
          pizzaCustomization: {
            id: customization.pizzaCustomization.id,
            name: customization.pizzaCustomization.name,
            type: customization.pizzaCustomization.type,
            ingredients: customization.pizzaCustomization.ingredients || null,
            toppingValue: customization.pizzaCustomization.toppingValue
          }
        }))
      })),
      deliveryInfo: order.deliveryInfo ? {
        // Si existe deliveryInfo en BD (DELIVERY y TAKE_AWAY)
        id: order.deliveryInfo.id,
        orderId: order.deliveryInfo.orderId,
        name: order.deliveryInfo.name || null,
        fullAddress: order.deliveryInfo.fullAddress || null,
        street: order.deliveryInfo.street || null,
        number: order.deliveryInfo.number || null,
        interiorNumber: order.deliveryInfo.interiorNumber || null,
        neighborhood: order.deliveryInfo.neighborhood || null,
        city: order.deliveryInfo.city || null,
        state: order.deliveryInfo.state || null,
        zipCode: order.deliveryInfo.zipCode || null,
        country: order.deliveryInfo.country || null,
        recipientName: order.deliveryInfo.recipientName || null,
        recipientPhone: order.deliveryInfo.recipientPhone || null,
        deliveryInstructions: order.deliveryInfo.deliveryInstructions || null,
        latitude: order.deliveryInfo.latitude?.toNumber() || null,
        longitude: order.deliveryInfo.longitude?.toNumber() || null,
        createdAt: order.deliveryInfo.createdAt.toISOString(),
        updatedAt: order.deliveryInfo.updatedAt.toISOString()
      } : {
        // Para √≥rdenes sin deliveryInfo en BD (DINE_IN o casos legacy)
        id: null,
        orderId: order.id,
        name: null,
        fullAddress: null,
        street: null,
        number: null,
        interiorNumber: null,
        neighborhood: null,
        city: null,
        state: null,
        zipCode: null,
        country: null,
        recipientName: order.orderType === 'TAKE_AWAY' ? 
          `${order.customer.firstName || ''} ${order.customer.lastName || ''}`.trim() || order.customer.whatsappPhoneNumber : null,
        recipientPhone: order.orderType === 'TAKE_AWAY' ? 
          order.customer.whatsappPhoneNumber : null,
        deliveryInstructions: null,
        latitude: null,
        longitude: null,
        createdAt: order.createdAt.toISOString(),
        updatedAt: order.updatedAt.toISOString()
      },
      payments: order.payments.map(payment => ({
        id: payment.id,
        orderId: payment.orderId,
        paymentMethod: payment.paymentMethod,
        amount: payment.amount.toNumber(),
        status: payment.status,
        stripePaymentId: payment.stripePaymentId || null,
        metadata: payment.metadata || null,
        createdAt: payment.createdAt.toISOString(),
        updatedAt: payment.updatedAt.toISOString()
      })),
      createdAt: order.createdAt.toISOString(),
      updatedAt: order.updatedAt.toISOString()
    }));
  }

  /**
   * Fetch pending customers with full data
   */
  private static async fetchPendingCustomers(customerIds: string[]): Promise<any[]> {
    if (customerIds.length === 0) {
      return [];
    }
    
    const customers = await prisma.customer.findMany({
      where: {
        id: { in: customerIds },
        deletedAt: null
      },
      include: {
        addresses: {
          where: { deletedAt: null }
        }
      }
    });
    
    // Transform to expected format
    return customers.map(customer => ({
      id: customer.id,
      firstName: customer.firstName || '',
      lastName: customer.lastName || '',
      whatsappPhoneNumber: customer.whatsappPhoneNumber,
      stripeCustomerId: customer.stripeCustomerId,
      email: customer.email || null,
      birthDate: customer.birthDate?.toISOString().split('T')[0] || null,
      fullChatHistory: customer.fullChatHistory || [],
      relevantChatHistory: customer.relevantChatHistory || [],
      lastInteraction: customer.lastInteraction?.toISOString() || null,
      totalOrders: customer.totalOrders,
      totalSpent: customer.totalSpent.toNumber(),
      isActive: customer.isActive,
      isBanned: customer.isBanned,
      bannedAt: customer.bannedAt?.toISOString() || null,
      banReason: customer.banReason || null,
      lastSyncedAt: new Date().toISOString(),
      addresses: customer.addresses.map(addr => ({
        id: addr.id,
        customerId: customer.id,
        name: addr.name,
        street: addr.street,
        number: addr.number,
        interiorNumber: addr.interiorNumber || null,
        neighborhood: addr.neighborhood || '',
        city: addr.city || '',
        state: addr.state || '',
        zipCode: addr.zipCode || '',
        country: addr.country || 'M√©xico',
        deliveryInstructions: addr.deliveryInstructions || '',
        latitude: addr.latitude?.toNumber() || null,
        longitude: addr.longitude?.toNumber() || null,
        isDefault: addr.isDefault,
        createdAt: addr.createdAt.toISOString(),
        updatedAt: addr.updatedAt.toISOString(),
        deletedAt: addr.deletedAt?.toISOString() || null
      })),
      createdAt: customer.createdAt.toISOString(),
      updatedAt: customer.updatedAt.toISOString(),
      deletedAt: customer.deletedAt?.toISOString() || null
    }));
  }


  /**
   * Process and save restaurant data received from local system
   */
  static async processRestaurantData(data: LocalSystemResponse): Promise<void> {
    logger.info('Processing restaurant data', {
      hasMenu: !!data.menu,
      hasConfig: !!data.config,
      menuCategoriesCount: data.menu?.categories?.length || 0,
      configHasRestaurantConfig: !!data.config?.restaurantConfig,
      configHasBusinessHours: !!data.config?.businessHours,
      businessHoursCount: data.config?.businessHours?.length || 0,
      // Detailed config info
      restaurantName: data.config?.restaurantConfig?.restaurantName,
      phoneNumbers: {
        main: data.config?.restaurantConfig?.phoneMain,
        whatsapp: data.config?.restaurantConfig?.phoneWhatsapp
      },
      deliverySettings: {
        isEnabled: data.config?.restaurantConfig?.isDeliveryEnabled,
        minimumOrder: data.config?.restaurantConfig?.minimumOrderAmountForDelivery,
        cost: data.config?.restaurantConfig?.deliveryCost
      }
    });
    
    await prisma.$transaction(async (tx) => {
      // Process menu data
      if (data.menu?.categories) {
        logger.info('Processing menu data with categories:', data.menu.categories.length);
        await this.processMenuData(data.menu.categories, tx);
      }

      // Process configuration data
      if (data.config) {
        logger.info('Processing configuration data');
        await this.processConfigData(data.config, tx);
      }
    });

    // Generate embeddings after menu sync (non-blocking)
    if (data.menu?.categories) {
      logger.info('Triggering embedding generation after menu sync');
      setTimeout(() => {
        EmbeddingManager.generateEmbeddingsAfterSync().catch(error => {
          logger.error('Failed to generate embeddings after sync:', error);
        });
      }, 2000); // Small delay to ensure transaction is committed
    }
  }

  /**
   * Process and save menu data (categories, subcategories, products)
   */
  private static async processMenuData(categories: any[], tx: any): Promise<void> {
    logger.info('UnifiedSync: Processing menu data', {
      totalCategories: categories.length,
      categoryNames: categories.map(c => c.name),
      categoriesWithProducts: categories.map(c => ({
        name: c.name,
        productsCount: c.products?.length || 0,
        subcategoriesCount: c.subcategories?.length || 0
      }))
    });
    
    for (const categoryData of categories) {
      // Upsert category
      const category = await tx.category.upsert({
        where: { id: categoryData.id },
        create: {
          id: categoryData.id,
          name: categoryData.name,
          description: categoryData.description,
          isActive: categoryData.isActive !== false,
          sortOrder: categoryData.sortOrder || 0,
          photoId: categoryData.photoId,
          createdAt: categoryData.createdAt ? new Date(categoryData.createdAt) : new Date(),
          updatedAt: categoryData.updatedAt ? new Date(categoryData.updatedAt) : new Date()
        },
        update: {
          name: categoryData.name,
          description: categoryData.description,
          isActive: categoryData.isActive !== false,
          sortOrder: categoryData.sortOrder || 0,
          photoId: categoryData.photoId,
          updatedAt: new Date(),
          deletedAt: categoryData.deletedAt ? new Date(categoryData.deletedAt) : null
        }
      });
      
      // Process subcategories
      if (categoryData.subcategories && Array.isArray(categoryData.subcategories)) {
        for (const subData of categoryData.subcategories) {
          const subcategory = await tx.subcategory.upsert({
            where: { id: subData.id },
            create: {
              id: subData.id,
              categoryId: category.id,
              name: subData.name,
              description: subData.description,
              isActive: subData.isActive !== false,
              sortOrder: subData.sortOrder || 0,
              photoId: subData.photoId,
              createdAt: subData.createdAt ? new Date(subData.createdAt) : new Date(),
              updatedAt: subData.updatedAt ? new Date(subData.updatedAt) : new Date()
            },
            update: {
              name: subData.name,
              description: subData.description,
              isActive: subData.isActive !== false,
              sortOrder: subData.sortOrder || 0,
              photoId: subData.photoId,
              updatedAt: new Date(),
              deletedAt: subData.deletedAt ? new Date(subData.deletedAt) : null
            }
          });
          
          // Process products
          if (subData.products && Array.isArray(subData.products)) {
            // Log first product of subcategory as sample
            if (subData.products.length > 0) {
              logger.debug('UnifiedSync: Sample product in subcategory', {
                subcategoryName: subData.name,
                productName: subData.products[0].name,
                price: subData.products[0].price,
                hasVariants: subData.products[0].hasVariants,
                variantsCount: subData.products[0].variants?.length || 0,
                modifierGroupsCount: subData.products[0].modifierGroups?.length || 0
              });
            }
            
            for (const productData of subData.products) {
              // Upsert product
              const product = await tx.product.upsert({
                where: { id: productData.id },
                create: {
                  id: productData.id,
                  name: productData.name,
                  description: productData.description,
                  price: productData.price ? parseFloat(productData.price.toString()) : null,
                  hasVariants: productData.hasVariants || false,
                  isActive: productData.isActive !== false,
                  isPizza: productData.isPizza || false,
                  sortOrder: productData.sortOrder || 0,
                  subcategoryId: productData.subcategoryId || subcategory.id,
                  photoId: productData.photoId,
                  estimatedPrepTime: productData.estimatedPrepTime || 0,
                  preparationScreenId: productData.preparationScreenId,
                  createdAt: productData.createdAt ? new Date(productData.createdAt) : new Date(),
                  updatedAt: productData.updatedAt ? new Date(productData.updatedAt) : new Date()
                },
                update: {
                  name: productData.name,
                  description: productData.description,
                  price: productData.price ? parseFloat(productData.price.toString()) : null,
                  hasVariants: productData.hasVariants || false,
                  isActive: productData.isActive !== false,
                  isPizza: productData.isPizza || false,
                  sortOrder: productData.sortOrder || 0,
                  photoId: productData.photoId,
                  estimatedPrepTime: productData.estimatedPrepTime || 0,
                  preparationScreenId: productData.preparationScreenId,
                  updatedAt: new Date(),
                  deletedAt: productData.deletedAt ? new Date(productData.deletedAt) : null
                }
              });
              
              // Process variants
              if (productData.variants && Array.isArray(productData.variants)) {
                for (const variantData of productData.variants) {
                  await tx.productVariant.upsert({
                    where: { id: variantData.id },
                    create: {
                      id: variantData.id,
                      productId: product.id,
                      name: variantData.name,
                      price: variantData.price != null ? parseFloat(variantData.price.toString()) : 0,
                      isActive: variantData.isActive !== false,
                      sortOrder: variantData.sortOrder || 0,
                      createdAt: variantData.createdAt ? new Date(variantData.createdAt) : new Date(),
                      updatedAt: variantData.updatedAt ? new Date(variantData.updatedAt) : new Date()
                    },
                    update: {
                      name: variantData.name,
                      price: variantData.price != null ? parseFloat(variantData.price.toString()) : 0,
                      isActive: variantData.isActive !== false,
                      sortOrder: variantData.sortOrder || 0,
                      updatedAt: new Date(),
                      deletedAt: variantData.deletedAt ? new Date(variantData.deletedAt) : null
                    }
                  });
                }
              }
              
              // Process modifier groups
              if (productData.modifierGroups && Array.isArray(productData.modifierGroups)) {
                for (const groupData of productData.modifierGroups) {
                  const modifierGroup = await tx.modifierGroup.upsert({
                    where: { id: groupData.id },
                    create: {
                      id: groupData.id,
                      name: groupData.name,
                      description: groupData.description,
                      minSelections: groupData.minSelections || 0,
                      maxSelections: groupData.maxSelections || 1,
                      isRequired: groupData.isRequired || false,
                      allowMultipleSelections: groupData.allowMultipleSelections || false,
                      isActive: groupData.isActive !== false,
                      sortOrder: groupData.sortOrder || 0,
                      createdAt: groupData.createdAt ? new Date(groupData.createdAt) : new Date(),
                      updatedAt: groupData.updatedAt ? new Date(groupData.updatedAt) : new Date()
                    },
                    update: {
                      name: groupData.name,
                      description: groupData.description,
                      minSelections: groupData.minSelections || 0,
                      maxSelections: groupData.maxSelections || 1,
                      isRequired: groupData.isRequired || false,
                      allowMultipleSelections: groupData.allowMultipleSelections || false,
                      isActive: groupData.isActive !== false,
                      sortOrder: groupData.sortOrder || 0,
                      updatedAt: new Date(),
                      deletedAt: groupData.deletedAt ? new Date(groupData.deletedAt) : null
                    }
                  });
                  
                  // Connect to product
                  await tx.product.update({
                    where: { id: product.id },
                    data: {
                      modifierGroups: {
                        disconnect: { id: modifierGroup.id },
                        connect: { id: modifierGroup.id }
                      }
                    }
                  });
                  
                  // Process modifiers
                  if (groupData.productModifiers && Array.isArray(groupData.productModifiers)) {
                    for (const modifierData of groupData.productModifiers) {
                      await tx.productModifier.upsert({
                        where: { id: modifierData.id },
                        create: {
                          id: modifierData.id,
                          modifierGroupId: modifierGroup.id,
                          name: modifierData.name,
                          description: modifierData.description,
                          price: modifierData.price ? parseFloat(modifierData.price.toString()) : 0,
                          sortOrder: modifierData.sortOrder || 0,
                          isDefault: modifierData.isDefault || false,
                          isActive: modifierData.isActive !== false,
                          createdAt: modifierData.createdAt ? new Date(modifierData.createdAt) : new Date(),
                          updatedAt: modifierData.updatedAt ? new Date(modifierData.updatedAt) : new Date()
                        },
                        update: {
                          name: modifierData.name,
                          description: modifierData.description,
                          price: modifierData.price ? parseFloat(modifierData.price.toString()) : 0,
                          sortOrder: modifierData.sortOrder || 0,
                          isDefault: modifierData.isDefault || false,
                          isActive: modifierData.isActive !== false,
                          updatedAt: new Date(),
                          deletedAt: modifierData.deletedAt ? new Date(modifierData.deletedAt) : null
                        }
                      });
                    }
                  }
                }
              }
              
              // Process pizza customizations
              if (productData.pizzaCustomizations && Array.isArray(productData.pizzaCustomizations)) {
                for (const customData of productData.pizzaCustomizations) {
                  await tx.pizzaCustomization.upsert({
                    where: { id: customData.id },
                    create: {
                      id: customData.id,
                      name: customData.name,
                      type: customData.type || 'INGREDIENT',
                      ingredients: customData.ingredients,
                      toppingValue: customData.toppingValue || 1,
                      isActive: customData.isActive !== false,
                      sortOrder: customData.sortOrder || 0
                    },
                    update: {
                      name: customData.name,
                      type: customData.type || 'INGREDIENT',
                      ingredients: customData.ingredients,
                      toppingValue: customData.toppingValue || 1,
                      isActive: customData.isActive !== false,
                      sortOrder: customData.sortOrder || 0
                    }
                  });
                  
                  // Connect to product
                  await tx.product.update({
                    where: { id: product.id },
                    data: {
                      pizzaCustomizations: {
                        disconnect: { id: customData.id },
                        connect: { id: customData.id }
                      }
                    }
                  });
                }
              }
              
              // Process pizza configuration
              if (productData.pizzaConfiguration) {
                await tx.pizzaConfiguration.upsert({
                  where: { productId: product.id },
                  create: {
                    productId: product.id,
                    includedToppings: productData.pizzaConfiguration?.includedToppings || 4,
                    extraToppingCost: productData.pizzaConfiguration?.extraToppingCost || 20
                  },
                  update: {
                    includedToppings: productData.pizzaConfiguration?.includedToppings || 4,
                    extraToppingCost: productData.pizzaConfiguration?.extraToppingCost || 20
                  }
                });
              }
            }
          }
        }
      }
    }
  }

  /**
   * Process and save configuration data
   */
  private static async processConfigData(configData: any, tx: any): Promise<void> {
    const { restaurantConfig } = configData;
    // Business hours can be at config level or nested in restaurantConfig
    const businessHours = configData.businessHours || restaurantConfig?.businessHours || [];
    
    logger.info('UnifiedSync: Processing config data', {
      hasRestaurantConfig: !!restaurantConfig,
      hasBusinessHours: businessHours.length > 0,
      businessHoursCount: businessHours.length,
      // Business hours details
      businessHoursDays: businessHours.map((h: any) => ({
        dayOfWeek: h.dayOfWeek,
        openTime: h.openingTime || h.openTime,
        closeTime: h.closingTime || h.closeTime,
        isOpen: h.isOpen !== false && !h.isClosed
      }))
    });

    // Upsert restaurant config
    await tx.restaurantConfig.upsert({
      where: { id: 1 }, // We use a fixed ID since we only have one config
      create: {
        id: 1,
        restaurantName: restaurantConfig.restaurantName,
        phoneMain: restaurantConfig.phoneMain,
        phoneSecondary: restaurantConfig.phoneSecondary,
        address: restaurantConfig.address,
        city: restaurantConfig.city,
        state: restaurantConfig.state,
        postalCode: restaurantConfig.postalCode,
        country: restaurantConfig.country || 'M√©xico',
        acceptingOrders: restaurantConfig.acceptingOrders !== false,
        estimatedPickupTime: restaurantConfig.estimatedPickupTime || 20,
        estimatedDeliveryTime: restaurantConfig.estimatedDeliveryTime || 40,
        openingGracePeriod: restaurantConfig.openingGracePeriod || 30,
        closingGracePeriod: restaurantConfig.closingGracePeriod || 30,
        timeZone: restaurantConfig.timeZone || 'America/Mexico_City',
        deliveryCoverageArea: restaurantConfig.deliveryCoverageArea || []
      },
      update: {
        restaurantName: restaurantConfig.restaurantName,
        phoneMain: restaurantConfig.phoneMain,
        phoneSecondary: restaurantConfig.phoneSecondary,
        address: restaurantConfig.address,
        city: restaurantConfig.city,
        state: restaurantConfig.state,
        postalCode: restaurantConfig.postalCode,
        country: restaurantConfig.country || 'M√©xico',
        acceptingOrders: restaurantConfig.acceptingOrders !== false,
        estimatedPickupTime: restaurantConfig.estimatedPickupTime || 20,
        estimatedDeliveryTime: restaurantConfig.estimatedDeliveryTime || 40,
        openingGracePeriod: restaurantConfig.openingGracePeriod || 30,
        closingGracePeriod: restaurantConfig.closingGracePeriod || 30,
        timeZone: restaurantConfig.timeZone || 'America/Mexico_City',
        deliveryCoverageArea: restaurantConfig.deliveryCoverageArea || []
      }
    });
    
    // Update business hours
    if (businessHours && Array.isArray(businessHours)) {
      for (const hoursData of businessHours) {
        // Format time to HH:mm if it includes seconds
        const formatTime = (time: string | null) => {
          if (!time) return null;
          // Remove seconds if present
          return time.substring(0, 5);
        };
        
        await tx.businessHours.upsert({
          where: {
            restaurantConfigId_dayOfWeek: {
              restaurantConfigId: 1,
              dayOfWeek: hoursData.dayOfWeek
            }
          },
          create: {
            restaurantConfigId: 1,
            dayOfWeek: hoursData.dayOfWeek,
            openingTime: formatTime(hoursData.openingTime),
            closingTime: formatTime(hoursData.closingTime),
            isClosed: hoursData.isClosed || false
          },
          update: {
            openingTime: formatTime(hoursData.openingTime),
            closingTime: formatTime(hoursData.closingTime),
            isClosed: hoursData.isClosed || false
          }
        });
      }
    }
    
    // Force reload of configuration cache
    const { ConfigService } = await import('../../services/config/ConfigService');
    await ConfigService.reloadConfig();
  }

  /**
   * Confirm synced items (orders and customers)
   * Marks them as no longer pending synchronization
   */
  static async confirmSyncedItems(
    confirmedOrders: Array<{ orderId: string; shiftOrderNumber: number }>,
    customerIds: string[]
  ): Promise<void> {
    logger.info('UnifiedSync: Confirming synced items', {
      orderCount: confirmedOrders.length,
      customerCount: customerIds.length
    });

    const entities: Array<{ entityType: 'Order' | 'Customer'; entityId: string }> = [];

    // Update orders with daily numbers and add to entities list
    for (const order of confirmedOrders) {
      await prisma.order.update({
        where: { id: order.orderId },
        data: { shiftOrderNumber: order.shiftOrderNumber }
      });
      entities.push({ entityType: 'Order', entityId: order.orderId });
    }

    // Add customers to entities list
    for (const customerId of customerIds) {
      entities.push({ entityType: 'Customer', entityId: customerId });
    }

    // Mark all entities as synced
    if (entities.length > 0) {
      await SyncMetadataService.markAsSynced(entities);
    }
  }
}

================
File: backend/src/routes/sync.ts
================
import { Router, Request, Response } from 'express';
import { asyncHandler } from '../common/middlewares/errorHandler';
import { apiKeyAuthMiddleware } from '../common/middlewares/apiKeyAuth.middleware';
import { UnifiedSyncService } from '../services/sync/UnifiedSyncService';
import logger from '../common/utils/logger';

const router = Router();

// Sync restaurant data from local system (PUSH method)
router.post('/push-restaurant-data', apiKeyAuthMiddleware, asyncHandler(async (req: Request, res: Response) => {
  try {
    // Log detailed information about received data
    logger.info('Restaurant data push received', {
      hasMenu: !!req.body.menu,
      hasConfig: !!req.body.config,
      menuCategories: req.body.menu?.categories?.length || 0,
      configKeys: req.body.config ? Object.keys(req.body.config) : [],
      requestBodyKeys: Object.keys(req.body),
      // Log first category and product as sample
      sampleCategory: req.body.menu?.categories?.[0] ? {
        name: req.body.menu.categories[0].name,
        productsCount: req.body.menu.categories[0].products?.length || 0
      } : null,
      sampleProduct: req.body.menu?.categories?.[0]?.products?.[0] ? {
        name: req.body.menu.categories[0].products[0].name,
        price: req.body.menu.categories[0].products[0].price
      } : null
    });
    
    // Process the restaurant data
    const wasUpdated = await UnifiedSyncService.processRestaurantDataPush(req.body);
    
    res.json({
      success: true,
      updated: wasUpdated,
      message: wasUpdated ? 'Restaurant data synchronized successfully' : 'No changes detected',
      timestamp: new Date().toISOString()
    });
  } catch (error: any) {
    logger.error('Restaurant data push error:', error);
    
    res.status(500).json({
      error: {
        code: 'SYNC_ERROR',
        message: error.message,
        details: {}
      }
    });
  }
}));

// Unified sync endpoint - Pull pending changes and confirm processed ones
router.post('/pull-changes', apiKeyAuthMiddleware, asyncHandler(async (req: Request, res: Response) => {
  try {
    logger.info('Pull changes request received', { 
      body: req.body,
      headers: req.headers 
    });
    
    // Extract confirmations from request body
    const { confirmedOrders = [], confirmedCustomerIds = [] } = req.body;
    
    logger.info('Processing confirmations', { 
      confirmedOrdersCount: confirmedOrders.length,
      confirmedCustomerIdsCount: confirmedCustomerIds.length 
    });
    
    // Process confirmations if any
    if (confirmedOrders.length > 0 || confirmedCustomerIds.length > 0) {
      await UnifiedSyncService.confirmSyncedItems(confirmedOrders, confirmedCustomerIds);
      logger.info('Confirmations processed successfully');
    }
    
    // Get pending changes (excluding confirmed ones)
    logger.info('Fetching pending changes...');
    const changes = await UnifiedSyncService.pullChanges();
    
    logger.info('Pull changes response', {
      ordersCount: changes.pending_orders?.length || 0,
      customersCount: changes.updated_customers?.length || 0
    });
    
    res.json(changes);
  } catch (error: any) {
    logger.error('Unified sync error:', {
      error: error.message,
      stack: error.stack,
      name: error.name
    });
    res.status(500).json({
      error: {
        code: 'SYNC_ERROR',
        message: error.message,
        details: {}
      }
    });
  }
}));


// Legacy endpoints - kept for backward compatibility
// NOTE: These endpoints are deprecated. Use POST /sync-restaurant-data instead

router.get('/status', asyncHandler(async (_req: Request, res: Response) => {
  res.json({
    success: true,
    status: 'healthy',
    timestamp: new Date()
  });
}));

export default router;

================
File: backend/src/services/orders/PreOrderWorkflowService.ts
================
import { randomUUID } from 'crypto';
import { prisma } from '../../lib/prisma';
import { redisService } from '../redis/RedisService';
import { PreOrderService } from './PreOrderService';
import { OrderManagementService } from './services/OrderManagementService';
import { sendWhatsAppMessage, WhatsAppService } from '../whatsapp';
import { generateOrderSummary } from '../../whatsapp/handlers/orders/orderFormatters';
import { BusinessLogicError, ErrorCode, ValidationError } from '../../common/services/errors';
import { redisKeys, REDIS_KEYS } from '../../common/constants';
import logger from '../../common/utils/logger';
import { SyncMetadataService } from '../sync/SyncMetadataService';
import {
  ProcessedOrderData,
  PreOrderWorkflowResult,
  PreOrderActionParams,
  TokenValidationResult
} from '../../common/types/preorder.types';

export class PreOrderWorkflowService {
  private static readonly TOKEN_TTL_SECONDS = 600; // 10 minutes
  private static readonly PREORDER_EXPIRY_MINUTES = 10; // Same as token TTL
  
  static async createAndNotify(params: {
    orderData: ProcessedOrderData;
    customerId: string;
    whatsappNumber: string;
  }): Promise<PreOrderWorkflowResult> {
    try {
      logger.info('Creating preorder with workflow', { 
        customerId: params.customerId,
        orderType: params.orderData.orderType 
      });
      
        if (!params.orderData.orderItems || params.orderData.orderItems.length === 0) {
        throw new ValidationError(
          ErrorCode.MISSING_REQUIRED_FIELD,
          'No se puede crear una orden sin productos',
          {
            metadata: {
              validationFailure: 'EMPTY_ORDER',
              message: 'Debes agregar al menos un producto a tu pedido'
            }
          }
        );
      }
      
      await this.cleanupExpiredPreOrders();
      
      await this.discardActivePreOrders(params.whatsappNumber);
      
      const preOrderService = new PreOrderService();
      const preOrderResult = await preOrderService.createPreOrder({
        orderItems: params.orderData.orderItems,
        orderType: params.orderData.orderType,
        scheduledAt: params.orderData.scheduledAt || undefined,
        whatsappPhoneNumber: params.whatsappNumber,
        deliveryInfo: params.orderData.deliveryInfo,
      });
      
      const actionToken = await this.generateActionToken(preOrderResult.preOrderId);
      const expiresAt = new Date(Date.now() + this.TOKEN_TTL_SECONDS * 1000);
      
      await this.sendOrderSummaryWithButtons(
        params.whatsappNumber, 
        preOrderResult,
        actionToken
      );
      
      await this.updateChatHistoryWithPreOrder(params.whatsappNumber, preOrderResult);
      
      logger.info('PreOrder workflow completed', { 
        preOrderId: preOrderResult.preOrderId,
        token: actionToken.substring(0, 8) + '...' 
      });
      
      return { 
        preOrderId: preOrderResult.preOrderId, 
        actionToken,
        expiresAt 
      };
    } catch (error) {
      logger.error('Error in preorder workflow', error);
      throw error;
    }
  }
  
  static async processAction(params: PreOrderActionParams): Promise<void> {
    logger.info('Processing preorder action', { 
      action: params.action,
      token: params.token.substring(0, 8) + '...' 
    });
    
    const validation = await this.validateActionToken(params.token);
    if (!validation.isValid || !validation.preOrderId) {
      // Don't send messages here - let the error handler do it
      // The error will be caught and handled by the WhatsApp handler
      throw new BusinessLogicError(
        ErrorCode.INVALID_TOKEN,
        validation.error || 'Token inv√°lido o expirado'
      );
    }
    
    if (params.action === 'confirm') {
      await this.confirmPreOrder(validation.preOrderId, params.whatsappNumber);
    } else {
      // Use the method that includes user interaction
      await this.discardPreOrderAndResetConversation(validation.preOrderId, params.whatsappNumber);
    }
    
    await this.deleteActionToken(params.token);
  }
  
  private static async generateActionToken(preOrderId: number): Promise<string> {
    const token = randomUUID();
    const key = redisKeys.preorderToken(token);
    
    await redisService.set(key, preOrderId.toString(), this.TOKEN_TTL_SECONDS);
    
    logger.debug('Generated action token', { 
      preOrderId, 
      token: token.substring(0, 8) + '...' 
    });
    
    return token;
  }
  
  private static async validateActionToken(token: string): Promise<TokenValidationResult> {
    const key = redisKeys.preorderToken(token);
    
    try {
      const preOrderIdStr = await redisService.get(key);
      
      if (!preOrderIdStr) {
        return { 
          isValid: false, 
          error: 'Token no encontrado o expirado' 
        };
      }
      
      const preOrderId = parseInt(preOrderIdStr, 10);
      
      const preOrder = await prisma.preOrder.findUnique({
        where: { id: preOrderId }
      });
      
      if (!preOrder) {
        return { 
          isValid: false, 
          error: 'Esta preorden ya no est√° disponible. Por favor, realiza un nuevo pedido.' 
        };
      }
      
      return { 
        isValid: true, 
        preOrderId 
      };
      
    } catch (error) {
      logger.error('Error validating token', error);
      return { 
        isValid: false, 
        error: 'Error al validar token' 
      };
    }
  }
  
  private static async deleteActionToken(token: string): Promise<void> {
    const key = redisKeys.preorderToken(token);
    await redisService.del(key);
  }
  
  static async sendOrderSummaryWithButtons(
    whatsappNumber: string, 
    preOrderResult: any,
    token: string
  ): Promise<void> {
    let orderSummary = generateOrderSummary(preOrderResult);
    
    // WhatsApp button messages have a 1024 character limit for the body
    const MAX_BODY_LENGTH = 1000; // Leave some margin
    if (orderSummary.length > MAX_BODY_LENGTH) {
      // Truncate and add indication that the message was truncated
      orderSummary = orderSummary.substring(0, MAX_BODY_LENGTH - 20) + '\n\n[...]';
      logger.warn(`Order summary truncated from ${orderSummary.length} to ${MAX_BODY_LENGTH} characters`);
    }
    
    // Build buttons array
    const buttons = [
      {
        type: "reply",
        reply: {
          id: `preorder_confirm:${token}`,
          title: "‚úÖ Confirmar"
        }
      }
    ];
    
    // Add change address button only for delivery orders
    if (preOrderResult.orderType === 'DELIVERY') {
      buttons.push({
        type: "reply",
        reply: {
          id: `preorder_change_address:${token}`,
          title: "üìç Cambiar direcci√≥n"
        }
      });
    }
    
    buttons.push({
      type: "reply",
      reply: {
        id: `preorder_discard:${token}`,
        title: "‚ùå Cancelar"
      }
    });
    
    const message = {
      type: "button",
      body: {
        text: orderSummary
      },
      action: {
        buttons: buttons
      }
    };
    
    await WhatsAppService.sendInteractiveMessage(
      whatsappNumber, 
      message
    );
  }
  
  /**
   * Creates a sanitized version of the order summary for chat history
   * Removes sensitive information like prices
   */
  private static createHistoryMarker(preOrderResult: any): string {
    const orderType = preOrderResult.orderType === 'DELIVERY' ? 'entrega a domicilio' : 'recolecci√≥n';
    
    let historyMessage = `üìã Resumen de pedido (${orderType}):\n`;
    
    // Agregar lista de productos sin precios
    if (preOrderResult.items && preOrderResult.items.length > 0) {
      historyMessage += 'Productos ordenados:\n';
      preOrderResult.items.forEach((item: any) => {
        const productName = item.product?.name || 'Producto';
        const variantName = item.productVariant?.name || '';
        const displayName = variantName || productName;
        const quantity = item.quantity || 1;
        
        historyMessage += `‚Ä¢ ${quantity}x ${displayName}`;
        
        // Agregar modificadores sin precios
        if (item.modifiers && item.modifiers.length > 0) {
          const modifierNames = item.modifiers.map((mod: any) => mod.name).join(', ');
          historyMessage += ` (${modifierNames})`;
        }
        
        // Agregar personalizaciones de pizza
        if (item.pizzaCustomizations && item.pizzaCustomizations.length > 0) {
          const customNames = item.pizzaCustomizations
            .filter((cust: any) => cust.action === 'ADD')
            .map((cust: any) => cust.name)
            .join(', ');
          if (customNames) {
            historyMessage += ` - ${customNames}`;
          }
        }
        
        historyMessage += '\n';
      });
    }
    
    return historyMessage.trim();
  }
  
  /**
   * Updates chat history with preorder information
   */
  private static async updateChatHistoryWithPreOrder(
    whatsappNumber: string, 
    preOrderResult: any
  ): Promise<void> {
    try {
      const customer = await prisma.customer.findUnique({
        where: { whatsappPhoneNumber: whatsappNumber }
      });
      
      if (!customer) {
        logger.warn('Customer not found for chat history update');
        return;
      }
      
      // Obtener historial actual - manejar tanto string como array
      let fullChatHistory = [];
      let relevantChatHistory = [];
      
      try {
        if (customer.fullChatHistory) {
          fullChatHistory = typeof customer.fullChatHistory === 'string' 
            ? JSON.parse(customer.fullChatHistory) 
            : customer.fullChatHistory;
        }
        if (customer.relevantChatHistory) {
          relevantChatHistory = typeof customer.relevantChatHistory === 'string'
            ? JSON.parse(customer.relevantChatHistory)
            : customer.relevantChatHistory;
        }
      } catch (parseError) {
        logger.warn('Error parsing chat history, using empty arrays', parseError);
        fullChatHistory = [];
        relevantChatHistory = [];
      }
      
      const historyMarker = this.createHistoryMarker(preOrderResult);
      
      const fullMessage = generateOrderSummary(preOrderResult);
      fullChatHistory.push({
        role: 'assistant',
        content: fullMessage,
        timestamp: new Date()
      });
      
      relevantChatHistory.push({
        role: 'assistant',
        content: historyMarker,
        timestamp: new Date()
      });
      
      // Limitar historial relevante a 20 mensajes
      const limitedRelevantHistory = relevantChatHistory.slice(-20);
      
      await prisma.customer.update({
        where: { id: customer.id },
        data: {
          fullChatHistory: JSON.stringify(fullChatHistory),
          relevantChatHistory: JSON.stringify(limitedRelevantHistory),
          lastInteraction: new Date()
        }
      });
      
      await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
      
      logger.info('Chat history updated with preorder information');
    } catch (error) {
      logger.error('Error updating chat history with preorder:', error);
      // No lanzar error para no interrumpir el flujo de preorden
    }
  }
  
  private static async confirmPreOrder(
    preOrderId: number, 
    whatsappNumber: string
  ): Promise<void> {
    logger.info('Confirming preorder', { preOrderId });
    
    const orderManagementService = new OrderManagementService();
    
    const order = await orderManagementService.confirmPreOrder(preOrderId);
    
    logger.info('Order created successfully', { 
      orderId: order.id,
      shiftOrderNumber: order.shiftOrderNumber 
    });
    
    // Clear relevant chat history after confirming order
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: whatsappNumber }
    });
    
    if (customer) {
      await prisma.customer.update({
        where: { id: customer.id },
        data: {
          relevantChatHistory: [],
          updatedAt: new Date()
        }
      });
      logger.info(`Cleared relevant chat history for customer ${customer.id} after order confirmation`);
      
      // Mark for sync
      await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
    }
    
    await orderManagementService.sendOrderConfirmation(whatsappNumber, order.id, 'confirmed');
  }
  
  /**
   * Discards a preorder and resets the conversation for the user
   * This includes clearing chat history and sending a notification
   */
  private static async discardPreOrderAndResetConversation(
    preOrderId: number, 
    whatsappNumber: string
  ): Promise<void> {
    logger.info('Discarding preorder and resetting conversation', { preOrderId });
    
    // 1. Discard the preorder data
    await this.discardPreOrderData(preOrderId);
    
    // 2. Clear chat history
    await this.clearCustomerChatHistory(whatsappNumber);
    
    // 3. Send reset notification to user
    await this.sendDiscardNotification(whatsappNumber);
  }
  
  /**
   * Only discards the preorder data without any side effects
   * Useful for silent cleanup operations
   */
  private static async discardPreOrderData(preOrderId: number): Promise<void> {
    logger.info('Discarding preorder data', { preOrderId });
    
    const orderManagementService = new OrderManagementService();
    await orderManagementService.discardPreOrder(preOrderId);
  }
  
  /**
   * Clears the customer's chat history
   */
  private static async clearCustomerChatHistory(whatsappNumber: string): Promise<void> {
    const customer = await prisma.customer.findUnique({
      where: { whatsappPhoneNumber: whatsappNumber }
    });
    
    if (customer) {
      await prisma.customer.update({
        where: { id: customer.id },
        data: {
          relevantChatHistory: [],
          updatedAt: new Date()
        }
      });
      logger.info(`Cleared relevant chat history for customer ${customer.id}`);
    }
  }
  
  /**
   * Sends a notification message after discarding a preorder
   */
  private static async sendDiscardNotification(whatsappNumber: string): Promise<void> {
    await sendWhatsAppMessage(
      whatsappNumber,
      "‚ùå Tu pedido ha sido descartado y tu historial de conversaci√≥n ha sido reiniciado.\n\n" +
      "üçï Puedes comenzar un nuevo pedido desde cero cuando gustes.\n\n" +
      "üí° *Tip:* Para hacer un pedido, simplemente escribe lo que deseas ordenar e indica si es para entrega a domicilio o recolecci√≥n en el restaurante."
    );
  }
  
  private static async discardActivePreOrders(whatsappNumber: string): Promise<void> {
    try {
      const activePreOrders = await prisma.preOrder.findMany({
        where: { whatsappPhoneNumber: whatsappNumber }
      });
      
      if (activePreOrders.length === 0) {
        return;
      }
      
      logger.info(`Found ${activePreOrders.length} active preorders for ${whatsappNumber}. Discarding them.`);
      
      const tokenKeys = await redisService.keys(`${REDIS_KEYS.PREORDER_TOKEN_PREFIX}*`);
      for (const key of tokenKeys) {
        const preOrderIdStr = await redisService.get(key);
        if (preOrderIdStr) {
          const preOrderId = parseInt(preOrderIdStr, 10);
          if (activePreOrders.some(po => po.id === preOrderId)) {
            await redisService.del(key);
            logger.debug(`Deleted token for preorder ${preOrderId}`);
          }
        }
      }
      
      await prisma.preOrder.deleteMany({
        where: { whatsappPhoneNumber: whatsappNumber }
      });
      
      logger.info(`Discarded ${activePreOrders.length} preorders for ${whatsappNumber}`);
    } catch (error) {
      logger.error('Error discarding active preorders', error);
      // Don't throw - this shouldn't prevent creating a new preorder
    }
  }
  
  static async cleanupExpiredPreOrders(): Promise<void> {
    try {
      const expiryDate = new Date();
      expiryDate.setMinutes(expiryDate.getMinutes() - this.PREORDER_EXPIRY_MINUTES);
      
      const expiredPreOrders = await prisma.preOrder.findMany({
        where: {
          createdAt: {
            lt: expiryDate
          }
        }
      });
      
      if (expiredPreOrders.length === 0) {
        return;
      }
      
      logger.info(`Found ${expiredPreOrders.length} expired preorders to clean up`);
      
      const tokenKeys = await redisService.keys(`${REDIS_KEYS.PREORDER_TOKEN_PREFIX}*`);
      for (const key of tokenKeys) {
        const preOrderIdStr = await redisService.get(key);
        if (preOrderIdStr) {
          const preOrderId = parseInt(preOrderIdStr, 10);
          if (expiredPreOrders.some(po => po.id === preOrderId)) {
            await redisService.del(key);
            logger.debug(`Deleted expired token for preorder ${preOrderId}`);
          }
        }
      }
      
      const result = await prisma.preOrder.deleteMany({
        where: {
          createdAt: {
            lt: expiryDate
          }
        }
      });
      
      logger.info(`Cleaned up ${result.count} expired preorders`);
    } catch (error) {
      logger.error('Error cleaning up expired preorders', error);
    }
  }
  
  /**
   * Recreate preOrder with new address
   * This is used when customer changes address during preorder flow
   */
  static async recreatePreOrderWithNewAddress(params: {
    oldPreOrderId: number;
    newAddressId: string;
    whatsappNumber: string;
  }): Promise<PreOrderWorkflowResult> {
    try {
      // Get the old preOrder with all details
      const oldPreOrder = await prisma.preOrder.findUnique({
        where: { id: params.oldPreOrderId },
        include: {
          orderItems: {
            include: {
              product: true,
              productVariant: true,
              productModifiers: true,
              selectedPizzaCustomizations: {
                include: {
                  pizzaCustomization: true
                }
              }
            }
          }
        }
      });
      
      if (!oldPreOrder) {
        throw new BusinessLogicError(
          ErrorCode.ORDER_NOT_FOUND,
          'PreOrder not found',
          { metadata: { preOrderId: params.oldPreOrderId } }
        );
      }
      
      // Get the new address
      const newAddress = await prisma.address.findUnique({
        where: { id: params.newAddressId },
        include: { customer: true }
      });
      
      if (!newAddress) {
        throw new BusinessLogicError(
          ErrorCode.ADDRESS_NOT_FOUND,
          'Address not found',
          { metadata: { addressId: params.newAddressId } }
        );
      }
      
      // Prepare order data from old preOrder
      const orderData: ProcessedOrderData = {
        orderItems: oldPreOrder.orderItems.map(item => ({
          productId: item.productId,
          productVariantId: item.productVariantId || undefined,
          quantity: 1,
          selectedModifiers: item.productModifiers.map(m => m.id),
          selectedPizzaCustomizations: item.selectedPizzaCustomizations.map(pc => ({
            pizzaCustomizationId: pc.pizzaCustomizationId,
            half: pc.half,
            action: pc.action
          }))
        })),
        orderType: oldPreOrder.orderType as 'DELIVERY' | 'TAKE_AWAY',
        scheduledAt: oldPreOrder.scheduledAt || undefined,
        deliveryInfo: {
          name: newAddress.name,
          street: newAddress.street,
          number: newAddress.number,
          interiorNumber: newAddress.interiorNumber,
          neighborhood: newAddress.neighborhood,
          city: newAddress.city,
          state: newAddress.state,
          zipCode: newAddress.zipCode,
          country: newAddress.country,
          deliveryInstructions: newAddress.deliveryInstructions,
          latitude: newAddress.latitude?.toNumber() || null,
          longitude: newAddress.longitude?.toNumber() || null
        }
      };
      
      // Mark that we're updating a preOrder to prevent welcome message
      const updateKey = redisKeys.preorderUpdating(params.whatsappNumber);
      await redisService.set(updateKey, 'true', 60); // 60 seconds TTL
      
      // Discard the old preOrder
      await this.discardPreOrderData(params.oldPreOrderId);
      
      // Delete old token
      const tokenKeys = await redisService.keys(`${REDIS_KEYS.PREORDER_TOKEN_PREFIX}*`);
      for (const key of tokenKeys) {
        const storedPreOrderId = await redisService.get(key);
        if (storedPreOrderId === params.oldPreOrderId.toString()) {
          await redisService.del(key);
          break;
        }
      }
      
      // Create new preOrder with new address
      const result = await this.createAndNotify({
        orderData,
        customerId: newAddress.customerId,
        whatsappNumber: params.whatsappNumber
      });
      
      // Clean up the update flag
      await redisService.del(updateKey);
      
      return result;
    } catch (error) {
      logger.error('Error recreating preOrder with new address', error);
      throw error;
    }
  }
}

================
File: backend/src/services/products/ProductService.ts
================
import { prisma } from '../../lib/prisma';
import { Product, Category, ProductVariant } from '@prisma/client';
import logger from '../../common/utils/logger';
import { NotFoundError, ErrorCode } from '../../common/services/errors';

/**
 * Service for managing products and menu
 */
export class ProductService {
  /**
   * Get all active products with their relations
   */
  static async getActiveProducts(includeRelations = true): Promise<Product[]> {
    try {
      const products = await prisma.product.findMany({
        where: { isActive: true },
        orderBy: { sortOrder: 'asc' },
        include: includeRelations ? {
          subcategory: {
            include: {
              category: true
            }
          },
          variants: {
            where: { isActive: true },
            orderBy: { sortOrder: 'asc' }
          },
          modifierGroups: {
            orderBy: { sortOrder: 'asc' },
            include: {
              productModifiers: {
                where: { isActive: true },
                orderBy: { sortOrder: 'asc' }
              }
            }
          },
          pizzaCustomizations: {
            where: { isActive: true },
            orderBy: { sortOrder: 'asc' }
          },
          pizzaConfiguration: true
        } : undefined
      });

      return products;
    } catch (error) {
      logger.error('Error fetching active products:', error);
      throw error;
    }
  }
  
  /**
   * Get formatted menu for WhatsApp
   */
  static async getMenuForWhatsApp(): Promise<string> {
    try {
      const products = await this.getActiveProducts();
      
      // Get restaurant name
      let restaurantName = "Nuestro Restaurante";
      try {
        const { RestaurantService } = await import('../restaurant/RestaurantService');
        const config = await RestaurantService.getConfig();
        restaurantName = config.restaurantName;
      } catch (error) {
        // Use default name
      }
      
      return this.formatMenuForWhatsApp(products, restaurantName);
    } catch (error) {
      logger.error('Error getting menu for WhatsApp:', error);
      throw error;
    }
  }

  /**
   * Format menu for WhatsApp - Improved formatting with better readability
   */
  private static formatMenuForWhatsApp(products: any[], restaurantName: string = "Nuestro Restaurante"): string {
    const menuLines: string[] = [];

    // Header
    menuLines.push(`*üçΩÔ∏è MEN√ö ${restaurantName.toUpperCase()} üçΩÔ∏è*`);
    menuLines.push("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");

    // Agrupar por categor√≠a con sortOrder
    const productsByCategory = products.reduce((acc, product) => {
      const category = product.subcategory?.category;
      const categoryName = category?.name || 'Sin categor√≠a';
      const categorySortOrder = category?.sortOrder || 999;
      
      if (!acc[categoryName]) {
        acc[categoryName] = {
          sortOrder: categorySortOrder,
          products: []
        };
      }
      acc[categoryName].products.push(product);
      return acc;
    }, {} as Record<string, { sortOrder: number; products: any[] }>);

    // Ordenar categor√≠as por sortOrder
    const sortedCategories = Object.entries(productsByCategory)
      .sort(([, a], [, b]) => (a as any).sortOrder - (b as any).sortOrder);

    // Formatear por categor√≠a
    for (const [category, data] of sortedCategories) {
      menuLines.push(`\n*‚óÜ ${category.toUpperCase()} ‚óÜ*`);
      
      // Productos ya vienen ordenados por sortOrder desde la consulta
      (data as any).products.forEach((product: any, index: number) => {
        // Agregar separaci√≥n entre productos (excepto el primero)
        if (index > 0) {
          menuLines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        }
        
        // Nombre del producto con precio si no tiene variantes
        let productLine = `*${product.name}*`;
        if (!product.hasVariants && product.price) {
          productLine += ` ‚Üí \`$${product.price.toFixed(2)}\``;
        }
        menuLines.push(productLine);
        
        // Variantes con precios (ya ordenadas)
        if (product.variants?.length > 0 && product.hasVariants) {
          product.variants.forEach((variant: any) => {
            menuLines.push(` _${variant.name}_: \`$${variant.price.toFixed(2)}\``);
          });
        }
        
        // Para pizzas, mostrar sabores disponibles
        if (product.isPizza && product.pizzaCustomizations?.length > 0) {
          const flavors = product.pizzaCustomizations.filter((c: any) => c.type === 'FLAVOR');
          if (flavors.length > 0) {
            menuLines.push(` _‚óá Sabores:_`);
            
            // Obtener configuraci√≥n de pizza
            const pizzaConfig = product.pizzaConfiguration;
            const includedToppings = pizzaConfig?.includedToppings || 4;
            const extraToppingCost = pizzaConfig?.extraToppingCost || 20;
            
            flavors.forEach((flavor: any) => {
              let flavorLine = `  ‚Ä¢ ${flavor.name}`;
              
              // Agregar ingredientes si existen
              if (flavor.ingredients) {
                flavorLine += ` _(${flavor.ingredients})_`;
              }
              
              // Calcular precio extra si el sabor excede los toppings incluidos
              if (flavor.toppingValue > includedToppings) {
                const extraToppings = flavor.toppingValue - includedToppings;
                const extraCost = extraToppings * extraToppingCost;
                flavorLine += ` \`+$${extraCost.toFixed(2)}\``;
              }
              
              menuLines.push(flavorLine);
            });
            
            menuLines.push(` _‚óá M√°x. 2 mitades_`);
          }
        }
        
        // Mostrar todos los modificadores agrupados
        if (product.modifierGroups?.length > 0) {
          product.modifierGroups.forEach((group: any) => {
            const activeModifiers = group.productModifiers?.filter((m: any) => m.isActive) || [];
            if (activeModifiers.length > 0) {
              menuLines.push(` _‚óá ${group.name}:_`);
              
              activeModifiers.forEach((modifier: any) => {
                // Solo agregar precio si es mayor a 0
                if (modifier.price && modifier.price > 0) {
                  menuLines.push(`  ‚Ä¢ ${modifier.name} \`+$${modifier.price.toFixed(2)}\``);
                } else {
                  menuLines.push(`  ‚Ä¢ ${modifier.name}`);
                }
              });
            }
          });
        }
      });
    }

    // Footer
    menuLines.push("\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
    menuLines.push("_üì± Para ordenar: menciona el producto completo con variante, extras y comentarios_");

    return menuLines.join('\n');
  }


  /**
   * Get all active categories
   */
  static async getActiveCategories(): Promise<Category[]> {
    try {
      return await prisma.category.findMany({
        where: { isActive: true },
        include: {
          subcategories: {
            where: { isActive: true }
          }
        }
      });
    } catch (error) {
      logger.error('Error fetching active categories:', error);
      throw error;
    }
  }

  /**
   * Get product by ID
   */
  static async getProductById(productId: string): Promise<Product | null> {
    try {
      return await prisma.product.findUnique({
        where: { id: productId },
        include: {
          variants: true,
          modifierGroups: {
            include: {
              productModifiers: true
            }
          },
          pizzaCustomizations: true,
          pizzaConfiguration: true
        }
      });
    } catch (error) {
      logger.error('Error fetching product by ID:', error);
      throw error;
    }
  }

  /**
   * Get variant by ID
   */
  static async getVariantById(variantId: string): Promise<ProductVariant | null> {
    try {
      return await prisma.productVariant.findUnique({
        where: { id: variantId },
        include: {
          product: true
        }
      });
    } catch (error) {
      logger.error('Error fetching variant by ID:', error);
      throw error;
    }
  }

  /**
   * Toggle product availability
   */
  static async toggleProductAvailability(productId: string, isActive: boolean): Promise<Product> {
    try {
      const product = await prisma.product.update({
        where: { id: productId },
        data: { isActive }
      });

      logger.info(`Product ${productId} availability set to ${isActive}`);
      return product;
    } catch (error) {
      logger.error('Error toggling product availability:', error);
      throw new NotFoundError(
        ErrorCode.INVALID_PRODUCT,
        'Product not found',
        { metadata: { productId } }
      );
    }
  }

  /**
   * Toggle variant availability
   */
  static async toggleVariantAvailability(variantId: string, isActive: boolean): Promise<ProductVariant> {
    try {
      const variant = await prisma.productVariant.update({
        where: { id: variantId },
        data: { isActive }
      });

      logger.info(`Variant ${variantId} availability set to ${isActive}`);
      return variant;
    } catch (error) {
      logger.error('Error toggling variant availability:', error);
      throw new NotFoundError(
        ErrorCode.INVALID_PRODUCT,
        'Product variant not found',
        { metadata: { variantId } }
      );
    }
  }

  /**
   * Get menu structure for AI context (without IDs or prices)
   */
  static async getMenuStructureForAI(): Promise<any> {
    try {
      const products = await prisma.product.findMany({
        where: { isActive: true },
        include: {
          subcategory: {
            include: {
              category: true
            }
          },
          variants: {
            where: { isActive: true },
            orderBy: { sortOrder: 'asc' }
          },
          modifierGroups: {
            orderBy: { sortOrder: 'asc' },
            include: {
              productModifiers: {
                where: { isActive: true },
                orderBy: { sortOrder: 'asc' }
              }
            }
          },
          pizzaCustomizations: {
            where: { isActive: true },
            orderBy: { sortOrder: 'asc' }
          },
          pizzaConfiguration: true
        },
        orderBy: { sortOrder: 'asc' }
      });

      // Agrupar por categor√≠as
      const menuStructure: Record<string, any> = {};

      for (const product of products) {
        const categoryName = product.subcategory.category.name;
        const subcategoryName = product.subcategory.name;

        // Crear estructura de categor√≠a si no existe
        if (!menuStructure[categoryName]) {
          menuStructure[categoryName] = {};
        }

        // Crear estructura de subcategor√≠a si no existe
        if (!menuStructure[categoryName][subcategoryName]) {
          menuStructure[categoryName][subcategoryName] = [];
        }

        // Crear estructura del producto
        const productStructure: any = {
          nombre: product.name,
          descripcion: product.description
        };

        // Agregar variantes si existen
        if (product.variants.length > 0) {
          productStructure.variantes = product.variants.map(v => v.name);
        }

        // Agregar modificadores si existen
        if (product.modifierGroups.length > 0) {
          productStructure.modificadores = {};
          
          for (const group of product.modifierGroups) {
            if (group.productModifiers.length > 0) {
              productStructure.modificadores[group.name] = group.productModifiers.map(m => m.name);
            }
          }
        }

        // Agregar personalizaciones de pizza si es una pizza
        if (product.isPizza && product.pizzaCustomizations.length > 0) {
          const flavors = product.pizzaCustomizations.filter((c: any) => c.type === 'FLAVOR');
          const ingredients = product.pizzaCustomizations.filter((c: any) => c.type === 'INGREDIENT');
          
          productStructure.personalizacionesPizza = {
            sabores: flavors.map(f => f.name),
            ingredientes: ingredients.map(i => i.name)
          };
        }

        menuStructure[categoryName][subcategoryName].push(productStructure);
      }

      return menuStructure;
    } catch (error) {
      logger.error('Error getting menu structure for AI:', error);
      throw error;
    }
  }

}

================
File: backend/src/routes/address-registration.ts
================
import { Router, Request, Response } from 'express';
import { OTPService } from '../services/security/OTPService';
import { DeliveryInfoService } from '../services/orders/services/DeliveryInfoService';
import { prisma } from '../lib/prisma';
import logger from '../common/utils/logger';
import { asyncHandler } from '../common/middlewares/errorHandler';
import { ValidationError, NotFoundError, ErrorCode } from '../common/services/errors';
import { validationMiddleware, queryValidationMiddleware } from '../common/middlewares/validation.middleware';
import { otpAuthMiddleware, AuthenticatedRequest } from '../common/middlewares/otp.middleware';
import { SyncMetadataService } from '../services/sync/SyncMetadataService';
import {
  VerifyOtpDto
} from '../dto/auth';
import {
  CreateAddressDto,
  UpdateAddressDto,
  GetAddressesQueryDto,
  DeleteAddressDto,
  SetDefaultAddressDto
} from '../dto/address';
import {
  UpdateCustomerNameDto
} from '../dto/customer';
import { Address } from '@prisma/client';

const router = Router();

/**
 * Verificar OTP para registro de direcci√≥n
 * POST /backend/address-registration/verify-otp
 */
router.post('/verify-otp', 
  validationMiddleware(VerifyOtpDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { whatsappPhoneNumber, otp } = req.body as VerifyOtpDto;
  
  const isValid = await OTPService.verifyOTP(whatsappPhoneNumber, otp);
  
  if (!isValid) {
    throw new ValidationError(
      ErrorCode.INVALID_OTP,
      'Invalid or expired OTP'
    );
  }
  
  // Obtener informaci√≥n del cliente
  const customer = await prisma.customer.findUnique({
    where: { whatsappPhoneNumber },
    select: {
      id: true,
      whatsappPhoneNumber: true,
      firstName: true,
      lastName: true,
      addresses: {
        where: { deletedAt: null },
        orderBy: { isDefault: 'desc' }
      }
    }
  });
  
  if (!customer) {
    throw new NotFoundError(
      ErrorCode.CUSTOMER_NOT_FOUND,
      'Customer not found',
      { whatsappPhoneNumber }
    );
  }
  
  res.json({ 
    valid: true,
    customer: {
      customerId: customer.whatsappPhoneNumber,
      firstName: customer.firstName,
      lastName: customer.lastName,
      hasAddresses: customer.addresses.length > 0,
      addresses: customer.addresses
    }
  });
}));


/**
 * Crear nueva direcci√≥n para el cliente
 * POST /backend/address-registration/create
 */
router.post('/create',
  validationMiddleware(CreateAddressDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const { address } = req.body as CreateAddressDto;
    const customer = req.customer; // Customer already validated by middleware
    
    // Crear direcci√≥n
    const addressData = {
      ...address,
      customer: { connect: { id: customer.id } }
    };
    
    const newAddress = await DeliveryInfoService.createCustomerAddress(addressData);
    
    // Mark customer for sync since addresses are part of customer data
    await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
    
    // Si viene de un preOrder, actualizar la direcci√≥n del preOrder
    const preOrderId = req.query.preOrderId || req.body.preOrderId;
    if (preOrderId) {
      await updatePreOrderWithAddress(parseInt(preOrderId as string), newAddress);
    }
    
    // Enviar mensaje de confirmaci√≥n a WhatsApp
    try {
      const { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } = await import('../services/whatsapp');
      const { ADDRESS_REGISTRATION_SUCCESS, WELCOME_MESSAGE_INTERACTIVE } = await import('../common/config/predefinedMessages');
      const { ConfigService } = await import('../services/config/ConfigService');
      
      // Verificar si viene de un preOrder (el frontend lo pasa como query param)
      const isFromPreOrder = preOrderId;
      
      if (!isFromPreOrder) {
        // Solo enviar estos mensajes si NO es parte de un preorder
        await sendWhatsAppMessage(
          customer.whatsappPhoneNumber,
          ADDRESS_REGISTRATION_SUCCESS(newAddress)
        );
        
        // Peque√±o retraso para asegurar el orden correcto de mensajes
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Enviar mensaje de bienvenida
        const config = ConfigService.getConfig();
        const welcomeMessage = WELCOME_MESSAGE_INTERACTIVE(config);
        await sendWhatsAppInteractiveMessage(customer.whatsappPhoneNumber, welcomeMessage);
      }
      
      // Siempre actualizar lastInteraction
      await prisma.customer.update({
        where: { id: customer.id },
        data: { 
          lastInteraction: new Date()
        }
      });
      
    } catch (msgError) {
      logger.error('Error sending confirmation message:', msgError);
    }
    
    res.json({ 
      success: true,
      address: newAddress
    });
  })
);

/**
 * Actualizar nombre del cliente
 * PUT /backend/address-registration/update-customer-name
 */
router.put('/update-customer-name',
  validationMiddleware(UpdateCustomerNameDto),
  asyncHandler(async (req: Request, res: Response) => {
    const { whatsappPhoneNumber, otp, firstName, lastName } = req.body as UpdateCustomerNameDto;
    
    // Verificar OTP
    const isValid = await OTPService.verifyOTP(whatsappPhoneNumber, otp);
    
    if (!isValid) {
      throw new ValidationError(
        ErrorCode.INVALID_OTP,
        'Invalid or expired OTP'
      );
    }
    
    // Actualizar nombre del cliente
    const updatedCustomer = await prisma.customer.update({
      where: { whatsappPhoneNumber },
      data: {
        firstName: firstName.trim(),
        lastName: lastName.trim()
      },
      select: {
        id: true,
        whatsappPhoneNumber: true,
        firstName: true,
        lastName: true,
        email: true,
        addresses: {
          where: { deletedAt: null },
          orderBy: { isDefault: 'desc' }
        }
      }
    });
    
    // Mark for sync
    await SyncMetadataService.markForSync('Customer', updatedCustomer.id, 'REMOTE');
    
    res.json({
      success: true,
      customer: updatedCustomer
    });
  })
);

/**
 * Actualizar direcci√≥n existente
 * PUT /backend/address-registration/:addressId
 */
router.put('/:addressId',
  validationMiddleware(UpdateAddressDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const { addressId } = req.params;
    const addressData = req.body as UpdateAddressDto;
    const customer = req.customer; // Customer already validated by middleware
    
    // Verificar que la direcci√≥n pertenece al cliente
    const existingAddress = await prisma.address.findFirst({
      where: { 
        id: addressId,
        customerId: customer.id
      }
    });
    
    if (!existingAddress) {
      throw new NotFoundError(
        ErrorCode.ADDRESS_NOT_FOUND,
        'Address not found or does not belong to customer',
        { addressId, customerId: customer.id }
      );
    }
    
    // Actualizar direcci√≥n
    const updatedAddress = await DeliveryInfoService.updateCustomerAddress(
      addressId,
      addressData
    );
    
    // Enviar notificaci√≥n de WhatsApp sobre actualizaci√≥n de direcci√≥n
    try {
      const { sendWhatsAppMessage, sendWhatsAppInteractiveMessage } = await import('../services/whatsapp');
      const { ADDRESS_UPDATE_SUCCESS, WELCOME_MESSAGE_INTERACTIVE } = await import('../common/config/predefinedMessages');
      const { ConfigService } = await import('../services/config/ConfigService');
      
      // Usar whatsappPhoneNumber del customer autenticado
      await sendWhatsAppMessage(
        customer.whatsappPhoneNumber,
        ADDRESS_UPDATE_SUCCESS(updatedAddress)
      );
      
      // Peque√±o retraso para asegurar el orden correcto de mensajes
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Enviar mensaje de bienvenida inmediatamente despu√©s
      const config = ConfigService.getConfig();
      const welcomeMessage = WELCOME_MESSAGE_INTERACTIVE(config);
      await sendWhatsAppInteractiveMessage(customer.whatsappPhoneNumber, welcomeMessage);
      
      // Marcar que hubo interacci√≥n para evitar mensaje de bienvenida duplicado
      await prisma.customer.update({
        where: { id: customer.id },
        data: { 
          lastInteraction: new Date()
        }
      });
      
      // Mark for sync
      await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
      
    } catch (sendError) {
      logger.error('Failed to send WhatsApp notification:', sendError);
      // Continuar aunque WhatsApp falle
    }
    
    res.json({ 
      success: true,
      address: updatedAddress
    });
  })
);

/**
 * Obtener direcciones del cliente
 * GET /backend/address-registration/:customerId/addresses
 */
router.get('/:customerId/addresses',
  queryValidationMiddleware(GetAddressesQueryDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const customer = req.customer; // Customer already validated by middleware
    
    const addresses = await DeliveryInfoService.getCustomerAddresses(customer.id);
    res.json({ addresses });
  })
);

/**
 * Eliminar direcci√≥n del cliente
 * DELETE /backend/address-registration/:addressId
 */
router.delete('/:addressId',
  validationMiddleware(DeleteAddressDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const { addressId } = req.params;
    const customer = req.customer; // Customer already validated by middleware
    
    // Eliminar direcci√≥n (eliminaci√≥n suave)
    await DeliveryInfoService.deleteCustomerAddress(
      addressId,
      customer.id
    );
    
    // Mark customer for sync since addresses are part of customer data
    await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
    
    res.json({ 
      success: true,
      message: 'Address deleted successfully'
    });
  })
);

/**
 * Establecer direcci√≥n como predeterminada
 * PUT /backend/address-registration/:addressId/default
 */
router.put('/:addressId/default',
  validationMiddleware(SetDefaultAddressDto),
  otpAuthMiddleware,
  asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    const { addressId } = req.params;
    const customer = req.customer; // Customer already validated by middleware
    
    // Establecer como predeterminada
    const updatedAddress = await DeliveryInfoService.setDefaultAddress(
      addressId,
      customer.id
    );
    
    // Mark customer for sync since addresses are part of customer data
    await SyncMetadataService.markForSync('Customer', customer.id, 'REMOTE');
    
    // Enviar notificaci√≥n de WhatsApp sobre cambio de direcci√≥n principal
    try {
      const { sendWhatsAppMessage } = await import('../services/whatsapp');
      const { DEFAULT_ADDRESS_CHANGED } = await import('../common/config/predefinedMessages');
      
      await sendWhatsAppMessage(
        customer.whatsappPhoneNumber, 
        DEFAULT_ADDRESS_CHANGED(updatedAddress)
      );
    } catch (msgError) {
      logger.error('Error sending default address notification:', msgError);
    }
    
    res.json({ 
      success: true,
      address: updatedAddress
    });
  })
);

/**
 * Obtener pol√≠gono del √°rea de entrega
 * GET /backend/address-registration/delivery-area
 */
router.get('/delivery-area', asyncHandler(async (_req: Request, res: Response) => {
    // Obtener configuraci√≥n del restaurante
    const restaurant = await prisma.restaurantConfig.findFirst({
      select: {
        deliveryCoverageArea: true
      }
    });

    if (!restaurant || !restaurant.deliveryCoverageArea) {
      res.json({ polygonCoords: [] });
      return;
    }

    // Devolver coordenadas del pol√≠gono
    res.json({ 
      polygonCoords: restaurant.deliveryCoverageArea
    });
  })
);


/**
 * Helper function to recreate preOrder with new address
 */
async function updatePreOrderWithAddress(preOrderId: number, address: Address): Promise<void> {
  const preOrder = await prisma.preOrder.findUnique({
    where: { id: preOrderId }
  });
  
  if (!preOrder) {
    return;
  }
  
  const { PreOrderWorkflowService } = await import('../services/orders/PreOrderWorkflowService');
  await PreOrderWorkflowService.recreatePreOrderWithNewAddress({
    oldPreOrderId: preOrderId,
    newAddressId: address.id,
    whatsappNumber: preOrder.whatsappPhoneNumber
  });
}

export default router;

================
File: .claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(node:*)",
      "Bash(find:*)",
      "Bash(rm:*)",
      "Bash(del cloudAuth.middleware.ts syncAuth.middleware.ts)",
      "Bash(mkdir:*)",
      "Bash(mv:*)",
      "Bash(cp:*)",
      "Bash(npx tsc:*)",
      "Bash(grep:*)",
      "Bash(true)",
      "Bash(npm install:*)",
      "Bash(npm run build:*)",
      "Bash(chmod:*)",
      "Bash(npx prisma migrate dev:*)",
      "Bash(npx prisma:*)",
      "Bash(start-dev.bat)",
      "Bash(cmd:*)",
      "Bash(curl:*)",
      "Bash(npm run dev:worker:*)",
      "Bash(copy .env.example .env)",
      "Bash(npm run migrate:dev:*)",
      "Bash(docker compose:*)",
      "Bash(npm run dev:*)",
      "Bash(npm ls:*)",
      "Bash(npm outdated)",
      "Bash(del update-prisma-imports.js)",
      "Bash(file:*)",
      "Bash(ls:*)",
      "Bash(cat:*)",
      "Bash(del nul)",
      "Bash(npm i:*)",
      "Bash(npm uninstall:*)",
      "Bash(npm run generate:*)",
      "Bash(sed:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git push:*)",
      "Bash(npm run lint)",
      "Bash(pm2 reload:*)",
      "Bash(git reset:*)",
      "Bash(git pull:*)",
      "Bash(git stash:*)",
      "Bash(npx ts-node:*)"
    ],
    "deny": []
  }
}

================
File: frontend-app/src/components/AddressRegistration.tsx
================
import { useEffect, useState, useCallback } from 'react';
import { useSearchParams } from 'react-router-dom';
import { useLoadScript } from '@react-google-maps/api';
import toast, { Toaster } from 'react-hot-toast';
import { AddressForm } from '@/components/AddressForm';
import { BasicMap as Map } from '@/components/BasicMap';
import { useAddressRegistrationStore } from '@/store/addressRegistrationStore';
import { 
  useVerifyOtp, 
  useCreateAddress, 
  useUpdateAddress, 
  useDeliveryArea,
  useUpdateCustomerName,
  useSetDefaultAddress 
} from '@/hooks/useAddressQueries';
import { CustomerNameForm } from '@/components/CustomerNameForm';
import type { AddressFormData, Address } from '@/types';
import { t } from '@/i18n';

const libraries: ('places' | 'geometry')[] = ['places', 'geometry'];

interface Location {
  lat: number;
  lng: number;
}

export function AddressRegistration() {
  const [searchParams] = useSearchParams();
  
  // Estado para controlar qu√© vista mostrar - MUST be before any conditional returns
  const [viewMode, setViewMode] = useState<'list' | 'form'>('list');
  const [isEditingCustomerName, setIsEditingCustomerName] = useState(false);
  const [isGettingLocation, setIsGettingLocation] = useState(false);
  const [showSuccessScreen, setShowSuccessScreen] = useState(false);
  const [showOTPErrorScreen, setShowOTPErrorScreen] = useState(false);
  
  // Get store state and actions
  const {
    customerId,
    otp,
    preOrderId,
    customer,
    formData,
    isValidating,
    isSaving,
    editingAddressId,
    setSession,
    setCustomer,
    setFormData,
    updateFormField,
    setValidating,
    setSaving,
    setError,
    setEditingAddressId,
    resetForm,
  } = useAddressRegistrationStore();

  // Initialize session from URL params
  useEffect(() => {
    // Clear old localStorage data with wrong field names
    const storedData = localStorage.getItem('address-registration-storage');
    if (storedData) {
      try {
        const parsed = JSON.parse(storedData);
        if (parsed.state?.formData?.references !== undefined) {
          localStorage.removeItem('address-registration-storage');
        }
      } catch (e) {
        // Ignore parse errors
      }
    }
    
    // Get customerId from URL path (e.g., /address-registration/5213320407035)
    const pathParts = window.location.pathname.split('/');
    const urlCustomerId = pathParts[pathParts.length - 1] || searchParams.get('from') || '';
    const urlOtp = searchParams.get('otp') || '';
    const urlPreOrderId = searchParams.get('preOrderId') || null;
    const urlViewMode = searchParams.get('viewMode');
    
    if (urlCustomerId && urlOtp) {
      setSession(urlCustomerId, urlOtp, urlPreOrderId || undefined);
    }
    
    // If viewMode=form is specified, go directly to form view with clean form
    if (urlViewMode === 'form') {
      setViewMode('form');
      resetForm();
      setEditingAddressId(null);
    }
  }, [searchParams, setSession]);

  // Google Maps
  const { isLoaded, loadError } = useLoadScript({
    googleMapsApiKey: import.meta.env.VITE_GOOGLE_MAPS_API_KEY,
    libraries,
  });

  // React Query hooks
  const { data: otpData, isLoading: isVerifying } = useVerifyOtp(
    customerId && otp ? { whatsappPhoneNumber: customerId, otp } : null
  );
  
  const { data: deliveryAreaData } = useDeliveryArea();
  const createAddressMutation = useCreateAddress();
  const updateAddressMutation = useUpdateAddress();
  const updateCustomerNameMutation = useUpdateCustomerName();
  const setDefaultAddressMutation = useSetDefaultAddress();

  const loadExistingAddress = useCallback((address: Address) => {
    setEditingAddressId(address.id.toString());
    
    const formattedData: AddressFormData = {
      name: address.name || '',
      street: address.street,
      number: address.number,
      interiorNumber: address.interiorNumber || '',
      neighborhood: address.neighborhood || '',
      zipCode: address.zipCode || '',
      city: address.city || '',
      state: address.state || '',
      country: address.country || '',
      deliveryInstructions: address.deliveryInstructions || '',
      latitude: Number(address.latitude),
      longitude: Number(address.longitude),
    };

    setFormData(formattedData);
  }, [setFormData, setEditingAddressId]);

  // Handle OTP verification response
  useEffect(() => {
    if (otpData) {
      if (otpData.valid && otpData.customer) {
        setCustomer(otpData.customer);
        setValidating(false);
        
        // If customer has addresses, load the default one ONLY if not creating new
        // Check if viewMode=form is in URL (which means user wants to create new)
        const urlViewMode = new URLSearchParams(window.location.search).get('viewMode');
        if (otpData.customer.addresses.length > 0 && urlViewMode !== 'form') {
          const defaultAddress = otpData.customer.addresses.find((addr: Address) => addr.isDefault) 
            || otpData.customer.addresses[0];
          loadExistingAddress(defaultAddress);
        }
      } else {
        setError('El enlace ha expirado o no es v√°lido.');
        toast.error(
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <svg className="w-6 h-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v2m0 2h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div className="ml-3">
              <p className="text-sm font-semibold text-gray-900">üïí Enlace Expirado</p>
              <p className="text-xs text-gray-600">
                Por seguridad, los enlaces expiran despu√©s de 10 minutos.
              </p>
            </div>
          </div>,
          {
            duration: 5000,
            style: {
              background: '#fef2f2',
              border: '1px solid #fecaca',
              padding: '16px',
              maxWidth: '420px',
            },
          }
        );
      }
    }
  }, [otpData, setCustomer, setValidating, setError, loadExistingAddress]);

  const handleLocationSelect = (location: Location) => {
    updateFormField('latitude', location.lat);
    updateFormField('longitude', location.lng);
    
    // Reverse geocoding
    const geocoder = new google.maps.Geocoder();
    geocoder.geocode({ location }, (results, status) => {
      if (status === 'OK' && results && results[0]) {
        const addressComponents = results[0].address_components;
        
        const updates: Partial<AddressFormData> = {};
        
        addressComponents.forEach((component) => {
          const types = component.types;
          if (types.includes('route')) {
            updates.street = component.long_name;
          } else if (types.includes('street_number')) {
            updates.number = component.long_name;
          } else if (types.includes('sublocality_level_1') || types.includes('neighborhood')) {
            updates.neighborhood = component.long_name;
          } else if (types.includes('postal_code')) {
            updates.zipCode = component.long_name;
          } else if (types.includes('locality')) {
            updates.city = component.long_name;
          } else if (types.includes('administrative_area_level_1')) {
            updates.state = component.long_name;
          } else if (types.includes('country')) {
            updates.country = component.long_name;
          }
        });

        setFormData(updates);
      }
    });
  };

  const handleSubmit = async (data: AddressFormData) => {
    
    if (!data.name || data.name.trim() === '') {
      toast.error('Por favor ingresa un nombre para identificar esta direcci√≥n');
      return;
    }
    
    if (!data.latitude || !data.longitude) {
      toast.error('Por favor selecciona una ubicaci√≥n en el mapa');
      return;
    }

    if (!customerId || !otp) {
      toast.error('Informaci√≥n de sesi√≥n no v√°lida');
      return;
    }

    setSaving(true);
    
    try {
      // Ensure required fields have values
      const addressData = {
        name: data.name.trim(), // Ensure name is trimmed
        street: data.street,
        number: data.number,
        interiorNumber: data.interiorNumber || '',
        neighborhood: data.neighborhood || '',
        city: data.city || 'Ciudad',
        state: data.state || 'Estado',
        country: data.country || 'M√©xico',
        zipCode: data.zipCode || '',
        deliveryInstructions: data.deliveryInstructions || '',
        latitude: data.latitude,
        longitude: data.longitude
      };
      

      if (editingAddressId) {
        // Update existing address
        await updateAddressMutation.mutateAsync({
          addressId: editingAddressId,
          whatsappPhoneNumber: customerId,
          otp,
          address: addressData,
        });
        toast.success(
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <svg className="w-6 h-6 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div className="ml-3">
              <p className="text-sm font-semibold text-gray-900">¬°Direcci√≥n actualizada!</p>
              <p className="text-xs text-gray-600">Los cambios se guardaron correctamente</p>
            </div>
          </div>,
          {
            duration: 4000,
            style: {
              background: '#f0fdf4',
              border: '1px solid #86efac',
              padding: '16px',
              maxWidth: '420px',
            },
          }
        );
      } else {
        // Create new address
        await createAddressMutation.mutateAsync({
          whatsappPhoneNumber: customerId,
          otp,
          address: addressData,
          preOrderId: preOrderId || undefined,
        });
        toast.success(
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <svg className="w-6 h-6 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div className="ml-3">
              <p className="text-sm font-semibold text-gray-900">¬°Direcci√≥n guardada!</p>
              <p className="text-xs text-gray-600">
                {preOrderId 
                  ? 'Regresando a WhatsApp...' 
                  : 'Tu nueva direcci√≥n est√° lista para usar'}
              </p>
            </div>
          </div>,
          {
            duration: preOrderId ? 2000 : 4000,
            style: {
              background: '#f0fdf4',
              border: '1px solid #86efac',
              padding: '16px',
              maxWidth: '420px',
            },
          }
        );
      }

      
      resetForm();
      
      // Si viene de WhatsApp (con preOrderId), mostrar pantalla de √©xito
      if (preOrderId) {
        setTimeout(() => {
          setShowSuccessScreen(true);
          // Intentar cerrar autom√°ticamente despu√©s de 3 segundos
          setTimeout(() => {
            window.close();
          }, 3000);
        }, 1500); // Mostrar toast por 1.5 segundos primero
      } else {
        // Si no viene de preorder, volver a la lista
        setTimeout(() => {
          setViewMode('list');
          setEditingAddressId(null);
        }, 1500);
      }
    } catch (error: any) {
      // Verificar si es un error de OTP expirado
      const isOTPError = error?.response?.data?.code === 'VAL006' || 
                        error?.response?.data?.error?.includes('OTP') ||
                        error?.message?.toLowerCase().includes('otp');
      
      if (isOTPError) {
        // Error de OTP expirado
        toast.error(
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <svg className="w-6 h-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v2m0 2h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div className="ml-3">
              <p className="text-sm font-semibold text-gray-900">üïí Enlace Expirado</p>
              <p className="text-xs text-gray-600">
                Tu enlace de registro ha expirado por seguridad.
                Por favor, solicita un nuevo enlace desde WhatsApp.
              </p>
            </div>
          </div>,
          {
            duration: 6000,
            style: {
              background: '#fef2f2',
              border: '1px solid #fecaca',
              padding: '16px',
              maxWidth: '420px',
            },
          }
        );
        
        // Mostrar pantalla de error despu√©s de 2 segundos
        setTimeout(() => {
          setShowOTPErrorScreen(true);
          // Intentar cerrar autom√°ticamente despu√©s de 5 segundos
          setTimeout(() => {
            window.close();
          }, 5000);
        }, 2000);
      } else {
        // Otros errores
        const errorMessage = error?.response?.data?.error || 
                           error?.message || 
                           'Hubo un error al guardar la direcci√≥n';
        
        toast.error(
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <svg className="w-6 h-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div className="ml-3">
              <p className="text-sm font-semibold text-gray-900">Error al guardar</p>
              <p className="text-xs text-gray-600">{errorMessage}</p>
            </div>
          </div>,
          {
            duration: 5000,
            style: {
              background: '#fef2f2',
              border: '1px solid #fecaca',
              padding: '16px',
              maxWidth: '420px',
            },
          }
        );
      }
    } finally {
      setSaving(false);
    }
  };

  const handleUpdateCustomerName = async (firstName: string, lastName: string) => {
    try {
      
      if (!customerId || !otp) {
        toast.error('Informaci√≥n de sesi√≥n no v√°lida. Por favor, recarga la p√°gina.');
        return;
      }
      
      const result = await updateCustomerNameMutation.mutateAsync({
        whatsappPhoneNumber: customerId,
        otp,
        firstName,
        lastName,
      });
      
      
      if (result.success && result.customer) {
        
        // Update the customer state with the new data
        const updatedCustomer = {
          ...result.customer,
          addresses: result.customer.addresses || []
        };
        
        setCustomer(updatedCustomer);
        toast.success('¬°Informaci√≥n actualizada correctamente!');
        
        // If customer has addresses, load the default one
        if (updatedCustomer.addresses.length > 0) {
          const defaultAddress = updatedCustomer.addresses.find((addr: Address) => addr.isDefault) 
            || updatedCustomer.addresses[0];
          loadExistingAddress(defaultAddress);
        }
      }
    } catch (error) {
      
      let errorMessage = 'Error al actualizar tu informaci√≥n';
      
      if (error instanceof Error) {
        errorMessage = error.message;
      }
      
      toast.error(errorMessage);
    }
  };

  const handleUseMyLocation = async () => {
    if (!('geolocation' in navigator)) {
      toast.error(t('geolocation.notSupported'));
      return;
    }

    setIsGettingLocation(true);

    try {
      // Primero verificar el estado de los permisos si la API est√° disponible
      if ('permissions' in navigator) {
        try {
          const permissionStatus = await navigator.permissions.query({ name: 'geolocation' });
          
          // Si los permisos fueron previamente denegados, informar al usuario
          if (permissionStatus.state === 'denied') {
            toast.error(t('geolocation.permissionDenied'));
            setIsGettingLocation(false);
            return;
          }
        } catch {
          // La API de permisos no est√° disponible en todos los navegadores, continuar
        }
      }

      // Solicitar la ubicaci√≥n con opciones mejoradas
      navigator.geolocation.getCurrentPosition(
        (position) => {
          handleLocationSelect({
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          });
          setIsGettingLocation(false);
          toast.success('Ubicaci√≥n obtenida exitosamente');
        },
        (error) => {
          setIsGettingLocation(false);
          
          // Manejar diferentes tipos de error
          switch (error.code) {
            case error.PERMISSION_DENIED:
              toast.error(t('geolocation.permissionDenied'));
              break;
            case error.POSITION_UNAVAILABLE:
              toast.error(t('geolocation.positionUnavailable'));
              break;
            case error.TIMEOUT:
              toast.error(t('geolocation.timeout'));
              break;
            default:
              toast.error(t('geolocation.unknownError'));
          }
        },
        {
          enableHighAccuracy: true,
          timeout: 10000, // 10 segundos
          maximumAge: 0 // No usar cach√©
        }
      );
    } catch (error) {
      setIsGettingLocation(false);
      toast.error(t('geolocation.unknownError'));
    }
  };

  // Si el usuario tiene direcciones, mostrar la lista primero
  // PERO respetar si viewMode viene de la URL
  useEffect(() => {
    // Solo cambiar viewMode si no se especific√≥ en la URL
    const urlViewMode = searchParams.get('viewMode');
    if (!urlViewMode) {
      if (customer?.addresses && customer.addresses.length > 0) {
        setViewMode('list');
      } else {
        setViewMode('form');
      }
    }
  }, [customer?.addresses?.length, searchParams]);

  const selectedLocation = formData.latitude && formData.longitude 
    ? { lat: formData.latitude, lng: formData.longitude } 
    : null;

  // Loading states
  if (isVerifying || isValidating) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-orange-50 via-red-50 to-pink-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-orange-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Verificando enlace...</p>
        </div>
      </div>
    );
  }

  if (!customer) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-orange-50 via-red-50 to-pink-50 p-4">
        <div className="max-w-md w-full bg-white p-8 rounded-lg shadow-lg text-center">
          <svg className="mx-auto h-12 w-12 text-red-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <h2 className="text-2xl font-bold text-gray-900 mb-2">Enlace inv√°lido</h2>
          <p className="text-gray-600">
            Este enlace ha expirado o no es v√°lido. Por favor, solicita un nuevo enlace desde WhatsApp.
          </p>
        </div>
        <Toaster position="top-center" />
      </div>
    );
  }

  if (loadError) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
        <div className="text-center text-red-600">
          Error al cargar Google Maps. Por favor, recarga la p√°gina.
        </div>
      </div>
    );
  }

  if (!isLoaded) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-orange-50 via-red-50 to-pink-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-orange-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Cargando mapa...</p>
        </div>
      </div>
    );
  }

  // Pantalla de √©xito para cuando se guarda desde WhatsApp
  if (showSuccessScreen) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-green-50 to-emerald-100 p-4">
        <div className="max-w-md w-full bg-white p-8 rounded-2xl shadow-xl text-center">
          <div className="mb-6">
            <div className="w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <svg className="w-10 h-10 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
              </svg>
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-2">¬°Direcci√≥n Guardada!</h2>
            <p className="text-gray-600 mb-6">
              Tu direcci√≥n se ha registrado correctamente.
              Ya puedes continuar con tu pedido en WhatsApp.
            </p>
          </div>
          
          <div className="space-y-3">
            <button
              onClick={() => window.close()}
              className="w-full px-6 py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white font-semibold rounded-xl hover:shadow-lg transform hover:scale-105 transition-all duration-200"
            >
              Cerrar ventana
            </button>
          </div>
          
          <p className="text-xs text-gray-500 mt-6">
            Esta ventana se cerrar√° autom√°ticamente en unos segundos...
          </p>
        </div>
      </div>
    );
  }

  // Pantalla de error de OTP expirado
  if (showOTPErrorScreen) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-red-50 to-orange-100 p-4">
        <div className="max-w-md w-full bg-white p-8 rounded-2xl shadow-xl text-center">
          <div className="mb-6">
            <div className="w-20 h-20 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4">
              <svg className="w-10 h-10 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-2">üïí Enlace Expirado</h2>
            <p className="text-gray-600 mb-2">
              Tu enlace ha expirado por seguridad.
            </p>
            <p className="text-sm text-gray-500 mb-6">
              Los enlaces son v√°lidos por 10 minutos para proteger tu informaci√≥n.
            </p>
          </div>
          
          <div className="space-y-3">
            <button
              onClick={() => {
                toast('üì± Por favor, solicita un nuevo enlace desde WhatsApp', {
                  duration: 4000,
                  icon: '‚ÑπÔ∏è',
                  style: {
                    background: '#f0f9ff',
                    border: '1px solid #3b82f6',
                    padding: '16px',
                  },
                });
              }}
              className="block w-full px-6 py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white font-semibold rounded-xl hover:shadow-lg transform hover:scale-105 transition-all duration-200"
            >
              <span className="flex items-center justify-center gap-2">
                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M.057 24l1.687-6.163c-1.041-1.804-1.588-3.849-1.587-5.946.003-6.556 5.338-11.891 11.893-11.891 3.181.001 6.167 1.24 8.413 3.488 2.245 2.248 3.481 5.236 3.48 8.414-.003 6.557-5.338 11.892-11.893 11.892-1.99-.001-3.951-.5-5.688-1.448l-6.305 1.654zm6.597-3.807c1.676.995 3.276 1.591 5.392 1.592 5.448 0 9.886-4.434 9.889-9.885.002-5.462-4.415-9.89-9.881-9.892-5.452 0-9.887 4.434-9.889 9.884-.001 2.225.651 3.891 1.746 5.634l-.999 3.648 3.742-.981zm11.387-5.464c-.074-.124-.272-.198-.57-.347-.297-.149-1.758-.868-2.031-.967-.272-.099-.47-.149-.669.149-.198.297-.768.967-.941 1.165-.173.198-.347.223-.644.074-.297-.149-1.255-.462-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.297-.347.446-.521.151-.172.2-.296.3-.495.099-.198.05-.372-.025-.521-.075-.148-.669-1.611-.916-2.206-.242-.579-.487-.501-.669-.51l-.57-.01c-.198 0-.52.074-.792.372s-1.04 1.016-1.04 2.479 1.065 2.876 1.213 3.074c.149.198 2.095 3.2 5.076 4.487.709.306 1.263.489 1.694.626.712.226 1.36.194 1.872.118.571-.085 1.758-.719 2.006-1.413.248-.695.248-1.29.173-1.414z"/>
                </svg>
                Solicitar nuevo enlace
              </span>
            </button>
            
            <button
              onClick={() => {
                window.close();
                // Si no se puede cerrar, al menos limpiar la pantalla
                setTimeout(() => {
                  window.location.href = 'about:blank';
                }, 500);
              }}
              className="w-full px-6 py-3 bg-gray-100 text-gray-700 font-semibold rounded-xl hover:bg-gray-200 transition-all duration-200"
            >
              Cerrar ventana
            </button>
          </div>
          
          <p className="text-xs text-gray-500 mt-6">
            Esta ventana se cerrar√° autom√°ticamente...
          </p>
        </div>
      </div>
    );
  }


  return (
    <div className="min-h-screen bg-gradient-to-br from-orange-50 via-red-50 to-pink-50">
      <div className="max-w-4xl mx-auto p-2 sm:p-4">
        <div className="bg-white rounded-xl sm:rounded-2xl shadow-xl overflow-hidden">
          {/* Header con gradiente naranja-rosa */}
          <div className="bg-gradient-to-r from-orange-500 to-pink-600 p-4 sm:p-6 text-white">
            <h1 className="text-xl sm:text-2xl md:text-3xl font-bold mb-2 drop-shadow-lg">
              üìç {viewMode === 'list' 
                ? 'Mis Direcciones de Entrega' 
                : editingAddressId 
                  ? `Actualizar: ${formData.name || 'Direcci√≥n'}` 
                  : 'Registrar Direcci√≥n de Entrega'}
            </h1>
            <div className="flex items-center gap-3 flex-wrap">
              <div className="flex items-center gap-2">
                <p className="text-sm sm:text-base text-white font-medium drop-shadow">
                  {customer.firstName && customer.lastName 
                    ? `${customer.firstName} ${customer.lastName}`
                    : customer.firstName 
                      ? customer.firstName
                      : 'Cliente'}
                </p>
                {customer.firstName && customer.lastName && (
                  <button
                    onClick={() => setIsEditingCustomerName(true)}
                    className="p-1.5 rounded-lg bg-white/20 hover:bg-white/30 transition-colors"
                    title="Editar nombre"
                  >
                    <svg className="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                    </svg>
                  </button>
                )}
              </div>
              {customerId && (
                <div className="inline-block bg-white/20 backdrop-blur-sm rounded-lg px-3 py-1">
                  <p className="text-xs sm:text-sm text-white font-medium">
                    üì± {customerId}
                  </p>
                </div>
              )}
            </div>
          </div>
          
          <div className="p-4 sm:p-6">
            {/* Show name form if customer doesn't have firstName or lastName OR if editing */}
            {customer && ((!customer.firstName || !customer.lastName) || isEditingCustomerName) && (
              <CustomerNameForm
                onSubmit={async (firstName, lastName) => {
                  await handleUpdateCustomerName(firstName, lastName);
                  setIsEditingCustomerName(false);
                }}
                isSubmitting={updateCustomerNameMutation.isPending}
                initialFirstName={customer.firstName || ''}
                initialLastName={customer.lastName || ''}
                isEditing={isEditingCustomerName}
                onCancel={() => setIsEditingCustomerName(false)}
              />
            )}

            {/* Show list view if customer has addresses and viewMode is 'list' AND not editing name */}
            {customer && customer.firstName && customer.lastName && !isEditingCustomerName && viewMode === 'list' && customer.addresses.length > 0 && (
              <div>
                <div className="grid gap-4 mb-6">
                  {customer.addresses.map((address) => (
                    <div 
                      key={address.id} 
                      className={`relative group transition-all duration-300 ${
                        address.isDefault 
                          ? 'ring-2 ring-orange-400 shadow-lg' 
                          : 'hover:shadow-lg'
                      }`}
                    >
                      <div className="bg-white rounded-2xl p-6 border border-gray-100">
                        <div className="flex justify-between items-start gap-4">
                          <div className="flex-1">
                            {/* Address Name with Icon */}
                            <div className="flex items-center gap-3 mb-3">
                              <div className={`p-2 rounded-lg ${
                                address.isDefault 
                                  ? 'bg-gradient-to-r from-orange-100 to-pink-100' 
                                  : 'bg-gray-100'
                              }`}>
                                <svg className="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                                </svg>
                              </div>
                              <h3 className="font-bold text-xl text-gray-800">{address.name}</h3>
                              {/* Default Badge inline */}
                              {address.isDefault && (
                                <span className="inline-flex items-center gap-1 bg-gradient-to-r from-orange-400 to-pink-500 text-white text-xs font-semibold px-3 py-1 rounded-full">
                                  <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                                  </svg>
                                  Principal
                                </span>
                              )}
                            </div>

                            {/* Address Details */}
                            <div className="space-y-1 text-gray-600">
                              <p className="font-medium">
                                {address.street} {address.number}
                                {address.interiorNumber && ` Int. ${address.interiorNumber}`}
                              </p>
                              <p className="text-sm">
                                {address.neighborhood && `${address.neighborhood}, `}
                                {address.city}, {address.state}
                              </p>
                            </div>

                            {/* Delivery Instructions */}
                            {address.deliveryInstructions && (
                              <div className="mt-3 flex items-start gap-2">
                                <svg className="w-4 h-4 text-gray-400 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />
                                </svg>
                                <p className="text-sm text-gray-500">{address.deliveryInstructions}</p>
                              </div>
                            )}
                          </div>

                          {/* Actions Column */}
                          <div className="flex flex-col gap-2">
                            {/* Edit Button */}
                            <button
                              onClick={() => {
                                loadExistingAddress(address);
                                setViewMode('form');
                              }}
                              className="flex items-center gap-2 px-4 py-2 bg-white border border-gray-200 text-gray-700 rounded-lg hover:bg-gray-50 hover:border-gray-300 transition-all duration-200 group"
                            >
                              <svg className="w-4 h-4 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                              </svg>
                              <span className="text-sm font-medium">Editar</span>
                            </button>

                            {/* Set as Default Button */}
                            {!address.isDefault && (
                              <button
                                onClick={async () => {
                                  try {
                                    await setDefaultAddressMutation.mutateAsync({
                                      addressId: address.id,
                                      whatsappPhoneNumber: customerId!,
                                      otp: otp!
                                    });
                                    toast.success(
                                      <div className="flex items-center">
                                        <div className="flex-shrink-0">
                                          <svg className="w-6 h-6 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                          </svg>
                                        </div>
                                        <div className="ml-3">
                                          <p className="text-sm font-semibold text-gray-900">¬°Direcci√≥n principal actualizada!</p>
                                          <p className="text-xs text-gray-600">{address.name} es ahora tu direcci√≥n principal</p>
                                        </div>
                                      </div>,
                                      {
                                        duration: 4000,
                                        style: {
                                          background: '#f0fdf4',
                                          border: '1px solid #86efac',
                                          padding: '16px',
                                          maxWidth: '420px',
                                        },
                                      }
                                    );
                                    // Actualizar el estado del cliente
                                    if (customer) {
                                      const updatedAddresses = customer.addresses.map((addr) => ({
                                        ...addr,
                                        isDefault: addr.id === address.id
                                      }));
                                      setCustomer({ ...customer, addresses: updatedAddresses });
                                    }
                                  } catch {
                                    toast.error(
                                      <div className="flex items-center">
                                        <div className="flex-shrink-0">
                                          <svg className="w-6 h-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                          </svg>
                                        </div>
                                        <div className="ml-3">
                                          <p className="text-sm font-semibold text-gray-900">Error</p>
                                          <p className="text-xs text-gray-600">No se pudo cambiar la direcci√≥n principal</p>
                                        </div>
                                      </div>,
                                      {
                                        duration: 5000,
                                        style: {
                                          background: '#fef2f2',
                                          border: '1px solid #fecaca',
                                          padding: '16px',
                                          maxWidth: '420px',
                                        },
                                      }
                                    );
                                  }
                                }}
                                disabled={setDefaultAddressMutation.isPending}
                                className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-orange-500 to-pink-600 text-white rounded-lg hover:shadow-md transition-all duration-200 group disabled:opacity-50 disabled:cursor-not-allowed"
                              >
                                {setDefaultAddressMutation.isPending ? (
                                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                                ) : (
                                  <svg className="w-4 h-4 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                                  </svg>
                                )}
                                <span className="text-sm font-medium">Hacer principal</span>
                              </button>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
                
                <button
                  onClick={() => {
                    resetForm();
                    setEditingAddressId(null);
                    setViewMode('form');
                  }}
                  className="w-full px-6 py-4 bg-gradient-to-r from-orange-500 to-pink-600 text-white font-bold rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200"
                >
                  <span className="flex items-center justify-center">
                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                    </svg>
                    Agregar nueva direcci√≥n
                  </span>
                </button>
              </div>
            )}

            {/* Show form view if viewMode is 'form' or no addresses AND not editing name */}
            {customer && customer.firstName && customer.lastName && !isEditingCustomerName && (viewMode === 'form' || customer.addresses.length === 0) && (
              <>
                {/* Bot√≥n para volver a la lista si hay direcciones */}
                {customer.addresses.length > 0 && (
                  <div className="mb-4">
                    <button
                      type="button"
                      onClick={() => {
                        setViewMode('list');
                        setEditingAddressId(null);
                        resetForm();
                      }}
                      className="flex items-center text-gray-600 hover:text-gray-800 font-medium"
                    >
                      <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                      </svg>
                      Volver a mis direcciones
                    </button>
                  </div>
                )}
                
                {/* Use my location button */}
                <div className="mb-6">
                  <button
                    type="button"
                    onClick={handleUseMyLocation}
                    disabled={isGettingLocation}
                    className="w-full sm:w-auto px-6 py-3 bg-gradient-to-r from-orange-500 to-pink-600 text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
                  >
                    {isGettingLocation ? (
                      <>
                        <svg className="animate-spin w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Obteniendo ubicaci√≥n...
                      </>
                    ) : (
                      <>
                        <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                        {t('address.useMyLocation')}
                      </>
                    )}
                  </button>
                </div>

                {/* Map */}
                <div className="mb-6">
                  <Map
              center={selectedLocation || { lat: 20.6597, lng: -103.3496 }}
              onLocationSelect={handleLocationSelect}
              selectedLocation={selectedLocation}
              polygonCoords={deliveryAreaData?.polygonCoords || []}
              onLocationError={(error) => toast.error(error)}
                  />
                </div>

                {/* Address Form */}
                <AddressForm
                  formData={formData}
                  onSubmit={handleSubmit}
                  isUpdating={!!editingAddressId}
                />

                {/* Submit Button */}
                <div className="mt-6 space-y-3">
                  <button
                    type="button"
                    onClick={() => {
                      // Trigger the form's submit to use its validation
                      const submitButton = document.getElementById('address-form-submit') as HTMLButtonElement;
                      if (submitButton) {
                        submitButton.click();
                      }
                    }}
                    disabled={isSaving || !selectedLocation}
                    className={`w-full px-6 py-4 font-bold text-white rounded-xl shadow-lg transform transition-all duration-200 ${
                      isSaving || !selectedLocation
                        ? 'bg-gray-400 cursor-not-allowed'
                        : 'bg-gradient-to-r from-orange-500 to-pink-600 hover:shadow-xl hover:scale-105'
                    }`}
                  >
                    {isSaving 
                      ? (
                        <div className="flex items-center justify-center">
                          <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2"></div>
                          Guardando...
                        </div>
                      )
                      : editingAddressId 
                        ? 'Actualizar direcci√≥n' 
                        : 'Registrar direcci√≥n'
                    }
                  </button>
                </div>
              </>
            )}

          </div>
        </div>
      </div>
      <Toaster position="top-center" />
    </div>
  );
}

export default AddressRegistration;

================
File: backend/src/whatsapp/handlers/interactiveMessageHandler.ts
================
/**
 * Main interactive message handler
 * Delegates to domain-specific handlers via the action registry
 */
import logger from '../../common/utils/logger';
import { handleWhatsAppError } from '../../common/utils/whatsappErrorHandler';
import { findHandler } from './interactive';

/**
 * Handle interactive messages (button/list replies)
 * Routes to appropriate handler based on action ID
 */
export async function handleInteractiveMessage(
  from: string,
  message: any
): Promise<void> {
  try {
    logger.info('Interactive message received:', JSON.stringify(message));
    
    if (!message.interactive) {
      logger.error('No interactive property in message');
      return;
    }
    
    const reply = message.interactive.button_reply || message.interactive.list_reply;
    if (!reply) {
      logger.error('No reply found in interactive message');
      return;
    }

    const { id } = reply;
    logger.info(`Processing interactive reply: ${id}`);
    
    // Find and execute the appropriate handler
    const handler = findHandler(id);
    
    if (handler) {
      logger.info(`Executing handler for action: ${id}`);
      await handler(from, id);
    } else {
      logger.warn(`No handler found for interactive action: ${id}`);
    }
  } catch (error) {
    await handleWhatsAppError(error, from, {
      userId: from,
      operation: 'handleInteractiveMessage'
    });
  }
}




================================================================
End of Codebase
================================================================
